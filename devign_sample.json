[{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static void onenand_command(OneNANDState *s)\n\n{\n\n    int b;\n\n    int sec;\n\n    void *buf;\n\n#define SETADDR(block, page)\t\t\t\\\n\n    sec = (s->addr[page] & 3) +\t\t\t\\\n\n            ((((s->addr[page] >> 2) & 0x3f) +\t\\\n\n              (((s->addr[block] & 0xfff) |\t\\\n\n                (s->addr[block] >> 15 ?\t\t\\\n\n                 s->density_mask : 0)) << 6)) << (PAGE_SHIFT - 9));\n\n#define SETBUF_M()\t\t\t\t\\\n\n    buf = (s->bufaddr & 8) ?\t\t\t\\\n\n            s->data[(s->bufaddr >> 2) & 1][0] : s->boot[0];\t\\\n\n    buf += (s->bufaddr & 3) << 9;\n\n#define SETBUF_S()\t\t\t\t\\\n\n    buf = (s->bufaddr & 8) ?\t\t\t\\\n\n            s->data[(s->bufaddr >> 2) & 1][1] : s->boot[1];\t\\\n\n    buf += (s->bufaddr & 3) << 4;\n\n\n\n    switch (s->command) {\n\n    case 0x00:\t\/* Load single\/multiple sector data unit into buffer *\/\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n\n\n        SETBUF_M()\n\n        if (onenand_load_main(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_LOAD;\n\n\n\n#if 0\n\n        SETBUF_S()\n\n        if (onenand_load_spare(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_LOAD;\n\n#endif\n\n\n\n        \/* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)\n\n         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)\n\n         * then we need two split the read\/write into two chunks.\n\n         *\/\n\n        s->intstatus |= ONEN_INT | ONEN_INT_LOAD;\n\n        break;\n\n    case 0x13:\t\/* Load single\/multiple spare sector into buffer *\/\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n\n\n        SETBUF_S()\n\n        if (onenand_load_spare(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_LOAD;\n\n\n\n        \/* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)\n\n         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)\n\n         * then we need two split the read\/write into two chunks.\n\n         *\/\n\n        s->intstatus |= ONEN_INT | ONEN_INT_LOAD;\n\n        break;\n\n    case 0x80:\t\/* Program single\/multiple sector data unit from buffer *\/\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n\n\n        SETBUF_M()\n\n        if (onenand_prog_main(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n\n\n#if 0\n\n        SETBUF_S()\n\n        if (onenand_prog_spare(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n#endif\n\n\n\n        \/* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)\n\n         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)\n\n         * then we need two split the read\/write into two chunks.\n\n         *\/\n\n        s->intstatus |= ONEN_INT | ONEN_INT_PROG;\n\n        break;\n\n    case 0x1a:\t\/* Program single\/multiple spare area sector from buffer *\/\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n\n\n        SETBUF_S()\n\n        if (onenand_prog_spare(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n\n\n        \/* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)\n\n         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)\n\n         * then we need two split the read\/write into two chunks.\n\n         *\/\n\n        s->intstatus |= ONEN_INT | ONEN_INT_PROG;\n\n        break;\n\n    case 0x1b:\t\/* Copy-back program *\/\n\n        SETBUF_S()\n\n\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n        if (onenand_load_main(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n\n\n        SETADDR(ONEN_BUF_DEST_BLOCK, ONEN_BUF_DEST_PAGE)\n\n        if (onenand_prog_main(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n\n\n        \/* TODO: spare areas *\/\n\n\n\n        s->intstatus |= ONEN_INT | ONEN_INT_PROG;\n\n        break;\n\n\n\n    case 0x23:\t\/* Unlock NAND array block(s) *\/\n\n        s->intstatus |= ONEN_INT;\n\n\n\n        \/* XXX the previous (?) area should be locked automatically *\/\n\n        for (b = s->unladdr[0]; b <= s->unladdr[1]; b ++) {\n\n            if (b >= s->blocks) {\n\n                s->status |= ONEN_ERR_CMD;\n\n                break;\n\n            }\n\n            if (s->blockwp[b] == ONEN_LOCK_LOCKTIGHTEN)\n\n                break;\n\n\n\n            s->wpstatus = s->blockwp[b] = ONEN_LOCK_UNLOCKED;\n\n        }\n\n        break;\n\n    case 0x27:\t\/* Unlock All NAND array blocks *\/\n\n        s->intstatus |= ONEN_INT;\n\n\n\n        for (b = 0; b < s->blocks; b ++) {\n\n            if (b >= s->blocks) {\n\n                s->status |= ONEN_ERR_CMD;\n\n                break;\n\n            }\n\n            if (s->blockwp[b] == ONEN_LOCK_LOCKTIGHTEN)\n\n                break;\n\n\n\n            s->wpstatus = s->blockwp[b] = ONEN_LOCK_UNLOCKED;\n\n        }\n\n        break;\n\n\n\n    case 0x2a:\t\/* Lock NAND array block(s) *\/\n\n        s->intstatus |= ONEN_INT;\n\n\n\n        for (b = s->unladdr[0]; b <= s->unladdr[1]; b ++) {\n\n            if (b >= s->blocks) {\n\n                s->status |= ONEN_ERR_CMD;\n\n                break;\n\n            }\n\n            if (s->blockwp[b] == ONEN_LOCK_LOCKTIGHTEN)\n\n                break;\n\n\n\n            s->wpstatus = s->blockwp[b] = ONEN_LOCK_LOCKED;\n\n        }\n\n        break;\n\n    case 0x2c:\t\/* Lock-tight NAND array block(s) *\/\n\n        s->intstatus |= ONEN_INT;\n\n\n\n        for (b = s->unladdr[0]; b <= s->unladdr[1]; b ++) {\n\n            if (b >= s->blocks) {\n\n                s->status |= ONEN_ERR_CMD;\n\n                break;\n\n            }\n\n            if (s->blockwp[b] == ONEN_LOCK_UNLOCKED)\n\n                continue;\n\n\n\n            s->wpstatus = s->blockwp[b] = ONEN_LOCK_LOCKTIGHTEN;\n\n        }\n\n        break;\n\n\n\n    case 0x71:\t\/* Erase-Verify-Read *\/\n\n        s->intstatus |= ONEN_INT;\n\n        break;\n\n    case 0x95:\t\/* Multi-block erase *\/\n\n        qemu_irq_pulse(s->intr);\n\n        \/* Fall through.  *\/\n\n    case 0x94:\t\/* Block erase *\/\n\n        sec = ((s->addr[ONEN_BUF_BLOCK] & 0xfff) |\n\n                        (s->addr[ONEN_BUF_BLOCK] >> 15 ? s->density_mask : 0))\n\n                << (BLOCK_SHIFT - 9);\n\n        if (onenand_erase(s, sec, 1 << (BLOCK_SHIFT - 9)))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_ERASE;\n\n\n\n        s->intstatus |= ONEN_INT | ONEN_INT_ERASE;\n\n        break;\n\n    case 0xb0:\t\/* Erase suspend *\/\n\n        break;\n\n    case 0x30:\t\/* Erase resume *\/\n\n        s->intstatus |= ONEN_INT | ONEN_INT_ERASE;\n\n        break;\n\n\n\n    case 0xf0:\t\/* Reset NAND Flash core *\/\n\n        onenand_reset(s, 0);\n\n        break;\n\n    case 0xf3:\t\/* Reset OneNAND *\/\n\n        onenand_reset(s, 0);\n\n        break;\n\n\n\n    case 0x65:\t\/* OTP Access *\/\n\n        s->intstatus |= ONEN_INT;\n\n        s->bdrv_cur = NULL;\n\n        s->current = s->otp;\n\n        s->secs_cur = 1 << (BLOCK_SHIFT - 9);\n\n        s->addr[ONEN_BUF_BLOCK] = 0;\n\n        s->otpmode = 1;\n\n        break;\n\n\n\n    default:\n\n        s->status |= ONEN_ERR_CMD;\n\n        s->intstatus |= ONEN_INT;\n\n        fprintf(stderr, \"%s: unknown OneNAND command %x\\n\",\n\n                        __func__, s->command);\n\n    }\n\n\n\n    onenand_intr_update(s);\n\n}\n"},{"project":"qemu","commit_id":"d6085e3ace20bc9b0fa625d8d79b22668710e217","target":0,"func":"static void virtio_net_device_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIONet *n = VIRTIO_NET(dev);\n\n    NetClientState *nc;\n\n    int i;\n\n\n\n    virtio_init(vdev, \"virtio-net\", VIRTIO_ID_NET, n->config_size);\n\n\n\n    n->max_queues = MAX(n->nic_conf.queues, 1);\n\n    n->vqs = g_malloc0(sizeof(VirtIONetQueue) * n->max_queues);\n\n    n->vqs[0].rx_vq = virtio_add_queue(vdev, 256, virtio_net_handle_rx);\n\n    n->curr_queues = 1;\n\n    n->vqs[0].n = n;\n\n    n->tx_timeout = n->net_conf.txtimer;\n\n\n\n    if (n->net_conf.tx && strcmp(n->net_conf.tx, \"timer\")\n\n                       && strcmp(n->net_conf.tx, \"bh\")) {\n\n        error_report(\"virtio-net: \"\n\n                     \"Unknown option tx=%s, valid options: \\\"timer\\\" \\\"bh\\\"\",\n\n                     n->net_conf.tx);\n\n        error_report(\"Defaulting to \\\"bh\\\"\");\n\n    }\n\n\n\n    if (n->net_conf.tx && !strcmp(n->net_conf.tx, \"timer\")) {\n\n        n->vqs[0].tx_vq = virtio_add_queue(vdev, 256,\n\n                                           virtio_net_handle_tx_timer);\n\n        n->vqs[0].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, virtio_net_tx_timer,\n\n                                               &n->vqs[0]);\n\n    } else {\n\n        n->vqs[0].tx_vq = virtio_add_queue(vdev, 256,\n\n                                           virtio_net_handle_tx_bh);\n\n        n->vqs[0].tx_bh = qemu_bh_new(virtio_net_tx_bh, &n->vqs[0]);\n\n    }\n\n    n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);\n\n    qemu_macaddr_default_if_unset(&n->nic_conf.macaddr);\n\n    memcpy(&n->mac[0], &n->nic_conf.macaddr, sizeof(n->mac));\n\n    n->status = VIRTIO_NET_S_LINK_UP;\n\n\n\n    if (n->netclient_type) {\n\n        \/*\n\n         * Happen when virtio_net_set_netclient_name has been called.\n\n         *\/\n\n        n->nic = qemu_new_nic(&net_virtio_info, &n->nic_conf,\n\n                              n->netclient_type, n->netclient_name, n);\n\n    } else {\n\n        n->nic = qemu_new_nic(&net_virtio_info, &n->nic_conf,\n\n                              object_get_typename(OBJECT(dev)), dev->id, n);\n\n    }\n\n\n\n    peer_test_vnet_hdr(n);\n\n    if (peer_has_vnet_hdr(n)) {\n\n        for (i = 0; i < n->max_queues; i++) {\n\n            qemu_peer_using_vnet_hdr(qemu_get_subqueue(n->nic, i), true);\n\n        }\n\n        n->host_hdr_len = sizeof(struct virtio_net_hdr);\n\n    } else {\n\n        n->host_hdr_len = 0;\n\n    }\n\n\n\n    qemu_format_nic_info_str(qemu_get_queue(n->nic), n->nic_conf.macaddr.a);\n\n\n\n    n->vqs[0].tx_waiting = 0;\n\n    n->tx_burst = n->net_conf.txburst;\n\n    virtio_net_set_mrg_rx_bufs(n, 0);\n\n    n->promisc = 1; \/* for compatibility *\/\n\n\n\n    n->mac_table.macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);\n\n\n\n    n->vlans = g_malloc0(MAX_VLAN >> 3);\n\n\n\n    nc = qemu_get_queue(n->nic);\n\n    nc->rxfilter_notify_enabled = 1;\n\n\n\n    n->qdev = dev;\n\n    register_savevm(dev, \"virtio-net\", -1, VIRTIO_NET_VM_VERSION,\n\n                    virtio_net_save, virtio_net_load, n);\n\n\n\n    add_boot_device_path(n->nic_conf.bootindex, dev, \"\/ethernet-phy@0\");\n\n}\n"},{"project":"qemu","commit_id":"60fe637bf0e4d7989e21e50f52526444765c63b4","target":1,"func":"static int get_int32(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int32_t *v = pv;\n\n    qemu_get_sbe32s(f, v);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"f06b2031a31cdd3acf6f61a977e505b8c6b58f73","target":0,"func":"void ga_channel_free(GAChannel *c)\n\n{\n\n    if (c->method == GA_CHANNEL_UNIX_LISTEN\n\n        && c->listen_channel) {\n\n        ga_channel_listen_close(c);\n\n    }\n\n    if (c->client_channel) {\n\n        ga_channel_client_close(c);\n\n    }\n\n    g_free(c);\n\n}\n"},{"project":"qemu","commit_id":"5d1abf234462d13bef3617cc2c55b6815703ddf2","target":0,"func":"int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr,\n\n                        uint8_t ar)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    S390PCIBusDevice *pbdev;\n\n    MemoryRegion *mr;\n\n    int i;\n\n    uint32_t fh;\n\n    uint8_t pcias;\n\n    uint8_t len;\n\n    uint8_t buffer[128];\n\n\n\n    if (env->psw.mask & PSW_MASK_PSTATE) {\n\n        program_interrupt(env, PGM_PRIVILEGED, 6);\n\n        return 0;\n\n    }\n\n\n\n    fh = env->regs[r1] >> 32;\n\n    pcias = (env->regs[r1] >> 16) & 0xf;\n\n    len = env->regs[r1] & 0xff;\n\n\n\n    if (pcias > 5) {\n\n        DPRINTF(\"pcistb invalid space\\n\");\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);\n\n        return 0;\n\n    }\n\n\n\n    switch (len) {\n\n    case 16:\n\n    case 32:\n\n    case 64:\n\n    case 128:\n\n        break;\n\n    default:\n\n        program_interrupt(env, PGM_SPECIFICATION, 6);\n\n        return 0;\n\n    }\n\n\n\n    pbdev = s390_pci_find_dev_by_fh(fh);\n\n    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {\n\n        DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh);\n\n        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);\n\n        return 0;\n\n    }\n\n\n\n    if (pbdev->lgstg_blocked) {\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);\n\n        return 0;\n\n    }\n\n\n\n    mr = pbdev->pdev->io_regions[pcias].memory;\n\n    if (!memory_region_access_valid(mr, env->regs[r3], len, true)) {\n\n        program_interrupt(env, PGM_ADDRESSING, 6);\n\n        return 0;\n\n    }\n\n\n\n    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < len \/ 8; i++) {\n\n        memory_region_dispatch_write(mr, env->regs[r3] + i * 8,\n\n                                     ldq_p(buffer + i * 8), 8,\n\n                                     MEMTXATTRS_UNSPECIFIED);\n\n    }\n\n\n\n    setcc(cpu, ZPCI_PCI_LS_OK);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"0522a959aec29768610900636f6234ab40530f82","target":1,"func":"static int net_socket_listen_init(NetClientState *peer,\n\n                                  const char *model,\n\n                                  const char *name,\n\n                                  const char *host_str)\n\n{\n\n    NetClientState *nc;\n\n    NetSocketState *s;\n\n    struct sockaddr_in saddr;\n\n    int fd, ret;\n\n    Error *err = NULL;\n\n\n\n    if (parse_host_port(&saddr, host_str, &err) < 0) {\n\n        error_report_err(err);\n\n        return -1;\n\n    }\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n\n\n    socket_set_fast_reuse(fd);\n\n\n\n    ret = bind(fd, (struct sockaddr *)&saddr, sizeof(saddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n        closesocket(fd);\n\n        return -1;\n\n    }\n\n    ret = listen(fd, 0);\n\n    if (ret < 0) {\n\n        perror(\"listen\");\n\n        closesocket(fd);\n\n        return -1;\n\n    }\n\n\n\n    nc = qemu_new_net_client(&net_socket_info, peer, model, name);\n\n    s = DO_UPCAST(NetSocketState, nc, nc);\n\n    s->fd = -1;\n\n    s->listen_fd = fd;\n\n    s->nc.link_down = true;\n\n    net_socket_rs_init(&s->rs, net_socket_rs_finalize, false);\n\n\n\n    qemu_set_fd_handler(s->listen_fd, net_socket_accept, NULL, s);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"90e496386fe7fd32c189561f846b7913f95b8cf4","target":0,"func":"static TCGv_i32 read_fp_sreg(DisasContext *s, int reg)\n\n{\n\n    TCGv_i32 v = tcg_temp_new_i32();\n\n\n\n    tcg_gen_ld_i32(v, cpu_env, fp_reg_offset(reg, MO_32));\n\n    return v;\n\n}\n"},{"project":"qemu","commit_id":"e100161b69f8cf56dae866912dfffe7dcd7140af","target":0,"func":"int vfio_spapr_create_window(VFIOContainer *container,\n\n                             MemoryRegionSection *section,\n\n                             hwaddr *pgsize)\n\n{\n\n    int ret;\n\n    IOMMUMemoryRegion *iommu_mr = IOMMU_MEMORY_REGION(section->mr);\n\n    unsigned pagesize = memory_region_iommu_get_min_page_size(iommu_mr);\n\n    unsigned entries, pages;\n\n    struct vfio_iommu_spapr_tce_create create = { .argsz = sizeof(create) };\n\n\n\n    \/*\n\n     * FIXME: For VFIO iommu types which have KVM acceleration to\n\n     * avoid bouncing all map\/unmaps through qemu this way, this\n\n     * would be the right place to wire that up (tell the KVM\n\n     * device emulation the VFIO iommu handles to use).\n\n     *\/\n\n    create.window_size = int128_get64(section->size);\n\n    create.page_shift = ctz64(pagesize);\n\n    \/*\n\n     * SPAPR host supports multilevel TCE tables, there is some\n\n     * heuristic to decide how many levels we want for our table:\n\n     * 0..64 = 1; 65..4096 = 2; 4097..262144 = 3; 262145.. = 4\n\n     *\/\n\n    entries = create.window_size >> create.page_shift;\n\n    pages = MAX((entries * sizeof(uint64_t)) \/ getpagesize(), 1);\n\n    pages = MAX(pow2ceil(pages) - 1, 1); \/* Round up *\/\n\n    create.levels = ctz64(pages) \/ 6 + 1;\n\n\n\n    ret = ioctl(container->fd, VFIO_IOMMU_SPAPR_TCE_CREATE, &create);\n\n    if (ret) {\n\n        error_report(\"Failed to create a window, ret = %d (%m)\", ret);\n\n        return -errno;\n\n    }\n\n\n\n    if (create.start_addr != section->offset_within_address_space) {\n\n        vfio_spapr_remove_window(container, create.start_addr);\n\n\n\n        error_report(\"Host doesn't support DMA window at %\"HWADDR_PRIx\", must be %\"PRIx64,\n\n                     section->offset_within_address_space,\n\n                     (uint64_t)create.start_addr);\n\n        return -EINVAL;\n\n    }\n\n    trace_vfio_spapr_create_window(create.page_shift,\n\n                                   create.window_size,\n\n                                   create.start_addr);\n\n    *pgsize = pagesize;\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"e7d336959b7c01699702dcda4b54a822972d74a8","target":0,"func":"S390PCIBusDevice *s390_pci_find_dev_by_idx(uint32_t idx)\n\n{\n\n    S390PCIBusDevice *pbdev;\n\n    int i;\n\n    int j = 0;\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(\n\n        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));\n\n\n\n    if (!s) {\n\n        return NULL;\n\n    }\n\n\n\n    for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n        pbdev = &s->pbdev[i];\n\n\n\n        if (pbdev->fh == 0) {\n\n            continue;\n\n        }\n\n\n\n        if (j == idx) {\n\n            return pbdev;\n\n        }\n\n        j++;\n\n    }\n\n\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"e1833e1f96456fd8fc17463246fe0b2050e68efb","target":0,"func":"static void spr_write_ibatl (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_ibatl((sprn - SPR_IBAT0L) \/ 2);\n\n    RET_STOP(ctx);\n\n}\n"},{"project":"qemu","commit_id":"3a4dbe6aa934370a92372528c1255ee1504965ee","target":1,"func":"static void vfio_put_device(VFIOPCIDevice *vdev)\n\n{\n\n    g_free(vdev->vbasedev.name);\n\n    if (vdev->msix) {\n\n\n        g_free(vdev->msix);\n\n        vdev->msix = NULL;\n\n    }\n\n    vfio_put_base_device(&vdev->vbasedev);\n\n}"},{"project":"qemu","commit_id":"8d5c773e323b22402abdd0beef4c7d2fc91dd0eb","target":0,"func":"static void contextidr_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                             uint64_t value)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n\n\n    if (env->cp15.contextidr_el1 != value && !arm_feature(env, ARM_FEATURE_MPU)\n\n        && !extended_addresses_enabled(env)) {\n\n        \/* For VMSA (when not using the LPAE long descriptor page table\n\n         * format) this register includes the ASID, so do a TLB flush.\n\n         * For PMSA it is purely a process ID and no action is needed.\n\n         *\/\n\n        tlb_flush(CPU(cpu), 1);\n\n    }\n\n    env->cp15.contextidr_el1 = value;\n\n}\n"},{"project":"qemu","commit_id":"fff4e48ed54cc39e5942921df91300646ad37707","target":1,"func":"int net_init_vhost_user(const NetClientOptions *opts, const char *name,\n\n                        NetClientState *peer, Error **errp)\n\n{\n\n    int queues;\n\n    const NetdevVhostUserOptions *vhost_user_opts;\n\n    CharDriverState *chr;\n\n\n\n    assert(opts->type == NET_CLIENT_OPTIONS_KIND_VHOST_USER);\n\n    vhost_user_opts = opts->u.vhost_user;\n\n\n\n    chr = net_vhost_parse_chardev(vhost_user_opts, errp);\n\n    if (!chr) {\n\n        return -1;\n\n    }\n\n\n\n    \/* verify net frontend *\/\n\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"), net_vhost_check_net,\n\n                          (char *)name, errp)) {\n\n        return -1;\n\n    }\n\n\n\n    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;\n\n    if (queues < 1) {\n\n        error_setg(errp,\n\n                   \"vhost-user number of queues must be bigger than zero\");\n\n        return -1;\n\n    }\n\n\n\n    return net_vhost_user_init(peer, \"vhost_user\", name, chr, queues);\n\n}\n"},{"project":"qemu","commit_id":"5839e53bbc0fec56021d758aab7610df421ed8c8","target":1,"func":"static int vdi_check(BlockDriverState *bs, BdrvCheckResult *res,\n\n                     BdrvCheckMode fix)\n\n{\n\n    \/* TODO: additional checks possible. *\/\n\n    BDRVVdiState *s = (BDRVVdiState *)bs->opaque;\n\n    uint32_t blocks_allocated = 0;\n\n    uint32_t block;\n\n    uint32_t *bmap;\n\n    logout(\"\\n\");\n\n\n\n    if (fix) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    bmap = g_try_malloc(s->header.blocks_in_image * sizeof(uint32_t));\n\n    if (s->header.blocks_in_image && bmap == NULL) {\n\n        res->check_errors++;\n\n        return -ENOMEM;\n\n    }\n\n\n\n    memset(bmap, 0xff, s->header.blocks_in_image * sizeof(uint32_t));\n\n\n\n    \/* Check block map and value of blocks_allocated. *\/\n\n    for (block = 0; block < s->header.blocks_in_image; block++) {\n\n        uint32_t bmap_entry = le32_to_cpu(s->bmap[block]);\n\n        if (VDI_IS_ALLOCATED(bmap_entry)) {\n\n            if (bmap_entry < s->header.blocks_in_image) {\n\n                blocks_allocated++;\n\n                if (!VDI_IS_ALLOCATED(bmap[bmap_entry])) {\n\n                    bmap[bmap_entry] = bmap_entry;\n\n                } else {\n\n                    fprintf(stderr, \"ERROR: block index %\" PRIu32\n\n                            \" also used by %\" PRIu32 \"\\n\", bmap[bmap_entry], bmap_entry);\n\n                    res->corruptions++;\n\n                }\n\n            } else {\n\n                fprintf(stderr, \"ERROR: block index %\" PRIu32\n\n                        \" too large, is %\" PRIu32 \"\\n\", block, bmap_entry);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n    if (blocks_allocated != s->header.blocks_allocated) {\n\n        fprintf(stderr, \"ERROR: allocated blocks mismatch, is %\" PRIu32\n\n               \", should be %\" PRIu32 \"\\n\",\n\n               blocks_allocated, s->header.blocks_allocated);\n\n        res->corruptions++;\n\n    }\n\n\n\n    g_free(bmap);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"60fe637bf0e4d7989e21e50f52526444765c63b4","target":1,"func":"static ssize_t qsb_get_iovec(const QEMUSizedBuffer *qsb,\n\n                             off_t pos, off_t *d_off)\n\n{\n\n    ssize_t i;\n\n    off_t curr = 0;\n\n\n\n    if (pos > qsb->used) {\n\n        return -1;\n\n    }\n\n\n\n    for (i = 0; i < qsb->n_iov; i++) {\n\n        if (curr + qsb->iov[i].iov_len > pos) {\n\n            *d_off = pos - curr;\n\n            return i;\n\n        }\n\n        curr += qsb->iov[i].iov_len;\n\n    }\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"4407c1c56adb0d3ef2bcbf577592d72278d6e11f","target":0,"func":"static void virtio_blk_dma_restart_cb(void *opaque, int running,\n\n                                      RunState state)\n\n{\n\n    VirtIOBlock *s = opaque;\n\n\n\n    if (!running) {\n\n        return;\n\n    }\n\n\n\n    if (!s->bh) {\n\n        s->bh = qemu_bh_new(virtio_blk_dma_restart_bh, s);\n\n        qemu_bh_schedule(s->bh);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"563890c7c7e977842e2a35afe7a24d06d2103242","target":1,"func":"static void test_media_insert(void)\n\n{\n\n    uint8_t dir;\n\n\n\n    \/* Insert media in drive. DSKCHK should not be reset until a step pulse\n\n     * is sent. *\/\n\n    qmp_discard_response(\"{'execute':'change', 'arguments':{\"\n\n                         \" 'device':'floppy0', 'target': '%s' }}\",\n\n                         test_image);\n\n    qmp_discard_response(\"\"); \/* ignore event\n\n                                 (FIXME open -> open transition?!) *\/\n\n    qmp_discard_response(\"\"); \/* ignore event *\/\n\n\n\n    dir = inb(FLOPPY_BASE + reg_dir);\n\n    assert_bit_set(dir, DSKCHG);\n\n    dir = inb(FLOPPY_BASE + reg_dir);\n\n    assert_bit_set(dir, DSKCHG);\n\n\n\n    send_seek(0);\n\n    dir = inb(FLOPPY_BASE + reg_dir);\n\n    assert_bit_set(dir, DSKCHG);\n\n    dir = inb(FLOPPY_BASE + reg_dir);\n\n    assert_bit_set(dir, DSKCHG);\n\n\n\n    \/* Step to next track should clear DSKCHG bit. *\/\n\n    send_seek(1);\n\n    dir = inb(FLOPPY_BASE + reg_dir);\n\n    assert_bit_clear(dir, DSKCHG);\n\n    dir = inb(FLOPPY_BASE + reg_dir);\n\n    assert_bit_clear(dir, DSKCHG);\n\n}\n"},{"project":"qemu","commit_id":"a3f1afb43a09e4577571c044c48f2ba9e6e4ad06","target":0,"func":"static int zero_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* Limit nb_clusters to one L2 table *\/\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_offset;\n\n\n\n        old_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        \/* Update L2 entries *\/\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (old_offset & QCOW_OFLAG_COMPRESSED) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);\n\n        } else {\n\n            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        }\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nb_clusters;\n\n}\n"},{"project":"qemu","commit_id":"b3db211f3c80bb996a704d665fe275619f728bd4","target":0,"func":"static void test_visitor_in_native_list_uint8(TestInputVisitorData *data,\n\n                                             const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_U8);\n\n}\n"},{"project":"qemu","commit_id":"f22d85e9e67262db34504f4079745f9843da6a92","target":0,"func":"static void enable_logging(void)\n\n{\n\n    ga_enable_logging(ga_state);\n\n}\n"},{"project":"qemu","commit_id":"b062ad86dcd33ab39be5060b0655d8e13834b167","target":0,"func":"static int readv_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0, vflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    \/* Some compilers get confused and warn if this is not initialized.  *\/\n\n    int total = 0;\n\n    int nr_iov;\n\n    QEMUIOVector qiov;\n\n    int pattern = 0;\n\n    int Pflag = 0;\n\n\n\n    while ((c = getopt(argc, argv, \"CP:qv\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'P':\n\n            Pflag = 1;\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        case 'v':\n\n            vflag = 1;\n\n            break;\n\n        default:\n\n            return qemuio_command_usage(&readv_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n        return qemuio_command_usage(&readv_cmd);\n\n    }\n\n\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               offset);\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    buf = create_iovec(blk, &qiov, &argv[optind], nr_iov, 0xab);\n\n    if (buf == NULL) {\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    cnt = do_aio_readv(blk, &qiov, offset, &total);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (Pflag) {\n\n        void *cmp_buf = g_malloc(qiov.size);\n\n        memset(cmp_buf, pattern, qiov.size);\n\n        if (memcmp(buf, cmp_buf, qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", offset, qiov.size);\n\n        }\n\n        g_free(cmp_buf);\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (vflag) {\n\n        dump_buffer(buf, offset, qiov.size);\n\n    }\n\n\n\n    \/* Finally, report back -- -C gives a parsable format *\/\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"read\", &t2, offset, qiov.size, total, cnt, Cflag);\n\n\n\nout:\n\n    qemu_iovec_destroy(&qiov);\n\n    qemu_io_free(buf);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"560f19f162529d691619ac69ed032321c7f5f1fb","target":1,"func":"bool object_property_get_bool(Object *obj, const char *name,\n\n                              Error **errp)\n\n{\n\n    QObject *ret = object_property_get_qobject(obj, name, errp);\n\n    QBool *qbool;\n\n    bool retval;\n\n\n\n    if (!ret) {\n\n        return false;\n\n    }\n\n    qbool = qobject_to_qbool(ret);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name, \"boolean\");\n\n        retval = false;\n\n    } else {\n\n        retval = qbool_get_bool(qbool);\n\n    }\n\n\n\n    QDECREF(qbool);\n\n    return retval;\n\n}\n"},{"project":"qemu","commit_id":"42bb9c9178ae7ac4c439172b1ae99cc29188a5c6","target":0,"func":"static void stream_desc_store(struct Stream *s, hwaddr addr)\n\n{\n\n    struct SDesc *d = &s->desc;\n\n    int i;\n\n\n\n    \/* Convert from host endianness into LE.  *\/\n\n    d->buffer_address = cpu_to_le64(d->buffer_address);\n\n    d->nxtdesc = cpu_to_le64(d->nxtdesc);\n\n    d->control = cpu_to_le32(d->control);\n\n    d->status = cpu_to_le32(d->status);\n\n    for (i = 0; i < ARRAY_SIZE(d->app); i++) {\n\n        d->app[i] = cpu_to_le32(d->app[i]);\n\n    }\n\n    cpu_physical_memory_write(addr, (void *) d, sizeof *d);\n\n}\n"},{"project":"qemu","commit_id":"09e68369a88d7de0f988972bf28eec1b80cc47f9","target":0,"func":"static void qmp_input_type_bool(Visitor *v, const char *name, bool *obj,\n\n                                Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qmp_input_get_object(qiv, name, true, errp);\n\n    QBool *qbool;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qbool = qobject_to_qbool(qobj);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"boolean\");\n\n        return;\n\n    }\n\n\n\n    *obj = qbool_get_bool(qbool);\n\n}\n"},{"project":"qemu","commit_id":"041d95f42e39ed1d3a029332cab9966889f0aeb3","target":0,"func":"void ppc_tlb_invalidate_one(CPUPPCState *env, target_ulong addr)\n\n{\n\n#if !defined(FLUSH_ALL_TLBS)\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    CPUState *cs;\n\n\n\n    addr &= TARGET_PAGE_MASK;\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_virt(env, addr, 0);\n\n        if (env->id_tlbs == 1) {\n\n            ppc6xx_tlb_invalidate_virt(env, addr, 1);\n\n        }\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_virt(env, addr, env->spr[SPR_40x_PID]);\n\n        break;\n\n    case POWERPC_MMU_REAL:\n\n        cpu_abort(CPU(cpu), \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_MPC8xx:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(CPU(cpu), \"MPC8xx MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(CPU(cpu), \"BookE MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE206:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(CPU(cpu), \"BookE 2.06 MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n        \/* tlbie invalidate TLBs for all segments *\/\n\n        addr &= ~((target_ulong)-1ULL << 28);\n\n        cs = CPU(cpu);\n\n        \/* XXX: this case should be optimized,\n\n         * giving a mask to tlb_flush_page\n\n         *\/\n\n        tlb_flush_page(cs, addr | (0x0 << 28));\n\n        tlb_flush_page(cs, addr | (0x1 << 28));\n\n        tlb_flush_page(cs, addr | (0x2 << 28));\n\n        tlb_flush_page(cs, addr | (0x3 << 28));\n\n        tlb_flush_page(cs, addr | (0x4 << 28));\n\n        tlb_flush_page(cs, addr | (0x5 << 28));\n\n        tlb_flush_page(cs, addr | (0x6 << 28));\n\n        tlb_flush_page(cs, addr | (0x7 << 28));\n\n        tlb_flush_page(cs, addr | (0x8 << 28));\n\n        tlb_flush_page(cs, addr | (0x9 << 28));\n\n        tlb_flush_page(cs, addr | (0xA << 28));\n\n        tlb_flush_page(cs, addr | (0xB << 28));\n\n        tlb_flush_page(cs, addr | (0xC << 28));\n\n        tlb_flush_page(cs, addr | (0xD << 28));\n\n        tlb_flush_page(cs, addr | (0xE << 28));\n\n        tlb_flush_page(cs, addr | (0xF << 28));\n\n        break;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_03:\n\n    case POWERPC_MMU_2_06:\n\n    case POWERPC_MMU_2_06a:\n\n    case POWERPC_MMU_2_07:\n\n    case POWERPC_MMU_2_07a:\n\n        \/* tlbie invalidate TLBs for all segments *\/\n\n        \/* XXX: given the fact that there are too many segments to invalidate,\n\n         *      and we still don't have a tlb_flush_mask(env, n, mask) in QEMU,\n\n         *      we just invalidate all TLBs\n\n         *\/\n\n        tlb_flush(CPU(cpu), 1);\n\n        break;\n\n#endif \/* defined(TARGET_PPC64) *\/\n\n    default:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(CPU(cpu), \"Unknown MMU model\\n\");\n\n        break;\n\n    }\n\n#else\n\n    ppc_tlb_invalidate_all(env);\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"12848bfc5d719bad536c5448205a3226be1fda47","target":1,"func":"static int local_chmod(FsContext *fs_ctx, const char *path, FsCred *credp)\n\n{\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        return local_set_xattr(rpath(fs_ctx, path), credp);\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        return chmod(rpath(fs_ctx, path), credp->fc_mode);\n\n    }\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"494a8ebe713055d3946183f4b395f85a18b43e9e","target":0,"func":"static int proxy_utimensat(FsContext *s, V9fsPath *fs_path,\n\n                           const struct timespec *buf)\n\n{\n\n    int retval;\n\n    retval = v9fs_request(s->private, T_UTIME, NULL, \"sqqqq\",\n\n                          fs_path,\n\n                          buf[0].tv_sec, buf[0].tv_nsec,\n\n                          buf[1].tv_sec, buf[1].tv_nsec);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n    }\n\n    return retval;\n\n}\n"},{"project":"qemu","commit_id":"12de9a396acbc95e25c5d60ed097cc55777eaaed","target":1,"func":"void ppc_tlb_invalidate_all (CPUPPCState *env)\n\n{\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_REAL_4xx:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"MMU model not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE_FSL:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"MMU model not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_601:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"MMU model not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_64BRIDGE:\n\n#endif \/* defined(TARGET_PPC64) *\/\n\n        tlb_flush(env, 1);\n\n        break;\n\n    default:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"Unknown MMU model %d\\n\", env->mmu_model);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"fd97fd4408040a9a6dfaf2fdaeca1c566db6d0aa","target":1,"func":"static long gethugepagesize(const char *path, Error **errp)\n\n{\n\n    struct statfs fs;\n\n    int ret;\n\n\n\n    do {\n\n        ret = statfs(path, &fs);\n\n    } while (ret != 0 && errno == EINTR);\n\n\n\n    if (ret != 0) {\n\n        error_setg_errno(errp, errno, \"failed to get page size of file %s\",\n\n                         path);\n\n        return 0;\n\n    }\n\n\n\n    return fs.f_bsize;\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static bool cmd_write_multiple(IDEState *s, uint8_t cmd)\n\n{\n\n    bool lba48 = (cmd == WIN_MULTWRITE_EXT);\n\n    int n;\n\n\n\n    if (!s->bs || !s->mult_sectors) {\n\n        ide_abort_command(s);\n\n        return true;\n\n    }\n\n\n\n    ide_cmd_lba48_transform(s, lba48);\n\n\n\n    s->req_nb_sectors = s->mult_sectors;\n\n    n = MIN(s->nsector, s->req_nb_sectors);\n\n\n\n    s->status = SEEK_STAT | READY_STAT;\n\n    ide_transfer_start(s, s->io_buffer, 512 * n, ide_sector_write);\n\n\n\n    s->media_changed = 1;\n\n\n\n    return false;\n\n}\n"},{"project":"qemu","commit_id":"54ca9095f046dfa03c3d093cc55f6d76b61864e1","target":0,"func":"int cpu_x86_handle_mmu_fault(CPUX86State *env, target_ulong addr, \n\n                             int is_write1, int is_user, int is_softmmu)\n\n{\n\n    uint64_t ptep, pte;\n\n    uint32_t pdpe_addr, pde_addr, pte_addr;\n\n    int error_code, is_dirty, prot, page_size, ret, is_write;\n\n    unsigned long paddr, page_offset;\n\n    target_ulong vaddr, virt_addr;\n\n    \n\n#if defined(DEBUG_MMU)\n\n    printf(\"MMU fault: addr=\" TARGET_FMT_lx \" w=%d u=%d eip=\" TARGET_FMT_lx \"\\n\", \n\n           addr, is_write1, is_user, env->eip);\n\n#endif\n\n    is_write = is_write1 & 1;\n\n    \n\n    if (!(env->cr[0] & CR0_PG_MASK)) {\n\n        pte = addr;\n\n        virt_addr = addr & TARGET_PAGE_MASK;\n\n        prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n        page_size = 4096;\n\n        goto do_mapping;\n\n    }\n\n\n\n    if (env->cr[4] & CR4_PAE_MASK) {\n\n        uint64_t pde, pdpe;\n\n\n\n        \/* XXX: we only use 32 bit physical addresses *\/\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_LMA_MASK) {\n\n            uint32_t pml4e_addr;\n\n            uint64_t pml4e;\n\n            int32_t sext;\n\n\n\n            \/* test virtual address sign extension *\/\n\n            sext = (int64_t)addr >> 47;\n\n            if (sext != 0 && sext != -1) {\n\n                error_code = 0;\n\n                goto do_fault;\n\n            }\n\n            \n\n            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) & \n\n                env->a20_mask;\n\n            pml4e = ldq_phys(pml4e_addr);\n\n            if (!(pml4e & PG_PRESENT_MASK)) {\n\n                error_code = 0;\n\n                goto do_fault;\n\n            }\n\n            if (!(env->efer & MSR_EFER_NXE) && (pml4e & PG_NX_MASK)) {\n\n                error_code = PG_ERROR_RSVD_MASK;\n\n                goto do_fault;\n\n            }\n\n            if (!(pml4e & PG_ACCESSED_MASK)) {\n\n                pml4e |= PG_ACCESSED_MASK;\n\n                stl_phys_notdirty(pml4e_addr, pml4e);\n\n            }\n\n            ptep = pml4e ^ PG_NX_MASK;\n\n            pdpe_addr = ((pml4e & PHYS_ADDR_MASK) + (((addr >> 30) & 0x1ff) << 3)) & \n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK)) {\n\n                error_code = 0;\n\n                goto do_fault;\n\n            }\n\n            if (!(env->efer & MSR_EFER_NXE) && (pdpe & PG_NX_MASK)) {\n\n                error_code = PG_ERROR_RSVD_MASK;\n\n                goto do_fault;\n\n            }\n\n            ptep &= pdpe ^ PG_NX_MASK;\n\n            if (!(pdpe & PG_ACCESSED_MASK)) {\n\n                pdpe |= PG_ACCESSED_MASK;\n\n                stl_phys_notdirty(pdpe_addr, pdpe);\n\n            }\n\n        } else\n\n#endif\n\n        {\n\n            \/* XXX: load them when cr3 is loaded ? *\/\n\n            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 30) << 3)) & \n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK)) {\n\n                error_code = 0;\n\n                goto do_fault;\n\n            }\n\n            ptep = PG_NX_MASK | PG_USER_MASK | PG_RW_MASK;\n\n        }\n\n\n\n        pde_addr = ((pdpe & PHYS_ADDR_MASK) + (((addr >> 21) & 0x1ff) << 3)) &\n\n            env->a20_mask;\n\n        pde = ldq_phys(pde_addr);\n\n        if (!(pde & PG_PRESENT_MASK)) {\n\n            error_code = 0;\n\n            goto do_fault;\n\n        }\n\n        if (!(env->efer & MSR_EFER_NXE) && (pde & PG_NX_MASK)) {\n\n            error_code = PG_ERROR_RSVD_MASK;\n\n            goto do_fault;\n\n        }\n\n        ptep &= pde ^ PG_NX_MASK;\n\n        if (pde & PG_PSE_MASK) {\n\n            \/* 2 MB page *\/\n\n            page_size = 2048 * 1024;\n\n            ptep ^= PG_NX_MASK;\n\n            if ((ptep & PG_NX_MASK) && is_write1 == 2)\n\n                goto do_fault_protect;\n\n            if (is_user) {\n\n                if (!(ptep & PG_USER_MASK))\n\n                    goto do_fault_protect;\n\n                if (is_write && !(ptep & PG_RW_MASK))\n\n                    goto do_fault_protect;\n\n            } else {\n\n                if ((env->cr[0] & CR0_WP_MASK) && \n\n                    is_write && !(ptep & PG_RW_MASK)) \n\n                    goto do_fault_protect;\n\n            }\n\n            is_dirty = is_write && !(pde & PG_DIRTY_MASK);\n\n            if (!(pde & PG_ACCESSED_MASK) || is_dirty) {\n\n                pde |= PG_ACCESSED_MASK;\n\n                if (is_dirty)\n\n                    pde |= PG_DIRTY_MASK;\n\n                stl_phys_notdirty(pde_addr, pde);\n\n            }\n\n            \/* align to page_size *\/\n\n            pte = pde & ((PHYS_ADDR_MASK & ~(page_size - 1)) | 0xfff); \n\n            virt_addr = addr & ~(page_size - 1);\n\n        } else {\n\n            \/* 4 KB page *\/\n\n            if (!(pde & PG_ACCESSED_MASK)) {\n\n                pde |= PG_ACCESSED_MASK;\n\n                stl_phys_notdirty(pde_addr, pde);\n\n            }\n\n            pte_addr = ((pde & PHYS_ADDR_MASK) + (((addr >> 12) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pte = ldq_phys(pte_addr);\n\n            if (!(pte & PG_PRESENT_MASK)) {\n\n                error_code = 0;\n\n                goto do_fault;\n\n            }\n\n            if (!(env->efer & MSR_EFER_NXE) && (pte & PG_NX_MASK)) {\n\n                error_code = PG_ERROR_RSVD_MASK;\n\n                goto do_fault;\n\n            }\n\n            \/* combine pde and pte nx, user and rw protections *\/\n\n            ptep &= pte ^ PG_NX_MASK;\n\n            ptep ^= PG_NX_MASK;\n\n            if ((ptep & PG_NX_MASK) && is_write1 == 2)\n\n                goto do_fault_protect; \n\n            if (is_user) {\n\n                if (!(ptep & PG_USER_MASK))\n\n                    goto do_fault_protect;\n\n                if (is_write && !(ptep & PG_RW_MASK))\n\n                    goto do_fault_protect;\n\n            } else {\n\n                if ((env->cr[0] & CR0_WP_MASK) &&\n\n                    is_write && !(ptep & PG_RW_MASK)) \n\n                    goto do_fault_protect;\n\n            }\n\n            is_dirty = is_write && !(pte & PG_DIRTY_MASK);\n\n            if (!(pte & PG_ACCESSED_MASK) || is_dirty) {\n\n                pte |= PG_ACCESSED_MASK;\n\n                if (is_dirty)\n\n                    pte |= PG_DIRTY_MASK;\n\n                stl_phys_notdirty(pte_addr, pte);\n\n            }\n\n            page_size = 4096;\n\n            virt_addr = addr & ~0xfff;\n\n            pte = pte & (PHYS_ADDR_MASK | 0xfff);\n\n        }\n\n    } else {\n\n        uint32_t pde;\n\n\n\n        \/* page directory entry *\/\n\n        pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & ~3)) & \n\n            env->a20_mask;\n\n        pde = ldl_phys(pde_addr);\n\n        if (!(pde & PG_PRESENT_MASK)) {\n\n            error_code = 0;\n\n            goto do_fault;\n\n        }\n\n        \/* if PSE bit is set, then we use a 4MB page *\/\n\n        if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n            page_size = 4096 * 1024;\n\n            if (is_user) {\n\n                if (!(pde & PG_USER_MASK))\n\n                    goto do_fault_protect;\n\n                if (is_write && !(pde & PG_RW_MASK))\n\n                    goto do_fault_protect;\n\n            } else {\n\n                if ((env->cr[0] & CR0_WP_MASK) && \n\n                    is_write && !(pde & PG_RW_MASK)) \n\n                    goto do_fault_protect;\n\n            }\n\n            is_dirty = is_write && !(pde & PG_DIRTY_MASK);\n\n            if (!(pde & PG_ACCESSED_MASK) || is_dirty) {\n\n                pde |= PG_ACCESSED_MASK;\n\n                if (is_dirty)\n\n                    pde |= PG_DIRTY_MASK;\n\n                stl_phys_notdirty(pde_addr, pde);\n\n            }\n\n        \n\n            pte = pde & ~( (page_size - 1) & ~0xfff); \/* align to page_size *\/\n\n            ptep = pte;\n\n            virt_addr = addr & ~(page_size - 1);\n\n        } else {\n\n            if (!(pde & PG_ACCESSED_MASK)) {\n\n                pde |= PG_ACCESSED_MASK;\n\n                stl_phys_notdirty(pde_addr, pde);\n\n            }\n\n\n\n            \/* page directory entry *\/\n\n            pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & \n\n                env->a20_mask;\n\n            pte = ldl_phys(pte_addr);\n\n            if (!(pte & PG_PRESENT_MASK)) {\n\n                error_code = 0;\n\n                goto do_fault;\n\n            }\n\n            \/* combine pde and pte user and rw protections *\/\n\n            ptep = pte & pde;\n\n            if (is_user) {\n\n                if (!(ptep & PG_USER_MASK))\n\n                    goto do_fault_protect;\n\n                if (is_write && !(ptep & PG_RW_MASK))\n\n                    goto do_fault_protect;\n\n            } else {\n\n                if ((env->cr[0] & CR0_WP_MASK) &&\n\n                    is_write && !(ptep & PG_RW_MASK)) \n\n                    goto do_fault_protect;\n\n            }\n\n            is_dirty = is_write && !(pte & PG_DIRTY_MASK);\n\n            if (!(pte & PG_ACCESSED_MASK) || is_dirty) {\n\n                pte |= PG_ACCESSED_MASK;\n\n                if (is_dirty)\n\n                    pte |= PG_DIRTY_MASK;\n\n                stl_phys_notdirty(pte_addr, pte);\n\n            }\n\n            page_size = 4096;\n\n            virt_addr = addr & ~0xfff;\n\n        }\n\n    }\n\n    \/* the page can be put in the TLB *\/\n\n    prot = PAGE_READ;\n\n    if (!(ptep & PG_NX_MASK))\n\n        prot |= PAGE_EXEC;\n\n    if (pte & PG_DIRTY_MASK) {\n\n        \/* only set write access if already dirty... otherwise wait\n\n           for dirty access *\/\n\n        if (is_user) {\n\n            if (ptep & PG_RW_MASK)\n\n                prot |= PAGE_WRITE;\n\n        } else {\n\n            if (!(env->cr[0] & CR0_WP_MASK) ||\n\n                (ptep & PG_RW_MASK))\n\n                prot |= PAGE_WRITE;\n\n        }\n\n    }\n\n do_mapping:\n\n    pte = pte & env->a20_mask;\n\n\n\n    \/* Even if 4MB pages, we map only one 4KB page in the cache to\n\n       avoid filling it too fast *\/\n\n    page_offset = (addr & TARGET_PAGE_MASK) & (page_size - 1);\n\n    paddr = (pte & TARGET_PAGE_MASK) + page_offset;\n\n    vaddr = virt_addr + page_offset;\n\n    \n\n    ret = tlb_set_page_exec(env, vaddr, paddr, prot, is_user, is_softmmu);\n\n    return ret;\n\n do_fault_protect:\n\n    error_code = PG_ERROR_P_MASK;\n\n do_fault:\n\n    env->cr[2] = addr;\n\n    error_code |= (is_write << PG_ERROR_W_BIT);\n\n    if (is_user)\n\n        error_code |= PG_ERROR_U_MASK;\n\n    if (is_write1 == 2 && \n\n        (env->efer & MSR_EFER_NXE) && \n\n        (env->cr[4] & CR4_PAE_MASK))\n\n        error_code |= PG_ERROR_I_D_MASK;\n\n    env->error_code = error_code;\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"30fb2ca603e8b8d0f02630ef18bc0d0637a88ffa","target":1,"func":"static int qemu_balloon(ram_addr_t target, MonitorCompletion cb, void *opaque)\n\n{\n\n    if (!balloon_event_fn) {\n\n        return 0;\n\n    }\n\n    trace_balloon_event(balloon_opaque, target);\n\n    balloon_event_fn(balloon_opaque, target, cb, opaque);\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"b84c4586234b26ccc875595713f6f4491e5b3385","target":0,"func":"static void __attribute__((destructor)) coroutine_cleanup(void)\n\n{\n\n    Coroutine *co;\n\n    Coroutine *tmp;\n\n\n\n    QSLIST_FOREACH_SAFE(co, &pool, pool_next, tmp) {\n\n        QSLIST_REMOVE_HEAD(&pool, pool_next);\n\n        qemu_coroutine_delete(co);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"760794f784f66e262a9ca32821ba202cdf3a3e4b","target":1,"func":"static int chr_can_read(void *opaque)\n\n{\n\n    int can_read;\n\n    SCLPConsole *scon = opaque;\n\n\n\n    can_read = SIZE_BUFFER_VT220 - scon->iov_data_len;\n\n\n\n    return can_read;\n\n}\n"},{"project":"qemu","commit_id":"5d79b80b335c5f65f148d1bb1672d9d534ace73b","target":0,"func":"static void pflash_write(pflash_t *pfl, hwaddr offset,\n\n                         uint32_t value, int width, int be)\n\n{\n\n    uint8_t *p;\n\n    uint8_t cmd;\n\n\n\n    cmd = value;\n\n\n\n    DPRINTF(\"%s: writing offset \" TARGET_FMT_plx \" value %08x width %d wcycle 0x%x\\n\",\n\n            __func__, offset, value, width, pfl->wcycle);\n\n\n\n    if (!pfl->wcycle) {\n\n        \/* Set the device in I\/O access mode *\/\n\n        memory_region_rom_device_set_readable(&pfl->mem, false);\n\n    }\n\n\n\n    switch (pfl->wcycle) {\n\n    case 0:\n\n        \/* read mode *\/\n\n        switch (cmd) {\n\n        case 0x00: \/* ??? *\/\n\n            goto reset_flash;\n\n        case 0x10: \/* Single Byte Program *\/\n\n        case 0x40: \/* Single Byte Program *\/\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            break;\n\n        case 0x20: \/* Block erase *\/\n\n            p = pfl->storage;\n\n            offset &= ~(pfl->sector_len - 1);\n\n\n\n            DPRINTF(\"%s: block erase at \" TARGET_FMT_plx \" bytes %x\\n\",\n\n                    __func__, offset, (unsigned)pfl->sector_len);\n\n\n\n            if (!pfl->ro) {\n\n                memset(p + offset, 0xff, pfl->sector_len);\n\n                pflash_update(pfl, offset, pfl->sector_len);\n\n            } else {\n\n                pfl->status |= 0x20; \/* Block erase error *\/\n\n            }\n\n            pfl->status |= 0x80; \/* Ready! *\/\n\n            break;\n\n        case 0x50: \/* Clear status bits *\/\n\n            DPRINTF(\"%s: Clear status bits\\n\", __func__);\n\n            pfl->status = 0x0;\n\n            goto reset_flash;\n\n        case 0x60: \/* Block (un)lock *\/\n\n            DPRINTF(\"%s: Block unlock\\n\", __func__);\n\n            break;\n\n        case 0x70: \/* Status Register *\/\n\n            DPRINTF(\"%s: Read status register\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x90: \/* Read Device ID *\/\n\n            DPRINTF(\"%s: Read Device information\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x98: \/* CFI query *\/\n\n            DPRINTF(\"%s: CFI query\\n\", __func__);\n\n            break;\n\n        case 0xe8: \/* Write to buffer *\/\n\n            DPRINTF(\"%s: Write to buffer\\n\", __func__);\n\n            pfl->status |= 0x80; \/* Ready! *\/\n\n            break;\n\n        case 0xf0: \/* Probe for AMD flash *\/\n\n            DPRINTF(\"%s: Probe for AMD flash\\n\", __func__);\n\n            goto reset_flash;\n\n        case 0xff: \/* Read array mode *\/\n\n            DPRINTF(\"%s: Read array mode\\n\", __func__);\n\n            goto reset_flash;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        pfl->wcycle++;\n\n        pfl->cmd = cmd;\n\n        break;\n\n    case 1:\n\n        switch (pfl->cmd) {\n\n        case 0x10: \/* Single Byte Program *\/\n\n        case 0x40: \/* Single Byte Program *\/\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n                pflash_update(pfl, offset, width);\n\n            } else {\n\n                pfl->status |= 0x10; \/* Programming error *\/\n\n            }\n\n            pfl->status |= 0x80; \/* Ready! *\/\n\n            pfl->wcycle = 0;\n\n        break;\n\n        case 0x20: \/* Block erase *\/\n\n        case 0x28:\n\n            if (cmd == 0xd0) { \/* confirm *\/\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) { \/* read array mode *\/\n\n                goto reset_flash;\n\n            } else\n\n                goto error_flash;\n\n\n\n            break;\n\n        case 0xe8:\n\n            DPRINTF(\"%s: block write of %x bytes\\n\", __func__, value);\n\n            pfl->counter = value;\n\n            pfl->wcycle++;\n\n            break;\n\n        case 0x60:\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0x01) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: Unknown (un)locking command\\n\", __func__);\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        case 0x98:\n\n            if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: leaving query mode\\n\", __func__);\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 2:\n\n        switch (pfl->cmd) {\n\n        case 0xe8: \/* Block write *\/\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n            } else {\n\n                pfl->status |= 0x10; \/* Programming error *\/\n\n            }\n\n\n\n            pfl->status |= 0x80;\n\n\n\n            if (!pfl->counter) {\n\n                hwaddr mask = pfl->writeblock_size - 1;\n\n                mask = ~mask;\n\n\n\n                DPRINTF(\"%s: block write finished\\n\", __func__);\n\n                pfl->wcycle++;\n\n                if (!pfl->ro) {\n\n                    \/* Flush the entire write buffer onto backing storage.  *\/\n\n                    pflash_update(pfl, offset & mask, pfl->writeblock_size);\n\n                } else {\n\n                    pfl->status |= 0x10; \/* Programming error *\/\n\n                }\n\n            }\n\n\n\n            pfl->counter--;\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 3: \/* Confirm mode *\/\n\n        switch (pfl->cmd) {\n\n        case 0xe8: \/* Block write *\/\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else {\n\n                DPRINTF(\"%s: unknown command for \\\"write block\\\"\\n\", __func__);\n\n                PFLASH_BUG(\"Write block confirm\");\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    default:\n\n        \/* Should never happen *\/\n\n        DPRINTF(\"%s: invalid write state\\n\",  __func__);\n\n        goto reset_flash;\n\n    }\n\n    return;\n\n\n\n error_flash:\n\n    qemu_log_mask(LOG_UNIMP, \"%s: Unimplemented flash cmd sequence \"\n\n                  \"(offset \" TARGET_FMT_plx \", wcycle 0x%x cmd 0x%x value 0x%x)\"\n\n                  \"\\n\", __func__, offset, pfl->wcycle, pfl->cmd, value);\n\n\n\n reset_flash:\n\n    memory_region_rom_device_set_readable(&pfl->mem, true);\n\n\n\n    pfl->bypass = 0;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n}\n"},{"project":"qemu","commit_id":"cfaf6d36ae761da1033159d85d670706ffb24fb9","target":0,"func":"static void exec_accept_incoming_migration(void *opaque)\n\n{\n\n    QEMUFile *f = opaque;\n\n    int ret;\n\n\n\n    ret = qemu_loadvm_state(f);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"load of migration failed\\n\");\n\n        goto err;\n\n    }\n\n    qemu_announce_self();\n\n    DPRINTF(\"successfully loaded vm state\\n\");\n\n    \/* we've successfully migrated, close the fd *\/\n\n    qemu_set_fd_handler2(qemu_stdio_fd(f), NULL, NULL, NULL, NULL);\n\n    if (autostart)\n\n        vm_start();\n\n\n\nerr:\n\n    qemu_fclose(f);\n\n}\n"},{"project":"qemu","commit_id":"0193c62c94643a837832f2b5ccc133434ee740cb","target":0,"func":"static int xenfb_map_fb(struct XenFB *xenfb)\n\n{\n\n    struct xenfb_page *page = xenfb->c.page;\n\n    char *protocol = xenfb->c.xendev.protocol;\n\n    int n_fbdirs;\n\n    unsigned long *pgmfns = NULL;\n\n    unsigned long *fbmfns = NULL;\n\n    void *map, *pd;\n\n    int mode, ret = -1;\n\n\n\n    \/* default to native *\/\n\n    pd = page->pd;\n\n    mode = sizeof(unsigned long) * 8;\n\n\n\n    if (!protocol) {\n\n\t\/*\n\n\t * Undefined protocol, some guesswork needed.\n\n\t *\n\n\t * Old frontends which don't set the protocol use\n\n\t * one page directory only, thus pd[1] must be zero.\n\n\t * pd[1] of the 32bit struct layout and the lower\n\n\t * 32 bits of pd[0] of the 64bit struct layout have\n\n\t * the same location, so we can check that ...\n\n\t *\/\n\n\tuint32_t *ptr32 = NULL;\n\n\tuint32_t *ptr64 = NULL;\n\n#if defined(__i386__)\n\n\tptr32 = (void*)page->pd;\n\n\tptr64 = ((void*)page->pd) + 4;\n\n#elif defined(__x86_64__)\n\n\tptr32 = ((void*)page->pd) - 4;\n\n\tptr64 = (void*)page->pd;\n\n#endif\n\n\tif (ptr32) {\n\n\t    if (ptr32[1] == 0) {\n\n\t\tmode = 32;\n\n\t\tpd   = ptr32;\n\n\t    } else {\n\n\t\tmode = 64;\n\n\t\tpd   = ptr64;\n\n\t    }\n\n\t}\n\n#if defined(__x86_64__)\n\n    } else if (strcmp(protocol, XEN_IO_PROTO_ABI_X86_32) == 0) {\n\n\t\/* 64bit dom0, 32bit domU *\/\n\n\tmode = 32;\n\n\tpd   = ((void*)page->pd) - 4;\n\n#elif defined(__i386__)\n\n    } else if (strcmp(protocol, XEN_IO_PROTO_ABI_X86_64) == 0) {\n\n\t\/* 32bit dom0, 64bit domU *\/\n\n\tmode = 64;\n\n\tpd   = ((void*)page->pd) + 4;\n\n#endif\n\n    }\n\n\n\n    if (xenfb->pixels) {\n\n        munmap(xenfb->pixels, xenfb->fbpages * XC_PAGE_SIZE);\n\n        xenfb->pixels = NULL;\n\n    }\n\n\n\n    xenfb->fbpages = (xenfb->fb_len + (XC_PAGE_SIZE - 1)) \/ XC_PAGE_SIZE;\n\n    n_fbdirs = xenfb->fbpages * mode \/ 8;\n\n    n_fbdirs = (n_fbdirs + (XC_PAGE_SIZE - 1)) \/ XC_PAGE_SIZE;\n\n\n\n    pgmfns = g_malloc0(sizeof(unsigned long) * n_fbdirs);\n\n    fbmfns = g_malloc0(sizeof(unsigned long) * xenfb->fbpages);\n\n\n\n    xenfb_copy_mfns(mode, n_fbdirs, pgmfns, pd);\n\n    map = xc_map_foreign_pages(xen_xc, xenfb->c.xendev.dom,\n\n\t\t\t       PROT_READ, pgmfns, n_fbdirs);\n\n    if (map == NULL)\n\n\tgoto out;\n\n    xenfb_copy_mfns(mode, xenfb->fbpages, fbmfns, map);\n\n    munmap(map, n_fbdirs * XC_PAGE_SIZE);\n\n\n\n    xenfb->pixels = xc_map_foreign_pages(xen_xc, xenfb->c.xendev.dom,\n\n\t\t\t\t\t PROT_READ | PROT_WRITE, fbmfns, xenfb->fbpages);\n\n    if (xenfb->pixels == NULL)\n\n\tgoto out;\n\n\n\n    ret = 0; \/* all is fine *\/\n\n\n\nout:\n\n    g_free(pgmfns);\n\n    g_free(fbmfns);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"08a2d4c4ffde60e48819449f461274c43ad6e2d3","target":0,"func":"static void sdl_mouse_warp(int x, int y, int on)\n\n{\n\n    if (on) {\n\n        if (!guest_cursor)\n\n            sdl_show_cursor();\n\n        if (gui_grab || kbd_mouse_is_absolute() || absolute_enabled) {\n\n            SDL_SetCursor(guest_sprite);\n\n            SDL_WarpMouse(x, y);\n\n        }\n\n    } else if (gui_grab)\n\n        sdl_hide_cursor();\n\n    guest_cursor = on;\n\n    guest_x = x, guest_y = y;\n\n}\n"},{"project":"qemu","commit_id":"81174dae3f9189519cd60c7b79e91c291b021bbe","target":1,"func":"static int tty_serial_ioctl(CharDriverState *chr, int cmd, void *arg)\n\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    switch(cmd) {\n\n    case CHR_IOCTL_SERIAL_SET_PARAMS:\n\n\n            QEMUSerialSetParams *ssp = arg;\n\n            tty_serial_init(s->fd_in, ssp->speed, ssp->parity,\n\n                            ssp->data_bits, ssp->stop_bits);\n\n\n\n    case CHR_IOCTL_SERIAL_SET_BREAK:\n\n\n            int enable = *(int *)arg;\n\n            if (enable)\n\n                tcsendbreak(s->fd_in, 1);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    default:\n\n        return -ENOTSUP;\n\n\n    return 0;\n"},{"project":"qemu","commit_id":"d9bce9d99f4656ae0b0127f7472db9067b8f84ab","target":1,"func":"void do_adde (void)\n\n{\n\n    T2 = T0;\n\n    T0 += T1 + xer_ca;\n\n    if (likely(!(T0 < T2 || (xer_ca == 1 && T0 == T2)))) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"bf8d492405feaee2c1685b3b9d5e03228ed3e47f","target":1,"func":"static void pxb_host_class_init(ObjectClass *class, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(class);\n\n    SysBusDeviceClass *sbc = SYS_BUS_DEVICE_CLASS(class);\n\n    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(class);\n\n\n\n    dc->fw_name = \"pci\";\n\n\n\n    sbc->explicit_ofw_unit_address = pxb_host_ofw_unit_address;\n\n    hc->root_bus_path = pxb_host_root_bus_path;\n\n}"},{"project":"qemu","commit_id":"72cf2d4f0e181d0d3a3122e04129c58a95da713e","target":0,"func":"static void rndis_clear_responsequeue(USBNetState *s)\n\n{\n\n    struct rndis_response *r;\n\n\n\n    while ((r = s->rndis_resp.tqh_first)) {\n\n        TAILQ_REMOVE(&s->rndis_resp, r, entries);\n\n        qemu_free(r);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"e4f4fb1eca795e36f363b4647724221e774523c1","target":1,"func":"static void unimp_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = unimp_realize;\n\n    dc->props = unimp_properties;\n\n\n\n\n\n\n}"},{"project":"qemu","commit_id":"621ff94d5074d88253a5818c6b9c4db718fbfc65","target":0,"func":"static int qcow2_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    char *backing_file = NULL;\n\n    char *backing_fmt = NULL;\n\n    char *buf = NULL;\n\n    uint64_t size = 0;\n\n    int flags = 0;\n\n    size_t cluster_size = DEFAULT_CLUSTER_SIZE;\n\n    PreallocMode prealloc;\n\n    int version = 3;\n\n    uint64_t refcount_bits = 16;\n\n    int refcount_order;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    \/* Read out options *\/\n\n    size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),\n\n                    BDRV_SECTOR_SIZE);\n\n    backing_file = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n    backing_fmt = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FMT);\n\n    if (qemu_opt_get_bool_del(opts, BLOCK_OPT_ENCRYPT, false)) {\n\n        flags |= BLOCK_FLAG_ENCRYPT;\n\n    }\n\n    cluster_size = qemu_opt_get_size_del(opts, BLOCK_OPT_CLUSTER_SIZE,\n\n                                         DEFAULT_CLUSTER_SIZE);\n\n    buf = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);\n\n    prealloc = qapi_enum_parse(PreallocMode_lookup, buf,\n\n                               PREALLOC_MODE__MAX, PREALLOC_MODE_OFF,\n\n                               &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n    g_free(buf);\n\n    buf = qemu_opt_get_del(opts, BLOCK_OPT_COMPAT_LEVEL);\n\n    if (!buf) {\n\n        \/* keep the default *\/\n\n    } else if (!strcmp(buf, \"0.10\")) {\n\n        version = 2;\n\n    } else if (!strcmp(buf, \"1.1\")) {\n\n        version = 3;\n\n    } else {\n\n        error_setg(errp, \"Invalid compatibility level: '%s'\", buf);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (qemu_opt_get_bool_del(opts, BLOCK_OPT_LAZY_REFCOUNTS, false)) {\n\n        flags |= BLOCK_FLAG_LAZY_REFCOUNTS;\n\n    }\n\n\n\n    if (backing_file && prealloc != PREALLOC_MODE_OFF) {\n\n        error_setg(errp, \"Backing file and preallocation cannot be used at \"\n\n                   \"the same time\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (version < 3 && (flags & BLOCK_FLAG_LAZY_REFCOUNTS)) {\n\n        error_setg(errp, \"Lazy refcounts only supported with compatibility \"\n\n                   \"level 1.1 and above (use compat=1.1 or greater)\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    refcount_bits = qemu_opt_get_number_del(opts, BLOCK_OPT_REFCOUNT_BITS,\n\n                                            refcount_bits);\n\n    if (refcount_bits > 64 || !is_power_of_2(refcount_bits)) {\n\n        error_setg(errp, \"Refcount width must be a power of two and may not \"\n\n                   \"exceed 64 bits\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (version < 3 && refcount_bits != 16) {\n\n        error_setg(errp, \"Different refcount widths than 16 bits require \"\n\n                   \"compatibility level 1.1 or above (use compat=1.1 or \"\n\n                   \"greater)\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    refcount_order = ctz32(refcount_bits);\n\n\n\n    ret = qcow2_create2(filename, size, backing_file, backing_fmt, flags,\n\n                        cluster_size, prealloc, opts, version, refcount_order,\n\n                        &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n\n\nfinish:\n\n    g_free(backing_file);\n\n    g_free(backing_fmt);\n\n    g_free(buf);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"b2899495e3bd467adb9ef195655407cd58a97ded","target":0,"func":"POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER9\";\n\n    dc->desc = \"POWER9\";\n\n    dc->props = powerpc_servercpu_properties;\n\n    pcc->pvr_match = ppc_pvr_match_power9;\n\n    pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07;\n\n    pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 |\n\n                         PCR_COMPAT_2_05;\n\n    pcc->init_proc = init_proc_POWER9;\n\n    pcc->check_pow = check_pow_nocheck;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_FRSQRTES |\n\n                       PPC_FLOAT_STFIWX |\n\n                       PPC_FLOAT_EXT |\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_64BX | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD |\n\n                       PPC_CILDST;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |\n\n                        PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |\n\n                        PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |\n\n                        PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |\n\n                        PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;\n\n    pcc->msr_mask = (1ull << MSR_SF) |\n\n                    (1ull << MSR_TM) |\n\n                    (1ull << MSR_VR) |\n\n                    (1ull << MSR_VSX) |\n\n                    (1ull << MSR_EE) |\n\n                    (1ull << MSR_PR) |\n\n                    (1ull << MSR_FP) |\n\n                    (1ull << MSR_ME) |\n\n                    (1ull << MSR_FE0) |\n\n                    (1ull << MSR_SE) |\n\n                    (1ull << MSR_DE) |\n\n                    (1ull << MSR_FE1) |\n\n                    (1ull << MSR_IR) |\n\n                    (1ull << MSR_DR) |\n\n                    (1ull << MSR_PMM) |\n\n                    (1ull << MSR_RI) |\n\n                    (1ull << MSR_LE);\n\n    pcc->mmu_model = POWERPC_MMU_3_00;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc_hash64_handle_mmu_fault;\n\n    \/* segment page size remain the same *\/\n\n    pcc->sps = &POWER7_POWER8_sps;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER8;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX | POWERPC_FLAG_TM;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr;\n\n}\n"},{"project":"qemu","commit_id":"5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b","target":0,"func":"static void vnc_write_s32(VncState *vs, int32_t value)\n\n{\n\n    vnc_write_u32(vs, *(uint32_t *)&value);\n\n}\n"},{"project":"qemu","commit_id":"d33271213437ed1834b0a50540d79e877e1cd894","target":0,"func":"uint32_t HELPER(mvcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,\n\n                       uint32_t r3)\n\n{\n\n    uintptr_t ra = GETPC();\n\n    uint64_t destlen = get_length(env, r1 + 1);\n\n    uint64_t dest = get_address(env, r1);\n\n    uint64_t srclen = get_length(env, r3 + 1);\n\n    uint64_t src = get_address(env, r3);\n\n    uint8_t pad = a2 & 0xff;\n\n    uint8_t v;\n\n    uint32_t cc;\n\n\n\n    if (destlen == srclen) {\n\n        cc = 0;\n\n    } else if (destlen < srclen) {\n\n        cc = 1;\n\n    } else {\n\n        cc = 2;\n\n    }\n\n\n\n    if (srclen > destlen) {\n\n        srclen = destlen;\n\n    }\n\n\n\n    for (; destlen && srclen; src++, dest++, destlen--, srclen--) {\n\n        v = cpu_ldub_data_ra(env, src, ra);\n\n        cpu_stb_data_ra(env, dest, v, ra);\n\n    }\n\n\n\n    for (; destlen; dest++, destlen--) {\n\n        cpu_stb_data_ra(env, dest, pad, ra);\n\n    }\n\n\n\n    set_length(env, r1 + 1 , destlen);\n\n    \/* can't use srclen here, we trunc'ed it *\/\n\n    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);\n\n    set_address(env, r1, dest);\n\n    set_address(env, r3, src);\n\n\n\n    return cc;\n\n}\n"},{"project":"qemu","commit_id":"4a41a2d68a684241aca96dba066e0699941b730d","target":1,"func":"void nbd_client_session_close(NbdClientSession *client)\n\n{\n\n    if (!client->bs) {\n\n        return;\n\n    }\n\n\n\n    nbd_teardown_connection(client);\n\n    client->bs = NULL;\n\n}\n"},{"project":"qemu","commit_id":"5a3165263ae6782a7fe712a0a0c29c17468b9b68","target":0,"func":"static void check_watchpoint(int offset, int len_mask, int flags)\n\n{\n\n    CPUArchState *env = cpu_single_env;\n\n    target_ulong pc, cs_base;\n\n    TranslationBlock *tb;\n\n    target_ulong vaddr;\n\n    CPUWatchpoint *wp;\n\n    int cpu_flags;\n\n\n\n    if (env->watchpoint_hit) {\n\n        \/* We re-entered the check after replacing the TB. Now raise\n\n         * the debug interrupt so that is will trigger after the\n\n         * current instruction. *\/\n\n        cpu_interrupt(env, CPU_INTERRUPT_DEBUG);\n\n        return;\n\n    }\n\n    vaddr = (env->mem_io_vaddr & TARGET_PAGE_MASK) + offset;\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if ((vaddr == (wp->vaddr & len_mask) ||\n\n             (vaddr & wp->len_mask) == wp->vaddr) && (wp->flags & flags)) {\n\n            wp->flags |= BP_WATCHPOINT_HIT;\n\n            if (!env->watchpoint_hit) {\n\n                env->watchpoint_hit = wp;\n\n                tb = tb_find_pc(env->mem_io_pc);\n\n                if (!tb) {\n\n                    cpu_abort(env, \"check_watchpoint: could not find TB for \"\n\n                              \"pc=%p\", (void *)env->mem_io_pc);\n\n                }\n\n                cpu_restore_state(tb, env, env->mem_io_pc);\n\n                tb_phys_invalidate(tb, -1);\n\n                if (wp->flags & BP_STOP_BEFORE_ACCESS) {\n\n                    env->exception_index = EXCP_DEBUG;\n\n                    cpu_loop_exit(env);\n\n                } else {\n\n                    cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);\n\n                    tb_gen_code(env, pc, cs_base, cpu_flags, 1);\n\n                    cpu_resume_from_signal(env, NULL);\n\n                }\n\n            }\n\n        } else {\n\n            wp->flags &= ~BP_WATCHPOINT_HIT;\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae","target":0,"func":"static void test_validate_union_anon(TestInputVisitorData *data,\n\n                                     const void *unused)\n\n{\n\n    UserDefAnonUnion *tmp = NULL;\n\n    Visitor *v;\n\n    Error *errp = NULL;\n\n\n\n    v = validate_test_init(data, \"42\");\n\n\n\n    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);\n\n    g_assert(!error_is_set(&errp));\n\n    qapi_free_UserDefAnonUnion(tmp);\n\n}\n"},{"project":"qemu","commit_id":"3e831b40e015ba34dfb55ff11f767001839425ff","target":1,"func":"pvscsi_on_cmd_setup_msg_ring(PVSCSIState *s)\n\n{\n\n    PVSCSICmdDescSetupMsgRing *rc =\n\n        (PVSCSICmdDescSetupMsgRing *) s->curr_cmd_data;\n\n\n\n    trace_pvscsi_on_cmd_arrived(\"PVSCSI_CMD_SETUP_MSG_RING\");\n\n\n\n    if (!s->use_msg) {\n\n        return PVSCSI_COMMAND_PROCESSING_FAILED;\n\n    }\n\n\n\n    if (s->rings_info_valid) {\n\n        pvscsi_ring_init_msg(&s->rings, rc);\n\n        s->msg_ring_info_valid = TRUE;\n\n    }\n\n    return sizeof(PVSCSICmdDescSetupMsgRing) \/ sizeof(uint32_t);\n\n}\n"},{"project":"qemu","commit_id":"5c3234c6c037943bd4c2d643a1b8cc35f563dbdb","target":1,"func":"static void submit_pdu(V9fsState *s, V9fsPDU *pdu)\n\n{\n\n    pdu_handler_t *handler;\n\n\n\n    if (debug_9p_pdu) {\n\n        pprint_pdu(pdu);\n\n    }\n\n\n\n    BUG_ON(pdu->id >= ARRAY_SIZE(pdu_handlers));\n\n\n\n    handler = pdu_handlers[pdu->id];\n\n    BUG_ON(handler == NULL);\n\n\n\n    handler(s, pdu);\n\n}\n"},{"project":"qemu","commit_id":"cb51ac2ffe3649eb8f5c65dccc2012f0ba2c6b12","target":0,"func":"void virt_acpi_build(VirtMachineState *vms, AcpiBuildTables *tables)\n\n{\n\n    VirtMachineClass *vmc = VIRT_MACHINE_GET_CLASS(vms);\n\n    GArray *table_offsets;\n\n    unsigned dsdt, rsdt;\n\n    GArray *tables_blob = tables->table_data;\n\n\n\n    table_offsets = g_array_new(false, true \/* clear *\/,\n\n                                        sizeof(uint32_t));\n\n\n\n    bios_linker_loader_alloc(tables->linker,\n\n                             ACPI_BUILD_TABLE_FILE, tables_blob,\n\n                             64, false \/* high memory *\/);\n\n\n\n    \/* DSDT is pointed to by FADT *\/\n\n    dsdt = tables_blob->len;\n\n    build_dsdt(tables_blob, tables->linker, vms);\n\n\n\n    \/* FADT MADT GTDT MCFG SPCR pointed to by RSDT *\/\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_fadt(tables_blob, tables->linker, vms, dsdt);\n\n\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_madt(tables_blob, tables->linker, vms);\n\n\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_gtdt(tables_blob, tables->linker, vms);\n\n\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_mcfg(tables_blob, tables->linker, vms);\n\n\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_spcr(tables_blob, tables->linker, vms);\n\n\n\n    if (nb_numa_nodes > 0) {\n\n        acpi_add_table(table_offsets, tables_blob);\n\n        build_srat(tables_blob, tables->linker, vms);\n\n    }\n\n\n\n    if (its_class_name() && !vmc->no_its) {\n\n        acpi_add_table(table_offsets, tables_blob);\n\n        build_iort(tables_blob, tables->linker);\n\n    }\n\n\n\n    \/* RSDT is pointed to by RSDP *\/\n\n    rsdt = tables_blob->len;\n\n    build_rsdt(tables_blob, tables->linker, table_offsets, NULL, NULL);\n\n\n\n    \/* RSDP is in FSEG memory, so allocate it separately *\/\n\n    build_rsdp(tables->rsdp, tables->linker, rsdt);\n\n\n\n    \/* Cleanup memory that's no longer used. *\/\n\n    g_array_free(table_offsets, true);\n\n}\n"},{"project":"qemu","commit_id":"c87b1520726f7ae1e698a41f07043d1b539ac88c","target":0,"func":"static void pc_init1(MachineState *machine,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    PCMachineState *pc_machine = PC_MACHINE(machine);\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *system_io = get_system_io();\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *gsi;\n\n    qemu_irq *i8259;\n\n    qemu_irq *smi_irq;\n\n    GSIState *gsi_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n    ISADevice *floppy;\n\n    MemoryRegion *ram_memory;\n\n    MemoryRegion *pci_memory;\n\n    MemoryRegion *rom_memory;\n\n    DeviceState *icc_bridge;\n\n    FWCfgState *fw_cfg = NULL;\n\n    PcGuestInfo *guest_info;\n\n\n\n    \/* Check whether RAM fits below 4G (leaving 1\/2 GByte for IO memory).\n\n     * If it doesn't, we need to split it in chunks below and above 4G.\n\n     * In any case, try to make sure that guest addresses aligned at\n\n     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.\n\n     * For old machine types, use whatever split we used historically to avoid\n\n     * breaking migration.\n\n     *\/\n\n    if (machine->ram_size >= 0xe0000000) {\n\n        ram_addr_t lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000;\n\n        above_4g_mem_size = machine->ram_size - lowmem;\n\n        below_4g_mem_size = lowmem;\n\n    } else {\n\n        above_4g_mem_size = 0;\n\n        below_4g_mem_size = machine->ram_size;\n\n    }\n\n\n\n    if (xen_enabled() && xen_hvm_init(&below_4g_mem_size, &above_4g_mem_size,\n\n                                      &ram_memory) != 0) {\n\n        fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);\n\n    object_property_add_child(qdev_get_machine(), \"icc-bridge\",\n\n                              OBJECT(icc_bridge), NULL);\n\n\n\n    pc_cpus_init(machine->cpu_model, icc_bridge);\n\n\n\n    if (kvm_enabled() && kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_memory = g_new(MemoryRegion, 1);\n\n        memory_region_init(pci_memory, NULL, \"pci\", UINT64_MAX);\n\n        rom_memory = pci_memory;\n\n    } else {\n\n        pci_memory = NULL;\n\n        rom_memory = system_memory;\n\n    }\n\n\n\n    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);\n\n\n\n    guest_info->has_acpi_build = has_acpi_build;\n\n\n\n    guest_info->has_pci_info = has_pci_info;\n\n    guest_info->isapc_ram_fw = !pci_enabled;\n\n    guest_info->has_reserved_memory = has_reserved_memory;\n\n\n\n    if (smbios_defaults) {\n\n        MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n        \/* These values are guest ABI, do not change *\/\n\n        smbios_set_defaults(\"QEMU\", \"Standard PC (i440FX + PIIX, 1996)\",\n\n                            mc->name, smbios_legacy_mode);\n\n    }\n\n\n\n    \/* allocate ram and load rom\/bios *\/\n\n    if (!xen_enabled()) {\n\n        fw_cfg = pc_memory_init(machine, system_memory,\n\n                                below_4g_mem_size, above_4g_mem_size,\n\n                                rom_memory, &ram_memory, guest_info);\n\n    }\n\n\n\n    gsi_state = g_malloc0(sizeof(*gsi_state));\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_pc_setup_irq_routing(pci_enabled);\n\n        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,\n\n                                 GSI_NUM_PINS);\n\n    } else {\n\n        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi,\n\n                              system_memory, system_io, machine->ram_size,\n\n                              below_4g_mem_size,\n\n                              above_4g_mem_size,\n\n                              pci_memory, ram_memory);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus = isa_bus_new(NULL, system_io);\n\n        no_hpet = 1;\n\n    }\n\n    isa_bus_irqs(isa_bus, gsi);\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        i8259 = kvm_i8259_init(isa_bus);\n\n    } else if (xen_enabled()) {\n\n        i8259 = xen_interrupt_controller_init();\n\n    } else {\n\n        cpu_irq = pc_allocate_cpu_irq();\n\n        i8259 = i8259_init(isa_bus, cpu_irq[0]);\n\n    }\n\n\n\n    for (i = 0; i < ISA_NUM_IRQS; i++) {\n\n        gsi_state->i8259_irq[i] = i8259[i];\n\n    }\n\n    if (pci_enabled) {\n\n        ioapic_init_gsi(gsi_state, \"i440fx\");\n\n    }\n\n    qdev_init_nofail(icc_bridge);\n\n\n\n    pc_register_ferr_irq(gsi[13]);\n\n\n\n    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);\n\n\n\n    \/* init basic PC hardware *\/\n\n    pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled(),\n\n        0x4);\n\n\n\n    pc_nic_init(isa_bus, pci_bus);\n\n\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        if (xen_enabled()) {\n\n            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        } else {\n\n            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        }\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            char busname[] = \"ide.0\";\n\n            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],\n\n                               ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            \/*\n\n             * The ide bus name is ide.0 for the first bus and ide.1 for the\n\n             * second one.\n\n             *\/\n\n            busname[4] = '0' + i;\n\n            idebus[i] = qdev_get_child_bus(DEVICE(dev), busname);\n\n        }\n\n    }\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, machine->boot_order,\n\n                 floppy, idebus[0], idebus[1], rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled(false)) {\n\n        pci_create_simple(pci_bus, piix3_devfn + 2, \"piix3-usb-uhci\");\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        DeviceState *piix4_pm;\n\n        I2CBus *smbus;\n\n\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        \/* TODO: Populate SPD eeprom data.  *\/\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              gsi[9], *smi_irq,\n\n                              kvm_enabled(), fw_cfg, &piix4_pm);\n\n        smbus_eeprom_init(smbus, 8, NULL, 0);\n\n\n\n        object_property_add_link(OBJECT(machine), PC_MACHINE_ACPI_DEVICE_PROP,\n\n                                 TYPE_HOTPLUG_HANDLER,\n\n                                 (Object **)&pc_machine->acpi_dev,\n\n                                 object_property_allow_set_link,\n\n                                 OBJ_PROP_LINK_UNREF_ON_RELEASE, &error_abort);\n\n        object_property_set_link(OBJECT(machine), OBJECT(piix4_pm),\n\n                                 PC_MACHINE_ACPI_DEVICE_PROP, &error_abort);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"db0289b9b26cb653d5662f5d6a2a52d70243cd56","target":1,"func":"static bool bdrv_drain_recurse(BlockDriverState *bs, bool begin)\n\n{\n\n    BdrvChild *child, *tmp;\n\n    bool waited;\n\n\n\n    \/* Ensure any pending metadata writes are submitted to bs->file.  *\/\n\n    bdrv_drain_invoke(bs, begin);\n\n\n\n    \/* Wait for drained requests to finish *\/\n\n    waited = BDRV_POLL_WHILE(bs, atomic_read(&bs->in_flight) > 0);\n\n\n\n    QLIST_FOREACH_SAFE(child, &bs->children, next, tmp) {\n\n        BlockDriverState *bs = child->bs;\n\n        bool in_main_loop =\n\n            qemu_get_current_aio_context() == qemu_get_aio_context();\n\n        assert(bs->refcnt > 0);\n\n        if (in_main_loop) {\n\n            \/* In case the recursive bdrv_drain_recurse processes a\n\n             * block_job_defer_to_main_loop BH and modifies the graph,\n\n             * let's hold a reference to bs until we are done.\n\n             *\n\n             * IOThread doesn't have such a BH, and it is not safe to call\n\n             * bdrv_unref without BQL, so skip doing it there.\n\n             *\/\n\n            bdrv_ref(bs);\n\n        }\n\n        waited |= bdrv_drain_recurse(bs, begin);\n\n        if (in_main_loop) {\n\n            bdrv_unref(bs);\n\n        }\n\n    }\n\n\n\n    return waited;\n\n}\n"},{"project":"qemu","commit_id":"f68945d42bab700d95b87f62e0898606ce2421ed","target":1,"func":"int qemu_savevm_state_iterate(QEMUFile *f)\n\n{\n\n    SaveStateEntry *se;\n\n    int ret = 1;\n\n\n\n    trace_savevm_state_iterate();\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n        if (!se->ops || !se->ops->save_live_iterate) {\n\n            continue;\n\n        }\n\n        if (se->ops && se->ops->is_active) {\n\n            if (!se->ops->is_active(se->opaque)) {\n\n                continue;\n\n            }\n\n        }\n\n        if (qemu_file_rate_limit(f)) {\n\n            return 0;\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_PART);\n\n\n\n        ret = se->ops->save_live_iterate(f, se->opaque);\n\n        trace_savevm_section_end(se->idstr, se->section_id, ret);\n\n\n\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n        }\n\n        if (ret <= 0) {\n\n            \/* Do not proceed to the next vmstate before this one reported\n\n               completion of the current stage. This serializes the migration\n\n               and reduces the probability that a faster changing state is\n\n               synchronized over and over again. *\/\n\n            break;\n\n        }\n\n    }\n\n    return ret;\n\n}"},{"project":"qemu","commit_id":"449041d4db1f82f281fe097e832f07cd9ee1e864","target":1,"func":"static int parse_uint32(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint32_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    \/* accept both hex and decimal *\/\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx32 : \"%\" PRIu32;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"80168bff43760bde98388480dc7c93f94693421c","target":1,"func":"int bdrv_create(BlockDriver *drv, const char* filename,\n\n    QEMUOptionParameter *options)\n\n{\n\n    int ret;\n\n\n\n    Coroutine *co;\n\n    CreateCo cco = {\n\n        .drv = drv,\n\n        .filename = g_strdup(filename),\n\n        .options = options,\n\n        .ret = NOT_DONE,\n\n    };\n\n\n\n    if (!drv->bdrv_create) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (qemu_in_coroutine()) {\n\n        \/* Fast-path if already in coroutine context *\/\n\n        bdrv_create_co_entry(&cco);\n\n    } else {\n\n        co = qemu_coroutine_create(bdrv_create_co_entry);\n\n        qemu_coroutine_enter(co, &cco);\n\n        while (cco.ret == NOT_DONE) {\n\n            qemu_aio_wait();\n\n        }\n\n    }\n\n\n\n    ret = cco.ret;\n\n    g_free(cco.filename);\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"15c2f669e3fb2bc97f7b42d1871f595c0ac24af8","target":1,"func":"opts_end_struct(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    GHashTableIter iter;\n\n    GQueue *any;\n\n\n\n    if (--ov->depth > 0) {\n\n        return;\n\n    }\n\n\n\n    \/* we should have processed all (distinct) QemuOpt instances *\/\n\n    g_hash_table_iter_init(&iter, ov->unprocessed_opts);\n\n    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {\n\n        const QemuOpt *first;\n\n\n\n        first = g_queue_peek_head(any);\n\n        error_setg(errp, QERR_INVALID_PARAMETER, first->name);\n\n    }\n\n    g_hash_table_destroy(ov->unprocessed_opts);\n\n    ov->unprocessed_opts = NULL;\n\n    if (ov->fake_id_opt) {\n\n        g_free(ov->fake_id_opt->name);\n\n        g_free(ov->fake_id_opt->str);\n\n        g_free(ov->fake_id_opt);\n\n    }\n\n    ov->fake_id_opt = NULL;\n\n}\n"},{"project":"qemu","commit_id":"c2fa30757a2ba1bb5b053883773a9a61fbdd7082","target":0,"func":"static void nvdimm_dsm_root(NvdimmDsmIn *in, hwaddr dsm_mem_addr)\n\n{\n\n    \/*\n\n     * function 0 is called to inquire which functions are supported by\n\n     * OSPM\n\n     *\/\n\n    if (!in->function) {\n\n        nvdimm_dsm_function0(0 \/* No function supported other than\n\n                                  function 0 *\/, dsm_mem_addr);\n\n        return;\n\n    }\n\n\n\n    \/* No function except function 0 is supported yet. *\/\n\n    nvdimm_dsm_no_payload(1 \/* Not Supported *\/, dsm_mem_addr);\n\n}\n"},{"project":"qemu","commit_id":"88be7b4be4aa17c88247e162bdd7577ea79db94f","target":1,"func":"static void vm_completion(ReadLineState *rs, const char *str)\n\n{\n\n    size_t len;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    len = strlen(str);\n\n    readline_set_completion_index(rs, len);\n\n\n\n    while ((it = bdrv_next(it, &bs))) {\n\n        SnapshotInfoList *snapshots, *snapshot;\n\n        AioContext *ctx = bdrv_get_aio_context(bs);\n\n        bool ok = false;\n\n\n\n        aio_context_acquire(ctx);\n\n        if (bdrv_can_snapshot(bs)) {\n\n            ok = bdrv_query_snapshot_info_list(bs, &snapshots, NULL) == 0;\n\n        }\n\n        aio_context_release(ctx);\n\n        if (!ok) {\n\n            continue;\n\n        }\n\n\n\n        snapshot = snapshots;\n\n        while (snapshot) {\n\n            char *completion = snapshot->value->name;\n\n            if (!strncmp(str, completion, len)) {\n\n                readline_add_completion(rs, completion);\n\n            }\n\n            completion = snapshot->value->id;\n\n            if (!strncmp(str, completion, len)) {\n\n                readline_add_completion(rs, completion);\n\n            }\n\n            snapshot = snapshot->next;\n\n        }\n\n        qapi_free_SnapshotInfoList(snapshots);\n\n    }\n\n\n\n}\n"},{"project":"qemu","commit_id":"59800ec8e52bcfa271fa61fb0aae19205ef1b7f1","target":0,"func":"uint64_t helper_fnmsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2,\n\n                       uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                 (float64_is_zero(farg1.d) &&\n\n                  float64_is_infinity(farg2.d)))) {\n\n        \/* Multiplication of zero by infinity *\/\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d) ||\n\n                     float64_is_signaling_nan(farg3.d))) {\n\n            \/* sNaN operation *\/\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        \/* This is the way the PowerPC specification defines it *\/\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) &&\n\n                     float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {\n\n            \/* Magnitude subtraction of infinities *\/\n\n            farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n        if (likely(!float64_is_any_nan(farg1.d))) {\n\n            farg1.d = float64_chs(farg1.d);\n\n        }\n\n    }\n\n    return farg1.ll;\n\n}\n"},{"project":"qemu","commit_id":"ebca2df783a5a742bb93784524336d8cbb9e662b","target":1,"func":"void tpm_backend_cancel_cmd(TPMBackend *s)\n\n{\n\n    TPMBackendClass *k = TPM_BACKEND_GET_CLASS(s);\n\n\n\n    assert(k->cancel_cmd);\n\n\n\n    k->cancel_cmd(s);\n\n}\n"},{"project":"qemu","commit_id":"0b8b8753e4d94901627b3e86431230f2319215c4","target":1,"func":"static int qcow2_write(BlockDriverState *bs, int64_t sector_num,\n\n                       const uint8_t *buf, int nb_sectors)\n\n{\n\n    Coroutine *co;\n\n    AioContext *aio_context = bdrv_get_aio_context(bs);\n\n    Qcow2WriteCo data = {\n\n        .bs         = bs,\n\n        .sector_num = sector_num,\n\n        .buf        = buf,\n\n        .nb_sectors = nb_sectors,\n\n        .ret        = -EINPROGRESS,\n\n    };\n\n    co = qemu_coroutine_create(qcow2_write_co_entry);\n\n    qemu_coroutine_enter(co, &data);\n\n    while (data.ret == -EINPROGRESS) {\n\n        aio_poll(aio_context, true);\n\n    }\n\n    return data.ret;\n\n}\n"},{"project":"qemu","commit_id":"f8ed85ac992c48814d916d5df4d44f9a971c5de4","target":1,"func":"static int prom_init1(SysBusDevice *dev)\n\n{\n\n    PROMState *s = OPENPROM(dev);\n\n\n\n    memory_region_init_ram(&s->prom, OBJECT(s), \"sun4m.prom\", PROM_SIZE_MAX,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->prom);\n\n    memory_region_set_readonly(&s->prom, true);\n\n    sysbus_init_mmio(dev, &s->prom);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"71ed827abd57dc7947ce3316118d0e601e70fac9","target":0,"func":"int ioinst_handle_stsch(CPUS390XState *env, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    uint64_t addr;\n\n    int cc;\n\n    SCHIB *schib;\n\n    hwaddr len = sizeof(*schib);\n\n\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        return -EIO;\n\n    }\n\n    trace_ioinst_sch_id(\"stsch\", cssid, ssid, schid);\n\n    addr = decode_basedisp_s(env, ipb);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return -EIO;\n\n    }\n\n    schib = s390_cpu_physical_memory_map(env, addr, &len, 1);\n\n    if (!schib || len != sizeof(*schib)) {\n\n        program_interrupt(env, PGM_ADDRESSING, 2);\n\n        cc = -EIO;\n\n        goto out;\n\n    }\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch) {\n\n        if (css_subch_visible(sch)) {\n\n            css_do_stsch(sch, schib);\n\n            cc = 0;\n\n        } else {\n\n            \/* Indicate no more subchannels in this css\/ss *\/\n\n            cc = 3;\n\n        }\n\n    } else {\n\n        if (css_schid_final(m, cssid, ssid, schid)) {\n\n            cc = 3; \/* No more subchannels in this css\/ss *\/\n\n        } else {\n\n            \/* Store an empty schib. *\/\n\n            memset(schib, 0, sizeof(*schib));\n\n            cc = 0;\n\n        }\n\n    }\n\nout:\n\n    s390_cpu_physical_memory_unmap(env, schib, len, 1);\n\n    return cc;\n\n}\n"},{"project":"qemu","commit_id":"72700d7e733948fa7fbb735ccdf2209931c88476","target":1,"func":"static void spapr_phb_vfio_finish_realize(sPAPRPHBState *sphb, Error **errp)\n\n{\n\n    sPAPRPHBVFIOState *svphb = SPAPR_PCI_VFIO_HOST_BRIDGE(sphb);\n\n    struct vfio_iommu_spapr_tce_info info = { .argsz = sizeof(info) };\n\n    int ret;\n\n    sPAPRTCETable *tcet;\n\n    uint32_t liobn = svphb->phb.dma_liobn;\n\n\n\n    if (svphb->iommugroupid == -1) {\n\n        error_setg(errp, \"Wrong IOMMU group ID %d\", svphb->iommugroupid);\n\n        return;\n\n    }\n\n\n\n    ret = vfio_container_ioctl(&svphb->phb.iommu_as, svphb->iommugroupid,\n\n                               VFIO_CHECK_EXTENSION,\n\n                               (void *) VFIO_SPAPR_TCE_IOMMU);\n\n    if (ret != 1) {\n\n        error_setg_errno(errp, -ret,\n\n                         \"spapr-vfio: SPAPR extension is not supported\");\n\n        return;\n\n    }\n\n\n\n    ret = vfio_container_ioctl(&svphb->phb.iommu_as, svphb->iommugroupid,\n\n                               VFIO_IOMMU_SPAPR_TCE_GET_INFO, &info);\n\n    if (ret) {\n\n        error_setg_errno(errp, -ret,\n\n                         \"spapr-vfio: get info from container failed\");\n\n        return;\n\n    }\n\n\n\n    tcet = spapr_tce_new_table(DEVICE(sphb), liobn, info.dma32_window_start,\n\n                               SPAPR_TCE_PAGE_SHIFT,\n\n                               info.dma32_window_size >> SPAPR_TCE_PAGE_SHIFT,\n\n                               true);\n\n    if (!tcet) {\n\n        error_setg(errp, \"spapr-vfio: failed to create VFIO TCE table\");\n\n        return;\n\n    }\n\n\n\n    \/* Register default 32bit DMA window *\/\n\n    memory_region_add_subregion(&sphb->iommu_root, tcet->bus_offset,\n\n                                spapr_tce_get_iommu(tcet));\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static uint64_t gem_read(void *opaque, target_phys_addr_t offset, unsigned size)\n\n{\n\n    GemState *s;\n\n    uint32_t retval;\n\n\n\n    s = (GemState *)opaque;\n\n\n\n    offset >>= 2;\n\n    retval = s->regs[offset];\n\n\n\n    DB_PRINT(\"offset: 0x%04x read: 0x%08x\\n\", offset*4, retval);\n\n\n\n    switch (offset) {\n\n    case GEM_ISR:\n\n        qemu_set_irq(s->irq, 0);\n\n        break;\n\n    case GEM_PHYMNTNC:\n\n        if (retval & GEM_PHYMNTNC_OP_R) {\n\n            uint32_t phy_addr, reg_num;\n\n\n\n            phy_addr = (retval & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;\n\n            if (phy_addr == BOARD_PHY_ADDRESS) {\n\n                reg_num = (retval & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;\n\n                retval &= 0xFFFF0000;\n\n                retval |= gem_phy_read(s, reg_num);\n\n            } else {\n\n                retval |= 0xFFFF; \/* No device at this address *\/\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    \/* Squash read to clear bits *\/\n\n    s->regs[offset] &= ~(s->regs_rtc[offset]);\n\n\n\n    \/* Do not provide write only bits *\/\n\n    retval &= ~(s->regs_wo[offset]);\n\n\n\n    DB_PRINT(\"0x%08x\\n\", retval);\n\n    return retval;\n\n}\n"},{"project":"qemu","commit_id":"25e5e4c7e9d5ec3e95c9526d1abaca40ada50ab0","target":1,"func":"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,\n\n                    size_t offset, size_t bytes, bool do_send)\n\n{\n\n    size_t done = 0;\n\n    ssize_t ret;\n\n    while (done < bytes) {\n\n        ret = iov_send_recv(sockfd, iov,\n\n                            offset + done, bytes - done, do_send);\n\n        if (ret > 0) {\n\n            done += ret;\n\n        } else if (ret < 0) {\n\n            if (errno == EAGAIN) {\n\n                qemu_coroutine_yield();\n\n            } else if (done == 0) {\n\n                return -1;\n\n            } else {\n\n                break;\n\n            }\n\n        } else if (ret == 0 && !do_send) {\n\n            \/* write (send) should never return 0.\n\n             * read (recv) returns 0 for end-of-file (-data).\n\n             * In both cases there's little point retrying,\n\n             * but we do for write anyway, just in case *\/\n\n            break;\n\n        }\n\n    }\n\n    return done;\n\n}\n"},{"project":"qemu","commit_id":"f76f665547f4a954a2c83552a88816fc2a316be0","target":1,"func":"static int virtio_balloon_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    vdev = virtio_balloon_init(&pci_dev->qdev);\n\n\n\n\n    virtio_init_pci(proxy, vdev);\n\n    return 0;\n"},{"project":"qemu","commit_id":"059bca46bbfd7f16cd2ccca631b91334e08d9abb","target":0,"func":"int mmap_frag(unsigned long host_start,\n\n               unsigned long start, unsigned long end,\n\n               int prot, int flags, int fd, unsigned long offset)\n\n{\n\n    unsigned long host_end, ret, addr;\n\n    int prot1, prot_new;\n\n\n\n    host_end = host_start + qemu_host_page_size;\n\n\n\n    \/* get the protection of the target pages outside the mapping *\/\n\n    prot1 = 0;\n\n    for(addr = host_start; addr < host_end; addr++) {\n\n        if (addr < start || addr >= end)\n\n            prot1 |= page_get_flags(addr);\n\n    }\n\n\n\n    if (prot1 == 0) {\n\n        \/* no page was there, so we allocate one *\/\n\n        ret = (long)mmap((void *)host_start, qemu_host_page_size, prot,\n\n                         flags | MAP_ANONYMOUS, -1, 0);\n\n        if (ret == -1)\n\n            return ret;\n\n    }\n\n    prot1 &= PAGE_BITS;\n\n\n\n    prot_new = prot | prot1;\n\n    if (!(flags & MAP_ANONYMOUS)) {\n\n        \/* msync() won't work here, so we return an error if write is\n\n           possible while it is a shared mapping *\/\n\n#ifndef __APPLE__\n\n        if ((flags & MAP_TYPE) == MAP_SHARED &&\n\n#else\n\n        if ((flags &  MAP_SHARED) &&\n\n#endif\n\n            (prot & PROT_WRITE))\n\n            return -EINVAL;\n\n\n\n        \/* adjust protection to be able to read *\/\n\n        if (!(prot1 & PROT_WRITE))\n\n            mprotect((void *)host_start, qemu_host_page_size, prot1 | PROT_WRITE);\n\n\n\n        \/* read the corresponding file data *\/\n\n        pread(fd, (void *)start, end - start, offset);\n\n\n\n        \/* put final protection *\/\n\n        if (prot_new != (prot1 | PROT_WRITE))\n\n            mprotect((void *)host_start, qemu_host_page_size, prot_new);\n\n    } else {\n\n        \/* just update the protection *\/\n\n        if (prot_new != prot1) {\n\n            mprotect((void *)host_start, qemu_host_page_size, prot_new);\n\n        }\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"4b5d5e87c7ab2e979a2cad6c8e01bcae55b85f1c","target":0,"func":"static uint32_t vfio_pci_read_config(PCIDevice *pdev, uint32_t addr, int len)\n\n{\n\n    VFIODevice *vdev = DO_UPCAST(VFIODevice, pdev, pdev);\n\n    uint32_t val = 0;\n\n\n\n    \/*\n\n     * We only need QEMU PCI config support for the ROM BAR, the MSI and MSIX\n\n     * capabilities, and the multifunction bit below.  We let VFIO handle\n\n     * virtualizing everything else.  Performance is not a concern here.\n\n     *\/\n\n    if (ranges_overlap(addr, len, PCI_ROM_ADDRESS, 4) ||\n\n        (pdev->cap_present & QEMU_PCI_CAP_MSIX &&\n\n         ranges_overlap(addr, len, pdev->msix_cap, MSIX_CAP_LENGTH)) ||\n\n        (pdev->cap_present & QEMU_PCI_CAP_MSI &&\n\n         ranges_overlap(addr, len, pdev->msi_cap, vdev->msi_cap_size))) {\n\n\n\n        val = pci_default_read_config(pdev, addr, len);\n\n    } else {\n\n        if (pread(vdev->fd, &val, len, vdev->config_offset + addr) != len) {\n\n            error_report(\"%s(%04x:%02x:%02x.%x, 0x%x, 0x%x) failed: %m\",\n\n                         __func__, vdev->host.domain, vdev->host.bus,\n\n                         vdev->host.slot, vdev->host.function, addr, len);\n\n            return -errno;\n\n        }\n\n        val = le32_to_cpu(val);\n\n    }\n\n\n\n    \/* Multifunction bit is virualized in QEMU *\/\n\n    if (unlikely(ranges_overlap(addr, len, PCI_HEADER_TYPE, 1))) {\n\n        uint32_t mask = PCI_HEADER_TYPE_MULTI_FUNCTION;\n\n\n\n        if (len == 4) {\n\n            mask <<= 16;\n\n        }\n\n\n\n        if (pdev->cap_present & QEMU_PCI_CAP_MULTIFUNCTION) {\n\n            val |= mask;\n\n        } else {\n\n            val &= ~mask;\n\n        }\n\n    }\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x, @0x%x, len=0x%x) %x\\n\", __func__,\n\n            vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n            vdev->host.function, addr, len, val);\n\n\n\n    return val;\n\n}\n"},{"project":"qemu","commit_id":"bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884","target":0,"func":"SocketAddressLegacy *socket_parse(const char *str, Error **errp)\n\n{\n\n    SocketAddressLegacy *addr;\n\n\n\n    addr = g_new0(SocketAddressLegacy, 1);\n\n    if (strstart(str, \"unix:\", NULL)) {\n\n        if (str[5] == '\\0') {\n\n            error_setg(errp, \"invalid Unix socket address\");\n\n            goto fail;\n\n        } else {\n\n            addr->type = SOCKET_ADDRESS_LEGACY_KIND_UNIX;\n\n            addr->u.q_unix.data = g_new(UnixSocketAddress, 1);\n\n            addr->u.q_unix.data->path = g_strdup(str + 5);\n\n        }\n\n    } else if (strstart(str, \"fd:\", NULL)) {\n\n        if (str[3] == '\\0') {\n\n            error_setg(errp, \"invalid file descriptor address\");\n\n            goto fail;\n\n        } else {\n\n            addr->type = SOCKET_ADDRESS_LEGACY_KIND_FD;\n\n            addr->u.fd.data = g_new(String, 1);\n\n            addr->u.fd.data->str = g_strdup(str + 3);\n\n        }\n\n    } else if (strstart(str, \"vsock:\", NULL)) {\n\n        addr->type = SOCKET_ADDRESS_LEGACY_KIND_VSOCK;\n\n        addr->u.vsock.data = g_new(VsockSocketAddress, 1);\n\n        if (vsock_parse(addr->u.vsock.data, str + strlen(\"vsock:\"), errp)) {\n\n            goto fail;\n\n        }\n\n    } else {\n\n        addr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;\n\n        addr->u.inet.data = g_new(InetSocketAddress, 1);\n\n        if (inet_parse(addr->u.inet.data, str, errp)) {\n\n            goto fail;\n\n        }\n\n    }\n\n    return addr;\n\n\n\nfail:\n\n    qapi_free_SocketAddressLegacy(addr);\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"2fd5d864099dd38b43b595e9e3375dad2f76049b","target":1,"func":"strdup(str)\n\n\tconst char *str;\n\n{\n\n\tchar *bptr;\n\n\n\n\tbptr = (char *)malloc(strlen(str)+1);\n\n\tstrcpy(bptr, str);\n\n\n\n\treturn bptr;\n\n}\n"},{"project":"qemu","commit_id":"10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b","target":0,"func":"static void ac97_initfn (PCIDevice *dev)\n\n{\n\n    PCIAC97LinkState *d = DO_UPCAST (PCIAC97LinkState, dev, dev);\n\n    AC97LinkState *s = &d->ac97;\n\n    uint8_t *c = d->dev.config;\n\n\n\n    s->pci_dev = &d->dev;\n\n    pci_config_set_vendor_id (c, PCI_VENDOR_ID_INTEL); \/* ro *\/\n\n    pci_config_set_device_id (c, PCI_DEVICE_ID_INTEL_82801AA_5); \/* ro *\/\n\n\n\n    c[0x04] = 0x00;      \/* pcicmd pci command rw, ro *\/\n\n    c[0x05] = 0x00;\n\n\n\n    c[0x06] = 0x80;      \/* pcists pci status rwc, ro *\/\n\n    c[0x07] = 0x02;\n\n\n\n    c[0x08] = 0x01;      \/* rid revision ro *\/\n\n    c[0x09] = 0x00;      \/* pi programming interface ro *\/\n\n    pci_config_set_class (c, PCI_CLASS_MULTIMEDIA_AUDIO); \/* ro *\/\n\n    c[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; \/* headtyp header type ro *\/\n\n\n\n    c[0x10] = 0x01;      \/* nabmar native audio mixer base\n\n                            address rw *\/\n\n    c[0x11] = 0x00;\n\n    c[0x12] = 0x00;\n\n    c[0x13] = 0x00;\n\n\n\n    c[0x14] = 0x01;      \/* nabmbar native audio bus mastering\n\n                            base address rw *\/\n\n    c[0x15] = 0x00;\n\n    c[0x16] = 0x00;\n\n    c[0x17] = 0x00;\n\n\n\n    c[0x2c] = 0x86;      \/* svid subsystem vendor id rwo *\/\n\n    c[0x2d] = 0x80;\n\n\n\n    c[0x2e] = 0x00;      \/* sid subsystem id rwo *\/\n\n    c[0x2f] = 0x00;\n\n\n\n    c[0x3c] = 0x00;      \/* intr_ln interrupt line rw *\/\n\n    c[0x3d] = 0x01;      \/* intr_pn interrupt pin ro *\/\n\n\n\n    pci_register_bar (&d->dev, 0, 256 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    pci_register_bar (&d->dev, 1, 64 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    register_savevm (\"ac97\", 0, 2, ac97_save, ac97_load, s);\n\n    qemu_register_reset (ac97_on_reset, s);\n\n    AUD_register_card (\"ac97\", &s->card);\n\n    ac97_on_reset (s);\n\n}\n"},{"project":"qemu","commit_id":"7b899f4dd596dbb7d271f7fab36fbfffec84868e","target":0,"func":"static void test_commands(void)\n\n{\n\n    char *response;\n\n    int i;\n\n\n\n    for (i = 0; hmp_cmds[i] != NULL; i++) {\n\n        if (verbose) {\n\n            fprintf(stderr, \"\\t%s\\n\", hmp_cmds[i]);\n\n        }\n\n        response = hmp(hmp_cmds[i]);\n\n        g_free(response);\n\n    }\n\n\n\n}\n"},{"project":"qemu","commit_id":"880a7578381d1c7ed4d41c7599ae3cc06567a824","target":0,"func":"static void gdb_chr_receive(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    GDBState *s = opaque;\n\n    int i;\n\n\n\n    for (i = 0; i < size; i++) {\n\n        gdb_read_byte(s, buf[i]);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"void framebuffer_update_display(\n\n    DisplayState *ds,\n\n    MemoryRegion *address_space,\n\n    target_phys_addr_t base,\n\n    int cols, \/* Width in pixels.  *\/\n\n    int rows, \/* Height in pixels.  *\/\n\n    int src_width, \/* Length of source line, in bytes.  *\/\n\n    int dest_row_pitch, \/* Bytes between adjacent horizontal output pixels.  *\/\n\n    int dest_col_pitch, \/* Bytes between adjacent vertical output pixels.  *\/\n\n    int invalidate, \/* nonzero to redraw the whole image.  *\/\n\n    drawfn fn,\n\n    void *opaque,\n\n    int *first_row, \/* Input and output.  *\/\n\n    int *last_row \/* Output only *\/)\n\n{\n\n    target_phys_addr_t src_len;\n\n    uint8_t *dest;\n\n    uint8_t *src;\n\n    uint8_t *src_base;\n\n    int first, last = 0;\n\n    int dirty;\n\n    int i;\n\n    ram_addr_t addr;\n\n    MemoryRegionSection mem_section;\n\n    MemoryRegion *mem;\n\n\n\n    i = *first_row;\n\n    *first_row = -1;\n\n    src_len = src_width * rows;\n\n\n\n    mem_section = memory_region_find(address_space, base, src_len);\n\n    if (mem_section.size != src_len || !memory_region_is_ram(mem_section.mr)) {\n\n        return;\n\n    }\n\n    mem = mem_section.mr;\n\n    assert(mem);\n\n    assert(mem_section.offset_within_address_space == base);\n\n\n\n    memory_region_sync_dirty_bitmap(mem);\n\n    src_base = cpu_physical_memory_map(base, &src_len, 0);\n\n    \/* If we can't map the framebuffer then bail.  We could try harder,\n\n       but it's not really worth it as dirty flag tracking will probably\n\n       already have failed above.  *\/\n\n    if (!src_base)\n\n        return;\n\n    if (src_len != src_width * rows) {\n\n        cpu_physical_memory_unmap(src_base, src_len, 0, 0);\n\n        return;\n\n    }\n\n    src = src_base;\n\n    dest = ds_get_data(ds);\n\n    if (dest_col_pitch < 0)\n\n        dest -= dest_col_pitch * (cols - 1);\n\n    if (dest_row_pitch < 0) {\n\n        dest -= dest_row_pitch * (rows - 1);\n\n    }\n\n    first = -1;\n\n    addr = mem_section.offset_within_region;\n\n\n\n    addr += i * src_width;\n\n    src += i * src_width;\n\n    dest += i * dest_row_pitch;\n\n\n\n    for (; i < rows; i++) {\n\n        dirty = memory_region_get_dirty(mem, addr, src_width,\n\n                                             DIRTY_MEMORY_VGA);\n\n        if (dirty || invalidate) {\n\n            fn(opaque, dest, src, cols, dest_col_pitch);\n\n            if (first == -1)\n\n                first = i;\n\n            last = i;\n\n        }\n\n        addr += src_width;\n\n        src += src_width;\n\n        dest += dest_row_pitch;\n\n    }\n\n    cpu_physical_memory_unmap(src_base, src_len, 0, 0);\n\n    if (first < 0) {\n\n        return;\n\n    }\n\n    memory_region_reset_dirty(mem, mem_section.offset_within_region, src_len,\n\n                              DIRTY_MEMORY_VGA);\n\n    *first_row = first;\n\n    *last_row = last;\n\n}\n"},{"project":"qemu","commit_id":"00ec5c37601accb2b85b089d72fc7ddff2f4222e","target":0,"func":"static int v9fs_do_mkdir(V9fsState *s, V9fsString *path, mode_t mode)\n\n{\n\n    return s->ops->mkdir(&s->ctx, path->data, mode);\n\n}\n"},{"project":"qemu","commit_id":"5cbab1bfdeab274e5d4e3353fa626ba8697eed10","target":1,"func":"static void kvm_s390_flic_realize(DeviceState *dev, Error **errp)\n\n{\n\n    KVMS390FLICState *flic_state = KVM_S390_FLIC(dev);\n\n    struct kvm_create_device cd = {0};\n\n    struct kvm_device_attr test_attr = {0};\n\n    int ret;\n\n    Error *errp_local = NULL;\n\n\n\n\n\n\n\n    flic_state->fd = -1;\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_DEVICE_CTRL)) {\n\n        error_setg_errno(&errp_local, errno, \"KVM is missing capability\"\n\n                         \" KVM_CAP_DEVICE_CTRL\");\n\n        trace_flic_no_device_api(errno);\n\n\n\n\n\n    cd.type = KVM_DEV_TYPE_FLIC;\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_CREATE_DEVICE, &cd);\n\n    if (ret < 0) {\n\n        error_setg_errno(&errp_local, errno, \"Creating the KVM device failed\");\n\n        trace_flic_create_device(errno);\n\n\n\n    flic_state->fd = cd.fd;\n\n\n\n    \/* Check clear_io_irq support *\/\n\n    test_attr.group = KVM_DEV_FLIC_CLEAR_IO_IRQ;\n\n    flic_state->clear_io_supported = !ioctl(flic_state->fd,\n\n                                            KVM_HAS_DEVICE_ATTR, test_attr);\n\n\n\n    return;\n\nfail:\n\n    error_propagate(errp, errp_local);\n"},{"project":"qemu","commit_id":"81f194dd69756677cc36ff0827bf970f0f048914","target":0,"func":"static void ppc_cpu_unrealizefn(DeviceState *dev, Error **errp)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(dev);\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n\n\n    for (i = 0; i < PPC_CPU_OPCODES_LEN; i++) {\n\n        if (env->opcodes[i] != &invalid_handler) {\n\n            g_free(env->opcodes[i]);\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"f1219091edd20e3b92544025c2b6dd5e4d98b61b","target":0,"func":"set_interrupt_cause(E1000State *s, int index, uint32_t val)\n\n{\n\n    if (val)\n\n        val |= E1000_ICR_INT_ASSERTED;\n\n    s->mac_reg[ICR] = val;\n\n    s->mac_reg[ICS] = val;\n\n    qemu_set_irq(s->dev.irq[0], (s->mac_reg[IMS] & s->mac_reg[ICR]) != 0);\n\n}\n"},{"project":"qemu","commit_id":"a1f7f97b950a46393b0e55a9a0082e70f540cbbd","target":1,"func":"static void cpu_4xx_wdt_cb (void *opaque)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    ppc_tb_t *tb_env;\n\n    ppc40x_timer_t *ppc40x_timer;\n\n    uint64_t now, next;\n\n\n\n    env = opaque;\n\n    cpu = ppc_env_get_cpu(env);\n\n    tb_env = env->tb_env;\n\n    ppc40x_timer = tb_env->opaque;\n\n    now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n    switch ((env->spr[SPR_40x_TCR] >> 30) & 0x3) {\n\n    case 0:\n\n        next = 1 << 17;\n\n        break;\n\n    case 1:\n\n        next = 1 << 21;\n\n        break;\n\n    case 2:\n\n        next = 1 << 25;\n\n        break;\n\n    case 3:\n\n        next = 1 << 29;\n\n        break;\n\n    default:\n\n        \/* Cannot occur, but makes gcc happy *\/\n\n        return;\n\n    }\n\n    next = now + muldiv64(next, get_ticks_per_sec(), tb_env->decr_freq);\n\n    if (next == now)\n\n        next++;\n\n    LOG_TB(\"%s: TCR \" TARGET_FMT_lx \" TSR \" TARGET_FMT_lx \"\\n\", __func__,\n\n           env->spr[SPR_40x_TCR], env->spr[SPR_40x_TSR]);\n\n    switch ((env->spr[SPR_40x_TSR] >> 30) & 0x3) {\n\n    case 0x0:\n\n    case 0x1:\n\n        timer_mod(ppc40x_timer->wdt_timer, next);\n\n        ppc40x_timer->wdt_next = next;\n\n        env->spr[SPR_40x_TSR] |= 1 << 31;\n\n        break;\n\n    case 0x2:\n\n        timer_mod(ppc40x_timer->wdt_timer, next);\n\n        ppc40x_timer->wdt_next = next;\n\n        env->spr[SPR_40x_TSR] |= 1 << 30;\n\n        if ((env->spr[SPR_40x_TCR] >> 27) & 0x1) {\n\n            ppc_set_irq(cpu, PPC_INTERRUPT_WDT, 1);\n\n        }\n\n        break;\n\n    case 0x3:\n\n        env->spr[SPR_40x_TSR] &= ~0x30000000;\n\n        env->spr[SPR_40x_TSR] |= env->spr[SPR_40x_TCR] & 0x30000000;\n\n        switch ((env->spr[SPR_40x_TCR] >> 28) & 0x3) {\n\n        case 0x0:\n\n            \/* No reset *\/\n\n            break;\n\n        case 0x1: \/* Core reset *\/\n\n            ppc40x_core_reset(cpu);\n\n            break;\n\n        case 0x2: \/* Chip reset *\/\n\n            ppc40x_chip_reset(cpu);\n\n            break;\n\n        case 0x3: \/* System reset *\/\n\n            ppc40x_system_reset(cpu);\n\n            break;\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"7385aed20db5d83979f683b9d0048674411e963c","target":0,"func":"static inline void clear_float_exceptions(CPUSPARCState *env)\n\n{\n\n    set_float_exception_flags(0, &env->fp_status);\n\n}\n"},{"project":"qemu","commit_id":"df8bf7a7fe75eb5d5caffa55f5cd4292b757aea6","target":1,"func":"void net_rx_pkt_attach_iovec(struct NetRxPkt *pkt,\n\n                                const struct iovec *iov, int iovcnt,\n\n                                size_t iovoff, bool strip_vlan)\n\n{\n\n    uint16_t tci = 0;\n\n    uint16_t ploff = iovoff;\n\n    assert(pkt);\n\n    pkt->vlan_stripped = false;\n\n\n\n    if (strip_vlan) {\n\n        pkt->vlan_stripped = eth_strip_vlan(iov, iovcnt, iovoff, pkt->ehdr_buf,\n\n                                            &ploff, &tci);\n\n    }\n\n\n\n    pkt->tci = tci;\n\n\n\n    net_rx_pkt_pull_data(pkt, iov, iovcnt, ploff);\n\n}\n"},{"project":"qemu","commit_id":"2886be1b01c274570fa139748a402207482405bd","target":1,"func":"static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width,\n\n                            uint64_t *data)\n\n{\n\n    PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport);\n\n    uint32_t val;\n\n\n\n    switch(addr) {\n\n    case 0x00:\n\n        val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n        break;\n\n    case 0x02:\n\n        val = s->ar.pm1.evt.en;\n\n        break;\n\n    case 0x04:\n\n        val = s->ar.pm1.cnt.cnt;\n\n        break;\n\n    case 0x08:\n\n        val = acpi_pm_tmr_get(&s->ar);\n\n        break;\n\n    default:\n\n        val = 0;\n\n        break;\n\n    }\n\n    PIIX4_DPRINTF(\"PM readw port=0x%04x val=0x%04x\\n\", (unsigned int)addr, val);\n\n    *data = val;\n\n}\n"},{"project":"qemu","commit_id":"f59df3f2354982ee0381b87d1ce561f1eb0ed505","target":1,"func":"static int disas_coproc_insn(CPUARMState * env, DisasContext *s, uint32_t insn)\n{\n    int cpnum, is64, crn, crm, opc1, opc2, isread, rt, rt2;\n    const ARMCPRegInfo *ri;\n    cpnum = (insn >> 8) & 0xf;\n    if (arm_feature(env, ARM_FEATURE_XSCALE)\n\t    && ((env->cp15.c15_cpar ^ 0x3fff) & (1 << cpnum)))\n\treturn 1;\n    \/* First check for coprocessor space used for actual instructions *\/\n    switch (cpnum) {\n      case 0:\n      case 1:\n\tif (arm_feature(env, ARM_FEATURE_IWMMXT)) {\n\t    return disas_iwmmxt_insn(env, s, insn);\n\t} else if (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\t    return disas_dsp_insn(env, s, insn);\n\treturn 1;\n    default:\n        break;\n    \/* Otherwise treat as a generic register access *\/\n    is64 = (insn & (1 << 25)) == 0;\n    if (!is64 && ((insn & (1 << 4)) == 0)) {\n        \/* cdp *\/\n        return 1;\n    crm = insn & 0xf;\n    if (is64) {\n        crn = 0;\n        opc1 = (insn >> 4) & 0xf;\n        opc2 = 0;\n        rt2 = (insn >> 16) & 0xf;\n    } else {\n        crn = (insn >> 16) & 0xf;\n        opc1 = (insn >> 21) & 7;\n        opc2 = (insn >> 5) & 7;\n        rt2 = 0;\n    isread = (insn >> 20) & 1;\n    rt = (insn >> 12) & 0xf;\n    ri = get_arm_cp_reginfo(s->cp_regs,\n                            ENCODE_CP_REG(cpnum, is64, crn, crm, opc1, opc2));\n    if (ri) {\n        \/* Check access permissions *\/\n        if (!cp_access_ok(s->current_pl, ri, isread)) {\n            return 1;\n        \/* Handle special cases first *\/\n        switch (ri->type & ~(ARM_CP_FLAG_MASK & ~ARM_CP_SPECIAL)) {\n        case ARM_CP_NOP:\n            return 0;\n        case ARM_CP_WFI:\n            if (isread) {\n                return 1;\n            s->is_jmp = DISAS_WFI;\n            return 0;\n        default:\n            break;\n        if (use_icount && (ri->type & ARM_CP_IO)) {\n            gen_io_start();\n        if (isread) {\n            \/* Read *\/\n            if (is64) {\n                TCGv_i64 tmp64;\n                TCGv_i32 tmp;\n                if (ri->type & ARM_CP_CONST) {\n                    tmp64 = tcg_const_i64(ri->resetvalue);\n                } else if (ri->readfn) {\n                    tmp64 = tcg_temp_new_i64();\n                    gen_helper_get_cp_reg64(tmp64, cpu_env, tmpptr);\n                } else {\n                    tmp64 = tcg_temp_new_i64();\n                    tcg_gen_ld_i64(tmp64, cpu_env, ri->fieldoffset);\n                tmp = tcg_temp_new_i32();\n                tcg_gen_trunc_i64_i32(tmp, tmp64);\n                store_reg(s, rt, tmp);\n                tcg_gen_shri_i64(tmp64, tmp64, 32);\n                tmp = tcg_temp_new_i32();\n                tcg_gen_trunc_i64_i32(tmp, tmp64);\n                tcg_temp_free_i64(tmp64);\n                store_reg(s, rt2, tmp);\n            } else {\n                TCGv_i32 tmp;\n                if (ri->type & ARM_CP_CONST) {\n                    tmp = tcg_const_i32(ri->resetvalue);\n                } else if (ri->readfn) {\n                    tmp = tcg_temp_new_i32();\n                    gen_helper_get_cp_reg(tmp, cpu_env, tmpptr);\n                } else {\n                    tmp = load_cpu_offset(ri->fieldoffset);\n                if (rt == 15) {\n                    \/* Destination register of r15 for 32 bit loads sets\n                     * the condition codes from the high 4 bits of the value\n                    gen_set_nzcv(tmp);\n                    tcg_temp_free_i32(tmp);\n                } else {\n                    store_reg(s, rt, tmp);\n        } else {\n            \/* Write *\/\n            if (ri->type & ARM_CP_CONST) {\n                \/* If not forbidden by access permissions, treat as WI *\/\n                return 0;\n            if (is64) {\n                TCGv_i32 tmplo, tmphi;\n                TCGv_i64 tmp64 = tcg_temp_new_i64();\n                tmplo = load_reg(s, rt);\n                tmphi = load_reg(s, rt2);\n                tcg_gen_concat_i32_i64(tmp64, tmplo, tmphi);\n                tcg_temp_free_i32(tmplo);\n                tcg_temp_free_i32(tmphi);\n                if (ri->writefn) {\n                    TCGv_ptr tmpptr = tcg_const_ptr(ri);\n                    gen_helper_set_cp_reg64(cpu_env, tmpptr, tmp64);\n                } else {\n                    tcg_gen_st_i64(tmp64, cpu_env, ri->fieldoffset);\n                tcg_temp_free_i64(tmp64);\n            } else {\n                if (ri->writefn) {\n                    TCGv_i32 tmp;\n                    tmp = load_reg(s, rt);\n                    gen_helper_set_cp_reg(cpu_env, tmpptr, tmp);\n                    tcg_temp_free_i32(tmp);\n                } else {\n                    TCGv_i32 tmp = load_reg(s, rt);\n                    store_cpu_offset(tmp, ri->fieldoffset);\n        if (use_icount && (ri->type & ARM_CP_IO)) {\n            \/* I\/O operations must end the TB here (whether read or write) *\/\n            gen_io_end();\n            gen_lookup_tb(s);\n        } else if (!isread && !(ri->type & ARM_CP_SUPPRESS_TB_END)) {\n            \/* We default to ending the TB on a coprocessor register write,\n             * but allow this to be suppressed by the register definition\n             * (usually only necessary to work around guest bugs).\n            gen_lookup_tb(s);\n        return 0;\n    \/* Unknown register; this might be a guest error or a QEMU\n     * unimplemented feature.\n    if (is64) {\n        qemu_log_mask(LOG_UNIMP, \"%s access to unsupported AArch32 \"\n                      \"64 bit system register cp:%d opc1: %d crm:%d\\n\",\n                      isread ? \"read\" : \"write\", cpnum, opc1, crm);\n    } else {\n        qemu_log_mask(LOG_UNIMP, \"%s access to unsupported AArch32 \"\n                      \"system register cp:%d opc1:%d crn:%d crm:%d opc2:%d\\n\",\n                      isread ? \"read\" : \"write\", cpnum, opc1, crn, crm, opc2);\n    return 1;"},{"project":"qemu","commit_id":"4656e1f01289cc3aa20986deb6a407165826abe5","target":1,"func":"void ppc_tlb_invalidate_all(CPUPPCState *env)\n\n{\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_REAL:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_MPC8xx:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        tlb_flush(env, 1);\n\n        break;\n\n    case POWERPC_MMU_BOOKE206:\n\n        booke206_flush_tlb(env, -1, 0);\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_620:\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_06:\n\n\n#endif \/* defined(TARGET_PPC64) *\/\n\n        tlb_flush(env, 1);\n\n        break;\n\n    default:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"Unknown MMU model\\n\");\n\n        break;\n\n    }\n\n}"},{"project":"qemu","commit_id":"acfb23ad3dd8d0ab385a10e483776ba7dcf927ad","target":0,"func":"static void test_bh_delete_from_cb_many(void)\n\n{\n\n    BHTestData data1 = { .n = 0, .max = 1 };\n\n    BHTestData data2 = { .n = 0, .max = 3 };\n\n    BHTestData data3 = { .n = 0, .max = 2 };\n\n    BHTestData data4 = { .n = 0, .max = 4 };\n\n\n\n    data1.bh = aio_bh_new(ctx, bh_delete_cb, &data1);\n\n    data2.bh = aio_bh_new(ctx, bh_delete_cb, &data2);\n\n    data3.bh = aio_bh_new(ctx, bh_delete_cb, &data3);\n\n    data4.bh = aio_bh_new(ctx, bh_delete_cb, &data4);\n\n\n\n    qemu_bh_schedule(data1.bh);\n\n    qemu_bh_schedule(data2.bh);\n\n    qemu_bh_schedule(data3.bh);\n\n    qemu_bh_schedule(data4.bh);\n\n    g_assert_cmpint(data1.n, ==, 0);\n\n    g_assert_cmpint(data2.n, ==, 0);\n\n    g_assert_cmpint(data3.n, ==, 0);\n\n    g_assert_cmpint(data4.n, ==, 0);\n\n\n\n    g_assert(aio_poll(ctx, false));\n\n    g_assert_cmpint(data1.n, ==, 1);\n\n    g_assert_cmpint(data2.n, ==, 1);\n\n    g_assert_cmpint(data3.n, ==, 1);\n\n    g_assert_cmpint(data4.n, ==, 1);\n\n    g_assert(data1.bh == NULL);\n\n\n\n    wait_for_aio();\n\n    g_assert_cmpint(data1.n, ==, data1.max);\n\n    g_assert_cmpint(data2.n, ==, data2.max);\n\n    g_assert_cmpint(data3.n, ==, data3.max);\n\n    g_assert_cmpint(data4.n, ==, data4.max);\n\n    g_assert(data1.bh == NULL);\n\n    g_assert(data2.bh == NULL);\n\n    g_assert(data3.bh == NULL);\n\n    g_assert(data4.bh == NULL);\n\n}\n"},{"project":"qemu","commit_id":"c4d9d19645a484298a67e9021060bc7c2b081d0f","target":0,"func":"int coroutine_fn thread_pool_submit_co(ThreadPoolFunc *func, void *arg)\n\n{\n\n    ThreadPoolCo tpc = { .co = qemu_coroutine_self(), .ret = -EINPROGRESS };\n\n    assert(qemu_in_coroutine());\n\n    thread_pool_submit_aio(func, arg, thread_pool_co_cb, &tpc);\n\n    qemu_coroutine_yield();\n\n    return tpc.ret;\n\n}\n"},{"project":"qemu","commit_id":"6e0d8677cb443e7408c0b7a25a93c6596d7fa380","target":0,"func":"void OPPROTO op_addw_ESI_T0(void)\n\n{\n\n    ESI = (ESI & ~0xffff) | ((ESI + T0) & 0xffff);\n\n}\n"},{"project":"qemu","commit_id":"ac531cb6e542b1e61d668604adf9dc5306a948c0","target":0,"func":"START_TEST(qdict_haskey_test)\n\n{\n\n    const char *key = \"test\";\n\n\n\n    qdict_put(tests_dict, key, qint_from_int(0));\n\n    fail_unless(qdict_haskey(tests_dict, key) == 1);\n\n}\n"},{"project":"qemu","commit_id":"c0a3172fa6bbddcc73192f2a2c48d0bf3a7ba61c","target":1,"func":"static void rc4030_write(void *opaque, hwaddr addr, uint64_t data,\n\n                         unsigned int size)\n\n{\n\n    rc4030State *s = opaque;\n\n    uint32_t val = data;\n\n    addr &= 0x3fff;\n\n\n\n    trace_rc4030_write(addr, val);\n\n\n\n    switch (addr & ~0x3) {\n\n    \/* Global config register *\/\n\n    case 0x0000:\n\n        s->config = val;\n\n        break;\n\n    \/* DMA transl. table base *\/\n\n    case 0x0018:\n\n        rc4030_dma_tt_update(s, val, s->dma_tl_limit);\n\n        break;\n\n    \/* DMA transl. table limit *\/\n\n    case 0x0020:\n\n        rc4030_dma_tt_update(s, s->dma_tl_base, val);\n\n        break;\n\n    \/* DMA transl. table invalidated *\/\n\n    case 0x0028:\n\n        break;\n\n    \/* Cache Maintenance *\/\n\n    case 0x0030:\n\n        s->cache_maint = val;\n\n        break;\n\n    \/* I\/O Cache Physical Tag *\/\n\n    case 0x0048:\n\n        s->cache_ptag = val;\n\n        break;\n\n    \/* I\/O Cache Logical Tag *\/\n\n    case 0x0050:\n\n        s->cache_ltag = val;\n\n        break;\n\n    \/* I\/O Cache Byte Mask *\/\n\n    case 0x0058:\n\n        s->cache_bmask |= val; \/* HACK *\/\n\n        break;\n\n    \/* I\/O Cache Buffer Window *\/\n\n    case 0x0060:\n\n        \/* HACK *\/\n\n        if (s->cache_ltag == 0x80000001 && s->cache_bmask == 0xf0f0f0f) {\n\n            hwaddr dest = s->cache_ptag & ~0x1;\n\n            dest += (s->cache_maint & 0x3) << 3;\n\n            cpu_physical_memory_write(dest, &val, 4);\n\n        }\n\n        break;\n\n    \/* Remote Speed Registers *\/\n\n    case 0x0070:\n\n    case 0x0078:\n\n    case 0x0080:\n\n    case 0x0088:\n\n    case 0x0090:\n\n    case 0x0098:\n\n    case 0x00a0:\n\n    case 0x00a8:\n\n    case 0x00b0:\n\n    case 0x00b8:\n\n    case 0x00c0:\n\n    case 0x00c8:\n\n    case 0x00d0:\n\n    case 0x00d8:\n\n    case 0x00e0:\n\n    case 0x00e8:\n\n        s->rem_speed[(addr - 0x0070) >> 3] = val;\n\n        break;\n\n    \/* DMA channel base address *\/\n\n    case 0x0100:\n\n    case 0x0108:\n\n    case 0x0110:\n\n    case 0x0118:\n\n    case 0x0120:\n\n    case 0x0128:\n\n    case 0x0130:\n\n    case 0x0138:\n\n    case 0x0140:\n\n    case 0x0148:\n\n    case 0x0150:\n\n    case 0x0158:\n\n    case 0x0160:\n\n    case 0x0168:\n\n    case 0x0170:\n\n    case 0x0178:\n\n    case 0x0180:\n\n    case 0x0188:\n\n    case 0x0190:\n\n    case 0x0198:\n\n    case 0x01a0:\n\n    case 0x01a8:\n\n    case 0x01b0:\n\n    case 0x01b8:\n\n    case 0x01c0:\n\n    case 0x01c8:\n\n    case 0x01d0:\n\n    case 0x01d8:\n\n    case 0x01e0:\n\n    case 0x01e8:\n\n    case 0x01f0:\n\n    case 0x01f8:\n\n        {\n\n            int entry = (addr - 0x0100) >> 5;\n\n            int idx = (addr & 0x1f) >> 3;\n\n            s->dma_regs[entry][idx] = val;\n\n        }\n\n        break;\n\n    \/* Memory refresh rate *\/\n\n    case 0x0210:\n\n        s->memory_refresh_rate = val;\n\n        break;\n\n    \/* Interval timer reload *\/\n\n    case 0x0228:\n\n        s->itr = val;\n\n        qemu_irq_lower(s->timer_irq);\n\n        set_next_tick(s);\n\n        break;\n\n    \/* EISA interrupt *\/\n\n    case 0x0238:\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"rc4030: invalid write of 0x%02x at 0x%x\",\n\n                      val, (int)addr);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"bf43330aa418908f7a5e2acda28ac1a8ed0d8ad6","target":1,"func":"void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n\n{\n\n    uint64_t real_count = count & ~timer->disabled_mask;\n\n    uint64_t disabled_bit = count & timer->disabled_mask;\n\n\n\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n\n                  timer->name, real_count,\n\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    timer->disabled = disabled_bit ? 1 : 0;\n\n    timer->clock_offset = vm_clock_offset;\n\n}\n"},{"project":"qemu","commit_id":"3b098d56979d2f7fd707c5be85555d114353a28d","target":0,"func":"void qapi_copy_SocketAddress(SocketAddress **p_dest,\n\n                             SocketAddress *src)\n\n{\n\n    QmpOutputVisitor *qov;\n\n    Visitor *ov, *iv;\n\n    QObject *obj;\n\n\n\n    *p_dest = NULL;\n\n\n\n    qov = qmp_output_visitor_new();\n\n    ov = qmp_output_get_visitor(qov);\n\n    visit_type_SocketAddress(ov, NULL, &src, &error_abort);\n\n    obj = qmp_output_get_qobject(qov);\n\n    visit_free(ov);\n\n    if (!obj) {\n\n        return;\n\n    }\n\n\n\n    iv = qmp_input_visitor_new(obj, true);\n\n    visit_type_SocketAddress(iv, NULL, p_dest, &error_abort);\n\n    visit_free(iv);\n\n    qobject_decref(obj);\n\n}\n"},{"project":"qemu","commit_id":"734a77584ae13d36113a7a7cd8b54beb49a8a48e","target":0,"func":"static int qcow2_save_vmstate(BlockDriverState *bs, QEMUIOVector *qiov,\n\n                              int64_t pos)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t total_sectors = bs->total_sectors;\n\n    bool zero_beyond_eof = bs->zero_beyond_eof;\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_VMSTATE_SAVE);\n\n    bs->zero_beyond_eof = false;\n\n    ret = bdrv_pwritev(bs, qcow2_vm_state_offset(s) + pos, qiov);\n\n    bs->zero_beyond_eof = zero_beyond_eof;\n\n\n\n    \/* bdrv_co_do_writev will have increased the total_sectors value to include\n\n     * the VM state - the VM state is however not an actual part of the block\n\n     * device, therefore, we need to restore the old value. *\/\n\n    bs->total_sectors = total_sectors;\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static void ide_set_signature(IDEState *s)\n\n{\n\n    s->select &= 0xf0; \/* clear head *\/\n\n    \/* put signature *\/\n\n    s->nsector = 1;\n\n    s->sector = 1;\n\n    if (s->drive_kind == IDE_CD) {\n\n        s->lcyl = 0x14;\n\n        s->hcyl = 0xeb;\n\n    } else if (s->bs) {\n\n        s->lcyl = 0;\n\n        s->hcyl = 0;\n\n    } else {\n\n        s->lcyl = 0xff;\n\n        s->hcyl = 0xff;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"59f39a47411ab6007a592555dc639aa9753f8d23","target":0,"func":"static bool check_section_footer(QEMUFile *f, SaveStateEntry *se)\n\n{\n\n    uint8_t read_mark;\n\n    uint32_t read_section_id;\n\n\n\n    if (skip_section_footers) {\n\n        \/* No footer to check *\/\n\n        return true;\n\n    }\n\n\n\n    read_mark = qemu_get_byte(f);\n\n\n\n    if (read_mark != QEMU_VM_SECTION_FOOTER) {\n\n        error_report(\"Missing section footer for %s\", se->idstr);\n\n        return false;\n\n    }\n\n\n\n    read_section_id = qemu_get_be32(f);\n\n    if (read_section_id != se->section_id) {\n\n        error_report(\"Mismatched section id in footer for %s -\"\n\n                     \" read 0x%x expected 0x%x\",\n\n                     se->idstr, read_section_id, se->section_id);\n\n        return false;\n\n    }\n\n\n\n    \/* All good *\/\n\n    return true;\n\n}\n"},{"project":"qemu","commit_id":"f8b0aa25599782eef91edc00ebf620bd14db720c","target":0,"func":"static void setup_frame(int usig, struct emulated_sigaction *ka,\n\n\t\t\ttarget_sigset_t *set, CPUState *regs)\n\n{\n\n\tstruct sigframe *frame;\n\n\tabi_ulong frame_addr = get_sigframe(ka, regs, sizeof(*frame));\n\n\tint i, err = 0;\n\n\n\n\tif (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n\n\t\treturn;\n\n\n\n\terr |= setup_sigcontext(&frame->sc, \/*&frame->fpstate,*\/ regs, set->sig[0]);\n\n\n\n        for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n            if (__put_user(set->sig[i], &frame->extramask[i - 1]))\n\n                goto end;\n\n\t}\n\n\n\n\tif (err == 0)\n\n            err = setup_return(regs, ka, &frame->retcode, frame, usig);\n\n\n\nend:\n\n\tunlock_user_struct(frame, frame_addr, 1);\n\n        \/\/\treturn err;\n\n}\n"},{"project":"qemu","commit_id":"b0fd8d18683f0d77a8e6b482771ebea82234d727","target":0,"func":"static void target_setup_frame(int usig, struct target_sigaction *ka,\n\n                               target_siginfo_t *info, target_sigset_t *set,\n\n                               CPUARMState *env)\n\n{\n\n    struct target_rt_sigframe *frame;\n\n    abi_ulong frame_addr, return_addr;\n\n\n\n    frame_addr = get_sigframe(ka, env);\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    __put_user(0, &frame->uc.tuc_flags);\n\n    __put_user(0, &frame->uc.tuc_link);\n\n\n\n    __put_user(target_sigaltstack_used.ss_sp,\n\n                      &frame->uc.tuc_stack.ss_sp);\n\n    __put_user(sas_ss_flags(env->xregs[31]),\n\n                      &frame->uc.tuc_stack.ss_flags);\n\n    __put_user(target_sigaltstack_used.ss_size,\n\n                      &frame->uc.tuc_stack.ss_size);\n\n    target_setup_sigframe(frame, env, set);\n\n    if (ka->sa_flags & TARGET_SA_RESTORER) {\n\n        return_addr = ka->sa_restorer;\n\n    } else {\n\n        \/* mov x8,#__NR_rt_sigreturn; svc #0 *\/\n\n        __put_user(0xd2801168, &frame->tramp[0]);\n\n        __put_user(0xd4000001, &frame->tramp[1]);\n\n        return_addr = frame_addr + offsetof(struct target_rt_sigframe, tramp);\n\n    }\n\n    env->xregs[0] = usig;\n\n    env->xregs[31] = frame_addr;\n\n    env->xregs[29] = env->xregs[31] + offsetof(struct target_rt_sigframe, fp);\n\n    env->pc = ka->_sa_handler;\n\n    env->xregs[30] = return_addr;\n\n    if (info) {\n\n        if (copy_siginfo_to_user(&frame->info, info)) {\n\n            goto give_sigsegv;\n\n        }\n\n        env->xregs[1] = frame_addr + offsetof(struct target_rt_sigframe, info);\n\n        env->xregs[2] = frame_addr + offsetof(struct target_rt_sigframe, uc);\n\n    }\n\n\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    return;\n\n\n\n give_sigsegv:\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n"}]