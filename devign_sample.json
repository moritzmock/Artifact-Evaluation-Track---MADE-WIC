[{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static void onenand_command(OneNANDState *s)\n\n{\n\n    int b;\n\n    int sec;\n\n    void *buf;\n\n#define SETADDR(block, page)\t\t\t\\\n\n    sec = (s->addr[page] & 3) +\t\t\t\\\n\n            ((((s->addr[page] >> 2) & 0x3f) +\t\\\n\n              (((s->addr[block] & 0xfff) |\t\\\n\n                (s->addr[block] >> 15 ?\t\t\\\n\n                 s->density_mask : 0)) << 6)) << (PAGE_SHIFT - 9));\n\n#define SETBUF_M()\t\t\t\t\\\n\n    buf = (s->bufaddr & 8) ?\t\t\t\\\n\n            s->data[(s->bufaddr >> 2) & 1][0] : s->boot[0];\t\\\n\n    buf += (s->bufaddr & 3) << 9;\n\n#define SETBUF_S()\t\t\t\t\\\n\n    buf = (s->bufaddr & 8) ?\t\t\t\\\n\n            s->data[(s->bufaddr >> 2) & 1][1] : s->boot[1];\t\\\n\n    buf += (s->bufaddr & 3) << 4;\n\n\n\n    switch (s->command) {\n\n    case 0x00:\t\/* Load single\/multiple sector data unit into buffer *\/\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n\n\n        SETBUF_M()\n\n        if (onenand_load_main(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_LOAD;\n\n\n\n#if 0\n\n        SETBUF_S()\n\n        if (onenand_load_spare(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_LOAD;\n\n#endif\n\n\n\n        \/* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)\n\n         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)\n\n         * then we need two split the read\/write into two chunks.\n\n         *\/\n\n        s->intstatus |= ONEN_INT | ONEN_INT_LOAD;\n\n        break;\n\n    case 0x13:\t\/* Load single\/multiple spare sector into buffer *\/\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n\n\n        SETBUF_S()\n\n        if (onenand_load_spare(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_LOAD;\n\n\n\n        \/* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)\n\n         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)\n\n         * then we need two split the read\/write into two chunks.\n\n         *\/\n\n        s->intstatus |= ONEN_INT | ONEN_INT_LOAD;\n\n        break;\n\n    case 0x80:\t\/* Program single\/multiple sector data unit from buffer *\/\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n\n\n        SETBUF_M()\n\n        if (onenand_prog_main(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n\n\n#if 0\n\n        SETBUF_S()\n\n        if (onenand_prog_spare(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n#endif\n\n\n\n        \/* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)\n\n         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)\n\n         * then we need two split the read\/write into two chunks.\n\n         *\/\n\n        s->intstatus |= ONEN_INT | ONEN_INT_PROG;\n\n        break;\n\n    case 0x1a:\t\/* Program single\/multiple spare area sector from buffer *\/\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n\n\n        SETBUF_S()\n\n        if (onenand_prog_spare(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n\n\n        \/* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)\n\n         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)\n\n         * then we need two split the read\/write into two chunks.\n\n         *\/\n\n        s->intstatus |= ONEN_INT | ONEN_INT_PROG;\n\n        break;\n\n    case 0x1b:\t\/* Copy-back program *\/\n\n        SETBUF_S()\n\n\n\n        SETADDR(ONEN_BUF_BLOCK, ONEN_BUF_PAGE)\n\n        if (onenand_load_main(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n\n\n        SETADDR(ONEN_BUF_DEST_BLOCK, ONEN_BUF_DEST_PAGE)\n\n        if (onenand_prog_main(s, sec, s->count, buf))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;\n\n\n\n        \/* TODO: spare areas *\/\n\n\n\n        s->intstatus |= ONEN_INT | ONEN_INT_PROG;\n\n        break;\n\n\n\n    case 0x23:\t\/* Unlock NAND array block(s) *\/\n\n        s->intstatus |= ONEN_INT;\n\n\n\n        \/* XXX the previous (?) area should be locked automatically *\/\n\n        for (b = s->unladdr[0]; b <= s->unladdr[1]; b ++) {\n\n            if (b >= s->blocks) {\n\n                s->status |= ONEN_ERR_CMD;\n\n                break;\n\n            }\n\n            if (s->blockwp[b] == ONEN_LOCK_LOCKTIGHTEN)\n\n                break;\n\n\n\n            s->wpstatus = s->blockwp[b] = ONEN_LOCK_UNLOCKED;\n\n        }\n\n        break;\n\n    case 0x27:\t\/* Unlock All NAND array blocks *\/\n\n        s->intstatus |= ONEN_INT;\n\n\n\n        for (b = 0; b < s->blocks; b ++) {\n\n            if (b >= s->blocks) {\n\n                s->status |= ONEN_ERR_CMD;\n\n                break;\n\n            }\n\n            if (s->blockwp[b] == ONEN_LOCK_LOCKTIGHTEN)\n\n                break;\n\n\n\n            s->wpstatus = s->blockwp[b] = ONEN_LOCK_UNLOCKED;\n\n        }\n\n        break;\n\n\n\n    case 0x2a:\t\/* Lock NAND array block(s) *\/\n\n        s->intstatus |= ONEN_INT;\n\n\n\n        for (b = s->unladdr[0]; b <= s->unladdr[1]; b ++) {\n\n            if (b >= s->blocks) {\n\n                s->status |= ONEN_ERR_CMD;\n\n                break;\n\n            }\n\n            if (s->blockwp[b] == ONEN_LOCK_LOCKTIGHTEN)\n\n                break;\n\n\n\n            s->wpstatus = s->blockwp[b] = ONEN_LOCK_LOCKED;\n\n        }\n\n        break;\n\n    case 0x2c:\t\/* Lock-tight NAND array block(s) *\/\n\n        s->intstatus |= ONEN_INT;\n\n\n\n        for (b = s->unladdr[0]; b <= s->unladdr[1]; b ++) {\n\n            if (b >= s->blocks) {\n\n                s->status |= ONEN_ERR_CMD;\n\n                break;\n\n            }\n\n            if (s->blockwp[b] == ONEN_LOCK_UNLOCKED)\n\n                continue;\n\n\n\n            s->wpstatus = s->blockwp[b] = ONEN_LOCK_LOCKTIGHTEN;\n\n        }\n\n        break;\n\n\n\n    case 0x71:\t\/* Erase-Verify-Read *\/\n\n        s->intstatus |= ONEN_INT;\n\n        break;\n\n    case 0x95:\t\/* Multi-block erase *\/\n\n        qemu_irq_pulse(s->intr);\n\n        \/* Fall through.  *\/\n\n    case 0x94:\t\/* Block erase *\/\n\n        sec = ((s->addr[ONEN_BUF_BLOCK] & 0xfff) |\n\n                        (s->addr[ONEN_BUF_BLOCK] >> 15 ? s->density_mask : 0))\n\n                << (BLOCK_SHIFT - 9);\n\n        if (onenand_erase(s, sec, 1 << (BLOCK_SHIFT - 9)))\n\n            s->status |= ONEN_ERR_CMD | ONEN_ERR_ERASE;\n\n\n\n        s->intstatus |= ONEN_INT | ONEN_INT_ERASE;\n\n        break;\n\n    case 0xb0:\t\/* Erase suspend *\/\n\n        break;\n\n    case 0x30:\t\/* Erase resume *\/\n\n        s->intstatus |= ONEN_INT | ONEN_INT_ERASE;\n\n        break;\n\n\n\n    case 0xf0:\t\/* Reset NAND Flash core *\/\n\n        onenand_reset(s, 0);\n\n        break;\n\n    case 0xf3:\t\/* Reset OneNAND *\/\n\n        onenand_reset(s, 0);\n\n        break;\n\n\n\n    case 0x65:\t\/* OTP Access *\/\n\n        s->intstatus |= ONEN_INT;\n\n        s->bdrv_cur = NULL;\n\n        s->current = s->otp;\n\n        s->secs_cur = 1 << (BLOCK_SHIFT - 9);\n\n        s->addr[ONEN_BUF_BLOCK] = 0;\n\n        s->otpmode = 1;\n\n        break;\n\n\n\n    default:\n\n        s->status |= ONEN_ERR_CMD;\n\n        s->intstatus |= ONEN_INT;\n\n        fprintf(stderr, \"%s: unknown OneNAND command %x\\n\",\n\n                        __func__, s->command);\n\n    }\n\n\n\n    onenand_intr_update(s);\n\n}\n"},{"project":"qemu","commit_id":"d6085e3ace20bc9b0fa625d8d79b22668710e217","target":0,"func":"static void virtio_net_device_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIONet *n = VIRTIO_NET(dev);\n\n    NetClientState *nc;\n\n    int i;\n\n\n\n    virtio_init(vdev, \"virtio-net\", VIRTIO_ID_NET, n->config_size);\n\n\n\n    n->max_queues = MAX(n->nic_conf.queues, 1);\n\n    n->vqs = g_malloc0(sizeof(VirtIONetQueue) * n->max_queues);\n\n    n->vqs[0].rx_vq = virtio_add_queue(vdev, 256, virtio_net_handle_rx);\n\n    n->curr_queues = 1;\n\n    n->vqs[0].n = n;\n\n    n->tx_timeout = n->net_conf.txtimer;\n\n\n\n    if (n->net_conf.tx && strcmp(n->net_conf.tx, \"timer\")\n\n                       && strcmp(n->net_conf.tx, \"bh\")) {\n\n        error_report(\"virtio-net: \"\n\n                     \"Unknown option tx=%s, valid options: \\\"timer\\\" \\\"bh\\\"\",\n\n                     n->net_conf.tx);\n\n        error_report(\"Defaulting to \\\"bh\\\"\");\n\n    }\n\n\n\n    if (n->net_conf.tx && !strcmp(n->net_conf.tx, \"timer\")) {\n\n        n->vqs[0].tx_vq = virtio_add_queue(vdev, 256,\n\n                                           virtio_net_handle_tx_timer);\n\n        n->vqs[0].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, virtio_net_tx_timer,\n\n                                               &n->vqs[0]);\n\n    } else {\n\n        n->vqs[0].tx_vq = virtio_add_queue(vdev, 256,\n\n                                           virtio_net_handle_tx_bh);\n\n        n->vqs[0].tx_bh = qemu_bh_new(virtio_net_tx_bh, &n->vqs[0]);\n\n    }\n\n    n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);\n\n    qemu_macaddr_default_if_unset(&n->nic_conf.macaddr);\n\n    memcpy(&n->mac[0], &n->nic_conf.macaddr, sizeof(n->mac));\n\n    n->status = VIRTIO_NET_S_LINK_UP;\n\n\n\n    if (n->netclient_type) {\n\n        \/*\n\n         * Happen when virtio_net_set_netclient_name has been called.\n\n         *\/\n\n        n->nic = qemu_new_nic(&net_virtio_info, &n->nic_conf,\n\n                              n->netclient_type, n->netclient_name, n);\n\n    } else {\n\n        n->nic = qemu_new_nic(&net_virtio_info, &n->nic_conf,\n\n                              object_get_typename(OBJECT(dev)), dev->id, n);\n\n    }\n\n\n\n    peer_test_vnet_hdr(n);\n\n    if (peer_has_vnet_hdr(n)) {\n\n        for (i = 0; i < n->max_queues; i++) {\n\n            qemu_peer_using_vnet_hdr(qemu_get_subqueue(n->nic, i), true);\n\n        }\n\n        n->host_hdr_len = sizeof(struct virtio_net_hdr);\n\n    } else {\n\n        n->host_hdr_len = 0;\n\n    }\n\n\n\n    qemu_format_nic_info_str(qemu_get_queue(n->nic), n->nic_conf.macaddr.a);\n\n\n\n    n->vqs[0].tx_waiting = 0;\n\n    n->tx_burst = n->net_conf.txburst;\n\n    virtio_net_set_mrg_rx_bufs(n, 0);\n\n    n->promisc = 1; \/* for compatibility *\/\n\n\n\n    n->mac_table.macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);\n\n\n\n    n->vlans = g_malloc0(MAX_VLAN >> 3);\n\n\n\n    nc = qemu_get_queue(n->nic);\n\n    nc->rxfilter_notify_enabled = 1;\n\n\n\n    n->qdev = dev;\n\n    register_savevm(dev, \"virtio-net\", -1, VIRTIO_NET_VM_VERSION,\n\n                    virtio_net_save, virtio_net_load, n);\n\n\n\n    add_boot_device_path(n->nic_conf.bootindex, dev, \"\/ethernet-phy@0\");\n\n}\n"},{"project":"qemu","commit_id":"60fe637bf0e4d7989e21e50f52526444765c63b4","target":1,"func":"static int get_int32(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int32_t *v = pv;\n\n    qemu_get_sbe32s(f, v);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"f06b2031a31cdd3acf6f61a977e505b8c6b58f73","target":0,"func":"void ga_channel_free(GAChannel *c)\n\n{\n\n    if (c->method == GA_CHANNEL_UNIX_LISTEN\n\n        && c->listen_channel) {\n\n        ga_channel_listen_close(c);\n\n    }\n\n    if (c->client_channel) {\n\n        ga_channel_client_close(c);\n\n    }\n\n    g_free(c);\n\n}\n"},{"project":"qemu","commit_id":"5d1abf234462d13bef3617cc2c55b6815703ddf2","target":0,"func":"int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr,\n\n                        uint8_t ar)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    S390PCIBusDevice *pbdev;\n\n    MemoryRegion *mr;\n\n    int i;\n\n    uint32_t fh;\n\n    uint8_t pcias;\n\n    uint8_t len;\n\n    uint8_t buffer[128];\n\n\n\n    if (env->psw.mask & PSW_MASK_PSTATE) {\n\n        program_interrupt(env, PGM_PRIVILEGED, 6);\n\n        return 0;\n\n    }\n\n\n\n    fh = env->regs[r1] >> 32;\n\n    pcias = (env->regs[r1] >> 16) & 0xf;\n\n    len = env->regs[r1] & 0xff;\n\n\n\n    if (pcias > 5) {\n\n        DPRINTF(\"pcistb invalid space\\n\");\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);\n\n        return 0;\n\n    }\n\n\n\n    switch (len) {\n\n    case 16:\n\n    case 32:\n\n    case 64:\n\n    case 128:\n\n        break;\n\n    default:\n\n        program_interrupt(env, PGM_SPECIFICATION, 6);\n\n        return 0;\n\n    }\n\n\n\n    pbdev = s390_pci_find_dev_by_fh(fh);\n\n    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {\n\n        DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh);\n\n        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);\n\n        return 0;\n\n    }\n\n\n\n    if (pbdev->lgstg_blocked) {\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);\n\n        return 0;\n\n    }\n\n\n\n    mr = pbdev->pdev->io_regions[pcias].memory;\n\n    if (!memory_region_access_valid(mr, env->regs[r3], len, true)) {\n\n        program_interrupt(env, PGM_ADDRESSING, 6);\n\n        return 0;\n\n    }\n\n\n\n    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < len \/ 8; i++) {\n\n        memory_region_dispatch_write(mr, env->regs[r3] + i * 8,\n\n                                     ldq_p(buffer + i * 8), 8,\n\n                                     MEMTXATTRS_UNSPECIFIED);\n\n    }\n\n\n\n    setcc(cpu, ZPCI_PCI_LS_OK);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"0522a959aec29768610900636f6234ab40530f82","target":1,"func":"static int net_socket_listen_init(NetClientState *peer,\n\n                                  const char *model,\n\n                                  const char *name,\n\n                                  const char *host_str)\n\n{\n\n    NetClientState *nc;\n\n    NetSocketState *s;\n\n    struct sockaddr_in saddr;\n\n    int fd, ret;\n\n    Error *err = NULL;\n\n\n\n    if (parse_host_port(&saddr, host_str, &err) < 0) {\n\n        error_report_err(err);\n\n        return -1;\n\n    }\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n\n\n    socket_set_fast_reuse(fd);\n\n\n\n    ret = bind(fd, (struct sockaddr *)&saddr, sizeof(saddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n        closesocket(fd);\n\n        return -1;\n\n    }\n\n    ret = listen(fd, 0);\n\n    if (ret < 0) {\n\n        perror(\"listen\");\n\n        closesocket(fd);\n\n        return -1;\n\n    }\n\n\n\n    nc = qemu_new_net_client(&net_socket_info, peer, model, name);\n\n    s = DO_UPCAST(NetSocketState, nc, nc);\n\n    s->fd = -1;\n\n    s->listen_fd = fd;\n\n    s->nc.link_down = true;\n\n    net_socket_rs_init(&s->rs, net_socket_rs_finalize, false);\n\n\n\n    qemu_set_fd_handler(s->listen_fd, net_socket_accept, NULL, s);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"90e496386fe7fd32c189561f846b7913f95b8cf4","target":0,"func":"static TCGv_i32 read_fp_sreg(DisasContext *s, int reg)\n\n{\n\n    TCGv_i32 v = tcg_temp_new_i32();\n\n\n\n    tcg_gen_ld_i32(v, cpu_env, fp_reg_offset(reg, MO_32));\n\n    return v;\n\n}\n"},{"project":"qemu","commit_id":"e100161b69f8cf56dae866912dfffe7dcd7140af","target":0,"func":"int vfio_spapr_create_window(VFIOContainer *container,\n\n                             MemoryRegionSection *section,\n\n                             hwaddr *pgsize)\n\n{\n\n    int ret;\n\n    IOMMUMemoryRegion *iommu_mr = IOMMU_MEMORY_REGION(section->mr);\n\n    unsigned pagesize = memory_region_iommu_get_min_page_size(iommu_mr);\n\n    unsigned entries, pages;\n\n    struct vfio_iommu_spapr_tce_create create = { .argsz = sizeof(create) };\n\n\n\n    \/*\n\n     * FIXME: For VFIO iommu types which have KVM acceleration to\n\n     * avoid bouncing all map\/unmaps through qemu this way, this\n\n     * would be the right place to wire that up (tell the KVM\n\n     * device emulation the VFIO iommu handles to use).\n\n     *\/\n\n    create.window_size = int128_get64(section->size);\n\n    create.page_shift = ctz64(pagesize);\n\n    \/*\n\n     * SPAPR host supports multilevel TCE tables, there is some\n\n     * heuristic to decide how many levels we want for our table:\n\n     * 0..64 = 1; 65..4096 = 2; 4097..262144 = 3; 262145.. = 4\n\n     *\/\n\n    entries = create.window_size >> create.page_shift;\n\n    pages = MAX((entries * sizeof(uint64_t)) \/ getpagesize(), 1);\n\n    pages = MAX(pow2ceil(pages) - 1, 1); \/* Round up *\/\n\n    create.levels = ctz64(pages) \/ 6 + 1;\n\n\n\n    ret = ioctl(container->fd, VFIO_IOMMU_SPAPR_TCE_CREATE, &create);\n\n    if (ret) {\n\n        error_report(\"Failed to create a window, ret = %d (%m)\", ret);\n\n        return -errno;\n\n    }\n\n\n\n    if (create.start_addr != section->offset_within_address_space) {\n\n        vfio_spapr_remove_window(container, create.start_addr);\n\n\n\n        error_report(\"Host doesn't support DMA window at %\"HWADDR_PRIx\", must be %\"PRIx64,\n\n                     section->offset_within_address_space,\n\n                     (uint64_t)create.start_addr);\n\n        return -EINVAL;\n\n    }\n\n    trace_vfio_spapr_create_window(create.page_shift,\n\n                                   create.window_size,\n\n                                   create.start_addr);\n\n    *pgsize = pagesize;\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"e7d336959b7c01699702dcda4b54a822972d74a8","target":0,"func":"S390PCIBusDevice *s390_pci_find_dev_by_idx(uint32_t idx)\n\n{\n\n    S390PCIBusDevice *pbdev;\n\n    int i;\n\n    int j = 0;\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(\n\n        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));\n\n\n\n    if (!s) {\n\n        return NULL;\n\n    }\n\n\n\n    for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n        pbdev = &s->pbdev[i];\n\n\n\n        if (pbdev->fh == 0) {\n\n            continue;\n\n        }\n\n\n\n        if (j == idx) {\n\n            return pbdev;\n\n        }\n\n        j++;\n\n    }\n\n\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"e1833e1f96456fd8fc17463246fe0b2050e68efb","target":0,"func":"static void spr_write_ibatl (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_ibatl((sprn - SPR_IBAT0L) \/ 2);\n\n    RET_STOP(ctx);\n\n}\n"},{"project":"qemu","commit_id":"3a4dbe6aa934370a92372528c1255ee1504965ee","target":1,"func":"static void vfio_put_device(VFIOPCIDevice *vdev)\n\n{\n\n    g_free(vdev->vbasedev.name);\n\n    if (vdev->msix) {\n\n\n        g_free(vdev->msix);\n\n        vdev->msix = NULL;\n\n    }\n\n    vfio_put_base_device(&vdev->vbasedev);\n\n}"},{"project":"qemu","commit_id":"8d5c773e323b22402abdd0beef4c7d2fc91dd0eb","target":0,"func":"static void contextidr_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                             uint64_t value)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n\n\n    if (env->cp15.contextidr_el1 != value && !arm_feature(env, ARM_FEATURE_MPU)\n\n        && !extended_addresses_enabled(env)) {\n\n        \/* For VMSA (when not using the LPAE long descriptor page table\n\n         * format) this register includes the ASID, so do a TLB flush.\n\n         * For PMSA it is purely a process ID and no action is needed.\n\n         *\/\n\n        tlb_flush(CPU(cpu), 1);\n\n    }\n\n    env->cp15.contextidr_el1 = value;\n\n}\n"},{"project":"qemu","commit_id":"fff4e48ed54cc39e5942921df91300646ad37707","target":1,"func":"int net_init_vhost_user(const NetClientOptions *opts, const char *name,\n\n                        NetClientState *peer, Error **errp)\n\n{\n\n    int queues;\n\n    const NetdevVhostUserOptions *vhost_user_opts;\n\n    CharDriverState *chr;\n\n\n\n    assert(opts->type == NET_CLIENT_OPTIONS_KIND_VHOST_USER);\n\n    vhost_user_opts = opts->u.vhost_user;\n\n\n\n    chr = net_vhost_parse_chardev(vhost_user_opts, errp);\n\n    if (!chr) {\n\n        return -1;\n\n    }\n\n\n\n    \/* verify net frontend *\/\n\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"), net_vhost_check_net,\n\n                          (char *)name, errp)) {\n\n        return -1;\n\n    }\n\n\n\n    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;\n\n    if (queues < 1) {\n\n        error_setg(errp,\n\n                   \"vhost-user number of queues must be bigger than zero\");\n\n        return -1;\n\n    }\n\n\n\n    return net_vhost_user_init(peer, \"vhost_user\", name, chr, queues);\n\n}\n"},{"project":"qemu","commit_id":"5839e53bbc0fec56021d758aab7610df421ed8c8","target":1,"func":"static int vdi_check(BlockDriverState *bs, BdrvCheckResult *res,\n\n                     BdrvCheckMode fix)\n\n{\n\n    \/* TODO: additional checks possible. *\/\n\n    BDRVVdiState *s = (BDRVVdiState *)bs->opaque;\n\n    uint32_t blocks_allocated = 0;\n\n    uint32_t block;\n\n    uint32_t *bmap;\n\n    logout(\"\\n\");\n\n\n\n    if (fix) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    bmap = g_try_malloc(s->header.blocks_in_image * sizeof(uint32_t));\n\n    if (s->header.blocks_in_image && bmap == NULL) {\n\n        res->check_errors++;\n\n        return -ENOMEM;\n\n    }\n\n\n\n    memset(bmap, 0xff, s->header.blocks_in_image * sizeof(uint32_t));\n\n\n\n    \/* Check block map and value of blocks_allocated. *\/\n\n    for (block = 0; block < s->header.blocks_in_image; block++) {\n\n        uint32_t bmap_entry = le32_to_cpu(s->bmap[block]);\n\n        if (VDI_IS_ALLOCATED(bmap_entry)) {\n\n            if (bmap_entry < s->header.blocks_in_image) {\n\n                blocks_allocated++;\n\n                if (!VDI_IS_ALLOCATED(bmap[bmap_entry])) {\n\n                    bmap[bmap_entry] = bmap_entry;\n\n                } else {\n\n                    fprintf(stderr, \"ERROR: block index %\" PRIu32\n\n                            \" also used by %\" PRIu32 \"\\n\", bmap[bmap_entry], bmap_entry);\n\n                    res->corruptions++;\n\n                }\n\n            } else {\n\n                fprintf(stderr, \"ERROR: block index %\" PRIu32\n\n                        \" too large, is %\" PRIu32 \"\\n\", block, bmap_entry);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n    if (blocks_allocated != s->header.blocks_allocated) {\n\n        fprintf(stderr, \"ERROR: allocated blocks mismatch, is %\" PRIu32\n\n               \", should be %\" PRIu32 \"\\n\",\n\n               blocks_allocated, s->header.blocks_allocated);\n\n        res->corruptions++;\n\n    }\n\n\n\n    g_free(bmap);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"60fe637bf0e4d7989e21e50f52526444765c63b4","target":1,"func":"static ssize_t qsb_get_iovec(const QEMUSizedBuffer *qsb,\n\n                             off_t pos, off_t *d_off)\n\n{\n\n    ssize_t i;\n\n    off_t curr = 0;\n\n\n\n    if (pos > qsb->used) {\n\n        return -1;\n\n    }\n\n\n\n    for (i = 0; i < qsb->n_iov; i++) {\n\n        if (curr + qsb->iov[i].iov_len > pos) {\n\n            *d_off = pos - curr;\n\n            return i;\n\n        }\n\n        curr += qsb->iov[i].iov_len;\n\n    }\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"4407c1c56adb0d3ef2bcbf577592d72278d6e11f","target":0,"func":"static void virtio_blk_dma_restart_cb(void *opaque, int running,\n\n                                      RunState state)\n\n{\n\n    VirtIOBlock *s = opaque;\n\n\n\n    if (!running) {\n\n        return;\n\n    }\n\n\n\n    if (!s->bh) {\n\n        s->bh = qemu_bh_new(virtio_blk_dma_restart_bh, s);\n\n        qemu_bh_schedule(s->bh);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"563890c7c7e977842e2a35afe7a24d06d2103242","target":1,"func":"static void test_media_insert(void)\n\n{\n\n    uint8_t dir;\n\n\n\n    \/* Insert media in drive. DSKCHK should not be reset until a step pulse\n\n     * is sent. *\/\n\n    qmp_discard_response(\"{'execute':'change', 'arguments':{\"\n\n                         \" 'device':'floppy0', 'target': '%s' }}\",\n\n                         test_image);\n\n    qmp_discard_response(\"\"); \/* ignore event\n\n                                 (FIXME open -> open transition?!) *\/\n\n    qmp_discard_response(\"\"); \/* ignore event *\/\n\n\n\n    dir = inb(FLOPPY_BASE + reg_dir);\n\n    assert_bit_set(dir, DSKCHG);\n\n    dir = inb(FLOPPY_BASE + reg_dir);\n\n    assert_bit_set(dir, DSKCHG);\n\n\n\n    send_seek(0);\n\n    dir = inb(FLOPPY_BASE + reg_dir);\n\n    assert_bit_set(dir, DSKCHG);\n\n    dir = inb(FLOPPY_BASE + reg_dir);\n\n    assert_bit_set(dir, DSKCHG);\n\n\n\n    \/* Step to next track should clear DSKCHG bit. *\/\n\n    send_seek(1);\n\n    dir = inb(FLOPPY_BASE + reg_dir);\n\n    assert_bit_clear(dir, DSKCHG);\n\n    dir = inb(FLOPPY_BASE + reg_dir);\n\n    assert_bit_clear(dir, DSKCHG);\n\n}\n"},{"project":"qemu","commit_id":"a3f1afb43a09e4577571c044c48f2ba9e6e4ad06","target":0,"func":"static int zero_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* Limit nb_clusters to one L2 table *\/\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_offset;\n\n\n\n        old_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        \/* Update L2 entries *\/\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (old_offset & QCOW_OFLAG_COMPRESSED) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);\n\n        } else {\n\n            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        }\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nb_clusters;\n\n}\n"},{"project":"qemu","commit_id":"b3db211f3c80bb996a704d665fe275619f728bd4","target":0,"func":"static void test_visitor_in_native_list_uint8(TestInputVisitorData *data,\n\n                                             const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_U8);\n\n}\n"},{"project":"qemu","commit_id":"f22d85e9e67262db34504f4079745f9843da6a92","target":0,"func":"static void enable_logging(void)\n\n{\n\n    ga_enable_logging(ga_state);\n\n}\n"},{"project":"qemu","commit_id":"b062ad86dcd33ab39be5060b0655d8e13834b167","target":0,"func":"static int readv_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0, vflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    \/* Some compilers get confused and warn if this is not initialized.  *\/\n\n    int total = 0;\n\n    int nr_iov;\n\n    QEMUIOVector qiov;\n\n    int pattern = 0;\n\n    int Pflag = 0;\n\n\n\n    while ((c = getopt(argc, argv, \"CP:qv\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'P':\n\n            Pflag = 1;\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        case 'v':\n\n            vflag = 1;\n\n            break;\n\n        default:\n\n            return qemuio_command_usage(&readv_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n        return qemuio_command_usage(&readv_cmd);\n\n    }\n\n\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               offset);\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    buf = create_iovec(blk, &qiov, &argv[optind], nr_iov, 0xab);\n\n    if (buf == NULL) {\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    cnt = do_aio_readv(blk, &qiov, offset, &total);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (Pflag) {\n\n        void *cmp_buf = g_malloc(qiov.size);\n\n        memset(cmp_buf, pattern, qiov.size);\n\n        if (memcmp(buf, cmp_buf, qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", offset, qiov.size);\n\n        }\n\n        g_free(cmp_buf);\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (vflag) {\n\n        dump_buffer(buf, offset, qiov.size);\n\n    }\n\n\n\n    \/* Finally, report back -- -C gives a parsable format *\/\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"read\", &t2, offset, qiov.size, total, cnt, Cflag);\n\n\n\nout:\n\n    qemu_iovec_destroy(&qiov);\n\n    qemu_io_free(buf);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"560f19f162529d691619ac69ed032321c7f5f1fb","target":1,"func":"bool object_property_get_bool(Object *obj, const char *name,\n\n                              Error **errp)\n\n{\n\n    QObject *ret = object_property_get_qobject(obj, name, errp);\n\n    QBool *qbool;\n\n    bool retval;\n\n\n\n    if (!ret) {\n\n        return false;\n\n    }\n\n    qbool = qobject_to_qbool(ret);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name, \"boolean\");\n\n        retval = false;\n\n    } else {\n\n        retval = qbool_get_bool(qbool);\n\n    }\n\n\n\n    QDECREF(qbool);\n\n    return retval;\n\n}\n"},{"project":"qemu","commit_id":"42bb9c9178ae7ac4c439172b1ae99cc29188a5c6","target":0,"func":"static void stream_desc_store(struct Stream *s, hwaddr addr)\n\n{\n\n    struct SDesc *d = &s->desc;\n\n    int i;\n\n\n\n    \/* Convert from host endianness into LE.  *\/\n\n    d->buffer_address = cpu_to_le64(d->buffer_address);\n\n    d->nxtdesc = cpu_to_le64(d->nxtdesc);\n\n    d->control = cpu_to_le32(d->control);\n\n    d->status = cpu_to_le32(d->status);\n\n    for (i = 0; i < ARRAY_SIZE(d->app); i++) {\n\n        d->app[i] = cpu_to_le32(d->app[i]);\n\n    }\n\n    cpu_physical_memory_write(addr, (void *) d, sizeof *d);\n\n}\n"},{"project":"qemu","commit_id":"09e68369a88d7de0f988972bf28eec1b80cc47f9","target":0,"func":"static void qmp_input_type_bool(Visitor *v, const char *name, bool *obj,\n\n                                Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qmp_input_get_object(qiv, name, true, errp);\n\n    QBool *qbool;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qbool = qobject_to_qbool(qobj);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"boolean\");\n\n        return;\n\n    }\n\n\n\n    *obj = qbool_get_bool(qbool);\n\n}\n"},{"project":"qemu","commit_id":"041d95f42e39ed1d3a029332cab9966889f0aeb3","target":0,"func":"void ppc_tlb_invalidate_one(CPUPPCState *env, target_ulong addr)\n\n{\n\n#if !defined(FLUSH_ALL_TLBS)\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    CPUState *cs;\n\n\n\n    addr &= TARGET_PAGE_MASK;\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_virt(env, addr, 0);\n\n        if (env->id_tlbs == 1) {\n\n            ppc6xx_tlb_invalidate_virt(env, addr, 1);\n\n        }\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_virt(env, addr, env->spr[SPR_40x_PID]);\n\n        break;\n\n    case POWERPC_MMU_REAL:\n\n        cpu_abort(CPU(cpu), \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_MPC8xx:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(CPU(cpu), \"MPC8xx MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(CPU(cpu), \"BookE MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE206:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(CPU(cpu), \"BookE 2.06 MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n        \/* tlbie invalidate TLBs for all segments *\/\n\n        addr &= ~((target_ulong)-1ULL << 28);\n\n        cs = CPU(cpu);\n\n        \/* XXX: this case should be optimized,\n\n         * giving a mask to tlb_flush_page\n\n         *\/\n\n        tlb_flush_page(cs, addr | (0x0 << 28));\n\n        tlb_flush_page(cs, addr | (0x1 << 28));\n\n        tlb_flush_page(cs, addr | (0x2 << 28));\n\n        tlb_flush_page(cs, addr | (0x3 << 28));\n\n        tlb_flush_page(cs, addr | (0x4 << 28));\n\n        tlb_flush_page(cs, addr | (0x5 << 28));\n\n        tlb_flush_page(cs, addr | (0x6 << 28));\n\n        tlb_flush_page(cs, addr | (0x7 << 28));\n\n        tlb_flush_page(cs, addr | (0x8 << 28));\n\n        tlb_flush_page(cs, addr | (0x9 << 28));\n\n        tlb_flush_page(cs, addr | (0xA << 28));\n\n        tlb_flush_page(cs, addr | (0xB << 28));\n\n        tlb_flush_page(cs, addr | (0xC << 28));\n\n        tlb_flush_page(cs, addr | (0xD << 28));\n\n        tlb_flush_page(cs, addr | (0xE << 28));\n\n        tlb_flush_page(cs, addr | (0xF << 28));\n\n        break;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_03:\n\n    case POWERPC_MMU_2_06:\n\n    case POWERPC_MMU_2_06a:\n\n    case POWERPC_MMU_2_07:\n\n    case POWERPC_MMU_2_07a:\n\n        \/* tlbie invalidate TLBs for all segments *\/\n\n        \/* XXX: given the fact that there are too many segments to invalidate,\n\n         *      and we still don't have a tlb_flush_mask(env, n, mask) in QEMU,\n\n         *      we just invalidate all TLBs\n\n         *\/\n\n        tlb_flush(CPU(cpu), 1);\n\n        break;\n\n#endif \/* defined(TARGET_PPC64) *\/\n\n    default:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(CPU(cpu), \"Unknown MMU model\\n\");\n\n        break;\n\n    }\n\n#else\n\n    ppc_tlb_invalidate_all(env);\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"12848bfc5d719bad536c5448205a3226be1fda47","target":1,"func":"static int local_chmod(FsContext *fs_ctx, const char *path, FsCred *credp)\n\n{\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        return local_set_xattr(rpath(fs_ctx, path), credp);\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        return chmod(rpath(fs_ctx, path), credp->fc_mode);\n\n    }\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"494a8ebe713055d3946183f4b395f85a18b43e9e","target":0,"func":"static int proxy_utimensat(FsContext *s, V9fsPath *fs_path,\n\n                           const struct timespec *buf)\n\n{\n\n    int retval;\n\n    retval = v9fs_request(s->private, T_UTIME, NULL, \"sqqqq\",\n\n                          fs_path,\n\n                          buf[0].tv_sec, buf[0].tv_nsec,\n\n                          buf[1].tv_sec, buf[1].tv_nsec);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n    }\n\n    return retval;\n\n}\n"},{"project":"qemu","commit_id":"12de9a396acbc95e25c5d60ed097cc55777eaaed","target":1,"func":"void ppc_tlb_invalidate_all (CPUPPCState *env)\n\n{\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_REAL_4xx:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"MMU model not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE_FSL:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"MMU model not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_601:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"MMU model not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_64BRIDGE:\n\n#endif \/* defined(TARGET_PPC64) *\/\n\n        tlb_flush(env, 1);\n\n        break;\n\n    default:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"Unknown MMU model %d\\n\", env->mmu_model);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"fd97fd4408040a9a6dfaf2fdaeca1c566db6d0aa","target":1,"func":"static long gethugepagesize(const char *path, Error **errp)\n\n{\n\n    struct statfs fs;\n\n    int ret;\n\n\n\n    do {\n\n        ret = statfs(path, &fs);\n\n    } while (ret != 0 && errno == EINTR);\n\n\n\n    if (ret != 0) {\n\n        error_setg_errno(errp, errno, \"failed to get page size of file %s\",\n\n                         path);\n\n        return 0;\n\n    }\n\n\n\n    return fs.f_bsize;\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static bool cmd_write_multiple(IDEState *s, uint8_t cmd)\n\n{\n\n    bool lba48 = (cmd == WIN_MULTWRITE_EXT);\n\n    int n;\n\n\n\n    if (!s->bs || !s->mult_sectors) {\n\n        ide_abort_command(s);\n\n        return true;\n\n    }\n\n\n\n    ide_cmd_lba48_transform(s, lba48);\n\n\n\n    s->req_nb_sectors = s->mult_sectors;\n\n    n = MIN(s->nsector, s->req_nb_sectors);\n\n\n\n    s->status = SEEK_STAT | READY_STAT;\n\n    ide_transfer_start(s, s->io_buffer, 512 * n, ide_sector_write);\n\n\n\n    s->media_changed = 1;\n\n\n\n    return false;\n\n}\n"},{"project":"qemu","commit_id":"54ca9095f046dfa03c3d093cc55f6d76b61864e1","target":0,"func":"int cpu_x86_handle_mmu_fault(CPUX86State *env, target_ulong addr, \n\n                             int is_write1, int is_user, int is_softmmu)\n\n{\n\n    uint64_t ptep, pte;\n\n    uint32_t pdpe_addr, pde_addr, pte_addr;\n\n    int error_code, is_dirty, prot, page_size, ret, is_write;\n\n    unsigned long paddr, page_offset;\n\n    target_ulong vaddr, virt_addr;\n\n    \n\n#if defined(DEBUG_MMU)\n\n    printf(\"MMU fault: addr=\" TARGET_FMT_lx \" w=%d u=%d eip=\" TARGET_FMT_lx \"\\n\", \n\n           addr, is_write1, is_user, env->eip);\n\n#endif\n\n    is_write = is_write1 & 1;\n\n    \n\n    if (!(env->cr[0] & CR0_PG_MASK)) {\n\n        pte = addr;\n\n        virt_addr = addr & TARGET_PAGE_MASK;\n\n        prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n        page_size = 4096;\n\n        goto do_mapping;\n\n    }\n\n\n\n    if (env->cr[4] & CR4_PAE_MASK) {\n\n        uint64_t pde, pdpe;\n\n\n\n        \/* XXX: we only use 32 bit physical addresses *\/\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_LMA_MASK) {\n\n            uint32_t pml4e_addr;\n\n            uint64_t pml4e;\n\n            int32_t sext;\n\n\n\n            \/* test virtual address sign extension *\/\n\n            sext = (int64_t)addr >> 47;\n\n            if (sext != 0 && sext != -1) {\n\n                error_code = 0;\n\n                goto do_fault;\n\n            }\n\n            \n\n            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) & \n\n                env->a20_mask;\n\n            pml4e = ldq_phys(pml4e_addr);\n\n            if (!(pml4e & PG_PRESENT_MASK)) {\n\n                error_code = 0;\n\n                goto do_fault;\n\n            }\n\n            if (!(env->efer & MSR_EFER_NXE) && (pml4e & PG_NX_MASK)) {\n\n                error_code = PG_ERROR_RSVD_MASK;\n\n                goto do_fault;\n\n            }\n\n            if (!(pml4e & PG_ACCESSED_MASK)) {\n\n                pml4e |= PG_ACCESSED_MASK;\n\n                stl_phys_notdirty(pml4e_addr, pml4e);\n\n            }\n\n            ptep = pml4e ^ PG_NX_MASK;\n\n            pdpe_addr = ((pml4e & PHYS_ADDR_MASK) + (((addr >> 30) & 0x1ff) << 3)) & \n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK)) {\n\n                error_code = 0;\n\n                goto do_fault;\n\n            }\n\n            if (!(env->efer & MSR_EFER_NXE) && (pdpe & PG_NX_MASK)) {\n\n                error_code = PG_ERROR_RSVD_MASK;\n\n                goto do_fault;\n\n            }\n\n            ptep &= pdpe ^ PG_NX_MASK;\n\n            if (!(pdpe & PG_ACCESSED_MASK)) {\n\n                pdpe |= PG_ACCESSED_MASK;\n\n                stl_phys_notdirty(pdpe_addr, pdpe);\n\n            }\n\n        } else\n\n#endif\n\n        {\n\n            \/* XXX: load them when cr3 is loaded ? *\/\n\n            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 30) << 3)) & \n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK)) {\n\n                error_code = 0;\n\n                goto do_fault;\n\n            }\n\n            ptep = PG_NX_MASK | PG_USER_MASK | PG_RW_MASK;\n\n        }\n\n\n\n        pde_addr = ((pdpe & PHYS_ADDR_MASK) + (((addr >> 21) & 0x1ff) << 3)) &\n\n            env->a20_mask;\n\n        pde = ldq_phys(pde_addr);\n\n        if (!(pde & PG_PRESENT_MASK)) {\n\n            error_code = 0;\n\n            goto do_fault;\n\n        }\n\n        if (!(env->efer & MSR_EFER_NXE) && (pde & PG_NX_MASK)) {\n\n            error_code = PG_ERROR_RSVD_MASK;\n\n            goto do_fault;\n\n        }\n\n        ptep &= pde ^ PG_NX_MASK;\n\n        if (pde & PG_PSE_MASK) {\n\n            \/* 2 MB page *\/\n\n            page_size = 2048 * 1024;\n\n            ptep ^= PG_NX_MASK;\n\n            if ((ptep & PG_NX_MASK) && is_write1 == 2)\n\n                goto do_fault_protect;\n\n            if (is_user) {\n\n                if (!(ptep & PG_USER_MASK))\n\n                    goto do_fault_protect;\n\n                if (is_write && !(ptep & PG_RW_MASK))\n\n                    goto do_fault_protect;\n\n            } else {\n\n                if ((env->cr[0] & CR0_WP_MASK) && \n\n                    is_write && !(ptep & PG_RW_MASK)) \n\n                    goto do_fault_protect;\n\n            }\n\n            is_dirty = is_write && !(pde & PG_DIRTY_MASK);\n\n            if (!(pde & PG_ACCESSED_MASK) || is_dirty) {\n\n                pde |= PG_ACCESSED_MASK;\n\n                if (is_dirty)\n\n                    pde |= PG_DIRTY_MASK;\n\n                stl_phys_notdirty(pde_addr, pde);\n\n            }\n\n            \/* align to page_size *\/\n\n            pte = pde & ((PHYS_ADDR_MASK & ~(page_size - 1)) | 0xfff); \n\n            virt_addr = addr & ~(page_size - 1);\n\n        } else {\n\n            \/* 4 KB page *\/\n\n            if (!(pde & PG_ACCESSED_MASK)) {\n\n                pde |= PG_ACCESSED_MASK;\n\n                stl_phys_notdirty(pde_addr, pde);\n\n            }\n\n            pte_addr = ((pde & PHYS_ADDR_MASK) + (((addr >> 12) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pte = ldq_phys(pte_addr);\n\n            if (!(pte & PG_PRESENT_MASK)) {\n\n                error_code = 0;\n\n                goto do_fault;\n\n            }\n\n            if (!(env->efer & MSR_EFER_NXE) && (pte & PG_NX_MASK)) {\n\n                error_code = PG_ERROR_RSVD_MASK;\n\n                goto do_fault;\n\n            }\n\n            \/* combine pde and pte nx, user and rw protections *\/\n\n            ptep &= pte ^ PG_NX_MASK;\n\n            ptep ^= PG_NX_MASK;\n\n            if ((ptep & PG_NX_MASK) && is_write1 == 2)\n\n                goto do_fault_protect; \n\n            if (is_user) {\n\n                if (!(ptep & PG_USER_MASK))\n\n                    goto do_fault_protect;\n\n                if (is_write && !(ptep & PG_RW_MASK))\n\n                    goto do_fault_protect;\n\n            } else {\n\n                if ((env->cr[0] & CR0_WP_MASK) &&\n\n                    is_write && !(ptep & PG_RW_MASK)) \n\n                    goto do_fault_protect;\n\n            }\n\n            is_dirty = is_write && !(pte & PG_DIRTY_MASK);\n\n            if (!(pte & PG_ACCESSED_MASK) || is_dirty) {\n\n                pte |= PG_ACCESSED_MASK;\n\n                if (is_dirty)\n\n                    pte |= PG_DIRTY_MASK;\n\n                stl_phys_notdirty(pte_addr, pte);\n\n            }\n\n            page_size = 4096;\n\n            virt_addr = addr & ~0xfff;\n\n            pte = pte & (PHYS_ADDR_MASK | 0xfff);\n\n        }\n\n    } else {\n\n        uint32_t pde;\n\n\n\n        \/* page directory entry *\/\n\n        pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & ~3)) & \n\n            env->a20_mask;\n\n        pde = ldl_phys(pde_addr);\n\n        if (!(pde & PG_PRESENT_MASK)) {\n\n            error_code = 0;\n\n            goto do_fault;\n\n        }\n\n        \/* if PSE bit is set, then we use a 4MB page *\/\n\n        if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n            page_size = 4096 * 1024;\n\n            if (is_user) {\n\n                if (!(pde & PG_USER_MASK))\n\n                    goto do_fault_protect;\n\n                if (is_write && !(pde & PG_RW_MASK))\n\n                    goto do_fault_protect;\n\n            } else {\n\n                if ((env->cr[0] & CR0_WP_MASK) && \n\n                    is_write && !(pde & PG_RW_MASK)) \n\n                    goto do_fault_protect;\n\n            }\n\n            is_dirty = is_write && !(pde & PG_DIRTY_MASK);\n\n            if (!(pde & PG_ACCESSED_MASK) || is_dirty) {\n\n                pde |= PG_ACCESSED_MASK;\n\n                if (is_dirty)\n\n                    pde |= PG_DIRTY_MASK;\n\n                stl_phys_notdirty(pde_addr, pde);\n\n            }\n\n        \n\n            pte = pde & ~( (page_size - 1) & ~0xfff); \/* align to page_size *\/\n\n            ptep = pte;\n\n            virt_addr = addr & ~(page_size - 1);\n\n        } else {\n\n            if (!(pde & PG_ACCESSED_MASK)) {\n\n                pde |= PG_ACCESSED_MASK;\n\n                stl_phys_notdirty(pde_addr, pde);\n\n            }\n\n\n\n            \/* page directory entry *\/\n\n            pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & \n\n                env->a20_mask;\n\n            pte = ldl_phys(pte_addr);\n\n            if (!(pte & PG_PRESENT_MASK)) {\n\n                error_code = 0;\n\n                goto do_fault;\n\n            }\n\n            \/* combine pde and pte user and rw protections *\/\n\n            ptep = pte & pde;\n\n            if (is_user) {\n\n                if (!(ptep & PG_USER_MASK))\n\n                    goto do_fault_protect;\n\n                if (is_write && !(ptep & PG_RW_MASK))\n\n                    goto do_fault_protect;\n\n            } else {\n\n                if ((env->cr[0] & CR0_WP_MASK) &&\n\n                    is_write && !(ptep & PG_RW_MASK)) \n\n                    goto do_fault_protect;\n\n            }\n\n            is_dirty = is_write && !(pte & PG_DIRTY_MASK);\n\n            if (!(pte & PG_ACCESSED_MASK) || is_dirty) {\n\n                pte |= PG_ACCESSED_MASK;\n\n                if (is_dirty)\n\n                    pte |= PG_DIRTY_MASK;\n\n                stl_phys_notdirty(pte_addr, pte);\n\n            }\n\n            page_size = 4096;\n\n            virt_addr = addr & ~0xfff;\n\n        }\n\n    }\n\n    \/* the page can be put in the TLB *\/\n\n    prot = PAGE_READ;\n\n    if (!(ptep & PG_NX_MASK))\n\n        prot |= PAGE_EXEC;\n\n    if (pte & PG_DIRTY_MASK) {\n\n        \/* only set write access if already dirty... otherwise wait\n\n           for dirty access *\/\n\n        if (is_user) {\n\n            if (ptep & PG_RW_MASK)\n\n                prot |= PAGE_WRITE;\n\n        } else {\n\n            if (!(env->cr[0] & CR0_WP_MASK) ||\n\n                (ptep & PG_RW_MASK))\n\n                prot |= PAGE_WRITE;\n\n        }\n\n    }\n\n do_mapping:\n\n    pte = pte & env->a20_mask;\n\n\n\n    \/* Even if 4MB pages, we map only one 4KB page in the cache to\n\n       avoid filling it too fast *\/\n\n    page_offset = (addr & TARGET_PAGE_MASK) & (page_size - 1);\n\n    paddr = (pte & TARGET_PAGE_MASK) + page_offset;\n\n    vaddr = virt_addr + page_offset;\n\n    \n\n    ret = tlb_set_page_exec(env, vaddr, paddr, prot, is_user, is_softmmu);\n\n    return ret;\n\n do_fault_protect:\n\n    error_code = PG_ERROR_P_MASK;\n\n do_fault:\n\n    env->cr[2] = addr;\n\n    error_code |= (is_write << PG_ERROR_W_BIT);\n\n    if (is_user)\n\n        error_code |= PG_ERROR_U_MASK;\n\n    if (is_write1 == 2 && \n\n        (env->efer & MSR_EFER_NXE) && \n\n        (env->cr[4] & CR4_PAE_MASK))\n\n        error_code |= PG_ERROR_I_D_MASK;\n\n    env->error_code = error_code;\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"30fb2ca603e8b8d0f02630ef18bc0d0637a88ffa","target":1,"func":"static int qemu_balloon(ram_addr_t target, MonitorCompletion cb, void *opaque)\n\n{\n\n    if (!balloon_event_fn) {\n\n        return 0;\n\n    }\n\n    trace_balloon_event(balloon_opaque, target);\n\n    balloon_event_fn(balloon_opaque, target, cb, opaque);\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"b84c4586234b26ccc875595713f6f4491e5b3385","target":0,"func":"static void __attribute__((destructor)) coroutine_cleanup(void)\n\n{\n\n    Coroutine *co;\n\n    Coroutine *tmp;\n\n\n\n    QSLIST_FOREACH_SAFE(co, &pool, pool_next, tmp) {\n\n        QSLIST_REMOVE_HEAD(&pool, pool_next);\n\n        qemu_coroutine_delete(co);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"760794f784f66e262a9ca32821ba202cdf3a3e4b","target":1,"func":"static int chr_can_read(void *opaque)\n\n{\n\n    int can_read;\n\n    SCLPConsole *scon = opaque;\n\n\n\n    can_read = SIZE_BUFFER_VT220 - scon->iov_data_len;\n\n\n\n    return can_read;\n\n}\n"},{"project":"qemu","commit_id":"5d79b80b335c5f65f148d1bb1672d9d534ace73b","target":0,"func":"static void pflash_write(pflash_t *pfl, hwaddr offset,\n\n                         uint32_t value, int width, int be)\n\n{\n\n    uint8_t *p;\n\n    uint8_t cmd;\n\n\n\n    cmd = value;\n\n\n\n    DPRINTF(\"%s: writing offset \" TARGET_FMT_plx \" value %08x width %d wcycle 0x%x\\n\",\n\n            __func__, offset, value, width, pfl->wcycle);\n\n\n\n    if (!pfl->wcycle) {\n\n        \/* Set the device in I\/O access mode *\/\n\n        memory_region_rom_device_set_readable(&pfl->mem, false);\n\n    }\n\n\n\n    switch (pfl->wcycle) {\n\n    case 0:\n\n        \/* read mode *\/\n\n        switch (cmd) {\n\n        case 0x00: \/* ??? *\/\n\n            goto reset_flash;\n\n        case 0x10: \/* Single Byte Program *\/\n\n        case 0x40: \/* Single Byte Program *\/\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            break;\n\n        case 0x20: \/* Block erase *\/\n\n            p = pfl->storage;\n\n            offset &= ~(pfl->sector_len - 1);\n\n\n\n            DPRINTF(\"%s: block erase at \" TARGET_FMT_plx \" bytes %x\\n\",\n\n                    __func__, offset, (unsigned)pfl->sector_len);\n\n\n\n            if (!pfl->ro) {\n\n                memset(p + offset, 0xff, pfl->sector_len);\n\n                pflash_update(pfl, offset, pfl->sector_len);\n\n            } else {\n\n                pfl->status |= 0x20; \/* Block erase error *\/\n\n            }\n\n            pfl->status |= 0x80; \/* Ready! *\/\n\n            break;\n\n        case 0x50: \/* Clear status bits *\/\n\n            DPRINTF(\"%s: Clear status bits\\n\", __func__);\n\n            pfl->status = 0x0;\n\n            goto reset_flash;\n\n        case 0x60: \/* Block (un)lock *\/\n\n            DPRINTF(\"%s: Block unlock\\n\", __func__);\n\n            break;\n\n        case 0x70: \/* Status Register *\/\n\n            DPRINTF(\"%s: Read status register\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x90: \/* Read Device ID *\/\n\n            DPRINTF(\"%s: Read Device information\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x98: \/* CFI query *\/\n\n            DPRINTF(\"%s: CFI query\\n\", __func__);\n\n            break;\n\n        case 0xe8: \/* Write to buffer *\/\n\n            DPRINTF(\"%s: Write to buffer\\n\", __func__);\n\n            pfl->status |= 0x80; \/* Ready! *\/\n\n            break;\n\n        case 0xf0: \/* Probe for AMD flash *\/\n\n            DPRINTF(\"%s: Probe for AMD flash\\n\", __func__);\n\n            goto reset_flash;\n\n        case 0xff: \/* Read array mode *\/\n\n            DPRINTF(\"%s: Read array mode\\n\", __func__);\n\n            goto reset_flash;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        pfl->wcycle++;\n\n        pfl->cmd = cmd;\n\n        break;\n\n    case 1:\n\n        switch (pfl->cmd) {\n\n        case 0x10: \/* Single Byte Program *\/\n\n        case 0x40: \/* Single Byte Program *\/\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n                pflash_update(pfl, offset, width);\n\n            } else {\n\n                pfl->status |= 0x10; \/* Programming error *\/\n\n            }\n\n            pfl->status |= 0x80; \/* Ready! *\/\n\n            pfl->wcycle = 0;\n\n        break;\n\n        case 0x20: \/* Block erase *\/\n\n        case 0x28:\n\n            if (cmd == 0xd0) { \/* confirm *\/\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) { \/* read array mode *\/\n\n                goto reset_flash;\n\n            } else\n\n                goto error_flash;\n\n\n\n            break;\n\n        case 0xe8:\n\n            DPRINTF(\"%s: block write of %x bytes\\n\", __func__, value);\n\n            pfl->counter = value;\n\n            pfl->wcycle++;\n\n            break;\n\n        case 0x60:\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0x01) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: Unknown (un)locking command\\n\", __func__);\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        case 0x98:\n\n            if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: leaving query mode\\n\", __func__);\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 2:\n\n        switch (pfl->cmd) {\n\n        case 0xe8: \/* Block write *\/\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n            } else {\n\n                pfl->status |= 0x10; \/* Programming error *\/\n\n            }\n\n\n\n            pfl->status |= 0x80;\n\n\n\n            if (!pfl->counter) {\n\n                hwaddr mask = pfl->writeblock_size - 1;\n\n                mask = ~mask;\n\n\n\n                DPRINTF(\"%s: block write finished\\n\", __func__);\n\n                pfl->wcycle++;\n\n                if (!pfl->ro) {\n\n                    \/* Flush the entire write buffer onto backing storage.  *\/\n\n                    pflash_update(pfl, offset & mask, pfl->writeblock_size);\n\n                } else {\n\n                    pfl->status |= 0x10; \/* Programming error *\/\n\n                }\n\n            }\n\n\n\n            pfl->counter--;\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 3: \/* Confirm mode *\/\n\n        switch (pfl->cmd) {\n\n        case 0xe8: \/* Block write *\/\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else {\n\n                DPRINTF(\"%s: unknown command for \\\"write block\\\"\\n\", __func__);\n\n                PFLASH_BUG(\"Write block confirm\");\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    default:\n\n        \/* Should never happen *\/\n\n        DPRINTF(\"%s: invalid write state\\n\",  __func__);\n\n        goto reset_flash;\n\n    }\n\n    return;\n\n\n\n error_flash:\n\n    qemu_log_mask(LOG_UNIMP, \"%s: Unimplemented flash cmd sequence \"\n\n                  \"(offset \" TARGET_FMT_plx \", wcycle 0x%x cmd 0x%x value 0x%x)\"\n\n                  \"\\n\", __func__, offset, pfl->wcycle, pfl->cmd, value);\n\n\n\n reset_flash:\n\n    memory_region_rom_device_set_readable(&pfl->mem, true);\n\n\n\n    pfl->bypass = 0;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n}\n"},{"project":"qemu","commit_id":"cfaf6d36ae761da1033159d85d670706ffb24fb9","target":0,"func":"static void exec_accept_incoming_migration(void *opaque)\n\n{\n\n    QEMUFile *f = opaque;\n\n    int ret;\n\n\n\n    ret = qemu_loadvm_state(f);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"load of migration failed\\n\");\n\n        goto err;\n\n    }\n\n    qemu_announce_self();\n\n    DPRINTF(\"successfully loaded vm state\\n\");\n\n    \/* we've successfully migrated, close the fd *\/\n\n    qemu_set_fd_handler2(qemu_stdio_fd(f), NULL, NULL, NULL, NULL);\n\n    if (autostart)\n\n        vm_start();\n\n\n\nerr:\n\n    qemu_fclose(f);\n\n}\n"},{"project":"qemu","commit_id":"0193c62c94643a837832f2b5ccc133434ee740cb","target":0,"func":"static int xenfb_map_fb(struct XenFB *xenfb)\n\n{\n\n    struct xenfb_page *page = xenfb->c.page;\n\n    char *protocol = xenfb->c.xendev.protocol;\n\n    int n_fbdirs;\n\n    unsigned long *pgmfns = NULL;\n\n    unsigned long *fbmfns = NULL;\n\n    void *map, *pd;\n\n    int mode, ret = -1;\n\n\n\n    \/* default to native *\/\n\n    pd = page->pd;\n\n    mode = sizeof(unsigned long) * 8;\n\n\n\n    if (!protocol) {\n\n\t\/*\n\n\t * Undefined protocol, some guesswork needed.\n\n\t *\n\n\t * Old frontends which don't set the protocol use\n\n\t * one page directory only, thus pd[1] must be zero.\n\n\t * pd[1] of the 32bit struct layout and the lower\n\n\t * 32 bits of pd[0] of the 64bit struct layout have\n\n\t * the same location, so we can check that ...\n\n\t *\/\n\n\tuint32_t *ptr32 = NULL;\n\n\tuint32_t *ptr64 = NULL;\n\n#if defined(__i386__)\n\n\tptr32 = (void*)page->pd;\n\n\tptr64 = ((void*)page->pd) + 4;\n\n#elif defined(__x86_64__)\n\n\tptr32 = ((void*)page->pd) - 4;\n\n\tptr64 = (void*)page->pd;\n\n#endif\n\n\tif (ptr32) {\n\n\t    if (ptr32[1] == 0) {\n\n\t\tmode = 32;\n\n\t\tpd   = ptr32;\n\n\t    } else {\n\n\t\tmode = 64;\n\n\t\tpd   = ptr64;\n\n\t    }\n\n\t}\n\n#if defined(__x86_64__)\n\n    } else if (strcmp(protocol, XEN_IO_PROTO_ABI_X86_32) == 0) {\n\n\t\/* 64bit dom0, 32bit domU *\/\n\n\tmode = 32;\n\n\tpd   = ((void*)page->pd) - 4;\n\n#elif defined(__i386__)\n\n    } else if (strcmp(protocol, XEN_IO_PROTO_ABI_X86_64) == 0) {\n\n\t\/* 32bit dom0, 64bit domU *\/\n\n\tmode = 64;\n\n\tpd   = ((void*)page->pd) + 4;\n\n#endif\n\n    }\n\n\n\n    if (xenfb->pixels) {\n\n        munmap(xenfb->pixels, xenfb->fbpages * XC_PAGE_SIZE);\n\n        xenfb->pixels = NULL;\n\n    }\n\n\n\n    xenfb->fbpages = (xenfb->fb_len + (XC_PAGE_SIZE - 1)) \/ XC_PAGE_SIZE;\n\n    n_fbdirs = xenfb->fbpages * mode \/ 8;\n\n    n_fbdirs = (n_fbdirs + (XC_PAGE_SIZE - 1)) \/ XC_PAGE_SIZE;\n\n\n\n    pgmfns = g_malloc0(sizeof(unsigned long) * n_fbdirs);\n\n    fbmfns = g_malloc0(sizeof(unsigned long) * xenfb->fbpages);\n\n\n\n    xenfb_copy_mfns(mode, n_fbdirs, pgmfns, pd);\n\n    map = xc_map_foreign_pages(xen_xc, xenfb->c.xendev.dom,\n\n\t\t\t       PROT_READ, pgmfns, n_fbdirs);\n\n    if (map == NULL)\n\n\tgoto out;\n\n    xenfb_copy_mfns(mode, xenfb->fbpages, fbmfns, map);\n\n    munmap(map, n_fbdirs * XC_PAGE_SIZE);\n\n\n\n    xenfb->pixels = xc_map_foreign_pages(xen_xc, xenfb->c.xendev.dom,\n\n\t\t\t\t\t PROT_READ | PROT_WRITE, fbmfns, xenfb->fbpages);\n\n    if (xenfb->pixels == NULL)\n\n\tgoto out;\n\n\n\n    ret = 0; \/* all is fine *\/\n\n\n\nout:\n\n    g_free(pgmfns);\n\n    g_free(fbmfns);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"08a2d4c4ffde60e48819449f461274c43ad6e2d3","target":0,"func":"static void sdl_mouse_warp(int x, int y, int on)\n\n{\n\n    if (on) {\n\n        if (!guest_cursor)\n\n            sdl_show_cursor();\n\n        if (gui_grab || kbd_mouse_is_absolute() || absolute_enabled) {\n\n            SDL_SetCursor(guest_sprite);\n\n            SDL_WarpMouse(x, y);\n\n        }\n\n    } else if (gui_grab)\n\n        sdl_hide_cursor();\n\n    guest_cursor = on;\n\n    guest_x = x, guest_y = y;\n\n}\n"},{"project":"qemu","commit_id":"81174dae3f9189519cd60c7b79e91c291b021bbe","target":1,"func":"static int tty_serial_ioctl(CharDriverState *chr, int cmd, void *arg)\n\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    switch(cmd) {\n\n    case CHR_IOCTL_SERIAL_SET_PARAMS:\n\n\n            QEMUSerialSetParams *ssp = arg;\n\n            tty_serial_init(s->fd_in, ssp->speed, ssp->parity,\n\n                            ssp->data_bits, ssp->stop_bits);\n\n\n\n    case CHR_IOCTL_SERIAL_SET_BREAK:\n\n\n            int enable = *(int *)arg;\n\n            if (enable)\n\n                tcsendbreak(s->fd_in, 1);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    default:\n\n        return -ENOTSUP;\n\n\n    return 0;\n"},{"project":"qemu","commit_id":"d9bce9d99f4656ae0b0127f7472db9067b8f84ab","target":1,"func":"void do_adde (void)\n\n{\n\n    T2 = T0;\n\n    T0 += T1 + xer_ca;\n\n    if (likely(!(T0 < T2 || (xer_ca == 1 && T0 == T2)))) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"bf8d492405feaee2c1685b3b9d5e03228ed3e47f","target":1,"func":"static void pxb_host_class_init(ObjectClass *class, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(class);\n\n    SysBusDeviceClass *sbc = SYS_BUS_DEVICE_CLASS(class);\n\n    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(class);\n\n\n\n    dc->fw_name = \"pci\";\n\n\n\n    sbc->explicit_ofw_unit_address = pxb_host_ofw_unit_address;\n\n    hc->root_bus_path = pxb_host_root_bus_path;\n\n}"},{"project":"qemu","commit_id":"72cf2d4f0e181d0d3a3122e04129c58a95da713e","target":0,"func":"static void rndis_clear_responsequeue(USBNetState *s)\n\n{\n\n    struct rndis_response *r;\n\n\n\n    while ((r = s->rndis_resp.tqh_first)) {\n\n        TAILQ_REMOVE(&s->rndis_resp, r, entries);\n\n        qemu_free(r);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"e4f4fb1eca795e36f363b4647724221e774523c1","target":1,"func":"static void unimp_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = unimp_realize;\n\n    dc->props = unimp_properties;\n\n\n\n\n\n\n}"},{"project":"qemu","commit_id":"621ff94d5074d88253a5818c6b9c4db718fbfc65","target":0,"func":"static int qcow2_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    char *backing_file = NULL;\n\n    char *backing_fmt = NULL;\n\n    char *buf = NULL;\n\n    uint64_t size = 0;\n\n    int flags = 0;\n\n    size_t cluster_size = DEFAULT_CLUSTER_SIZE;\n\n    PreallocMode prealloc;\n\n    int version = 3;\n\n    uint64_t refcount_bits = 16;\n\n    int refcount_order;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    \/* Read out options *\/\n\n    size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),\n\n                    BDRV_SECTOR_SIZE);\n\n    backing_file = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n    backing_fmt = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FMT);\n\n    if (qemu_opt_get_bool_del(opts, BLOCK_OPT_ENCRYPT, false)) {\n\n        flags |= BLOCK_FLAG_ENCRYPT;\n\n    }\n\n    cluster_size = qemu_opt_get_size_del(opts, BLOCK_OPT_CLUSTER_SIZE,\n\n                                         DEFAULT_CLUSTER_SIZE);\n\n    buf = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);\n\n    prealloc = qapi_enum_parse(PreallocMode_lookup, buf,\n\n                               PREALLOC_MODE__MAX, PREALLOC_MODE_OFF,\n\n                               &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n    g_free(buf);\n\n    buf = qemu_opt_get_del(opts, BLOCK_OPT_COMPAT_LEVEL);\n\n    if (!buf) {\n\n        \/* keep the default *\/\n\n    } else if (!strcmp(buf, \"0.10\")) {\n\n        version = 2;\n\n    } else if (!strcmp(buf, \"1.1\")) {\n\n        version = 3;\n\n    } else {\n\n        error_setg(errp, \"Invalid compatibility level: '%s'\", buf);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (qemu_opt_get_bool_del(opts, BLOCK_OPT_LAZY_REFCOUNTS, false)) {\n\n        flags |= BLOCK_FLAG_LAZY_REFCOUNTS;\n\n    }\n\n\n\n    if (backing_file && prealloc != PREALLOC_MODE_OFF) {\n\n        error_setg(errp, \"Backing file and preallocation cannot be used at \"\n\n                   \"the same time\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (version < 3 && (flags & BLOCK_FLAG_LAZY_REFCOUNTS)) {\n\n        error_setg(errp, \"Lazy refcounts only supported with compatibility \"\n\n                   \"level 1.1 and above (use compat=1.1 or greater)\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    refcount_bits = qemu_opt_get_number_del(opts, BLOCK_OPT_REFCOUNT_BITS,\n\n                                            refcount_bits);\n\n    if (refcount_bits > 64 || !is_power_of_2(refcount_bits)) {\n\n        error_setg(errp, \"Refcount width must be a power of two and may not \"\n\n                   \"exceed 64 bits\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (version < 3 && refcount_bits != 16) {\n\n        error_setg(errp, \"Different refcount widths than 16 bits require \"\n\n                   \"compatibility level 1.1 or above (use compat=1.1 or \"\n\n                   \"greater)\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    refcount_order = ctz32(refcount_bits);\n\n\n\n    ret = qcow2_create2(filename, size, backing_file, backing_fmt, flags,\n\n                        cluster_size, prealloc, opts, version, refcount_order,\n\n                        &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n\n\nfinish:\n\n    g_free(backing_file);\n\n    g_free(backing_fmt);\n\n    g_free(buf);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"b2899495e3bd467adb9ef195655407cd58a97ded","target":0,"func":"POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER9\";\n\n    dc->desc = \"POWER9\";\n\n    dc->props = powerpc_servercpu_properties;\n\n    pcc->pvr_match = ppc_pvr_match_power9;\n\n    pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07;\n\n    pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 |\n\n                         PCR_COMPAT_2_05;\n\n    pcc->init_proc = init_proc_POWER9;\n\n    pcc->check_pow = check_pow_nocheck;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_FRSQRTES |\n\n                       PPC_FLOAT_STFIWX |\n\n                       PPC_FLOAT_EXT |\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_64BX | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD |\n\n                       PPC_CILDST;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |\n\n                        PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |\n\n                        PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |\n\n                        PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |\n\n                        PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;\n\n    pcc->msr_mask = (1ull << MSR_SF) |\n\n                    (1ull << MSR_TM) |\n\n                    (1ull << MSR_VR) |\n\n                    (1ull << MSR_VSX) |\n\n                    (1ull << MSR_EE) |\n\n                    (1ull << MSR_PR) |\n\n                    (1ull << MSR_FP) |\n\n                    (1ull << MSR_ME) |\n\n                    (1ull << MSR_FE0) |\n\n                    (1ull << MSR_SE) |\n\n                    (1ull << MSR_DE) |\n\n                    (1ull << MSR_FE1) |\n\n                    (1ull << MSR_IR) |\n\n                    (1ull << MSR_DR) |\n\n                    (1ull << MSR_PMM) |\n\n                    (1ull << MSR_RI) |\n\n                    (1ull << MSR_LE);\n\n    pcc->mmu_model = POWERPC_MMU_3_00;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc_hash64_handle_mmu_fault;\n\n    \/* segment page size remain the same *\/\n\n    pcc->sps = &POWER7_POWER8_sps;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER8;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX | POWERPC_FLAG_TM;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr;\n\n}\n"},{"project":"qemu","commit_id":"5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b","target":0,"func":"static void vnc_write_s32(VncState *vs, int32_t value)\n\n{\n\n    vnc_write_u32(vs, *(uint32_t *)&value);\n\n}\n"},{"project":"qemu","commit_id":"d33271213437ed1834b0a50540d79e877e1cd894","target":0,"func":"uint32_t HELPER(mvcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,\n\n                       uint32_t r3)\n\n{\n\n    uintptr_t ra = GETPC();\n\n    uint64_t destlen = get_length(env, r1 + 1);\n\n    uint64_t dest = get_address(env, r1);\n\n    uint64_t srclen = get_length(env, r3 + 1);\n\n    uint64_t src = get_address(env, r3);\n\n    uint8_t pad = a2 & 0xff;\n\n    uint8_t v;\n\n    uint32_t cc;\n\n\n\n    if (destlen == srclen) {\n\n        cc = 0;\n\n    } else if (destlen < srclen) {\n\n        cc = 1;\n\n    } else {\n\n        cc = 2;\n\n    }\n\n\n\n    if (srclen > destlen) {\n\n        srclen = destlen;\n\n    }\n\n\n\n    for (; destlen && srclen; src++, dest++, destlen--, srclen--) {\n\n        v = cpu_ldub_data_ra(env, src, ra);\n\n        cpu_stb_data_ra(env, dest, v, ra);\n\n    }\n\n\n\n    for (; destlen; dest++, destlen--) {\n\n        cpu_stb_data_ra(env, dest, pad, ra);\n\n    }\n\n\n\n    set_length(env, r1 + 1 , destlen);\n\n    \/* can't use srclen here, we trunc'ed it *\/\n\n    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);\n\n    set_address(env, r1, dest);\n\n    set_address(env, r3, src);\n\n\n\n    return cc;\n\n}\n"},{"project":"qemu","commit_id":"4a41a2d68a684241aca96dba066e0699941b730d","target":1,"func":"void nbd_client_session_close(NbdClientSession *client)\n\n{\n\n    if (!client->bs) {\n\n        return;\n\n    }\n\n\n\n    nbd_teardown_connection(client);\n\n    client->bs = NULL;\n\n}\n"},{"project":"qemu","commit_id":"5a3165263ae6782a7fe712a0a0c29c17468b9b68","target":0,"func":"static void check_watchpoint(int offset, int len_mask, int flags)\n\n{\n\n    CPUArchState *env = cpu_single_env;\n\n    target_ulong pc, cs_base;\n\n    TranslationBlock *tb;\n\n    target_ulong vaddr;\n\n    CPUWatchpoint *wp;\n\n    int cpu_flags;\n\n\n\n    if (env->watchpoint_hit) {\n\n        \/* We re-entered the check after replacing the TB. Now raise\n\n         * the debug interrupt so that is will trigger after the\n\n         * current instruction. *\/\n\n        cpu_interrupt(env, CPU_INTERRUPT_DEBUG);\n\n        return;\n\n    }\n\n    vaddr = (env->mem_io_vaddr & TARGET_PAGE_MASK) + offset;\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if ((vaddr == (wp->vaddr & len_mask) ||\n\n             (vaddr & wp->len_mask) == wp->vaddr) && (wp->flags & flags)) {\n\n            wp->flags |= BP_WATCHPOINT_HIT;\n\n            if (!env->watchpoint_hit) {\n\n                env->watchpoint_hit = wp;\n\n                tb = tb_find_pc(env->mem_io_pc);\n\n                if (!tb) {\n\n                    cpu_abort(env, \"check_watchpoint: could not find TB for \"\n\n                              \"pc=%p\", (void *)env->mem_io_pc);\n\n                }\n\n                cpu_restore_state(tb, env, env->mem_io_pc);\n\n                tb_phys_invalidate(tb, -1);\n\n                if (wp->flags & BP_STOP_BEFORE_ACCESS) {\n\n                    env->exception_index = EXCP_DEBUG;\n\n                    cpu_loop_exit(env);\n\n                } else {\n\n                    cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);\n\n                    tb_gen_code(env, pc, cs_base, cpu_flags, 1);\n\n                    cpu_resume_from_signal(env, NULL);\n\n                }\n\n            }\n\n        } else {\n\n            wp->flags &= ~BP_WATCHPOINT_HIT;\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae","target":0,"func":"static void test_validate_union_anon(TestInputVisitorData *data,\n\n                                     const void *unused)\n\n{\n\n    UserDefAnonUnion *tmp = NULL;\n\n    Visitor *v;\n\n    Error *errp = NULL;\n\n\n\n    v = validate_test_init(data, \"42\");\n\n\n\n    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);\n\n    g_assert(!error_is_set(&errp));\n\n    qapi_free_UserDefAnonUnion(tmp);\n\n}\n"},{"project":"qemu","commit_id":"3e831b40e015ba34dfb55ff11f767001839425ff","target":1,"func":"pvscsi_on_cmd_setup_msg_ring(PVSCSIState *s)\n\n{\n\n    PVSCSICmdDescSetupMsgRing *rc =\n\n        (PVSCSICmdDescSetupMsgRing *) s->curr_cmd_data;\n\n\n\n    trace_pvscsi_on_cmd_arrived(\"PVSCSI_CMD_SETUP_MSG_RING\");\n\n\n\n    if (!s->use_msg) {\n\n        return PVSCSI_COMMAND_PROCESSING_FAILED;\n\n    }\n\n\n\n    if (s->rings_info_valid) {\n\n        pvscsi_ring_init_msg(&s->rings, rc);\n\n        s->msg_ring_info_valid = TRUE;\n\n    }\n\n    return sizeof(PVSCSICmdDescSetupMsgRing) \/ sizeof(uint32_t);\n\n}\n"},{"project":"qemu","commit_id":"5c3234c6c037943bd4c2d643a1b8cc35f563dbdb","target":1,"func":"static void submit_pdu(V9fsState *s, V9fsPDU *pdu)\n\n{\n\n    pdu_handler_t *handler;\n\n\n\n    if (debug_9p_pdu) {\n\n        pprint_pdu(pdu);\n\n    }\n\n\n\n    BUG_ON(pdu->id >= ARRAY_SIZE(pdu_handlers));\n\n\n\n    handler = pdu_handlers[pdu->id];\n\n    BUG_ON(handler == NULL);\n\n\n\n    handler(s, pdu);\n\n}\n"},{"project":"qemu","commit_id":"cb51ac2ffe3649eb8f5c65dccc2012f0ba2c6b12","target":0,"func":"void virt_acpi_build(VirtMachineState *vms, AcpiBuildTables *tables)\n\n{\n\n    VirtMachineClass *vmc = VIRT_MACHINE_GET_CLASS(vms);\n\n    GArray *table_offsets;\n\n    unsigned dsdt, rsdt;\n\n    GArray *tables_blob = tables->table_data;\n\n\n\n    table_offsets = g_array_new(false, true \/* clear *\/,\n\n                                        sizeof(uint32_t));\n\n\n\n    bios_linker_loader_alloc(tables->linker,\n\n                             ACPI_BUILD_TABLE_FILE, tables_blob,\n\n                             64, false \/* high memory *\/);\n\n\n\n    \/* DSDT is pointed to by FADT *\/\n\n    dsdt = tables_blob->len;\n\n    build_dsdt(tables_blob, tables->linker, vms);\n\n\n\n    \/* FADT MADT GTDT MCFG SPCR pointed to by RSDT *\/\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_fadt(tables_blob, tables->linker, vms, dsdt);\n\n\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_madt(tables_blob, tables->linker, vms);\n\n\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_gtdt(tables_blob, tables->linker, vms);\n\n\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_mcfg(tables_blob, tables->linker, vms);\n\n\n\n    acpi_add_table(table_offsets, tables_blob);\n\n    build_spcr(tables_blob, tables->linker, vms);\n\n\n\n    if (nb_numa_nodes > 0) {\n\n        acpi_add_table(table_offsets, tables_blob);\n\n        build_srat(tables_blob, tables->linker, vms);\n\n    }\n\n\n\n    if (its_class_name() && !vmc->no_its) {\n\n        acpi_add_table(table_offsets, tables_blob);\n\n        build_iort(tables_blob, tables->linker);\n\n    }\n\n\n\n    \/* RSDT is pointed to by RSDP *\/\n\n    rsdt = tables_blob->len;\n\n    build_rsdt(tables_blob, tables->linker, table_offsets, NULL, NULL);\n\n\n\n    \/* RSDP is in FSEG memory, so allocate it separately *\/\n\n    build_rsdp(tables->rsdp, tables->linker, rsdt);\n\n\n\n    \/* Cleanup memory that's no longer used. *\/\n\n    g_array_free(table_offsets, true);\n\n}\n"},{"project":"qemu","commit_id":"c87b1520726f7ae1e698a41f07043d1b539ac88c","target":0,"func":"static void pc_init1(MachineState *machine,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    PCMachineState *pc_machine = PC_MACHINE(machine);\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *system_io = get_system_io();\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *gsi;\n\n    qemu_irq *i8259;\n\n    qemu_irq *smi_irq;\n\n    GSIState *gsi_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n    ISADevice *floppy;\n\n    MemoryRegion *ram_memory;\n\n    MemoryRegion *pci_memory;\n\n    MemoryRegion *rom_memory;\n\n    DeviceState *icc_bridge;\n\n    FWCfgState *fw_cfg = NULL;\n\n    PcGuestInfo *guest_info;\n\n\n\n    \/* Check whether RAM fits below 4G (leaving 1\/2 GByte for IO memory).\n\n     * If it doesn't, we need to split it in chunks below and above 4G.\n\n     * In any case, try to make sure that guest addresses aligned at\n\n     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.\n\n     * For old machine types, use whatever split we used historically to avoid\n\n     * breaking migration.\n\n     *\/\n\n    if (machine->ram_size >= 0xe0000000) {\n\n        ram_addr_t lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000;\n\n        above_4g_mem_size = machine->ram_size - lowmem;\n\n        below_4g_mem_size = lowmem;\n\n    } else {\n\n        above_4g_mem_size = 0;\n\n        below_4g_mem_size = machine->ram_size;\n\n    }\n\n\n\n    if (xen_enabled() && xen_hvm_init(&below_4g_mem_size, &above_4g_mem_size,\n\n                                      &ram_memory) != 0) {\n\n        fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);\n\n    object_property_add_child(qdev_get_machine(), \"icc-bridge\",\n\n                              OBJECT(icc_bridge), NULL);\n\n\n\n    pc_cpus_init(machine->cpu_model, icc_bridge);\n\n\n\n    if (kvm_enabled() && kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_memory = g_new(MemoryRegion, 1);\n\n        memory_region_init(pci_memory, NULL, \"pci\", UINT64_MAX);\n\n        rom_memory = pci_memory;\n\n    } else {\n\n        pci_memory = NULL;\n\n        rom_memory = system_memory;\n\n    }\n\n\n\n    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);\n\n\n\n    guest_info->has_acpi_build = has_acpi_build;\n\n\n\n    guest_info->has_pci_info = has_pci_info;\n\n    guest_info->isapc_ram_fw = !pci_enabled;\n\n    guest_info->has_reserved_memory = has_reserved_memory;\n\n\n\n    if (smbios_defaults) {\n\n        MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n        \/* These values are guest ABI, do not change *\/\n\n        smbios_set_defaults(\"QEMU\", \"Standard PC (i440FX + PIIX, 1996)\",\n\n                            mc->name, smbios_legacy_mode);\n\n    }\n\n\n\n    \/* allocate ram and load rom\/bios *\/\n\n    if (!xen_enabled()) {\n\n        fw_cfg = pc_memory_init(machine, system_memory,\n\n                                below_4g_mem_size, above_4g_mem_size,\n\n                                rom_memory, &ram_memory, guest_info);\n\n    }\n\n\n\n    gsi_state = g_malloc0(sizeof(*gsi_state));\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_pc_setup_irq_routing(pci_enabled);\n\n        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,\n\n                                 GSI_NUM_PINS);\n\n    } else {\n\n        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi,\n\n                              system_memory, system_io, machine->ram_size,\n\n                              below_4g_mem_size,\n\n                              above_4g_mem_size,\n\n                              pci_memory, ram_memory);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus = isa_bus_new(NULL, system_io);\n\n        no_hpet = 1;\n\n    }\n\n    isa_bus_irqs(isa_bus, gsi);\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        i8259 = kvm_i8259_init(isa_bus);\n\n    } else if (xen_enabled()) {\n\n        i8259 = xen_interrupt_controller_init();\n\n    } else {\n\n        cpu_irq = pc_allocate_cpu_irq();\n\n        i8259 = i8259_init(isa_bus, cpu_irq[0]);\n\n    }\n\n\n\n    for (i = 0; i < ISA_NUM_IRQS; i++) {\n\n        gsi_state->i8259_irq[i] = i8259[i];\n\n    }\n\n    if (pci_enabled) {\n\n        ioapic_init_gsi(gsi_state, \"i440fx\");\n\n    }\n\n    qdev_init_nofail(icc_bridge);\n\n\n\n    pc_register_ferr_irq(gsi[13]);\n\n\n\n    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);\n\n\n\n    \/* init basic PC hardware *\/\n\n    pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled(),\n\n        0x4);\n\n\n\n    pc_nic_init(isa_bus, pci_bus);\n\n\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        if (xen_enabled()) {\n\n            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        } else {\n\n            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        }\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            char busname[] = \"ide.0\";\n\n            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],\n\n                               ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            \/*\n\n             * The ide bus name is ide.0 for the first bus and ide.1 for the\n\n             * second one.\n\n             *\/\n\n            busname[4] = '0' + i;\n\n            idebus[i] = qdev_get_child_bus(DEVICE(dev), busname);\n\n        }\n\n    }\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, machine->boot_order,\n\n                 floppy, idebus[0], idebus[1], rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled(false)) {\n\n        pci_create_simple(pci_bus, piix3_devfn + 2, \"piix3-usb-uhci\");\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        DeviceState *piix4_pm;\n\n        I2CBus *smbus;\n\n\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        \/* TODO: Populate SPD eeprom data.  *\/\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              gsi[9], *smi_irq,\n\n                              kvm_enabled(), fw_cfg, &piix4_pm);\n\n        smbus_eeprom_init(smbus, 8, NULL, 0);\n\n\n\n        object_property_add_link(OBJECT(machine), PC_MACHINE_ACPI_DEVICE_PROP,\n\n                                 TYPE_HOTPLUG_HANDLER,\n\n                                 (Object **)&pc_machine->acpi_dev,\n\n                                 object_property_allow_set_link,\n\n                                 OBJ_PROP_LINK_UNREF_ON_RELEASE, &error_abort);\n\n        object_property_set_link(OBJECT(machine), OBJECT(piix4_pm),\n\n                                 PC_MACHINE_ACPI_DEVICE_PROP, &error_abort);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"db0289b9b26cb653d5662f5d6a2a52d70243cd56","target":1,"func":"static bool bdrv_drain_recurse(BlockDriverState *bs, bool begin)\n\n{\n\n    BdrvChild *child, *tmp;\n\n    bool waited;\n\n\n\n    \/* Ensure any pending metadata writes are submitted to bs->file.  *\/\n\n    bdrv_drain_invoke(bs, begin);\n\n\n\n    \/* Wait for drained requests to finish *\/\n\n    waited = BDRV_POLL_WHILE(bs, atomic_read(&bs->in_flight) > 0);\n\n\n\n    QLIST_FOREACH_SAFE(child, &bs->children, next, tmp) {\n\n        BlockDriverState *bs = child->bs;\n\n        bool in_main_loop =\n\n            qemu_get_current_aio_context() == qemu_get_aio_context();\n\n        assert(bs->refcnt > 0);\n\n        if (in_main_loop) {\n\n            \/* In case the recursive bdrv_drain_recurse processes a\n\n             * block_job_defer_to_main_loop BH and modifies the graph,\n\n             * let's hold a reference to bs until we are done.\n\n             *\n\n             * IOThread doesn't have such a BH, and it is not safe to call\n\n             * bdrv_unref without BQL, so skip doing it there.\n\n             *\/\n\n            bdrv_ref(bs);\n\n        }\n\n        waited |= bdrv_drain_recurse(bs, begin);\n\n        if (in_main_loop) {\n\n            bdrv_unref(bs);\n\n        }\n\n    }\n\n\n\n    return waited;\n\n}\n"},{"project":"qemu","commit_id":"f68945d42bab700d95b87f62e0898606ce2421ed","target":1,"func":"int qemu_savevm_state_iterate(QEMUFile *f)\n\n{\n\n    SaveStateEntry *se;\n\n    int ret = 1;\n\n\n\n    trace_savevm_state_iterate();\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n        if (!se->ops || !se->ops->save_live_iterate) {\n\n            continue;\n\n        }\n\n        if (se->ops && se->ops->is_active) {\n\n            if (!se->ops->is_active(se->opaque)) {\n\n                continue;\n\n            }\n\n        }\n\n        if (qemu_file_rate_limit(f)) {\n\n            return 0;\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_PART);\n\n\n\n        ret = se->ops->save_live_iterate(f, se->opaque);\n\n        trace_savevm_section_end(se->idstr, se->section_id, ret);\n\n\n\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n        }\n\n        if (ret <= 0) {\n\n            \/* Do not proceed to the next vmstate before this one reported\n\n               completion of the current stage. This serializes the migration\n\n               and reduces the probability that a faster changing state is\n\n               synchronized over and over again. *\/\n\n            break;\n\n        }\n\n    }\n\n    return ret;\n\n}"},{"project":"qemu","commit_id":"449041d4db1f82f281fe097e832f07cd9ee1e864","target":1,"func":"static int parse_uint32(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint32_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    \/* accept both hex and decimal *\/\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx32 : \"%\" PRIu32;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"80168bff43760bde98388480dc7c93f94693421c","target":1,"func":"int bdrv_create(BlockDriver *drv, const char* filename,\n\n    QEMUOptionParameter *options)\n\n{\n\n    int ret;\n\n\n\n    Coroutine *co;\n\n    CreateCo cco = {\n\n        .drv = drv,\n\n        .filename = g_strdup(filename),\n\n        .options = options,\n\n        .ret = NOT_DONE,\n\n    };\n\n\n\n    if (!drv->bdrv_create) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (qemu_in_coroutine()) {\n\n        \/* Fast-path if already in coroutine context *\/\n\n        bdrv_create_co_entry(&cco);\n\n    } else {\n\n        co = qemu_coroutine_create(bdrv_create_co_entry);\n\n        qemu_coroutine_enter(co, &cco);\n\n        while (cco.ret == NOT_DONE) {\n\n            qemu_aio_wait();\n\n        }\n\n    }\n\n\n\n    ret = cco.ret;\n\n    g_free(cco.filename);\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"15c2f669e3fb2bc97f7b42d1871f595c0ac24af8","target":1,"func":"opts_end_struct(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    GHashTableIter iter;\n\n    GQueue *any;\n\n\n\n    if (--ov->depth > 0) {\n\n        return;\n\n    }\n\n\n\n    \/* we should have processed all (distinct) QemuOpt instances *\/\n\n    g_hash_table_iter_init(&iter, ov->unprocessed_opts);\n\n    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {\n\n        const QemuOpt *first;\n\n\n\n        first = g_queue_peek_head(any);\n\n        error_setg(errp, QERR_INVALID_PARAMETER, first->name);\n\n    }\n\n    g_hash_table_destroy(ov->unprocessed_opts);\n\n    ov->unprocessed_opts = NULL;\n\n    if (ov->fake_id_opt) {\n\n        g_free(ov->fake_id_opt->name);\n\n        g_free(ov->fake_id_opt->str);\n\n        g_free(ov->fake_id_opt);\n\n    }\n\n    ov->fake_id_opt = NULL;\n\n}\n"},{"project":"qemu","commit_id":"c2fa30757a2ba1bb5b053883773a9a61fbdd7082","target":0,"func":"static void nvdimm_dsm_root(NvdimmDsmIn *in, hwaddr dsm_mem_addr)\n\n{\n\n    \/*\n\n     * function 0 is called to inquire which functions are supported by\n\n     * OSPM\n\n     *\/\n\n    if (!in->function) {\n\n        nvdimm_dsm_function0(0 \/* No function supported other than\n\n                                  function 0 *\/, dsm_mem_addr);\n\n        return;\n\n    }\n\n\n\n    \/* No function except function 0 is supported yet. *\/\n\n    nvdimm_dsm_no_payload(1 \/* Not Supported *\/, dsm_mem_addr);\n\n}\n"},{"project":"qemu","commit_id":"88be7b4be4aa17c88247e162bdd7577ea79db94f","target":1,"func":"static void vm_completion(ReadLineState *rs, const char *str)\n\n{\n\n    size_t len;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    len = strlen(str);\n\n    readline_set_completion_index(rs, len);\n\n\n\n    while ((it = bdrv_next(it, &bs))) {\n\n        SnapshotInfoList *snapshots, *snapshot;\n\n        AioContext *ctx = bdrv_get_aio_context(bs);\n\n        bool ok = false;\n\n\n\n        aio_context_acquire(ctx);\n\n        if (bdrv_can_snapshot(bs)) {\n\n            ok = bdrv_query_snapshot_info_list(bs, &snapshots, NULL) == 0;\n\n        }\n\n        aio_context_release(ctx);\n\n        if (!ok) {\n\n            continue;\n\n        }\n\n\n\n        snapshot = snapshots;\n\n        while (snapshot) {\n\n            char *completion = snapshot->value->name;\n\n            if (!strncmp(str, completion, len)) {\n\n                readline_add_completion(rs, completion);\n\n            }\n\n            completion = snapshot->value->id;\n\n            if (!strncmp(str, completion, len)) {\n\n                readline_add_completion(rs, completion);\n\n            }\n\n            snapshot = snapshot->next;\n\n        }\n\n        qapi_free_SnapshotInfoList(snapshots);\n\n    }\n\n\n\n}\n"},{"project":"qemu","commit_id":"59800ec8e52bcfa271fa61fb0aae19205ef1b7f1","target":0,"func":"uint64_t helper_fnmsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2,\n\n                       uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                 (float64_is_zero(farg1.d) &&\n\n                  float64_is_infinity(farg2.d)))) {\n\n        \/* Multiplication of zero by infinity *\/\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d) ||\n\n                     float64_is_signaling_nan(farg3.d))) {\n\n            \/* sNaN operation *\/\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        \/* This is the way the PowerPC specification defines it *\/\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) &&\n\n                     float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {\n\n            \/* Magnitude subtraction of infinities *\/\n\n            farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n        if (likely(!float64_is_any_nan(farg1.d))) {\n\n            farg1.d = float64_chs(farg1.d);\n\n        }\n\n    }\n\n    return farg1.ll;\n\n}\n"},{"project":"qemu","commit_id":"ebca2df783a5a742bb93784524336d8cbb9e662b","target":1,"func":"void tpm_backend_cancel_cmd(TPMBackend *s)\n\n{\n\n    TPMBackendClass *k = TPM_BACKEND_GET_CLASS(s);\n\n\n\n    assert(k->cancel_cmd);\n\n\n\n    k->cancel_cmd(s);\n\n}\n"},{"project":"qemu","commit_id":"0b8b8753e4d94901627b3e86431230f2319215c4","target":1,"func":"static int qcow2_write(BlockDriverState *bs, int64_t sector_num,\n\n                       const uint8_t *buf, int nb_sectors)\n\n{\n\n    Coroutine *co;\n\n    AioContext *aio_context = bdrv_get_aio_context(bs);\n\n    Qcow2WriteCo data = {\n\n        .bs         = bs,\n\n        .sector_num = sector_num,\n\n        .buf        = buf,\n\n        .nb_sectors = nb_sectors,\n\n        .ret        = -EINPROGRESS,\n\n    };\n\n    co = qemu_coroutine_create(qcow2_write_co_entry);\n\n    qemu_coroutine_enter(co, &data);\n\n    while (data.ret == -EINPROGRESS) {\n\n        aio_poll(aio_context, true);\n\n    }\n\n    return data.ret;\n\n}\n"},{"project":"qemu","commit_id":"f8ed85ac992c48814d916d5df4d44f9a971c5de4","target":1,"func":"static int prom_init1(SysBusDevice *dev)\n\n{\n\n    PROMState *s = OPENPROM(dev);\n\n\n\n    memory_region_init_ram(&s->prom, OBJECT(s), \"sun4m.prom\", PROM_SIZE_MAX,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->prom);\n\n    memory_region_set_readonly(&s->prom, true);\n\n    sysbus_init_mmio(dev, &s->prom);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"71ed827abd57dc7947ce3316118d0e601e70fac9","target":0,"func":"int ioinst_handle_stsch(CPUS390XState *env, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    uint64_t addr;\n\n    int cc;\n\n    SCHIB *schib;\n\n    hwaddr len = sizeof(*schib);\n\n\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        return -EIO;\n\n    }\n\n    trace_ioinst_sch_id(\"stsch\", cssid, ssid, schid);\n\n    addr = decode_basedisp_s(env, ipb);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return -EIO;\n\n    }\n\n    schib = s390_cpu_physical_memory_map(env, addr, &len, 1);\n\n    if (!schib || len != sizeof(*schib)) {\n\n        program_interrupt(env, PGM_ADDRESSING, 2);\n\n        cc = -EIO;\n\n        goto out;\n\n    }\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch) {\n\n        if (css_subch_visible(sch)) {\n\n            css_do_stsch(sch, schib);\n\n            cc = 0;\n\n        } else {\n\n            \/* Indicate no more subchannels in this css\/ss *\/\n\n            cc = 3;\n\n        }\n\n    } else {\n\n        if (css_schid_final(m, cssid, ssid, schid)) {\n\n            cc = 3; \/* No more subchannels in this css\/ss *\/\n\n        } else {\n\n            \/* Store an empty schib. *\/\n\n            memset(schib, 0, sizeof(*schib));\n\n            cc = 0;\n\n        }\n\n    }\n\nout:\n\n    s390_cpu_physical_memory_unmap(env, schib, len, 1);\n\n    return cc;\n\n}\n"},{"project":"qemu","commit_id":"72700d7e733948fa7fbb735ccdf2209931c88476","target":1,"func":"static void spapr_phb_vfio_finish_realize(sPAPRPHBState *sphb, Error **errp)\n\n{\n\n    sPAPRPHBVFIOState *svphb = SPAPR_PCI_VFIO_HOST_BRIDGE(sphb);\n\n    struct vfio_iommu_spapr_tce_info info = { .argsz = sizeof(info) };\n\n    int ret;\n\n    sPAPRTCETable *tcet;\n\n    uint32_t liobn = svphb->phb.dma_liobn;\n\n\n\n    if (svphb->iommugroupid == -1) {\n\n        error_setg(errp, \"Wrong IOMMU group ID %d\", svphb->iommugroupid);\n\n        return;\n\n    }\n\n\n\n    ret = vfio_container_ioctl(&svphb->phb.iommu_as, svphb->iommugroupid,\n\n                               VFIO_CHECK_EXTENSION,\n\n                               (void *) VFIO_SPAPR_TCE_IOMMU);\n\n    if (ret != 1) {\n\n        error_setg_errno(errp, -ret,\n\n                         \"spapr-vfio: SPAPR extension is not supported\");\n\n        return;\n\n    }\n\n\n\n    ret = vfio_container_ioctl(&svphb->phb.iommu_as, svphb->iommugroupid,\n\n                               VFIO_IOMMU_SPAPR_TCE_GET_INFO, &info);\n\n    if (ret) {\n\n        error_setg_errno(errp, -ret,\n\n                         \"spapr-vfio: get info from container failed\");\n\n        return;\n\n    }\n\n\n\n    tcet = spapr_tce_new_table(DEVICE(sphb), liobn, info.dma32_window_start,\n\n                               SPAPR_TCE_PAGE_SHIFT,\n\n                               info.dma32_window_size >> SPAPR_TCE_PAGE_SHIFT,\n\n                               true);\n\n    if (!tcet) {\n\n        error_setg(errp, \"spapr-vfio: failed to create VFIO TCE table\");\n\n        return;\n\n    }\n\n\n\n    \/* Register default 32bit DMA window *\/\n\n    memory_region_add_subregion(&sphb->iommu_root, tcet->bus_offset,\n\n                                spapr_tce_get_iommu(tcet));\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static uint64_t gem_read(void *opaque, target_phys_addr_t offset, unsigned size)\n\n{\n\n    GemState *s;\n\n    uint32_t retval;\n\n\n\n    s = (GemState *)opaque;\n\n\n\n    offset >>= 2;\n\n    retval = s->regs[offset];\n\n\n\n    DB_PRINT(\"offset: 0x%04x read: 0x%08x\\n\", offset*4, retval);\n\n\n\n    switch (offset) {\n\n    case GEM_ISR:\n\n        qemu_set_irq(s->irq, 0);\n\n        break;\n\n    case GEM_PHYMNTNC:\n\n        if (retval & GEM_PHYMNTNC_OP_R) {\n\n            uint32_t phy_addr, reg_num;\n\n\n\n            phy_addr = (retval & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;\n\n            if (phy_addr == BOARD_PHY_ADDRESS) {\n\n                reg_num = (retval & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;\n\n                retval &= 0xFFFF0000;\n\n                retval |= gem_phy_read(s, reg_num);\n\n            } else {\n\n                retval |= 0xFFFF; \/* No device at this address *\/\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    \/* Squash read to clear bits *\/\n\n    s->regs[offset] &= ~(s->regs_rtc[offset]);\n\n\n\n    \/* Do not provide write only bits *\/\n\n    retval &= ~(s->regs_wo[offset]);\n\n\n\n    DB_PRINT(\"0x%08x\\n\", retval);\n\n    return retval;\n\n}\n"},{"project":"qemu","commit_id":"25e5e4c7e9d5ec3e95c9526d1abaca40ada50ab0","target":1,"func":"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,\n\n                    size_t offset, size_t bytes, bool do_send)\n\n{\n\n    size_t done = 0;\n\n    ssize_t ret;\n\n    while (done < bytes) {\n\n        ret = iov_send_recv(sockfd, iov,\n\n                            offset + done, bytes - done, do_send);\n\n        if (ret > 0) {\n\n            done += ret;\n\n        } else if (ret < 0) {\n\n            if (errno == EAGAIN) {\n\n                qemu_coroutine_yield();\n\n            } else if (done == 0) {\n\n                return -1;\n\n            } else {\n\n                break;\n\n            }\n\n        } else if (ret == 0 && !do_send) {\n\n            \/* write (send) should never return 0.\n\n             * read (recv) returns 0 for end-of-file (-data).\n\n             * In both cases there's little point retrying,\n\n             * but we do for write anyway, just in case *\/\n\n            break;\n\n        }\n\n    }\n\n    return done;\n\n}\n"},{"project":"qemu","commit_id":"f76f665547f4a954a2c83552a88816fc2a316be0","target":1,"func":"static int virtio_balloon_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    vdev = virtio_balloon_init(&pci_dev->qdev);\n\n\n\n\n    virtio_init_pci(proxy, vdev);\n\n    return 0;\n"},{"project":"qemu","commit_id":"059bca46bbfd7f16cd2ccca631b91334e08d9abb","target":0,"func":"int mmap_frag(unsigned long host_start,\n\n               unsigned long start, unsigned long end,\n\n               int prot, int flags, int fd, unsigned long offset)\n\n{\n\n    unsigned long host_end, ret, addr;\n\n    int prot1, prot_new;\n\n\n\n    host_end = host_start + qemu_host_page_size;\n\n\n\n    \/* get the protection of the target pages outside the mapping *\/\n\n    prot1 = 0;\n\n    for(addr = host_start; addr < host_end; addr++) {\n\n        if (addr < start || addr >= end)\n\n            prot1 |= page_get_flags(addr);\n\n    }\n\n\n\n    if (prot1 == 0) {\n\n        \/* no page was there, so we allocate one *\/\n\n        ret = (long)mmap((void *)host_start, qemu_host_page_size, prot,\n\n                         flags | MAP_ANONYMOUS, -1, 0);\n\n        if (ret == -1)\n\n            return ret;\n\n    }\n\n    prot1 &= PAGE_BITS;\n\n\n\n    prot_new = prot | prot1;\n\n    if (!(flags & MAP_ANONYMOUS)) {\n\n        \/* msync() won't work here, so we return an error if write is\n\n           possible while it is a shared mapping *\/\n\n#ifndef __APPLE__\n\n        if ((flags & MAP_TYPE) == MAP_SHARED &&\n\n#else\n\n        if ((flags &  MAP_SHARED) &&\n\n#endif\n\n            (prot & PROT_WRITE))\n\n            return -EINVAL;\n\n\n\n        \/* adjust protection to be able to read *\/\n\n        if (!(prot1 & PROT_WRITE))\n\n            mprotect((void *)host_start, qemu_host_page_size, prot1 | PROT_WRITE);\n\n\n\n        \/* read the corresponding file data *\/\n\n        pread(fd, (void *)start, end - start, offset);\n\n\n\n        \/* put final protection *\/\n\n        if (prot_new != (prot1 | PROT_WRITE))\n\n            mprotect((void *)host_start, qemu_host_page_size, prot_new);\n\n    } else {\n\n        \/* just update the protection *\/\n\n        if (prot_new != prot1) {\n\n            mprotect((void *)host_start, qemu_host_page_size, prot_new);\n\n        }\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"4b5d5e87c7ab2e979a2cad6c8e01bcae55b85f1c","target":0,"func":"static uint32_t vfio_pci_read_config(PCIDevice *pdev, uint32_t addr, int len)\n\n{\n\n    VFIODevice *vdev = DO_UPCAST(VFIODevice, pdev, pdev);\n\n    uint32_t val = 0;\n\n\n\n    \/*\n\n     * We only need QEMU PCI config support for the ROM BAR, the MSI and MSIX\n\n     * capabilities, and the multifunction bit below.  We let VFIO handle\n\n     * virtualizing everything else.  Performance is not a concern here.\n\n     *\/\n\n    if (ranges_overlap(addr, len, PCI_ROM_ADDRESS, 4) ||\n\n        (pdev->cap_present & QEMU_PCI_CAP_MSIX &&\n\n         ranges_overlap(addr, len, pdev->msix_cap, MSIX_CAP_LENGTH)) ||\n\n        (pdev->cap_present & QEMU_PCI_CAP_MSI &&\n\n         ranges_overlap(addr, len, pdev->msi_cap, vdev->msi_cap_size))) {\n\n\n\n        val = pci_default_read_config(pdev, addr, len);\n\n    } else {\n\n        if (pread(vdev->fd, &val, len, vdev->config_offset + addr) != len) {\n\n            error_report(\"%s(%04x:%02x:%02x.%x, 0x%x, 0x%x) failed: %m\",\n\n                         __func__, vdev->host.domain, vdev->host.bus,\n\n                         vdev->host.slot, vdev->host.function, addr, len);\n\n            return -errno;\n\n        }\n\n        val = le32_to_cpu(val);\n\n    }\n\n\n\n    \/* Multifunction bit is virualized in QEMU *\/\n\n    if (unlikely(ranges_overlap(addr, len, PCI_HEADER_TYPE, 1))) {\n\n        uint32_t mask = PCI_HEADER_TYPE_MULTI_FUNCTION;\n\n\n\n        if (len == 4) {\n\n            mask <<= 16;\n\n        }\n\n\n\n        if (pdev->cap_present & QEMU_PCI_CAP_MULTIFUNCTION) {\n\n            val |= mask;\n\n        } else {\n\n            val &= ~mask;\n\n        }\n\n    }\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x, @0x%x, len=0x%x) %x\\n\", __func__,\n\n            vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n            vdev->host.function, addr, len, val);\n\n\n\n    return val;\n\n}\n"},{"project":"qemu","commit_id":"bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884","target":0,"func":"SocketAddressLegacy *socket_parse(const char *str, Error **errp)\n\n{\n\n    SocketAddressLegacy *addr;\n\n\n\n    addr = g_new0(SocketAddressLegacy, 1);\n\n    if (strstart(str, \"unix:\", NULL)) {\n\n        if (str[5] == '\\0') {\n\n            error_setg(errp, \"invalid Unix socket address\");\n\n            goto fail;\n\n        } else {\n\n            addr->type = SOCKET_ADDRESS_LEGACY_KIND_UNIX;\n\n            addr->u.q_unix.data = g_new(UnixSocketAddress, 1);\n\n            addr->u.q_unix.data->path = g_strdup(str + 5);\n\n        }\n\n    } else if (strstart(str, \"fd:\", NULL)) {\n\n        if (str[3] == '\\0') {\n\n            error_setg(errp, \"invalid file descriptor address\");\n\n            goto fail;\n\n        } else {\n\n            addr->type = SOCKET_ADDRESS_LEGACY_KIND_FD;\n\n            addr->u.fd.data = g_new(String, 1);\n\n            addr->u.fd.data->str = g_strdup(str + 3);\n\n        }\n\n    } else if (strstart(str, \"vsock:\", NULL)) {\n\n        addr->type = SOCKET_ADDRESS_LEGACY_KIND_VSOCK;\n\n        addr->u.vsock.data = g_new(VsockSocketAddress, 1);\n\n        if (vsock_parse(addr->u.vsock.data, str + strlen(\"vsock:\"), errp)) {\n\n            goto fail;\n\n        }\n\n    } else {\n\n        addr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;\n\n        addr->u.inet.data = g_new(InetSocketAddress, 1);\n\n        if (inet_parse(addr->u.inet.data, str, errp)) {\n\n            goto fail;\n\n        }\n\n    }\n\n    return addr;\n\n\n\nfail:\n\n    qapi_free_SocketAddressLegacy(addr);\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"2fd5d864099dd38b43b595e9e3375dad2f76049b","target":1,"func":"strdup(str)\n\n\tconst char *str;\n\n{\n\n\tchar *bptr;\n\n\n\n\tbptr = (char *)malloc(strlen(str)+1);\n\n\tstrcpy(bptr, str);\n\n\n\n\treturn bptr;\n\n}\n"},{"project":"qemu","commit_id":"10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b","target":0,"func":"static void ac97_initfn (PCIDevice *dev)\n\n{\n\n    PCIAC97LinkState *d = DO_UPCAST (PCIAC97LinkState, dev, dev);\n\n    AC97LinkState *s = &d->ac97;\n\n    uint8_t *c = d->dev.config;\n\n\n\n    s->pci_dev = &d->dev;\n\n    pci_config_set_vendor_id (c, PCI_VENDOR_ID_INTEL); \/* ro *\/\n\n    pci_config_set_device_id (c, PCI_DEVICE_ID_INTEL_82801AA_5); \/* ro *\/\n\n\n\n    c[0x04] = 0x00;      \/* pcicmd pci command rw, ro *\/\n\n    c[0x05] = 0x00;\n\n\n\n    c[0x06] = 0x80;      \/* pcists pci status rwc, ro *\/\n\n    c[0x07] = 0x02;\n\n\n\n    c[0x08] = 0x01;      \/* rid revision ro *\/\n\n    c[0x09] = 0x00;      \/* pi programming interface ro *\/\n\n    pci_config_set_class (c, PCI_CLASS_MULTIMEDIA_AUDIO); \/* ro *\/\n\n    c[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; \/* headtyp header type ro *\/\n\n\n\n    c[0x10] = 0x01;      \/* nabmar native audio mixer base\n\n                            address rw *\/\n\n    c[0x11] = 0x00;\n\n    c[0x12] = 0x00;\n\n    c[0x13] = 0x00;\n\n\n\n    c[0x14] = 0x01;      \/* nabmbar native audio bus mastering\n\n                            base address rw *\/\n\n    c[0x15] = 0x00;\n\n    c[0x16] = 0x00;\n\n    c[0x17] = 0x00;\n\n\n\n    c[0x2c] = 0x86;      \/* svid subsystem vendor id rwo *\/\n\n    c[0x2d] = 0x80;\n\n\n\n    c[0x2e] = 0x00;      \/* sid subsystem id rwo *\/\n\n    c[0x2f] = 0x00;\n\n\n\n    c[0x3c] = 0x00;      \/* intr_ln interrupt line rw *\/\n\n    c[0x3d] = 0x01;      \/* intr_pn interrupt pin ro *\/\n\n\n\n    pci_register_bar (&d->dev, 0, 256 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    pci_register_bar (&d->dev, 1, 64 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    register_savevm (\"ac97\", 0, 2, ac97_save, ac97_load, s);\n\n    qemu_register_reset (ac97_on_reset, s);\n\n    AUD_register_card (\"ac97\", &s->card);\n\n    ac97_on_reset (s);\n\n}\n"},{"project":"qemu","commit_id":"7b899f4dd596dbb7d271f7fab36fbfffec84868e","target":0,"func":"static void test_commands(void)\n\n{\n\n    char *response;\n\n    int i;\n\n\n\n    for (i = 0; hmp_cmds[i] != NULL; i++) {\n\n        if (verbose) {\n\n            fprintf(stderr, \"\\t%s\\n\", hmp_cmds[i]);\n\n        }\n\n        response = hmp(hmp_cmds[i]);\n\n        g_free(response);\n\n    }\n\n\n\n}\n"},{"project":"qemu","commit_id":"880a7578381d1c7ed4d41c7599ae3cc06567a824","target":0,"func":"static void gdb_chr_receive(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    GDBState *s = opaque;\n\n    int i;\n\n\n\n    for (i = 0; i < size; i++) {\n\n        gdb_read_byte(s, buf[i]);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"void framebuffer_update_display(\n\n    DisplayState *ds,\n\n    MemoryRegion *address_space,\n\n    target_phys_addr_t base,\n\n    int cols, \/* Width in pixels.  *\/\n\n    int rows, \/* Height in pixels.  *\/\n\n    int src_width, \/* Length of source line, in bytes.  *\/\n\n    int dest_row_pitch, \/* Bytes between adjacent horizontal output pixels.  *\/\n\n    int dest_col_pitch, \/* Bytes between adjacent vertical output pixels.  *\/\n\n    int invalidate, \/* nonzero to redraw the whole image.  *\/\n\n    drawfn fn,\n\n    void *opaque,\n\n    int *first_row, \/* Input and output.  *\/\n\n    int *last_row \/* Output only *\/)\n\n{\n\n    target_phys_addr_t src_len;\n\n    uint8_t *dest;\n\n    uint8_t *src;\n\n    uint8_t *src_base;\n\n    int first, last = 0;\n\n    int dirty;\n\n    int i;\n\n    ram_addr_t addr;\n\n    MemoryRegionSection mem_section;\n\n    MemoryRegion *mem;\n\n\n\n    i = *first_row;\n\n    *first_row = -1;\n\n    src_len = src_width * rows;\n\n\n\n    mem_section = memory_region_find(address_space, base, src_len);\n\n    if (mem_section.size != src_len || !memory_region_is_ram(mem_section.mr)) {\n\n        return;\n\n    }\n\n    mem = mem_section.mr;\n\n    assert(mem);\n\n    assert(mem_section.offset_within_address_space == base);\n\n\n\n    memory_region_sync_dirty_bitmap(mem);\n\n    src_base = cpu_physical_memory_map(base, &src_len, 0);\n\n    \/* If we can't map the framebuffer then bail.  We could try harder,\n\n       but it's not really worth it as dirty flag tracking will probably\n\n       already have failed above.  *\/\n\n    if (!src_base)\n\n        return;\n\n    if (src_len != src_width * rows) {\n\n        cpu_physical_memory_unmap(src_base, src_len, 0, 0);\n\n        return;\n\n    }\n\n    src = src_base;\n\n    dest = ds_get_data(ds);\n\n    if (dest_col_pitch < 0)\n\n        dest -= dest_col_pitch * (cols - 1);\n\n    if (dest_row_pitch < 0) {\n\n        dest -= dest_row_pitch * (rows - 1);\n\n    }\n\n    first = -1;\n\n    addr = mem_section.offset_within_region;\n\n\n\n    addr += i * src_width;\n\n    src += i * src_width;\n\n    dest += i * dest_row_pitch;\n\n\n\n    for (; i < rows; i++) {\n\n        dirty = memory_region_get_dirty(mem, addr, src_width,\n\n                                             DIRTY_MEMORY_VGA);\n\n        if (dirty || invalidate) {\n\n            fn(opaque, dest, src, cols, dest_col_pitch);\n\n            if (first == -1)\n\n                first = i;\n\n            last = i;\n\n        }\n\n        addr += src_width;\n\n        src += src_width;\n\n        dest += dest_row_pitch;\n\n    }\n\n    cpu_physical_memory_unmap(src_base, src_len, 0, 0);\n\n    if (first < 0) {\n\n        return;\n\n    }\n\n    memory_region_reset_dirty(mem, mem_section.offset_within_region, src_len,\n\n                              DIRTY_MEMORY_VGA);\n\n    *first_row = first;\n\n    *last_row = last;\n\n}\n"},{"project":"qemu","commit_id":"00ec5c37601accb2b85b089d72fc7ddff2f4222e","target":0,"func":"static int v9fs_do_mkdir(V9fsState *s, V9fsString *path, mode_t mode)\n\n{\n\n    return s->ops->mkdir(&s->ctx, path->data, mode);\n\n}\n"},{"project":"qemu","commit_id":"5cbab1bfdeab274e5d4e3353fa626ba8697eed10","target":1,"func":"static void kvm_s390_flic_realize(DeviceState *dev, Error **errp)\n\n{\n\n    KVMS390FLICState *flic_state = KVM_S390_FLIC(dev);\n\n    struct kvm_create_device cd = {0};\n\n    struct kvm_device_attr test_attr = {0};\n\n    int ret;\n\n    Error *errp_local = NULL;\n\n\n\n\n\n\n\n    flic_state->fd = -1;\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_DEVICE_CTRL)) {\n\n        error_setg_errno(&errp_local, errno, \"KVM is missing capability\"\n\n                         \" KVM_CAP_DEVICE_CTRL\");\n\n        trace_flic_no_device_api(errno);\n\n\n\n\n\n    cd.type = KVM_DEV_TYPE_FLIC;\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_CREATE_DEVICE, &cd);\n\n    if (ret < 0) {\n\n        error_setg_errno(&errp_local, errno, \"Creating the KVM device failed\");\n\n        trace_flic_create_device(errno);\n\n\n\n    flic_state->fd = cd.fd;\n\n\n\n    \/* Check clear_io_irq support *\/\n\n    test_attr.group = KVM_DEV_FLIC_CLEAR_IO_IRQ;\n\n    flic_state->clear_io_supported = !ioctl(flic_state->fd,\n\n                                            KVM_HAS_DEVICE_ATTR, test_attr);\n\n\n\n    return;\n\nfail:\n\n    error_propagate(errp, errp_local);\n"},{"project":"qemu","commit_id":"81f194dd69756677cc36ff0827bf970f0f048914","target":0,"func":"static void ppc_cpu_unrealizefn(DeviceState *dev, Error **errp)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(dev);\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n\n\n    for (i = 0; i < PPC_CPU_OPCODES_LEN; i++) {\n\n        if (env->opcodes[i] != &invalid_handler) {\n\n            g_free(env->opcodes[i]);\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"f1219091edd20e3b92544025c2b6dd5e4d98b61b","target":0,"func":"set_interrupt_cause(E1000State *s, int index, uint32_t val)\n\n{\n\n    if (val)\n\n        val |= E1000_ICR_INT_ASSERTED;\n\n    s->mac_reg[ICR] = val;\n\n    s->mac_reg[ICS] = val;\n\n    qemu_set_irq(s->dev.irq[0], (s->mac_reg[IMS] & s->mac_reg[ICR]) != 0);\n\n}\n"},{"project":"qemu","commit_id":"a1f7f97b950a46393b0e55a9a0082e70f540cbbd","target":1,"func":"static void cpu_4xx_wdt_cb (void *opaque)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    ppc_tb_t *tb_env;\n\n    ppc40x_timer_t *ppc40x_timer;\n\n    uint64_t now, next;\n\n\n\n    env = opaque;\n\n    cpu = ppc_env_get_cpu(env);\n\n    tb_env = env->tb_env;\n\n    ppc40x_timer = tb_env->opaque;\n\n    now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n    switch ((env->spr[SPR_40x_TCR] >> 30) & 0x3) {\n\n    case 0:\n\n        next = 1 << 17;\n\n        break;\n\n    case 1:\n\n        next = 1 << 21;\n\n        break;\n\n    case 2:\n\n        next = 1 << 25;\n\n        break;\n\n    case 3:\n\n        next = 1 << 29;\n\n        break;\n\n    default:\n\n        \/* Cannot occur, but makes gcc happy *\/\n\n        return;\n\n    }\n\n    next = now + muldiv64(next, get_ticks_per_sec(), tb_env->decr_freq);\n\n    if (next == now)\n\n        next++;\n\n    LOG_TB(\"%s: TCR \" TARGET_FMT_lx \" TSR \" TARGET_FMT_lx \"\\n\", __func__,\n\n           env->spr[SPR_40x_TCR], env->spr[SPR_40x_TSR]);\n\n    switch ((env->spr[SPR_40x_TSR] >> 30) & 0x3) {\n\n    case 0x0:\n\n    case 0x1:\n\n        timer_mod(ppc40x_timer->wdt_timer, next);\n\n        ppc40x_timer->wdt_next = next;\n\n        env->spr[SPR_40x_TSR] |= 1 << 31;\n\n        break;\n\n    case 0x2:\n\n        timer_mod(ppc40x_timer->wdt_timer, next);\n\n        ppc40x_timer->wdt_next = next;\n\n        env->spr[SPR_40x_TSR] |= 1 << 30;\n\n        if ((env->spr[SPR_40x_TCR] >> 27) & 0x1) {\n\n            ppc_set_irq(cpu, PPC_INTERRUPT_WDT, 1);\n\n        }\n\n        break;\n\n    case 0x3:\n\n        env->spr[SPR_40x_TSR] &= ~0x30000000;\n\n        env->spr[SPR_40x_TSR] |= env->spr[SPR_40x_TCR] & 0x30000000;\n\n        switch ((env->spr[SPR_40x_TCR] >> 28) & 0x3) {\n\n        case 0x0:\n\n            \/* No reset *\/\n\n            break;\n\n        case 0x1: \/* Core reset *\/\n\n            ppc40x_core_reset(cpu);\n\n            break;\n\n        case 0x2: \/* Chip reset *\/\n\n            ppc40x_chip_reset(cpu);\n\n            break;\n\n        case 0x3: \/* System reset *\/\n\n            ppc40x_system_reset(cpu);\n\n            break;\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"7385aed20db5d83979f683b9d0048674411e963c","target":0,"func":"static inline void clear_float_exceptions(CPUSPARCState *env)\n\n{\n\n    set_float_exception_flags(0, &env->fp_status);\n\n}\n"},{"project":"qemu","commit_id":"df8bf7a7fe75eb5d5caffa55f5cd4292b757aea6","target":1,"func":"void net_rx_pkt_attach_iovec(struct NetRxPkt *pkt,\n\n                                const struct iovec *iov, int iovcnt,\n\n                                size_t iovoff, bool strip_vlan)\n\n{\n\n    uint16_t tci = 0;\n\n    uint16_t ploff = iovoff;\n\n    assert(pkt);\n\n    pkt->vlan_stripped = false;\n\n\n\n    if (strip_vlan) {\n\n        pkt->vlan_stripped = eth_strip_vlan(iov, iovcnt, iovoff, pkt->ehdr_buf,\n\n                                            &ploff, &tci);\n\n    }\n\n\n\n    pkt->tci = tci;\n\n\n\n    net_rx_pkt_pull_data(pkt, iov, iovcnt, ploff);\n\n}\n"},{"project":"qemu","commit_id":"2886be1b01c274570fa139748a402207482405bd","target":1,"func":"static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width,\n\n                            uint64_t *data)\n\n{\n\n    PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport);\n\n    uint32_t val;\n\n\n\n    switch(addr) {\n\n    case 0x00:\n\n        val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n        break;\n\n    case 0x02:\n\n        val = s->ar.pm1.evt.en;\n\n        break;\n\n    case 0x04:\n\n        val = s->ar.pm1.cnt.cnt;\n\n        break;\n\n    case 0x08:\n\n        val = acpi_pm_tmr_get(&s->ar);\n\n        break;\n\n    default:\n\n        val = 0;\n\n        break;\n\n    }\n\n    PIIX4_DPRINTF(\"PM readw port=0x%04x val=0x%04x\\n\", (unsigned int)addr, val);\n\n    *data = val;\n\n}\n"},{"project":"qemu","commit_id":"f59df3f2354982ee0381b87d1ce561f1eb0ed505","target":1,"func":"static int disas_coproc_insn(CPUARMState * env, DisasContext *s, uint32_t insn)\n{\n    int cpnum, is64, crn, crm, opc1, opc2, isread, rt, rt2;\n    const ARMCPRegInfo *ri;\n    cpnum = (insn >> 8) & 0xf;\n    if (arm_feature(env, ARM_FEATURE_XSCALE)\n\t    && ((env->cp15.c15_cpar ^ 0x3fff) & (1 << cpnum)))\n\treturn 1;\n    \/* First check for coprocessor space used for actual instructions *\/\n    switch (cpnum) {\n      case 0:\n      case 1:\n\tif (arm_feature(env, ARM_FEATURE_IWMMXT)) {\n\t    return disas_iwmmxt_insn(env, s, insn);\n\t} else if (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\t    return disas_dsp_insn(env, s, insn);\n\treturn 1;\n    default:\n        break;\n    \/* Otherwise treat as a generic register access *\/\n    is64 = (insn & (1 << 25)) == 0;\n    if (!is64 && ((insn & (1 << 4)) == 0)) {\n        \/* cdp *\/\n        return 1;\n    crm = insn & 0xf;\n    if (is64) {\n        crn = 0;\n        opc1 = (insn >> 4) & 0xf;\n        opc2 = 0;\n        rt2 = (insn >> 16) & 0xf;\n    } else {\n        crn = (insn >> 16) & 0xf;\n        opc1 = (insn >> 21) & 7;\n        opc2 = (insn >> 5) & 7;\n        rt2 = 0;\n    isread = (insn >> 20) & 1;\n    rt = (insn >> 12) & 0xf;\n    ri = get_arm_cp_reginfo(s->cp_regs,\n                            ENCODE_CP_REG(cpnum, is64, crn, crm, opc1, opc2));\n    if (ri) {\n        \/* Check access permissions *\/\n        if (!cp_access_ok(s->current_pl, ri, isread)) {\n            return 1;\n        \/* Handle special cases first *\/\n        switch (ri->type & ~(ARM_CP_FLAG_MASK & ~ARM_CP_SPECIAL)) {\n        case ARM_CP_NOP:\n            return 0;\n        case ARM_CP_WFI:\n            if (isread) {\n                return 1;\n            s->is_jmp = DISAS_WFI;\n            return 0;\n        default:\n            break;\n        if (use_icount && (ri->type & ARM_CP_IO)) {\n            gen_io_start();\n        if (isread) {\n            \/* Read *\/\n            if (is64) {\n                TCGv_i64 tmp64;\n                TCGv_i32 tmp;\n                if (ri->type & ARM_CP_CONST) {\n                    tmp64 = tcg_const_i64(ri->resetvalue);\n                } else if (ri->readfn) {\n                    tmp64 = tcg_temp_new_i64();\n                    gen_helper_get_cp_reg64(tmp64, cpu_env, tmpptr);\n                } else {\n                    tmp64 = tcg_temp_new_i64();\n                    tcg_gen_ld_i64(tmp64, cpu_env, ri->fieldoffset);\n                tmp = tcg_temp_new_i32();\n                tcg_gen_trunc_i64_i32(tmp, tmp64);\n                store_reg(s, rt, tmp);\n                tcg_gen_shri_i64(tmp64, tmp64, 32);\n                tmp = tcg_temp_new_i32();\n                tcg_gen_trunc_i64_i32(tmp, tmp64);\n                tcg_temp_free_i64(tmp64);\n                store_reg(s, rt2, tmp);\n            } else {\n                TCGv_i32 tmp;\n                if (ri->type & ARM_CP_CONST) {\n                    tmp = tcg_const_i32(ri->resetvalue);\n                } else if (ri->readfn) {\n                    tmp = tcg_temp_new_i32();\n                    gen_helper_get_cp_reg(tmp, cpu_env, tmpptr);\n                } else {\n                    tmp = load_cpu_offset(ri->fieldoffset);\n                if (rt == 15) {\n                    \/* Destination register of r15 for 32 bit loads sets\n                     * the condition codes from the high 4 bits of the value\n                    gen_set_nzcv(tmp);\n                    tcg_temp_free_i32(tmp);\n                } else {\n                    store_reg(s, rt, tmp);\n        } else {\n            \/* Write *\/\n            if (ri->type & ARM_CP_CONST) {\n                \/* If not forbidden by access permissions, treat as WI *\/\n                return 0;\n            if (is64) {\n                TCGv_i32 tmplo, tmphi;\n                TCGv_i64 tmp64 = tcg_temp_new_i64();\n                tmplo = load_reg(s, rt);\n                tmphi = load_reg(s, rt2);\n                tcg_gen_concat_i32_i64(tmp64, tmplo, tmphi);\n                tcg_temp_free_i32(tmplo);\n                tcg_temp_free_i32(tmphi);\n                if (ri->writefn) {\n                    TCGv_ptr tmpptr = tcg_const_ptr(ri);\n                    gen_helper_set_cp_reg64(cpu_env, tmpptr, tmp64);\n                } else {\n                    tcg_gen_st_i64(tmp64, cpu_env, ri->fieldoffset);\n                tcg_temp_free_i64(tmp64);\n            } else {\n                if (ri->writefn) {\n                    TCGv_i32 tmp;\n                    tmp = load_reg(s, rt);\n                    gen_helper_set_cp_reg(cpu_env, tmpptr, tmp);\n                    tcg_temp_free_i32(tmp);\n                } else {\n                    TCGv_i32 tmp = load_reg(s, rt);\n                    store_cpu_offset(tmp, ri->fieldoffset);\n        if (use_icount && (ri->type & ARM_CP_IO)) {\n            \/* I\/O operations must end the TB here (whether read or write) *\/\n            gen_io_end();\n            gen_lookup_tb(s);\n        } else if (!isread && !(ri->type & ARM_CP_SUPPRESS_TB_END)) {\n            \/* We default to ending the TB on a coprocessor register write,\n             * but allow this to be suppressed by the register definition\n             * (usually only necessary to work around guest bugs).\n            gen_lookup_tb(s);\n        return 0;\n    \/* Unknown register; this might be a guest error or a QEMU\n     * unimplemented feature.\n    if (is64) {\n        qemu_log_mask(LOG_UNIMP, \"%s access to unsupported AArch32 \"\n                      \"64 bit system register cp:%d opc1: %d crm:%d\\n\",\n                      isread ? \"read\" : \"write\", cpnum, opc1, crm);\n    } else {\n        qemu_log_mask(LOG_UNIMP, \"%s access to unsupported AArch32 \"\n                      \"system register cp:%d opc1:%d crn:%d crm:%d opc2:%d\\n\",\n                      isread ? \"read\" : \"write\", cpnum, opc1, crn, crm, opc2);\n    return 1;"},{"project":"qemu","commit_id":"4656e1f01289cc3aa20986deb6a407165826abe5","target":1,"func":"void ppc_tlb_invalidate_all(CPUPPCState *env)\n\n{\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_REAL:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_MPC8xx:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        tlb_flush(env, 1);\n\n        break;\n\n    case POWERPC_MMU_BOOKE206:\n\n        booke206_flush_tlb(env, -1, 0);\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_620:\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_06:\n\n\n#endif \/* defined(TARGET_PPC64) *\/\n\n        tlb_flush(env, 1);\n\n        break;\n\n    default:\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"Unknown MMU model\\n\");\n\n        break;\n\n    }\n\n}"},{"project":"qemu","commit_id":"acfb23ad3dd8d0ab385a10e483776ba7dcf927ad","target":0,"func":"static void test_bh_delete_from_cb_many(void)\n\n{\n\n    BHTestData data1 = { .n = 0, .max = 1 };\n\n    BHTestData data2 = { .n = 0, .max = 3 };\n\n    BHTestData data3 = { .n = 0, .max = 2 };\n\n    BHTestData data4 = { .n = 0, .max = 4 };\n\n\n\n    data1.bh = aio_bh_new(ctx, bh_delete_cb, &data1);\n\n    data2.bh = aio_bh_new(ctx, bh_delete_cb, &data2);\n\n    data3.bh = aio_bh_new(ctx, bh_delete_cb, &data3);\n\n    data4.bh = aio_bh_new(ctx, bh_delete_cb, &data4);\n\n\n\n    qemu_bh_schedule(data1.bh);\n\n    qemu_bh_schedule(data2.bh);\n\n    qemu_bh_schedule(data3.bh);\n\n    qemu_bh_schedule(data4.bh);\n\n    g_assert_cmpint(data1.n, ==, 0);\n\n    g_assert_cmpint(data2.n, ==, 0);\n\n    g_assert_cmpint(data3.n, ==, 0);\n\n    g_assert_cmpint(data4.n, ==, 0);\n\n\n\n    g_assert(aio_poll(ctx, false));\n\n    g_assert_cmpint(data1.n, ==, 1);\n\n    g_assert_cmpint(data2.n, ==, 1);\n\n    g_assert_cmpint(data3.n, ==, 1);\n\n    g_assert_cmpint(data4.n, ==, 1);\n\n    g_assert(data1.bh == NULL);\n\n\n\n    wait_for_aio();\n\n    g_assert_cmpint(data1.n, ==, data1.max);\n\n    g_assert_cmpint(data2.n, ==, data2.max);\n\n    g_assert_cmpint(data3.n, ==, data3.max);\n\n    g_assert_cmpint(data4.n, ==, data4.max);\n\n    g_assert(data1.bh == NULL);\n\n    g_assert(data2.bh == NULL);\n\n    g_assert(data3.bh == NULL);\n\n    g_assert(data4.bh == NULL);\n\n}\n"},{"project":"qemu","commit_id":"c4d9d19645a484298a67e9021060bc7c2b081d0f","target":0,"func":"int coroutine_fn thread_pool_submit_co(ThreadPoolFunc *func, void *arg)\n\n{\n\n    ThreadPoolCo tpc = { .co = qemu_coroutine_self(), .ret = -EINPROGRESS };\n\n    assert(qemu_in_coroutine());\n\n    thread_pool_submit_aio(func, arg, thread_pool_co_cb, &tpc);\n\n    qemu_coroutine_yield();\n\n    return tpc.ret;\n\n}\n"},{"project":"qemu","commit_id":"6e0d8677cb443e7408c0b7a25a93c6596d7fa380","target":0,"func":"void OPPROTO op_addw_ESI_T0(void)\n\n{\n\n    ESI = (ESI & ~0xffff) | ((ESI + T0) & 0xffff);\n\n}\n"},{"project":"qemu","commit_id":"ac531cb6e542b1e61d668604adf9dc5306a948c0","target":0,"func":"START_TEST(qdict_haskey_test)\n\n{\n\n    const char *key = \"test\";\n\n\n\n    qdict_put(tests_dict, key, qint_from_int(0));\n\n    fail_unless(qdict_haskey(tests_dict, key) == 1);\n\n}\n"},{"project":"qemu","commit_id":"c0a3172fa6bbddcc73192f2a2c48d0bf3a7ba61c","target":1,"func":"static void rc4030_write(void *opaque, hwaddr addr, uint64_t data,\n\n                         unsigned int size)\n\n{\n\n    rc4030State *s = opaque;\n\n    uint32_t val = data;\n\n    addr &= 0x3fff;\n\n\n\n    trace_rc4030_write(addr, val);\n\n\n\n    switch (addr & ~0x3) {\n\n    \/* Global config register *\/\n\n    case 0x0000:\n\n        s->config = val;\n\n        break;\n\n    \/* DMA transl. table base *\/\n\n    case 0x0018:\n\n        rc4030_dma_tt_update(s, val, s->dma_tl_limit);\n\n        break;\n\n    \/* DMA transl. table limit *\/\n\n    case 0x0020:\n\n        rc4030_dma_tt_update(s, s->dma_tl_base, val);\n\n        break;\n\n    \/* DMA transl. table invalidated *\/\n\n    case 0x0028:\n\n        break;\n\n    \/* Cache Maintenance *\/\n\n    case 0x0030:\n\n        s->cache_maint = val;\n\n        break;\n\n    \/* I\/O Cache Physical Tag *\/\n\n    case 0x0048:\n\n        s->cache_ptag = val;\n\n        break;\n\n    \/* I\/O Cache Logical Tag *\/\n\n    case 0x0050:\n\n        s->cache_ltag = val;\n\n        break;\n\n    \/* I\/O Cache Byte Mask *\/\n\n    case 0x0058:\n\n        s->cache_bmask |= val; \/* HACK *\/\n\n        break;\n\n    \/* I\/O Cache Buffer Window *\/\n\n    case 0x0060:\n\n        \/* HACK *\/\n\n        if (s->cache_ltag == 0x80000001 && s->cache_bmask == 0xf0f0f0f) {\n\n            hwaddr dest = s->cache_ptag & ~0x1;\n\n            dest += (s->cache_maint & 0x3) << 3;\n\n            cpu_physical_memory_write(dest, &val, 4);\n\n        }\n\n        break;\n\n    \/* Remote Speed Registers *\/\n\n    case 0x0070:\n\n    case 0x0078:\n\n    case 0x0080:\n\n    case 0x0088:\n\n    case 0x0090:\n\n    case 0x0098:\n\n    case 0x00a0:\n\n    case 0x00a8:\n\n    case 0x00b0:\n\n    case 0x00b8:\n\n    case 0x00c0:\n\n    case 0x00c8:\n\n    case 0x00d0:\n\n    case 0x00d8:\n\n    case 0x00e0:\n\n    case 0x00e8:\n\n        s->rem_speed[(addr - 0x0070) >> 3] = val;\n\n        break;\n\n    \/* DMA channel base address *\/\n\n    case 0x0100:\n\n    case 0x0108:\n\n    case 0x0110:\n\n    case 0x0118:\n\n    case 0x0120:\n\n    case 0x0128:\n\n    case 0x0130:\n\n    case 0x0138:\n\n    case 0x0140:\n\n    case 0x0148:\n\n    case 0x0150:\n\n    case 0x0158:\n\n    case 0x0160:\n\n    case 0x0168:\n\n    case 0x0170:\n\n    case 0x0178:\n\n    case 0x0180:\n\n    case 0x0188:\n\n    case 0x0190:\n\n    case 0x0198:\n\n    case 0x01a0:\n\n    case 0x01a8:\n\n    case 0x01b0:\n\n    case 0x01b8:\n\n    case 0x01c0:\n\n    case 0x01c8:\n\n    case 0x01d0:\n\n    case 0x01d8:\n\n    case 0x01e0:\n\n    case 0x01e8:\n\n    case 0x01f0:\n\n    case 0x01f8:\n\n        {\n\n            int entry = (addr - 0x0100) >> 5;\n\n            int idx = (addr & 0x1f) >> 3;\n\n            s->dma_regs[entry][idx] = val;\n\n        }\n\n        break;\n\n    \/* Memory refresh rate *\/\n\n    case 0x0210:\n\n        s->memory_refresh_rate = val;\n\n        break;\n\n    \/* Interval timer reload *\/\n\n    case 0x0228:\n\n        s->itr = val;\n\n        qemu_irq_lower(s->timer_irq);\n\n        set_next_tick(s);\n\n        break;\n\n    \/* EISA interrupt *\/\n\n    case 0x0238:\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"rc4030: invalid write of 0x%02x at 0x%x\",\n\n                      val, (int)addr);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"bf43330aa418908f7a5e2acda28ac1a8ed0d8ad6","target":1,"func":"void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n\n{\n\n    uint64_t real_count = count & ~timer->disabled_mask;\n\n    uint64_t disabled_bit = count & timer->disabled_mask;\n\n\n\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n\n                  timer->name, real_count,\n\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    timer->disabled = disabled_bit ? 1 : 0;\n\n    timer->clock_offset = vm_clock_offset;\n\n}\n"},{"project":"qemu","commit_id":"3b098d56979d2f7fd707c5be85555d114353a28d","target":0,"func":"void qapi_copy_SocketAddress(SocketAddress **p_dest,\n\n                             SocketAddress *src)\n\n{\n\n    QmpOutputVisitor *qov;\n\n    Visitor *ov, *iv;\n\n    QObject *obj;\n\n\n\n    *p_dest = NULL;\n\n\n\n    qov = qmp_output_visitor_new();\n\n    ov = qmp_output_get_visitor(qov);\n\n    visit_type_SocketAddress(ov, NULL, &src, &error_abort);\n\n    obj = qmp_output_get_qobject(qov);\n\n    visit_free(ov);\n\n    if (!obj) {\n\n        return;\n\n    }\n\n\n\n    iv = qmp_input_visitor_new(obj, true);\n\n    visit_type_SocketAddress(iv, NULL, p_dest, &error_abort);\n\n    visit_free(iv);\n\n    qobject_decref(obj);\n\n}\n"},{"project":"qemu","commit_id":"734a77584ae13d36113a7a7cd8b54beb49a8a48e","target":0,"func":"static int qcow2_save_vmstate(BlockDriverState *bs, QEMUIOVector *qiov,\n\n                              int64_t pos)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t total_sectors = bs->total_sectors;\n\n    bool zero_beyond_eof = bs->zero_beyond_eof;\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_VMSTATE_SAVE);\n\n    bs->zero_beyond_eof = false;\n\n    ret = bdrv_pwritev(bs, qcow2_vm_state_offset(s) + pos, qiov);\n\n    bs->zero_beyond_eof = zero_beyond_eof;\n\n\n\n    \/* bdrv_co_do_writev will have increased the total_sectors value to include\n\n     * the VM state - the VM state is however not an actual part of the block\n\n     * device, therefore, we need to restore the old value. *\/\n\n    bs->total_sectors = total_sectors;\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static void ide_set_signature(IDEState *s)\n\n{\n\n    s->select &= 0xf0; \/* clear head *\/\n\n    \/* put signature *\/\n\n    s->nsector = 1;\n\n    s->sector = 1;\n\n    if (s->drive_kind == IDE_CD) {\n\n        s->lcyl = 0x14;\n\n        s->hcyl = 0xeb;\n\n    } else if (s->bs) {\n\n        s->lcyl = 0;\n\n        s->hcyl = 0;\n\n    } else {\n\n        s->lcyl = 0xff;\n\n        s->hcyl = 0xff;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"59f39a47411ab6007a592555dc639aa9753f8d23","target":0,"func":"static bool check_section_footer(QEMUFile *f, SaveStateEntry *se)\n\n{\n\n    uint8_t read_mark;\n\n    uint32_t read_section_id;\n\n\n\n    if (skip_section_footers) {\n\n        \/* No footer to check *\/\n\n        return true;\n\n    }\n\n\n\n    read_mark = qemu_get_byte(f);\n\n\n\n    if (read_mark != QEMU_VM_SECTION_FOOTER) {\n\n        error_report(\"Missing section footer for %s\", se->idstr);\n\n        return false;\n\n    }\n\n\n\n    read_section_id = qemu_get_be32(f);\n\n    if (read_section_id != se->section_id) {\n\n        error_report(\"Mismatched section id in footer for %s -\"\n\n                     \" read 0x%x expected 0x%x\",\n\n                     se->idstr, read_section_id, se->section_id);\n\n        return false;\n\n    }\n\n\n\n    \/* All good *\/\n\n    return true;\n\n}\n"},{"project":"qemu","commit_id":"f8b0aa25599782eef91edc00ebf620bd14db720c","target":0,"func":"static void setup_frame(int usig, struct emulated_sigaction *ka,\n\n\t\t\ttarget_sigset_t *set, CPUState *regs)\n\n{\n\n\tstruct sigframe *frame;\n\n\tabi_ulong frame_addr = get_sigframe(ka, regs, sizeof(*frame));\n\n\tint i, err = 0;\n\n\n\n\tif (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n\n\t\treturn;\n\n\n\n\terr |= setup_sigcontext(&frame->sc, \/*&frame->fpstate,*\/ regs, set->sig[0]);\n\n\n\n        for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n            if (__put_user(set->sig[i], &frame->extramask[i - 1]))\n\n                goto end;\n\n\t}\n\n\n\n\tif (err == 0)\n\n            err = setup_return(regs, ka, &frame->retcode, frame, usig);\n\n\n\nend:\n\n\tunlock_user_struct(frame, frame_addr, 1);\n\n        \/\/\treturn err;\n\n}\n"},{"project":"qemu","commit_id":"b0fd8d18683f0d77a8e6b482771ebea82234d727","target":0,"func":"static void target_setup_frame(int usig, struct target_sigaction *ka,\n\n                               target_siginfo_t *info, target_sigset_t *set,\n\n                               CPUARMState *env)\n\n{\n\n    struct target_rt_sigframe *frame;\n\n    abi_ulong frame_addr, return_addr;\n\n\n\n    frame_addr = get_sigframe(ka, env);\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    __put_user(0, &frame->uc.tuc_flags);\n\n    __put_user(0, &frame->uc.tuc_link);\n\n\n\n    __put_user(target_sigaltstack_used.ss_sp,\n\n                      &frame->uc.tuc_stack.ss_sp);\n\n    __put_user(sas_ss_flags(env->xregs[31]),\n\n                      &frame->uc.tuc_stack.ss_flags);\n\n    __put_user(target_sigaltstack_used.ss_size,\n\n                      &frame->uc.tuc_stack.ss_size);\n\n    target_setup_sigframe(frame, env, set);\n\n    if (ka->sa_flags & TARGET_SA_RESTORER) {\n\n        return_addr = ka->sa_restorer;\n\n    } else {\n\n        \/* mov x8,#__NR_rt_sigreturn; svc #0 *\/\n\n        __put_user(0xd2801168, &frame->tramp[0]);\n\n        __put_user(0xd4000001, &frame->tramp[1]);\n\n        return_addr = frame_addr + offsetof(struct target_rt_sigframe, tramp);\n\n    }\n\n    env->xregs[0] = usig;\n\n    env->xregs[31] = frame_addr;\n\n    env->xregs[29] = env->xregs[31] + offsetof(struct target_rt_sigframe, fp);\n\n    env->pc = ka->_sa_handler;\n\n    env->xregs[30] = return_addr;\n\n    if (info) {\n\n        if (copy_siginfo_to_user(&frame->info, info)) {\n\n            goto give_sigsegv;\n\n        }\n\n        env->xregs[1] = frame_addr + offsetof(struct target_rt_sigframe, info);\n\n        env->xregs[2] = frame_addr + offsetof(struct target_rt_sigframe, uc);\n\n    }\n\n\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    return;\n\n\n\n give_sigsegv:\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n"},{"project":"qemu","commit_id":"ac4b0d0c4feb291643c0e8a07a92e449e13881b5","target":0,"func":"char *qemu_strdup(const char *str)\n\n{\n\n    char *ptr;\n\n    size_t len = strlen(str);\n\n    ptr = qemu_malloc(len + 1);\n\n    if (!ptr)\n\n        return NULL;\n\n    pstrcpy(ptr, len + 1, str);\n\n    return ptr;\n\n}\n"},{"project":"qemu","commit_id":"ab9509cceabef28071e41bdfa073083859c949a7","target":1,"func":"void qemu_spice_display_init_common(SimpleSpiceDisplay *ssd)\n\n{\n\n    qemu_mutex_init(&ssd->lock);\n\n    QTAILQ_INIT(&ssd->updates);\n\n    ssd->mouse_x = -1;\n\n    ssd->mouse_y = -1;\n\n    if (ssd->num_surfaces == 0) {\n\n        ssd->num_surfaces = 1024;\n\n    }\n\n    ssd->bufsize = (16 * 1024 * 1024);\n\n    ssd->buf = g_malloc(ssd->bufsize);\n\n}\n"},{"project":"qemu","commit_id":"c919297379e9980c2bcc4d2053addbc1fd6d762b","target":1,"func":"static int img_compare(int argc, char **argv)\n\n{\n\n    const char *fmt1 = NULL, *fmt2 = NULL, *cache, *filename1, *filename2;\n\n    BlockBackend *blk1, *blk2;\n\n    BlockDriverState *bs1, *bs2;\n\n    int64_t total_sectors1, total_sectors2;\n\n    uint8_t *buf1 = NULL, *buf2 = NULL;\n\n    int pnum1, pnum2;\n\n    int allocated1, allocated2;\n\n    int ret = 0; \/* return value - 0 Ident, 1 Different, >1 Error *\/\n\n    bool progress = false, quiet = false, strict = false;\n\n    int flags;\n\n    bool writethrough;\n\n    int64_t total_sectors;\n\n    int64_t sector_num = 0;\n\n    int64_t nb_sectors;\n\n    int c, pnum;\n\n    uint64_t progress_base;\n\n    bool image_opts = false;\n\n\n\n    cache = BDRV_DEFAULT_CACHE;\n\n    for (;;) {\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"hf:F:T:pqs\",\n\n                        long_options, NULL);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch (c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt1 = optarg;\n\n            break;\n\n        case 'F':\n\n            fmt2 = optarg;\n\n            break;\n\n        case 'T':\n\n            cache = optarg;\n\n            break;\n\n        case 'p':\n\n            progress = true;\n\n            break;\n\n        case 'q':\n\n            quiet = true;\n\n            break;\n\n        case 's':\n\n            strict = true;\n\n            break;\n\n        case OPTION_OBJECT: {\n\n            QemuOpts *opts;\n\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n\n                                           optarg, true);\n\n            if (!opts) {\n\n                ret = 2;\n\n                goto out4;\n\n            }\n\n        }   break;\n\n        case OPTION_IMAGE_OPTS:\n\n            image_opts = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    \/* Progress is not shown in Quiet mode *\/\n\n    if (quiet) {\n\n        progress = false;\n\n    }\n\n\n\n\n\n    if (optind != argc - 2) {\n\n        error_exit(\"Expecting two image file names\");\n\n    }\n\n    filename1 = argv[optind++];\n\n    filename2 = argv[optind++];\n\n\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n\n                          user_creatable_add_opts_foreach,\n\n                          NULL, NULL)) {\n\n        ret = 2;\n\n        goto out4;\n\n    }\n\n\n\n    \/* Initialize before goto out *\/\n\n    qemu_progress_init(progress, 2.0);\n\n\n\n    flags = 0;\n\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n\n    if (ret < 0) {\n\n        error_report(\"Invalid source cache option: %s\", cache);\n\n        ret = 2;\n\n        goto out3;\n\n    }\n\n\n\n    blk1 = img_open(image_opts, filename1, fmt1, flags, writethrough, quiet);\n\n    if (!blk1) {\n\n        ret = 2;\n\n        goto out3;\n\n    }\n\n\n\n    blk2 = img_open(image_opts, filename2, fmt2, flags, writethrough, quiet);\n\n    if (!blk2) {\n\n        ret = 2;\n\n        goto out2;\n\n    }\n\n    bs1 = blk_bs(blk1);\n\n    bs2 = blk_bs(blk2);\n\n\n\n    buf1 = blk_blockalign(blk1, IO_BUF_SIZE);\n\n    buf2 = blk_blockalign(blk2, IO_BUF_SIZE);\n\n    total_sectors1 = blk_nb_sectors(blk1);\n\n    if (total_sectors1 < 0) {\n\n        error_report(\"Can't get size of %s: %s\",\n\n                     filename1, strerror(-total_sectors1));\n\n        ret = 4;\n\n        goto out;\n\n    }\n\n    total_sectors2 = blk_nb_sectors(blk2);\n\n    if (total_sectors2 < 0) {\n\n        error_report(\"Can't get size of %s: %s\",\n\n                     filename2, strerror(-total_sectors2));\n\n        ret = 4;\n\n        goto out;\n\n    }\n\n    total_sectors = MIN(total_sectors1, total_sectors2);\n\n    progress_base = MAX(total_sectors1, total_sectors2);\n\n\n\n    qemu_progress_print(0, 100);\n\n\n\n    if (strict && total_sectors1 != total_sectors2) {\n\n        ret = 1;\n\n        qprintf(quiet, \"Strict mode: Image size mismatch!\\n\");\n\n        goto out;\n\n    }\n\n\n\n    for (;;) {\n\n        int64_t status1, status2;\n\n        BlockDriverState *file;\n\n\n\n        nb_sectors = sectors_to_process(total_sectors, sector_num);\n\n        if (nb_sectors <= 0) {\n\n            break;\n\n        }\n\n        status1 = bdrv_get_block_status_above(bs1, NULL, sector_num,\n\n                                              total_sectors1 - sector_num,\n\n                                              &pnum1, &file);\n\n        if (status1 < 0) {\n\n            ret = 3;\n\n            error_report(\"Sector allocation test failed for %s\", filename1);\n\n            goto out;\n\n        }\n\n        allocated1 = status1 & BDRV_BLOCK_ALLOCATED;\n\n\n\n        status2 = bdrv_get_block_status_above(bs2, NULL, sector_num,\n\n                                              total_sectors2 - sector_num,\n\n                                              &pnum2, &file);\n\n        if (status2 < 0) {\n\n            ret = 3;\n\n            error_report(\"Sector allocation test failed for %s\", filename2);\n\n            goto out;\n\n        }\n\n        allocated2 = status2 & BDRV_BLOCK_ALLOCATED;\n\n        if (pnum1) {\n\n            nb_sectors = MIN(nb_sectors, pnum1);\n\n        }\n\n        if (pnum2) {\n\n            nb_sectors = MIN(nb_sectors, pnum2);\n\n        }\n\n\n\n        if (strict) {\n\n            if ((status1 & ~BDRV_BLOCK_OFFSET_MASK) !=\n\n                (status2 & ~BDRV_BLOCK_OFFSET_MASK)) {\n\n                ret = 1;\n\n                qprintf(quiet, \"Strict mode: Offset %\" PRId64\n\n                        \" block status mismatch!\\n\",\n\n                        sectors_to_bytes(sector_num));\n\n                goto out;\n\n            }\n\n        }\n\n        if ((status1 & BDRV_BLOCK_ZERO) && (status2 & BDRV_BLOCK_ZERO)) {\n\n            nb_sectors = MIN(pnum1, pnum2);\n\n        } else if (allocated1 == allocated2) {\n\n            if (allocated1) {\n\n                ret = blk_pread(blk1, sector_num << BDRV_SECTOR_BITS, buf1,\n\n                                nb_sectors << BDRV_SECTOR_BITS);\n\n                if (ret < 0) {\n\n                    error_report(\"Error while reading offset %\" PRId64 \" of %s:\"\n\n                                 \" %s\", sectors_to_bytes(sector_num), filename1,\n\n                                 strerror(-ret));\n\n                    ret = 4;\n\n                    goto out;\n\n                }\n\n                ret = blk_pread(blk2, sector_num << BDRV_SECTOR_BITS, buf2,\n\n                                nb_sectors << BDRV_SECTOR_BITS);\n\n                if (ret < 0) {\n\n                    error_report(\"Error while reading offset %\" PRId64\n\n                                 \" of %s: %s\", sectors_to_bytes(sector_num),\n\n                                 filename2, strerror(-ret));\n\n                    ret = 4;\n\n                    goto out;\n\n                }\n\n                ret = compare_sectors(buf1, buf2, nb_sectors, &pnum);\n\n                if (ret || pnum != nb_sectors) {\n\n                    qprintf(quiet, \"Content mismatch at offset %\" PRId64 \"!\\n\",\n\n                            sectors_to_bytes(\n\n                                ret ? sector_num : sector_num + pnum));\n\n                    ret = 1;\n\n                    goto out;\n\n                }\n\n            }\n\n        } else {\n\n\n\n            if (allocated1) {\n\n                ret = check_empty_sectors(blk1, sector_num, nb_sectors,\n\n                                          filename1, buf1, quiet);\n\n            } else {\n\n                ret = check_empty_sectors(blk2, sector_num, nb_sectors,\n\n                                          filename2, buf1, quiet);\n\n            }\n\n            if (ret) {\n\n                if (ret < 0) {\n\n                    error_report(\"Error while reading offset %\" PRId64 \": %s\",\n\n                                 sectors_to_bytes(sector_num), strerror(-ret));\n\n                    ret = 4;\n\n                }\n\n                goto out;\n\n            }\n\n        }\n\n        sector_num += nb_sectors;\n\n        qemu_progress_print(((float) nb_sectors \/ progress_base)*100, 100);\n\n    }\n\n\n\n    if (total_sectors1 != total_sectors2) {\n\n        BlockBackend *blk_over;\n\n        int64_t total_sectors_over;\n\n        const char *filename_over;\n\n\n\n        qprintf(quiet, \"Warning: Image size mismatch!\\n\");\n\n        if (total_sectors1 > total_sectors2) {\n\n            total_sectors_over = total_sectors1;\n\n            blk_over = blk1;\n\n            filename_over = filename1;\n\n        } else {\n\n            total_sectors_over = total_sectors2;\n\n            blk_over = blk2;\n\n            filename_over = filename2;\n\n        }\n\n\n\n        for (;;) {\n\n            nb_sectors = sectors_to_process(total_sectors_over, sector_num);\n\n            if (nb_sectors <= 0) {\n\n                break;\n\n            }\n\n            ret = bdrv_is_allocated_above(blk_bs(blk_over), NULL, sector_num,\n\n                                          nb_sectors, &pnum);\n\n            if (ret < 0) {\n\n                ret = 3;\n\n                error_report(\"Sector allocation test failed for %s\",\n\n                             filename_over);\n\n                goto out;\n\n\n\n            }\n\n            nb_sectors = pnum;\n\n            if (ret) {\n\n                ret = check_empty_sectors(blk_over, sector_num, nb_sectors,\n\n                                          filename_over, buf1, quiet);\n\n                if (ret) {\n\n                    if (ret < 0) {\n\n                        error_report(\"Error while reading offset %\" PRId64\n\n                                     \" of %s: %s\", sectors_to_bytes(sector_num),\n\n                                     filename_over, strerror(-ret));\n\n                        ret = 4;\n\n                    }\n\n                    goto out;\n\n                }\n\n            }\n\n            sector_num += nb_sectors;\n\n            qemu_progress_print(((float) nb_sectors \/ progress_base)*100, 100);\n\n        }\n\n    }\n\n\n\n    qprintf(quiet, \"Images are identical.\\n\");\n\n    ret = 0;\n\n\n\nout:\n\n    qemu_vfree(buf1);\n\n    qemu_vfree(buf2);\n\n    blk_unref(blk2);\n\nout2:\n\n    blk_unref(blk1);\n\nout3:\n\n    qemu_progress_end();\n\nout4:\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"0b5538c300a56c3cfb33022840fe0b4968147e7a","target":1,"func":"void st_flush_trace_buffer(void)\n\n{\n\n    if (trace_file_enabled) {\n\n        flush_trace_file();\n\n    }\n\n\n\n    \/* Discard written trace records *\/\n\n    trace_idx = 0;\n\n}\n"},{"project":"qemu","commit_id":"e0e2d644096c79a71099b176d08f465f6803a8b1","target":1,"func":"static inline void vring_set_avail_event(VirtQueue *vq, uint16_t val)\n\n{\n\n    VRingMemoryRegionCaches *caches;\n\n    hwaddr pa;\n\n    if (!vq->notification) {\n\n        return;\n\n    }\n\n\n\n    caches = atomic_rcu_read(&vq->vring.caches);\n\n    pa = offsetof(VRingUsed, ring[vq->vring.num]);\n\n    virtio_stw_phys_cached(vq->vdev, &caches->used, pa, val);\n\n    address_space_cache_invalidate(&caches->used, pa, sizeof(val));\n\n}\n"},{"project":"qemu","commit_id":"15c2f669e3fb2bc97f7b42d1871f595c0ac24af8","target":1,"func":"static void qmp_output_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    QObject *value = qmp_output_pop(qov);\n\n    assert(qobject_type(value) == QTYPE_QDICT);\n\n}\n"},{"project":"qemu","commit_id":"0fa758c3a069bc59a0d903d69028971c46d1a119","target":0,"func":"int i2c_start_transfer(I2CBus *bus, uint8_t address, int recv)\n\n{\n\n    BusChild *kid;\n\n    I2CSlaveClass *sc;\n\n    I2CNode *node;\n\n\n\n    if (address == I2C_BROADCAST) {\n\n        \/*\n\n         * This is a broadcast, the current_devs will be all the devices of the\n\n         * bus.\n\n         *\/\n\n        bus->broadcast = true;\n\n    }\n\n\n\n    QTAILQ_FOREACH(kid, &bus->qbus.children, sibling) {\n\n        DeviceState *qdev = kid->child;\n\n        I2CSlave *candidate = I2C_SLAVE(qdev);\n\n        if ((candidate->address == address) || (bus->broadcast)) {\n\n            node = g_malloc(sizeof(struct I2CNode));\n\n            node->elt = candidate;\n\n            QLIST_INSERT_HEAD(&bus->current_devs, node, next);\n\n            if (!bus->broadcast) {\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (QLIST_EMPTY(&bus->current_devs)) {\n\n        return 1;\n\n    }\n\n\n\n    QLIST_FOREACH(node, &bus->current_devs, next) {\n\n        sc = I2C_SLAVE_GET_CLASS(node->elt);\n\n        \/* If the bus is already busy, assume this is a repeated\n\n           start condition.  *\/\n\n        if (sc->event) {\n\n            sc->event(node->elt, recv ? I2C_START_RECV : I2C_START_SEND);\n\n        }\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"245f7b51c0ea04fb2224b1127430a096c91aee70","target":0,"func":"static int tight_init_stream(VncState *vs, int stream_id,\n\n                             int level, int strategy)\n\n{\n\n    z_streamp zstream = &vs->tight_stream[stream_id];\n\n\n\n    if (zstream->opaque == NULL) {\n\n        int err;\n\n\n\n        VNC_DEBUG(\"VNC: TIGHT: initializing zlib stream %d\\n\", stream_id);\n\n        VNC_DEBUG(\"VNC: TIGHT: opaque = %p | vs = %p\\n\", zstream->opaque, vs);\n\n        zstream->zalloc = vnc_zlib_zalloc;\n\n        zstream->zfree = vnc_zlib_zfree;\n\n\n\n        err = deflateInit2(zstream, level, Z_DEFLATED, MAX_WBITS,\n\n                           MAX_MEM_LEVEL, strategy);\n\n\n\n        if (err != Z_OK) {\n\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n\n            return -1;\n\n        }\n\n\n\n        vs->tight_levels[stream_id] = level;\n\n        zstream->opaque = vs;\n\n    }\n\n\n\n    if (vs->tight_levels[stream_id] != level) {\n\n        if (deflateParams(zstream, level, strategy) != Z_OK) {\n\n            return -1;\n\n        }\n\n        vs->tight_levels[stream_id] = level;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"364031f17932814484657e5551ba12957d993d7e","target":0,"func":"static ssize_t v9fs_synth_readlink(FsContext *fs_ctx, V9fsPath *path,\n\n                                   char *buf, size_t bufsz)\n\n{\n\n    errno = ENOSYS;\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"1343a107e46feed8b901bf08ad8485bd5f302912","target":1,"func":"static int pci_rocker_init(PCIDevice *dev)\n\n{\n\n    Rocker *r = to_rocker(dev);\n\n    const MACAddr zero = { .a = { 0, 0, 0, 0, 0, 0 } };\n\n    const MACAddr dflt = { .a = { 0x52, 0x54, 0x00, 0x12, 0x35, 0x01 } };\n\n    static int sw_index;\n\n    int i, err = 0;\n\n\n\n    \/* allocate worlds *\/\n\n\n\n    r->worlds[ROCKER_WORLD_TYPE_OF_DPA] = of_dpa_world_alloc(r);\n\n\n\n    if (!r->world_name) {\n\n        r->world_name = g_strdup(world_name(r->worlds[ROCKER_WORLD_TYPE_OF_DPA]));\n\n    }\n\n\n\n    r->world_dflt = rocker_world_type_by_name(r, r->world_name);\n\n    if (!r->world_dflt) {\n\n        fprintf(stderr,\n\n                \"rocker: requested world \\\"%s\\\" does not exist\\n\",\n\n                r->world_name);\n\n        err = -EINVAL;\n\n        goto err_world_type_by_name;\n\n    }\n\n\n\n    \/* set up memory-mapped region at BAR0 *\/\n\n\n\n    memory_region_init_io(&r->mmio, OBJECT(r), &rocker_mmio_ops, r,\n\n                          \"rocker-mmio\", ROCKER_PCI_BAR0_SIZE);\n\n    pci_register_bar(dev, ROCKER_PCI_BAR0_IDX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &r->mmio);\n\n\n\n    \/* set up memory-mapped region for MSI-X *\/\n\n\n\n    memory_region_init(&r->msix_bar, OBJECT(r), \"rocker-msix-bar\",\n\n                       ROCKER_PCI_MSIX_BAR_SIZE);\n\n    pci_register_bar(dev, ROCKER_PCI_MSIX_BAR_IDX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &r->msix_bar);\n\n\n\n    \/* MSI-X init *\/\n\n\n\n    err = rocker_msix_init(r);\n\n    if (err) {\n\n        goto err_msix_init;\n\n    }\n\n\n\n    \/* validate switch properties *\/\n\n\n\n    if (!r->name) {\n\n        r->name = g_strdup(ROCKER);\n\n    }\n\n\n\n    if (rocker_find(r->name)) {\n\n        err = -EEXIST;\n\n        goto err_duplicate;\n\n    }\n\n\n\n    \/* Rocker name is passed in port name requests to OS with the intention\n\n     * that the name is used in interface names. Limit the length of the\n\n     * rocker name to avoid naming problems in the OS. Also, adding the\n\n     * port number as p# and unganged breakout b#, where # is at most 2\n\n     * digits, so leave room for it too (-1 for string terminator, -3 for\n\n     * p# and -3 for b#)\n\n     *\/\n\n#define ROCKER_IFNAMSIZ 16\n\n#define MAX_ROCKER_NAME_LEN  (ROCKER_IFNAMSIZ - 1 - 3 - 3)\n\n    if (strlen(r->name) > MAX_ROCKER_NAME_LEN) {\n\n        fprintf(stderr,\n\n                \"rocker: name too long; please shorten to at most %d chars\\n\",\n\n                MAX_ROCKER_NAME_LEN);\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (memcmp(&r->fp_start_macaddr, &zero, sizeof(zero)) == 0) {\n\n        memcpy(&r->fp_start_macaddr, &dflt, sizeof(dflt));\n\n        r->fp_start_macaddr.a[4] += (sw_index++);\n\n    }\n\n\n\n    if (!r->switch_id) {\n\n        memcpy(&r->switch_id, &r->fp_start_macaddr,\n\n               sizeof(r->fp_start_macaddr));\n\n    }\n\n\n\n    if (r->fp_ports > ROCKER_FP_PORTS_MAX) {\n\n        r->fp_ports = ROCKER_FP_PORTS_MAX;\n\n    }\n\n\n\n    r->rings = g_new(DescRing *, rocker_pci_ring_count(r));\n\n\n\n    \/* Rings are ordered like this:\n\n     * - command ring\n\n     * - event ring\n\n     * - port0 tx ring\n\n     * - port0 rx ring\n\n     * - port1 tx ring\n\n     * - port1 rx ring\n\n     * .....\n\n     *\/\n\n\n\n    for (i = 0; i < rocker_pci_ring_count(r); i++) {\n\n        DescRing *ring = desc_ring_alloc(r, i);\n\n\n\n        if (i == ROCKER_RING_CMD) {\n\n            desc_ring_set_consume(ring, cmd_consume, ROCKER_MSIX_VEC_CMD);\n\n        } else if (i == ROCKER_RING_EVENT) {\n\n            desc_ring_set_consume(ring, NULL, ROCKER_MSIX_VEC_EVENT);\n\n        } else if (i % 2 == 0) {\n\n            desc_ring_set_consume(ring, tx_consume,\n\n                                  ROCKER_MSIX_VEC_TX((i - 2) \/ 2));\n\n        } else if (i % 2 == 1) {\n\n            desc_ring_set_consume(ring, NULL, ROCKER_MSIX_VEC_RX((i - 3) \/ 2));\n\n        }\n\n\n\n        r->rings[i] = ring;\n\n    }\n\n\n\n    for (i = 0; i < r->fp_ports; i++) {\n\n        FpPort *port =\n\n            fp_port_alloc(r, r->name, &r->fp_start_macaddr,\n\n                          i, &r->fp_ports_peers[i]);\n\n\n\n        r->fp_port[i] = port;\n\n        fp_port_set_world(port, r->world_dflt);\n\n    }\n\n\n\n    QLIST_INSERT_HEAD(&rockers, r, next);\n\n\n\n    return 0;\n\n\n\nerr_duplicate:\n\n    rocker_msix_uninit(r);\n\nerr_msix_init:\n\n    object_unparent(OBJECT(&r->msix_bar));\n\n    object_unparent(OBJECT(&r->mmio));\n\nerr_world_type_by_name:\n\n    for (i = 0; i < ROCKER_WORLD_TYPE_MAX; i++) {\n\n        if (r->worlds[i]) {\n\n            world_free(r->worlds[i]);\n\n        }\n\n    }\n\n    return err;\n\n}\n"},{"project":"qemu","commit_id":"e048dac616748273c2153490e9fdf1da242f0cad","target":0,"func":"static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\n\t\t\t\t     int off_pitch, int bytesperline,\n\n\t\t\t\t     int lines)\n\n{\n\n    int y;\n\n    int off_cur;\n\n    int off_cur_end;\n\n\n\n    if (off_pitch < 0) {\n\n        off_begin -= bytesperline - 1;\n\n    }\n\n\n\n    for (y = 0; y < lines; y++) {\n\n\toff_cur = off_begin;\n\n\toff_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;\n\n        assert(off_cur_end >= off_cur);\n\n        memory_region_set_dirty(&s->vga.vram, off_cur, off_cur_end - off_cur);\n\n\toff_begin += off_pitch;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"ae2ebad7331930280324005c06bc0891f02eef53","target":0,"func":"static int sh_pci_host_init(PCIDevice *d)\n\n{\n\n    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_HITACHI);\n\n    pci_config_set_device_id(d->config, PCI_DEVICE_ID_HITACHI_SH7751R);\n\n    pci_set_word(d->config + PCI_COMMAND, PCI_COMMAND_WAIT);\n\n    pci_set_word(d->config + PCI_STATUS, PCI_STATUS_CAP_LIST |\n\n                 PCI_STATUS_FAST_BACK | PCI_STATUS_DEVSEL_MEDIUM);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"d9f62dde1303286b24ac8ce88be27e2b9b9c5f46","target":0,"func":"opts_end_list(Visitor *v)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n\n\n    assert(ov->list_mode == LM_STARTED ||\n\n           ov->list_mode == LM_IN_PROGRESS ||\n\n           ov->list_mode == LM_SIGNED_INTERVAL ||\n\n           ov->list_mode == LM_UNSIGNED_INTERVAL);\n\n    ov->repeated_opts = NULL;\n\n    ov->list_mode = LM_NONE;\n\n}\n"},{"project":"qemu","commit_id":"0b5538c300a56c3cfb33022840fe0b4968147e7a","target":1,"func":"static bool write_header(FILE *fp)\n\n{\n\n    static const TraceRecord header = {\n\n        .event = HEADER_EVENT_ID,\n\n        .timestamp_ns = HEADER_MAGIC,\n\n        .x1 = HEADER_VERSION,\n\n    };\n\n\n\n    return fwrite(&header, sizeof header, 1, fp) == 1;\n\n}\n"},{"project":"qemu","commit_id":"3e9418e160cd8901c83a3c88967158084f5b5c03","target":0,"func":"static int qemu_signal_init(void)\n\n{\n\n    int sigfd;\n\n    sigset_t set;\n\n\n\n    \/*\n\n     * SIG_IPI must be blocked in the main thread and must not be caught\n\n     * by sigwait() in the signal thread. Otherwise, the cpu thread will\n\n     * not catch it reliably.\n\n     *\/\n\n    sigemptyset(&set);\n\n    sigaddset(&set, SIG_IPI);\n\n    sigaddset(&set, SIGIO);\n\n    sigaddset(&set, SIGALRM);\n\n    sigaddset(&set, SIGBUS);\n\n    sigaddset(&set, SIGINT);\n\n    sigaddset(&set, SIGHUP);\n\n    sigaddset(&set, SIGTERM);\n\n    pthread_sigmask(SIG_BLOCK, &set, NULL);\n\n\n\n    sigdelset(&set, SIG_IPI);\n\n    sigfd = qemu_signalfd(&set);\n\n    if (sigfd == -1) {\n\n        fprintf(stderr, \"failed to create signalfd\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    fcntl_setfl(sigfd, O_NONBLOCK);\n\n\n\n    qemu_set_fd_handler2(sigfd, NULL, sigfd_handler, NULL,\n\n                         (void *)(intptr_t)sigfd);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"eabb7b91b36b202b4dac2df2d59d698e3aff197a","target":0,"func":"static inline void temp_save(TCGContext *s, TCGTemp *ts,\n\n                             TCGRegSet allocated_regs)\n\n{\n\n#ifdef USE_LIVENESS_ANALYSIS\n\n    \/* ??? Liveness does not yet incorporate indirect bases.  *\/\n\n    if (!ts->indirect_base) {\n\n        \/* The liveness analysis already ensures that globals are back\n\n           in memory. Keep an assert for safety. *\/\n\n        tcg_debug_assert(ts->val_type == TEMP_VAL_MEM || ts->fixed_reg);\n\n        return;\n\n    }\n\n#endif\n\n    temp_sync(s, ts, allocated_regs);\n\n    temp_dead(s, ts);\n\n}\n"},{"project":"qemu","commit_id":"2dc7fdf33d28940255f171b8ea4b692d9d5b7a7d","target":1,"func":"static MTPData *usb_mtp_get_object(MTPState *s, MTPControl *c,\n\n                                   MTPObject *o)\n\n{\n\n    MTPData *d = usb_mtp_data_alloc(c);\n\n\n\n    trace_usb_mtp_op_get_object(s->dev.addr, o->handle, o->path);\n\n\n\n    d->fd = open(o->path, O_RDONLY);\n\n    if (d->fd == -1) {\n\n\n        return NULL;\n\n    }\n\n    d->length = o->stat.st_size;\n\n    d->alloc  = 512;\n\n    d->data   = g_malloc(d->alloc);\n\n    return d;\n\n}"},{"project":"qemu","commit_id":"e3f5ec2b5e92706e3b807059f79b1fb5d936e567","target":0,"func":"static int ne2000_can_receive(void *opaque)\n\n{\n\n    NE2000State *s = opaque;\n\n\n\n    if (s->cmd & E8390_STOP)\n\n        return 1;\n\n    return !ne2000_buffer_full(s);\n\n}\n"},{"project":"qemu","commit_id":"14a10fc39923b3af07c8c46d22cb20843bee3a72","target":1,"func":"static void alpha_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    AlphaCPUClass *acc = ALPHA_CPU_GET_CLASS(dev);\n    acc->parent_realize(dev, errp);\n}"},{"project":"qemu","commit_id":"237d78f8fc62e62f62246883ecf62e44ed35fb80","target":0,"func":"int bdrv_make_zero(BdrvChild *child, BdrvRequestFlags flags)\n\n{\n\n    int64_t target_size, ret, bytes, offset = 0;\n\n    BlockDriverState *bs = child->bs;\n\n    int n; \/* sectors *\/\n\n\n\n    target_size = bdrv_getlength(bs);\n\n    if (target_size < 0) {\n\n        return target_size;\n\n    }\n\n\n\n    for (;;) {\n\n        bytes = MIN(target_size - offset, BDRV_REQUEST_MAX_BYTES);\n\n        if (bytes <= 0) {\n\n            return 0;\n\n        }\n\n        ret = bdrv_get_block_status(bs, offset >> BDRV_SECTOR_BITS,\n\n                                    bytes >> BDRV_SECTOR_BITS, &n, NULL);\n\n        if (ret < 0) {\n\n            error_report(\"error getting block status at offset %\" PRId64 \": %s\",\n\n                         offset, strerror(-ret));\n\n            return ret;\n\n        }\n\n        if (ret & BDRV_BLOCK_ZERO) {\n\n            offset += n * BDRV_SECTOR_BITS;\n\n            continue;\n\n        }\n\n        ret = bdrv_pwrite_zeroes(child, offset, n * BDRV_SECTOR_SIZE, flags);\n\n        if (ret < 0) {\n\n            error_report(\"error writing zeroes at offset %\" PRId64 \": %s\",\n\n                         offset, strerror(-ret));\n\n            return ret;\n\n        }\n\n        offset += n * BDRV_SECTOR_SIZE;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"97f90cbfe810bb153fc44bde732d9639610783bb","target":0,"func":"void helper_memalign(uint32_t addr, uint32_t dr, uint32_t wr, uint32_t mask)\n\n{\n\n    if (addr & mask) {\n\n            qemu_log(\"unaligned access addr=%x mask=%x, wr=%d\\n\",\n\n                     addr, mask, wr);\n\n            if (!(env->sregs[SR_MSR] & MSR_EE)) {\n\n                return;\n\n            }\n\n\n\n            env->sregs[SR_ESR] = ESR_EC_UNALIGNED_DATA | (wr << 10) \\\n\n                                 | (dr & 31) << 5;\n\n            if (mask == 3) {\n\n                env->sregs[SR_ESR] |= 1 << 11;\n\n            }\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"0ab07c623c629acfbc792e5a174129c19faefbb7","target":0,"func":"static void *qemu_kvm_cpu_thread_fn(void *arg)\n\n{\n\n    CPUState *env = arg;\n\n    int r;\n\n\n\n    qemu_mutex_lock(&qemu_global_mutex);\n\n    qemu_thread_self(env->thread);\n\n\n\n    r = kvm_init_vcpu(env);\n\n    if (r < 0) {\n\n        fprintf(stderr, \"kvm_init_vcpu failed: %s\\n\", strerror(-r));\n\n        exit(1);\n\n    }\n\n\n\n    qemu_kvm_init_cpu_signals(env);\n\n\n\n    \/* signal CPU creation *\/\n\n    env->created = 1;\n\n    qemu_cond_signal(&qemu_cpu_cond);\n\n\n\n    \/* and wait for machine initialization *\/\n\n    while (!qemu_system_ready)\n\n        qemu_cond_timedwait(&qemu_system_cond, &qemu_global_mutex, 100);\n\n\n\n    while (1) {\n\n        if (cpu_can_run(env))\n\n            qemu_cpu_exec(env);\n\n        qemu_kvm_wait_io_event(env);\n\n    }\n\n\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"57407ea44cc0a3d630b9b89a2be011f1955ce5c1","target":0,"func":"static void eth_cleanup(NetClientState *nc)\n\n{\n\n    ETRAXFSEthState *eth = qemu_get_nic_opaque(nc);\n\n\n\n    \/* Disconnect the client.  *\/\n\n    eth->dma_out->client.push = NULL;\n\n    eth->dma_out->client.opaque = NULL;\n\n    eth->dma_in->client.opaque = NULL;\n\n    eth->dma_in->client.pull = NULL;\n\n        g_free(eth);\n\n}\n"},{"project":"qemu","commit_id":"e4f4fb1eca795e36f363b4647724221e774523c1","target":1,"func":"static void ioapic_class_init(ObjectClass *klass, void *data)\n\n{\n\n    IOAPICCommonClass *k = IOAPIC_COMMON_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->realize = ioapic_realize;\n\n\n     * If APIC is in kernel, we need to update the kernel cache after\n\n     * migration, otherwise first 24 gsi routes will be invalid.\n\n\n    k->post_load = ioapic_update_kvm_routes;\n\n    dc->reset = ioapic_reset_common;\n\n    dc->props = ioapic_properties;\n\n\n\n\n\n\n}"},{"project":"qemu","commit_id":"4a1418e07bdcfaa3177739e04707ecaec75d89e1","target":0,"func":"void cpu_register_physical_memory_offset(target_phys_addr_t start_addr,\n\n                                         ram_addr_t size,\n\n                                         ram_addr_t phys_offset,\n\n                                         ram_addr_t region_offset)\n\n{\n\n    target_phys_addr_t addr, end_addr;\n\n    PhysPageDesc *p;\n\n    CPUState *env;\n\n    ram_addr_t orig_size = size;\n\n    void *subpage;\n\n\n\n#ifdef CONFIG_KQEMU\n\n    \/* XXX: should not depend on cpu context *\/\n\n    env = first_cpu;\n\n    if (env->kqemu_enabled) {\n\n        kqemu_set_phys_mem(start_addr, size, phys_offset);\n\n    }\n\n#endif\n\n    if (kvm_enabled())\n\n        kvm_set_phys_mem(start_addr, size, phys_offset);\n\n\n\n    if (phys_offset == IO_MEM_UNASSIGNED) {\n\n        region_offset = start_addr;\n\n    }\n\n    region_offset &= TARGET_PAGE_MASK;\n\n    size = (size + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK;\n\n    end_addr = start_addr + (target_phys_addr_t)size;\n\n    for(addr = start_addr; addr != end_addr; addr += TARGET_PAGE_SIZE) {\n\n        p = phys_page_find(addr >> TARGET_PAGE_BITS);\n\n        if (p && p->phys_offset != IO_MEM_UNASSIGNED) {\n\n            ram_addr_t orig_memory = p->phys_offset;\n\n            target_phys_addr_t start_addr2, end_addr2;\n\n            int need_subpage = 0;\n\n\n\n            CHECK_SUBPAGE(addr, start_addr, start_addr2, end_addr, end_addr2,\n\n                          need_subpage);\n\n            if (need_subpage || phys_offset & IO_MEM_SUBWIDTH) {\n\n                if (!(orig_memory & IO_MEM_SUBPAGE)) {\n\n                    subpage = subpage_init((addr & TARGET_PAGE_MASK),\n\n                                           &p->phys_offset, orig_memory,\n\n                                           p->region_offset);\n\n                } else {\n\n                    subpage = io_mem_opaque[(orig_memory & ~TARGET_PAGE_MASK)\n\n                                            >> IO_MEM_SHIFT];\n\n                }\n\n                subpage_register(subpage, start_addr2, end_addr2, phys_offset,\n\n                                 region_offset);\n\n                p->region_offset = 0;\n\n            } else {\n\n                p->phys_offset = phys_offset;\n\n                if ((phys_offset & ~TARGET_PAGE_MASK) <= IO_MEM_ROM ||\n\n                    (phys_offset & IO_MEM_ROMD))\n\n                    phys_offset += TARGET_PAGE_SIZE;\n\n            }\n\n        } else {\n\n            p = phys_page_find_alloc(addr >> TARGET_PAGE_BITS, 1);\n\n            p->phys_offset = phys_offset;\n\n            p->region_offset = region_offset;\n\n            if ((phys_offset & ~TARGET_PAGE_MASK) <= IO_MEM_ROM ||\n\n                (phys_offset & IO_MEM_ROMD)) {\n\n                phys_offset += TARGET_PAGE_SIZE;\n\n            } else {\n\n                target_phys_addr_t start_addr2, end_addr2;\n\n                int need_subpage = 0;\n\n\n\n                CHECK_SUBPAGE(addr, start_addr, start_addr2, end_addr,\n\n                              end_addr2, need_subpage);\n\n\n\n                if (need_subpage || phys_offset & IO_MEM_SUBWIDTH) {\n\n                    subpage = subpage_init((addr & TARGET_PAGE_MASK),\n\n                                           &p->phys_offset, IO_MEM_UNASSIGNED,\n\n                                           addr & TARGET_PAGE_MASK);\n\n                    subpage_register(subpage, start_addr2, end_addr2,\n\n                                     phys_offset, region_offset);\n\n                    p->region_offset = 0;\n\n                }\n\n            }\n\n        }\n\n        region_offset += TARGET_PAGE_SIZE;\n\n    }\n\n\n\n    \/* since each CPU stores ram addresses in its TLB cache, we must\n\n       reset the modified entries *\/\n\n    \/* XXX: slow ! *\/\n\n    for(env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        tlb_flush(env, 1);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884","target":0,"func":"static void char_socket_finalize(Object *obj)\n\n{\n\n    Chardev *chr = CHARDEV(obj);\n\n    SocketChardev *s = SOCKET_CHARDEV(obj);\n\n\n\n    tcp_chr_free_connection(chr);\n\n\n\n    if (s->reconnect_timer) {\n\n        g_source_remove(s->reconnect_timer);\n\n        s->reconnect_timer = 0;\n\n    }\n\n    qapi_free_SocketAddressLegacy(s->addr);\n\n    if (s->listen_tag) {\n\n        g_source_remove(s->listen_tag);\n\n        s->listen_tag = 0;\n\n    }\n\n    if (s->listen_ioc) {\n\n        object_unref(OBJECT(s->listen_ioc));\n\n    }\n\n    if (s->tls_creds) {\n\n        object_unref(OBJECT(s->tls_creds));\n\n    }\n\n\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n}\n"},{"project":"qemu","commit_id":"d7cd369402191814a1bb339a730f3af411e9682f","target":1,"func":"static void enter_migration_coroutine(void *opaque)\n\n{\n\n    Coroutine *co = opaque;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n"},{"project":"qemu","commit_id":"215e79c01c4e6f766eb9add56c56453e9ea1d948","target":0,"func":"static bool cpu_thread_is_idle(CPUState *cpu)\n\n{\n\n    if (cpu->stop || cpu->queued_work_first) {\n\n        return false;\n\n    }\n\n    if (cpu->stopped || !runstate_is_running()) {\n\n        return true;\n\n    }\n\n    if (!cpu->halted || qemu_cpu_has_work(cpu) ||\n\n        kvm_async_interrupts_enabled()) {\n\n        return false;\n\n    }\n\n    return true;\n\n}\n"},{"project":"qemu","commit_id":"c3e10c7b4377c1cbc0a4fbc12312c2cf41c0cda7","target":1,"func":"static always_inline void gen_op_subfco (void)\n\n{\n\n    gen_op_move_T2_T0();\n\n    gen_op_subf();\n\n    gen_op_check_subfc();\n\n    gen_op_check_subfo();\n\n}\n"},{"project":"qemu","commit_id":"539de1246d355d3b8aa33fb7cde732352d8827c7","target":0,"func":"static int blk_mig_save_dirty_block(Monitor *mon, QEMUFile *f, int is_async)\n\n{\n\n    BlkMigDevState *bmds;\n\n    int ret = 0;\n\n\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        if (mig_save_device_dirty(mon, f, bmds, is_async) == 0) {\n\n            ret = 1;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"5a123b3c1a1d3540d4455772c42c466870d81061","target":1,"func":"static int mmu_translate_region(CPUS390XState *env, target_ulong vaddr,\n\n                                uint64_t asc, uint64_t entry, int level,\n\n                                target_ulong *raddr, int *flags, int rw,\n\n                                bool exc)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    uint64_t origin, offs, new_entry;\n\n    const int pchks[4] = {\n\n        PGM_SEGMENT_TRANS, PGM_REG_THIRD_TRANS,\n\n        PGM_REG_SEC_TRANS, PGM_REG_FIRST_TRANS\n\n    };\n\n\n\n    PTE_DPRINTF(\"%s: 0x%\" PRIx64 \"\\n\", __func__, entry);\n\n\n\n    origin = entry & _REGION_ENTRY_ORIGIN;\n\n    offs = (vaddr >> (17 + 11 * level \/ 4)) & 0x3ff8;\n\n\n\n    new_entry = ldq_phys(cs->as, origin + offs);\n\n    PTE_DPRINTF(\"%s: 0x%\" PRIx64 \" + 0x%\" PRIx64 \" => 0x%016\" PRIx64 \"\\n\",\n\n                __func__, origin, offs, new_entry);\n\n\n\n    if ((new_entry & _REGION_ENTRY_INV) != 0) {\n\n        \/* XXX different regions have different faults *\/\n\n        DPRINTF(\"%s: invalid region\\n\", __func__);\n\n        trigger_page_fault(env, vaddr, PGM_SEGMENT_TRANS, asc, rw, exc);\n\n        return -1;\n\n    }\n\n\n\n    if ((new_entry & _REGION_ENTRY_TYPE_MASK) != level) {\n\n        trigger_page_fault(env, vaddr, PGM_TRANS_SPEC, asc, rw, exc);\n\n        return -1;\n\n    }\n\n\n\n    \/* XXX region protection flags *\/\n\n    \/* *flags &= ~PAGE_WRITE *\/\n\n\n\n    if (level == _ASCE_TYPE_SEGMENT) {\n\n        return mmu_translate_segment(env, vaddr, asc, new_entry, raddr, flags,\n\n                                     rw, exc);\n\n    }\n\n\n\n    \/* Check region table offset and length *\/\n\n    offs = (vaddr >> (28 + 11 * (level - 4) \/ 4)) & 3;\n\n    if (offs < ((new_entry & _REGION_ENTRY_TF) >> 6)\n\n        || offs > (new_entry & _REGION_ENTRY_LENGTH)) {\n\n        DPRINTF(\"%s: invalid offset or len (%lx)\\n\", __func__, new_entry);\n\n        trigger_page_fault(env, vaddr, pchks[level \/ 4 - 1], asc, rw, exc);\n\n        return -1;\n\n    }\n\n\n\n    \/* yet another region *\/\n\n    return mmu_translate_region(env, vaddr, asc, new_entry, level - 4,\n\n                                raddr, flags, rw, exc);\n\n}\n"},{"project":"qemu","commit_id":"54c16572a03e3c9c5694653361f9bfa3959fcb59","target":1,"func":"static int qcow_snapshot_create(BlockDriverState *bs,\n\n                                QEMUSnapshotInfo *sn_info)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowSnapshot *snapshots1, sn1, *sn = &sn1;\n\n    int i, ret;\n\n    uint64_t *l1_table = NULL;\n\n\n\n    memset(sn, 0, sizeof(*sn));\n\n\n\n    if (sn_info->id_str[0] == '\\0') {\n\n        \/* compute a new id *\/\n\n        find_new_snapshot_id(bs, sn_info->id_str, sizeof(sn_info->id_str));\n\n    }\n\n\n\n    \/* check that the ID is unique *\/\n\n    if (find_snapshot_by_id(bs, sn_info->id_str) >= 0)\n\n        return -ENOENT;\n\n\n\n    sn->id_str = qemu_strdup(sn_info->id_str);\n\n    if (!sn->id_str)\n\n        goto fail;\n\n    sn->name = qemu_strdup(sn_info->name);\n\n    if (!sn->name)\n\n        goto fail;\n\n    sn->vm_state_size = sn_info->vm_state_size;\n\n    sn->date_sec = sn_info->date_sec;\n\n    sn->date_nsec = sn_info->date_nsec;\n\n    sn->vm_clock_nsec = sn_info->vm_clock_nsec;\n\n\n\n    ret = update_snapshot_refcount(bs, s->l1_table_offset, s->l1_size, 1);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    \/* create the L1 table of the snapshot *\/\n\n    sn->l1_table_offset = alloc_clusters(bs, s->l1_size * sizeof(uint64_t));\n\n    sn->l1_size = s->l1_size;\n\n\n\n    l1_table = qemu_malloc(s->l1_size * sizeof(uint64_t));\n\n    if (!l1_table)\n\n        goto fail;\n\n    for(i = 0; i < s->l1_size; i++) {\n\n        l1_table[i] = cpu_to_be64(s->l1_table[i]);\n\n    }\n\n    if (bdrv_pwrite(s->hd, sn->l1_table_offset,\n\n                    l1_table, s->l1_size * sizeof(uint64_t)) !=\n\n        (s->l1_size * sizeof(uint64_t)))\n\n        goto fail;\n\n    qemu_free(l1_table);\n\n    l1_table = NULL;\n\n\n\n    snapshots1 = qemu_malloc((s->nb_snapshots + 1) * sizeof(QCowSnapshot));\n\n    if (!snapshots1)\n\n        goto fail;\n\n    memcpy(snapshots1, s->snapshots, s->nb_snapshots * sizeof(QCowSnapshot));\n\n\n    s->snapshots = snapshots1;\n\n    s->snapshots[s->nb_snapshots++] = *sn;\n\n\n\n    if (qcow_write_snapshots(bs) < 0)\n\n        goto fail;\n\n#ifdef DEBUG_ALLOC\n\n    check_refcounts(bs);\n\n#endif\n\n    return 0;\n\n fail:\n\n    qemu_free(sn->name);\n\n    qemu_free(l1_table);\n\n    return -1;\n\n}"},{"project":"qemu","commit_id":"b4049b74b97f30fe944c63b5f158ec9e87bd2593","target":0,"func":"void qemu_register_clock_reset_notifier(QEMUClock *clock,\n\n                                        Notifier *notifier)\n\n{\n\n    qemu_clock_register_reset_notifier(clock->type, notifier);\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void sysctl_write(void *opaque, target_phys_addr_t addr, uint64_t value,\n\n                         unsigned size)\n\n{\n\n    MilkymistSysctlState *s = opaque;\n\n\n\n    trace_milkymist_sysctl_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_GPIO_OUT:\n\n    case R_GPIO_INTEN:\n\n    case R_TIMER0_COUNTER:\n\n    case R_TIMER1_COUNTER:\n\n    case R_DBG_SCRATCHPAD:\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER0_COMPARE:\n\n        ptimer_set_limit(s->ptimer0, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER1_COMPARE:\n\n        ptimer_set_limit(s->ptimer1, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER0_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER0_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer0();\n\n            ptimer_set_count(s->ptimer0,\n\n                    s->regs[R_TIMER0_COMPARE] - s->regs[R_TIMER0_COUNTER]);\n\n            ptimer_run(s->ptimer0, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer0();\n\n            ptimer_stop(s->ptimer0);\n\n        }\n\n        break;\n\n    case R_TIMER1_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER1_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_set_count(s->ptimer1,\n\n                    s->regs[R_TIMER1_COMPARE] - s->regs[R_TIMER1_COUNTER]);\n\n            ptimer_run(s->ptimer1, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer1);\n\n        }\n\n        break;\n\n    case R_ICAP:\n\n        sysctl_icap_write(s, value);\n\n        break;\n\n    case R_DBG_WRITE_LOCK:\n\n        s->regs[addr] = 1;\n\n        break;\n\n    case R_SYSTEM_ID:\n\n        qemu_system_reset_request();\n\n        break;\n\n\n\n    case R_GPIO_IN:\n\n    case R_CLK_FREQUENCY:\n\n    case R_CAPABILITIES:\n\n        error_report(\"milkymist_sysctl: write to read-only register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_sysctl: write access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"258dc7c96bb4b7ca71d5bee811e73933310e168c","target":1,"func":"int virtio_load(VirtIODevice *vdev, QEMUFile *f)\n\n{\n\n    int num, i, ret;\n\n    uint32_t features;\n\n    uint32_t supported_features =\n\n        vdev->binding->get_features(vdev->binding_opaque);\n\n\n\n\n    if (vdev->binding->load_config) {\n\n        ret = vdev->binding->load_config(vdev->binding_opaque, f);\n\n        if (ret)\n\n            return ret;\n\n    }\n\n\n\n    qemu_get_8s(f, &vdev->status);\n\n    qemu_get_8s(f, &vdev->isr);\n\n    qemu_get_be16s(f, &vdev->queue_sel);\n\n    qemu_get_be32s(f, &features);\n\n    if (features & ~supported_features) {\n\n        fprintf(stderr, \"Features 0x%x unsupported. Allowed features: 0x%x\\n\",\n\n                features, supported_features);\n\n        return -1;\n\n    }\n\n    if (vdev->set_features)\n\n        vdev->set_features(vdev, features);\n\n    vdev->guest_features = features;\n\n    vdev->config_len = qemu_get_be32(f);\n\n    qemu_get_buffer(f, vdev->config, vdev->config_len);\n\n\n\n    num = qemu_get_be32(f);\n\n\n\n    for (i = 0; i < num; i++) {\n\n        vdev->vq[i].vring.num = qemu_get_be32(f);\n\n        vdev->vq[i].pa = qemu_get_be64(f);\n\n        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);\n\n\n\n        if (vdev->vq[i].pa) {\n\n            virtqueue_init(&vdev->vq[i]);\n\n        }\n\n\tnum_heads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;\n\n\t\/* Check it isn't doing very strange things with descriptor numbers. *\/\n\n\tif (num_heads > vdev->vq[i].vring.num) {\n\n\t\tfprintf(stderr, \"VQ %d size 0x%x Guest index 0x%x \"\n\n                        \"inconsistent with Host index 0x%x: delta 0x%x\\n\",\n\n\t\t\ti, vdev->vq[i].vring.num,\n\n                        vring_avail_idx(&vdev->vq[i]),\n\n                        vdev->vq[i].last_avail_idx, num_heads);\n\n\t\treturn -1;\n\n\t}\n\n        if (vdev->binding->load_queue) {\n\n            ret = vdev->binding->load_queue(vdev->binding_opaque, i, f);\n\n            if (ret)\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);\n\n    return 0;\n\n}"},{"project":"qemu","commit_id":"7860a380ac2a9fd09a6e8f31fd9db5318fc91285","target":0,"func":"static void nbd_accept(void *opaque)\n\n{\n\n    int server_fd = (uintptr_t) opaque;\n\n    struct sockaddr_in addr;\n\n    socklen_t addr_len = sizeof(addr);\n\n\n\n    int fd = accept(server_fd, (struct sockaddr *)&addr, &addr_len);\n\n    nbd_started = true;\n\n    if (fd >= 0 && nbd_client_new(exp, fd, nbd_client_closed)) {\n\n        nb_fds++;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"1931e26054fdf2b1b84091f0b9662979eb6931ec","target":0,"func":"static void gt64120_write_config(PCIDevice *d, uint32_t address, uint32_t val,\n\n                                 int len)\n\n{\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n    pci_default_write_config(d, address, val, len);\n\n}\n"},{"project":"qemu","commit_id":"f51074cdc6e750daa3b6df727d83449a7e42b391","target":1,"func":"static int pci_device_hot_remove(Monitor *mon, const char *pci_addr)\n\n{\n\n    PCIBus *root = pci_find_primary_bus();\n\n    PCIDevice *d;\n\n    int bus;\n\n    unsigned slot;\n\n    Error *local_err = NULL;\n\n\n\n    if (!root) {\n\n        monitor_printf(mon, \"no primary PCI bus (if there are multiple\"\n\n                       \" PCI roots, you must use device_del instead)\");\n\n        return -1;\n\n    }\n\n\n\n    if (pci_read_devaddr(mon, pci_addr, &bus, &slot)) {\n\n        return -1;\n\n    }\n\n\n\n    d = pci_find_device(root, bus, PCI_DEVFN(slot, 0));\n\n    if (!d) {\n\n        monitor_printf(mon, \"slot %d empty\\n\", slot);\n\n        return -1;\n\n    }\n\n\n\n    qdev_unplug(&d->qdev, &local_err);\n\n    if (local_err) {\n\n        monitor_printf(mon, \"%s\\n\", error_get_pretty(local_err));\n\n        error_free(local_err);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"ac531cb6e542b1e61d668604adf9dc5306a948c0","target":0,"func":"START_TEST(qdict_del_test)\n\n{\n\n    const char *key = \"key test\";\n\n\n\n    qdict_put(tests_dict, key, qstring_from_str(\"foo\"));\n\n    fail_unless(qdict_size(tests_dict) == 1);\n\n\n\n    qdict_del(tests_dict, key);\n\n\n\n    fail_unless(qdict_size(tests_dict) == 0);\n\n    fail_unless(qdict_haskey(tests_dict, key) == 0);\n\n}\n"},{"project":"qemu","commit_id":"a89f364ae8740dfc31b321eed9ee454e996dc3c1","target":0,"func":"static uint64_t pxa2xx_i2s_read(void *opaque, hwaddr addr,\n\n                                unsigned size)\n\n{\n\n    PXA2xxI2SState *s = (PXA2xxI2SState *) opaque;\n\n\n\n    switch (addr) {\n\n    case SACR0:\n\n        return s->control[0];\n\n    case SACR1:\n\n        return s->control[1];\n\n    case SASR0:\n\n        return s->status;\n\n    case SAIMR:\n\n        return s->mask;\n\n    case SAICR:\n\n        return 0;\n\n    case SADIV:\n\n        return s->clk;\n\n    case SADR:\n\n        if (s->rx_len > 0) {\n\n            s->rx_len --;\n\n            pxa2xx_i2s_update(s);\n\n            return s->codec_in(s->opaque);\n\n        }\n\n        return 0;\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"ef76dc59fa5203d146a2acf85a0ad5a5971a4824","target":0,"func":"START_TEST(empty_input)\n\n{\n\n    const char *empty = \"\";\n\n\n\n    QObject *obj = qobject_from_json(empty);\n\n    fail_unless(obj == NULL);\n\n}\n"},{"project":"qemu","commit_id":"7e09797c299712cafa7bc05dd57c1b13afcc6039","target":1,"func":"static uint64_t pmsav5_data_ap_read(CPUARMState *env, const ARMCPRegInfo *ri)\n\n{\n\n    return simple_mpu_ap_bits(env->cp15.c5_data);\n\n}\n"},{"project":"qemu","commit_id":"9456c2fbcd82dd82328ac6e7602a815582b1043e","target":0,"func":"void r4k_helper_tlbp(CPUMIPSState *env)\n\n{\n\n    r4k_tlb_t *tlb;\n\n    target_ulong mask;\n\n    target_ulong tag;\n\n    target_ulong VPN;\n\n    uint8_t ASID;\n\n    int i;\n\n\n\n    ASID = env->CP0_EntryHi & 0xFF;\n\n    for (i = 0; i < env->tlb->nb_tlb; i++) {\n\n        tlb = &env->tlb->mmu.r4k.tlb[i];\n\n        \/* 1k pages are not supported. *\/\n\n        mask = tlb->PageMask | ~(TARGET_PAGE_MASK << 1);\n\n        tag = env->CP0_EntryHi & ~mask;\n\n        VPN = tlb->VPN & ~mask;\n\n#if defined(TARGET_MIPS64)\n\n        tag &= env->SEGMask;\n\n#endif\n\n        \/* Check ASID, virtual page number & size *\/\n\n        if ((tlb->G == 1 || tlb->ASID == ASID) && VPN == tag) {\n\n            \/* TLB match *\/\n\n            env->CP0_Index = i;\n\n            break;\n\n        }\n\n    }\n\n    if (i == env->tlb->nb_tlb) {\n\n        \/* No match.  Discard any shadow entries, if any of them match.  *\/\n\n        for (i = env->tlb->nb_tlb; i < env->tlb->tlb_in_use; i++) {\n\n            tlb = &env->tlb->mmu.r4k.tlb[i];\n\n            \/* 1k pages are not supported. *\/\n\n            mask = tlb->PageMask | ~(TARGET_PAGE_MASK << 1);\n\n            tag = env->CP0_EntryHi & ~mask;\n\n            VPN = tlb->VPN & ~mask;\n\n#if defined(TARGET_MIPS64)\n\n            tag &= env->SEGMask;\n\n#endif\n\n            \/* Check ASID, virtual page number & size *\/\n\n            if ((tlb->G == 1 || tlb->ASID == ASID) && VPN == tag) {\n\n                r4k_mips_tlb_flush_extra (env, i);\n\n                break;\n\n            }\n\n        }\n\n\n\n        env->CP0_Index |= 0x80000000;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"06b106889a09277617fc8c542397a9f595ee605a","target":1,"func":"static inline bool migration_bitmap_clear_dirty(RAMState *rs, ram_addr_t addr)\n\n{\n\n    bool ret;\n\n    int nr = addr >> TARGET_PAGE_BITS;\n\n    unsigned long *bitmap = atomic_rcu_read(&rs->ram_bitmap)->bmap;\n\n\n\n    ret = test_and_clear_bit(nr, bitmap);\n\n\n\n    if (ret) {\n\n        rs->migration_dirty_pages--;\n\n    }\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"f7c11b535040df31cc8bc3b1f0c33f546073ee62","target":0,"func":"void cpu_physical_memory_unmap(void *buffer, target_phys_addr_t len,\n\n                               int is_write, target_phys_addr_t access_len)\n\n{\n\n    if (buffer != bounce.buffer) {\n\n        if (is_write) {\n\n            ram_addr_t addr1 = qemu_ram_addr_from_host(buffer);\n\n            while (access_len) {\n\n                unsigned l;\n\n                l = TARGET_PAGE_SIZE;\n\n                if (l > access_len)\n\n                    l = access_len;\n\n                if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                    \/* invalidate code *\/\n\n                    tb_invalidate_phys_page_range(addr1, addr1 + l, 0);\n\n                    \/* set dirty bit *\/\n\n                    phys_ram_dirty[addr1 >> TARGET_PAGE_BITS] |=\n\n                        (0xff & ~CODE_DIRTY_FLAG);\n\n                }\n\n                addr1 += l;\n\n                access_len -= l;\n\n            }\n\n        }\n\n        return;\n\n    }\n\n    if (is_write) {\n\n        cpu_physical_memory_write(bounce.addr, bounce.buffer, access_len);\n\n    }\n\n    qemu_vfree(bounce.buffer);\n\n    bounce.buffer = NULL;\n\n    cpu_notify_map_clients();\n\n}\n"},{"project":"qemu","commit_id":"44b6789299a8acca3f25331bc411055cafc7bb06","target":1,"func":"static void blkverify_aio_cb(void *opaque, int ret)\n\n{\n\n    BlkverifyAIOCB *acb = opaque;\n\n\n\n    switch (++acb->done) {\n\n    case 1:\n\n        acb->ret = ret;\n\n        break;\n\n\n\n    case 2:\n\n        if (acb->ret != ret) {\n\n            blkverify_err(acb, \"return value mismatch %d != %d\", acb->ret, ret);\n\n        }\n\n\n\n        if (acb->verify) {\n\n            acb->verify(acb);\n\n        }\n\n\n\n        aio_bh_schedule_oneshot(bdrv_get_aio_context(acb->common.bs),\n\n                                blkverify_aio_bh, acb);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"void stq_phys(target_phys_addr_t addr, uint64_t val)\n\n{\n\n    val = tswap64(val);\n\n    cpu_physical_memory_write(addr, &val, 8);\n\n}\n"},{"project":"qemu","commit_id":"7364dbdabb7824d5bde1e341bb6d928282f01c83","target":1,"func":"static int protocol_client_auth_vnc(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    unsigned char response[VNC_AUTH_CHALLENGE_SIZE];\n\n    size_t i, pwlen;\n\n    unsigned char key[8];\n\n    time_t now = time(NULL);\n\n    QCryptoCipher *cipher = NULL;\n\n    Error *err = NULL;\n\n\n\n    if (!vs->vd->password) {\n\n        VNC_DEBUG(\"No password configured on server\");\n\n        goto reject;\n\n    }\n\n    if (vs->vd->expires < now) {\n\n        VNC_DEBUG(\"Password is expired\");\n\n        goto reject;\n\n    }\n\n\n\n    memcpy(response, vs->challenge, VNC_AUTH_CHALLENGE_SIZE);\n\n\n\n    \/* Calculate the expected challenge response *\/\n\n    pwlen = strlen(vs->vd->password);\n\n    for (i=0; i<sizeof(key); i++)\n\n        key[i] = i<pwlen ? vs->vd->password[i] : 0;\n\n\n\n    cipher = qcrypto_cipher_new(\n\n        QCRYPTO_CIPHER_ALG_DES_RFB,\n\n        QCRYPTO_CIPHER_MODE_ECB,\n\n        key, G_N_ELEMENTS(key),\n\n        &err);\n\n    if (!cipher) {\n\n        VNC_DEBUG(\"Cannot initialize cipher %s\",\n\n                  error_get_pretty(err));\n\n        error_free(err);\n\n        goto reject;\n\n    }\n\n\n\n    if (qcrypto_cipher_encrypt(cipher,\n\n                               vs->challenge,\n\n                               response,\n\n                               VNC_AUTH_CHALLENGE_SIZE,\n\n                               &err) < 0) {\n\n        VNC_DEBUG(\"Cannot encrypt challenge %s\",\n\n                  error_get_pretty(err));\n\n        error_free(err);\n\n        goto reject;\n\n    }\n\n\n\n    \/* Compare expected vs actual challenge response *\/\n\n    if (memcmp(response, data, VNC_AUTH_CHALLENGE_SIZE) != 0) {\n\n        VNC_DEBUG(\"Client challenge response did not match\\n\");\n\n        goto reject;\n\n    } else {\n\n        VNC_DEBUG(\"Accepting VNC challenge response\\n\");\n\n        vnc_write_u32(vs, 0); \/* Accept auth *\/\n\n        vnc_flush(vs);\n\n\n\n        start_client_init(vs);\n\n    }\n\n\n\n    qcrypto_cipher_free(cipher);\n\n    return 0;\n\n\n\nreject:\n\n    vnc_write_u32(vs, 1); \/* Reject auth *\/\n\n    if (vs->minor >= 8) {\n\n        static const char err[] = \"Authentication failed\";\n\n        vnc_write_u32(vs, sizeof(err));\n\n        vnc_write(vs, err, sizeof(err));\n\n    }\n\n    vnc_flush(vs);\n\n    vnc_client_error(vs);\n\n    qcrypto_cipher_free(cipher);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"297a3646c2947ee64a6d42ca264039732c6218e0","target":1,"func":"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_int(v, obj, name, errp);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"cd245a19329edfcd968b00d05ad92de7a0e2daa1","target":1,"func":"void *qemu_vmalloc(size_t size)\n\n{\n\n    \/* FIXME: this is not exactly optimal solution since VirtualAlloc\n\n       has 64Kb granularity, but at least it guarantees us that the\n\n       memory is page aligned. *\/\n\n    if (!size) {\n\n        abort();\n\n    }\n\n    return oom_check(VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE));\n\n}\n"},{"project":"qemu","commit_id":"fbb7b4e0804d2168f24142eebf7552adde1968dc","target":1,"func":"static int bdrv_check_byte_request(BlockDriverState *bs, int64_t offset,\n\n                                   size_t size)\n\n{\n\n    int64_t len;\n\n\n\n    if (!bdrv_is_inserted(bs))\n\n        return -ENOMEDIUM;\n\n\n\n    if (bs->growable)\n\n        return 0;\n\n\n\n    len = bdrv_getlength(bs);\n\n\n\n    if ((offset + size) > len)\n\n        return -EIO;\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"03ecd2c80a64d030a22fe67cc7a60f24e17ff211","target":0,"func":"static void handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOSerial *vser;\n\n    VirtIOSerialPort *port;\n\n    VirtIOSerialPortInfo *info;\n\n\n\n    vser = DO_UPCAST(VirtIOSerial, vdev, vdev);\n\n    port = find_port_by_vq(vser, vq);\n\n    info = port ? DO_UPCAST(VirtIOSerialPortInfo, qdev, port->dev.info) : NULL;\n\n\n\n    if (!port || !port->host_connected || !info->have_data) {\n\n        discard_vq_data(vq, vdev);\n\n        return;\n\n    }\n\n\n\n    if (!port->throttled) {\n\n        do_flush_queued_data(port, vq, vdev);\n\n        return;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"80fa3341a70151d250be92ae900e3c1580817540","target":1,"func":"int qcow2_check_refcounts(BlockDriverState *bs, BdrvCheckResult *res)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t size;\n\n    int nb_clusters, refcount1, refcount2, i;\n\n    QCowSnapshot *sn;\n\n    uint16_t *refcount_table;\n\n    int ret;\n\n\n\n    size = bdrv_getlength(bs->file);\n\n    nb_clusters = size_to_clusters(s, size);\n\n    refcount_table = qemu_mallocz(nb_clusters * sizeof(uint16_t));\n\n\n\n    \/* header *\/\n\n    inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n        0, s->cluster_size);\n\n\n\n    \/* current L1 table *\/\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                       s->l1_table_offset, s->l1_size, 1);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* snapshots *\/\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n            sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n        s->snapshots_offset, s->snapshots_size);\n\n\n\n    \/* refcount data *\/\n\n    inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n        s->refcount_table_offset,\n\n        s->refcount_table_size * sizeof(uint64_t));\n\n\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        uint64_t offset, cluster;\n\n        offset = s->refcount_table[i];\n\n        cluster = offset >> s->cluster_bits;\n\n\n\n        \/* Refcount blocks are cluster aligned *\/\n\n        if (offset & (s->cluster_size - 1)) {\n\n            fprintf(stderr, \"ERROR refcount block %d is not \"\n\n                \"cluster aligned; refcount table entry corrupted\\n\", i);\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n\n\n        if (cluster >= nb_clusters) {\n\n            fprintf(stderr, \"ERROR refcount block %d is outside image\\n\", i);\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n\n\n        if (offset != 0) {\n\n            inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                offset, s->cluster_size);\n\n            if (refcount_table[cluster] != 1) {\n\n                fprintf(stderr, \"ERROR refcount block %d refcount=%d\\n\",\n\n                    i, refcount_table[cluster]);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n\n\n    \/* compare ref counts *\/\n\n    for(i = 0; i < nb_clusters; i++) {\n\n        refcount1 = get_refcount(bs, i);\n\n        if (refcount1 < 0) {\n\n            fprintf(stderr, \"Can't get refcount for cluster %d: %s\\n\",\n\n                i, strerror(-refcount1));\n\n            res->check_errors++;\n\n            continue;\n\n        }\n\n\n\n        refcount2 = refcount_table[i];\n\n        if (refcount1 != refcount2) {\n\n            fprintf(stderr, \"%s cluster %d refcount=%d reference=%d\\n\",\n\n                   refcount1 < refcount2 ? \"ERROR\" : \"Leaked\",\n\n                   i, refcount1, refcount2);\n\n            if (refcount1 < refcount2) {\n\n                res->corruptions++;\n\n            } else {\n\n                res->leaks++;\n\n            }\n\n        }\n\n    }\n\n\n\n    qemu_free(refcount_table);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"dd673288a8ff73ad77fcc1c255486d2466a772e1","target":0,"func":"void kvm_arch_reset_vcpu(CPUX86State *env)\n\n{\n\n    env->exception_injected = -1;\n\n    env->interrupt_injected = -1;\n\n    env->xcr0 = 1;\n\n    if (kvm_irqchip_in_kernel()) {\n\n        env->mp_state = cpu_is_bsp(env) ? KVM_MP_STATE_RUNNABLE :\n\n                                          KVM_MP_STATE_UNINITIALIZED;\n\n    } else {\n\n        env->mp_state = KVM_MP_STATE_RUNNABLE;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"2bcf018340cbf233f7145e643fc1bb367f23fd90","target":0,"func":"uint32_t HELPER(testblock)(CPUS390XState *env, uint64_t real_addr)\n\n{\n\n    uintptr_t ra = GETPC();\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    int i;\n\n\n\n    real_addr = wrap_address(env, real_addr) & TARGET_PAGE_MASK;\n\n\n\n    \/* Check low-address protection *\/\n\n    if ((env->cregs[0] & CR0_LOWPROT) && real_addr < 0x2000) {\n\n        cpu_restore_state(cs, ra);\n\n        program_interrupt(env, PGM_PROTECTION, 4);\n\n        return 1;\n\n    }\n\n\n\n    for (i = 0; i < TARGET_PAGE_SIZE; i += 8) {\n\n        cpu_stq_real_ra(env, real_addr + i, 0, ra);\n\n    }\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"b14ef7c9ab41ea824c3ccadb070ad95567cca84e","target":1,"func":"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem read \" TARGET_FMT_plx \"\\n\", addr);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 0, 0, 0, 4);\n\n#endif\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"6687b79d636cd60ed9adb1177d0d946b58fa7717","target":1,"func":"int net_init_socket(QemuOpts *opts, const char *name, VLANState *vlan)\n\n{\n\n    if (qemu_opt_get(opts, \"fd\")) {\n\n        int fd;\n\n\n\n        if (qemu_opt_get(opts, \"listen\") ||\n\n            qemu_opt_get(opts, \"connect\") ||\n\n            qemu_opt_get(opts, \"mcast\") ||\n\n            qemu_opt_get(opts, \"localaddr\")) {\n\n            error_report(\"listen=, connect=, mcast= and localaddr= is invalid with fd=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_handle_fd_param(cur_mon, qemu_opt_get(opts, \"fd\"));\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        if (!net_socket_fd_init(vlan, \"socket\", name, fd, 1)) {\n\n            return -1;\n\n        }\n\n    } else if (qemu_opt_get(opts, \"listen\")) {\n\n        const char *listen;\n\n\n\n        if (qemu_opt_get(opts, \"fd\") ||\n\n            qemu_opt_get(opts, \"connect\") ||\n\n            qemu_opt_get(opts, \"mcast\") ||\n\n            qemu_opt_get(opts, \"localaddr\")) {\n\n            error_report(\"fd=, connect=, mcast= and localaddr= is invalid with listen=\");\n\n            return -1;\n\n        }\n\n\n\n        listen = qemu_opt_get(opts, \"listen\");\n\n\n\n        if (net_socket_listen_init(vlan, \"socket\", name, listen) == -1) {\n\n            return -1;\n\n        }\n\n    } else if (qemu_opt_get(opts, \"connect\")) {\n\n        const char *connect;\n\n\n\n        if (qemu_opt_get(opts, \"fd\") ||\n\n            qemu_opt_get(opts, \"listen\") ||\n\n            qemu_opt_get(opts, \"mcast\") ||\n\n            qemu_opt_get(opts, \"localaddr\")) {\n\n            error_report(\"fd=, listen=, mcast= and localaddr= is invalid with connect=\");\n\n            return -1;\n\n        }\n\n\n\n        connect = qemu_opt_get(opts, \"connect\");\n\n\n\n        if (net_socket_connect_init(vlan, \"socket\", name, connect) == -1) {\n\n            return -1;\n\n        }\n\n    } else if (qemu_opt_get(opts, \"mcast\")) {\n\n        const char *mcast, *localaddr;\n\n\n\n        if (qemu_opt_get(opts, \"fd\") ||\n\n            qemu_opt_get(opts, \"connect\") ||\n\n            qemu_opt_get(opts, \"listen\")) {\n\n            error_report(\"fd=, connect= and listen= is invalid with mcast=\");\n\n            return -1;\n\n        }\n\n\n\n        mcast = qemu_opt_get(opts, \"mcast\");\n\n        localaddr = qemu_opt_get(opts, \"localaddr\");\n\n\n\n        if (net_socket_mcast_init(vlan, \"socket\", name, mcast, localaddr) == -1) {\n\n            return -1;\n\n        }\n\n    } else if (qemu_opt_get(opts, \"udp\")) {\n\n        const char *udp, *localaddr;\n\n\n\n        if (qemu_opt_get(opts, \"fd\") ||\n\n            qemu_opt_get(opts, \"connect\") ||\n\n            qemu_opt_get(opts, \"listen\") ||\n\n            qemu_opt_get(opts, \"mcast\")) {\n\n            error_report(\"fd=, connect=, listen=\"\n\n                         \" and mcast= is invalid with udp=\");\n\n            return -1;\n\n        }\n\n\n\n        udp = qemu_opt_get(opts, \"udp\");\n\n        localaddr = qemu_opt_get(opts, \"localaddr\");\n\n        if (localaddr == NULL) {\n\n                error_report(\"localaddr= is mandatory with udp=\");\n\n                return -1;\n\n        }\n\n\n\n        if (net_socket_udp_init(vlan, \"udp\", name, udp, localaddr) == -1) {\n\n            return -1;\n\n        }\n\n    } else {\n\n        error_report(\"-socket requires fd=, listen=,\"\n\n                     \" connect=, mcast= or udp=\");\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"8786db7cb96f8ce5c75c6e1e074319c9dca8d356","target":1,"func":"void set_system_memory_map(MemoryRegion *mr)\n\n{\n\n    memory_region_transaction_begin();\n\n    address_space_memory.root = mr;\n\n    memory_region_transaction_commit();\n\n}\n"},{"project":"qemu","commit_id":"973cbd37ce6d4c33dea7f4ed6b8e0e602fa50d25","target":0,"func":"void net_cleanup(void)\n\n{\n\n    VLANState *vlan;\n\n\n\n#if !defined(_WIN32)\n\n    \/* close network clients *\/\n\n    for(vlan = first_vlan; vlan != NULL; vlan = vlan->next) {\n\n        VLANClientState *vc;\n\n\n\n        for(vc = vlan->first_client; vc != NULL; vc = vc->next) {\n\n            if (vc->fd_read == tap_receive) {\n\n                char ifname[64];\n\n                TAPState *s = vc->opaque;\n\n\n\n                if (strcmp(vc->model, \"tap\") == 0 &&\n\n                    sscanf(vc->info_str, \"ifname=%63s \", ifname) == 1 &&\n\n                    s->down_script[0])\n\n                    launch_script(s->down_script, ifname, s->fd);\n\n            }\n\n#if defined(CONFIG_VDE)\n\n            if (vc->fd_read == vde_from_qemu) {\n\n                VDEState *s = vc->opaque;\n\n                vde_close(s->vde);\n\n            }\n\n#endif\n\n        }\n\n    }\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"struct omap_mpu_state_s *omap2420_mpu_init(MemoryRegion *sysmem,\n\n                unsigned long sdram_size,\n\n                const char *core)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)\n\n            g_malloc0(sizeof(struct omap_mpu_state_s));\n\n    qemu_irq dma_irqs[4];\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    SysBusDevice *busdev;\n\n    struct omap_target_agent_s *ta;\n\n\n\n    \/* Core *\/\n\n    s->mpu_model = omap2420;\n\n    s->cpu = cpu_arm_init(core ?: \"arm1136-r2\");\n\n    if (s->cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->sdram_size = sdram_size;\n\n    s->sram_size = OMAP242X_SRAM_SIZE;\n\n\n\n    s->wakeup = qemu_allocate_irq(omap_mpu_wakeup, s, 0);\n\n\n\n    \/* Clocks *\/\n\n    omap_clk_init(s);\n\n\n\n    \/* Memory-mapped stuff *\/\n\n    memory_region_init_ram(&s->sdram, NULL, \"omap2.dram\", s->sdram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->sdram);\n\n    memory_region_add_subregion(sysmem, OMAP2_Q2_BASE, &s->sdram);\n\n    memory_region_init_ram(&s->sram, NULL, \"omap2.sram\", s->sram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->sram);\n\n    memory_region_add_subregion(sysmem, OMAP2_SRAM_BASE, &s->sram);\n\n\n\n    s->l4 = omap_l4_init(sysmem, OMAP2_L4_BASE, 54);\n\n\n\n    \/* Actually mapped at any 2K boundary in the ARM11 private-peripheral if *\/\n\n    s->ih[0] = qdev_create(NULL, \"omap2-intc\");\n\n    qdev_prop_set_uint8(s->ih[0], \"revision\", 0x21);\n\n    qdev_prop_set_ptr(s->ih[0], \"fclk\", omap_findclk(s, \"mpu_intc_fclk\"));\n\n    qdev_prop_set_ptr(s->ih[0], \"iclk\", omap_findclk(s, \"mpu_intc_iclk\"));\n\n    qdev_init_nofail(s->ih[0]);\n\n    busdev = SYS_BUS_DEVICE(s->ih[0]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_IRQ));\n\n    sysbus_connect_irq(busdev, 1,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_FIQ));\n\n    sysbus_mmio_map(busdev, 0, 0x480fe000);\n\n    s->prcm = omap_prcm_init(omap_l4tao(s->l4, 3),\n\n                             qdev_get_gpio_in(s->ih[0],\n\n                                              OMAP_INT_24XX_PRCM_MPU_IRQ),\n\n                             NULL, NULL, s);\n\n\n\n    s->sysc = omap_sysctl_init(omap_l4tao(s->l4, 1),\n\n                    omap_findclk(s, \"omapctrl_iclk\"), s);\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        dma_irqs[i] = qdev_get_gpio_in(s->ih[omap2_dma_irq_map[i].ih],\n\n                                       omap2_dma_irq_map[i].intr);\n\n    }\n\n    s->dma = omap_dma4_init(0x48056000, dma_irqs, sysmem, s, 256, 32,\n\n                    omap_findclk(s, \"sdma_iclk\"),\n\n                    omap_findclk(s, \"sdma_fclk\"));\n\n    s->port->addr_valid = omap2_validate_addr;\n\n\n\n    \/* Register SDRAM and SRAM ports for fast DMA transfers.  *\/\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->sdram),\n\n                         OMAP2_Q2_BASE, s->sdram_size);\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->sram),\n\n                         OMAP2_SRAM_BASE, s->sram_size);\n\n\n\n    s->uart[0] = omap2_uart_init(sysmem, omap_l4ta(s->l4, 19),\n\n                                 qdev_get_gpio_in(s->ih[0],\n\n                                                  OMAP_INT_24XX_UART1_IRQ),\n\n                    omap_findclk(s, \"uart1_fclk\"),\n\n                    omap_findclk(s, \"uart1_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART1_TX],\n\n                    s->drq[OMAP24XX_DMA_UART1_RX],\n\n                    \"uart1\",\n\n                    serial_hds[0]);\n\n    s->uart[1] = omap2_uart_init(sysmem, omap_l4ta(s->l4, 20),\n\n                                 qdev_get_gpio_in(s->ih[0],\n\n                                                  OMAP_INT_24XX_UART2_IRQ),\n\n                    omap_findclk(s, \"uart2_fclk\"),\n\n                    omap_findclk(s, \"uart2_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART2_TX],\n\n                    s->drq[OMAP24XX_DMA_UART2_RX],\n\n                    \"uart2\",\n\n                    serial_hds[0] ? serial_hds[1] : NULL);\n\n    s->uart[2] = omap2_uart_init(sysmem, omap_l4ta(s->l4, 21),\n\n                                 qdev_get_gpio_in(s->ih[0],\n\n                                                  OMAP_INT_24XX_UART3_IRQ),\n\n                    omap_findclk(s, \"uart3_fclk\"),\n\n                    omap_findclk(s, \"uart3_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART3_TX],\n\n                    s->drq[OMAP24XX_DMA_UART3_RX],\n\n                    \"uart3\",\n\n                    serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);\n\n\n\n    s->gptimer[0] = omap_gp_timer_init(omap_l4ta(s->l4, 7),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER1),\n\n                    omap_findclk(s, \"wu_gpt1_clk\"),\n\n                    omap_findclk(s, \"wu_l4_iclk\"));\n\n    s->gptimer[1] = omap_gp_timer_init(omap_l4ta(s->l4, 8),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER2),\n\n                    omap_findclk(s, \"core_gpt2_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[2] = omap_gp_timer_init(omap_l4ta(s->l4, 22),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER3),\n\n                    omap_findclk(s, \"core_gpt3_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[3] = omap_gp_timer_init(omap_l4ta(s->l4, 23),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER4),\n\n                    omap_findclk(s, \"core_gpt4_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[4] = omap_gp_timer_init(omap_l4ta(s->l4, 24),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER5),\n\n                    omap_findclk(s, \"core_gpt5_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[5] = omap_gp_timer_init(omap_l4ta(s->l4, 25),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER6),\n\n                    omap_findclk(s, \"core_gpt6_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[6] = omap_gp_timer_init(omap_l4ta(s->l4, 26),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER7),\n\n                    omap_findclk(s, \"core_gpt7_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[7] = omap_gp_timer_init(omap_l4ta(s->l4, 27),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER8),\n\n                    omap_findclk(s, \"core_gpt8_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[8] = omap_gp_timer_init(omap_l4ta(s->l4, 28),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER9),\n\n                    omap_findclk(s, \"core_gpt9_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[9] = omap_gp_timer_init(omap_l4ta(s->l4, 29),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER10),\n\n                    omap_findclk(s, \"core_gpt10_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[10] = omap_gp_timer_init(omap_l4ta(s->l4, 30),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER11),\n\n                    omap_findclk(s, \"core_gpt11_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[11] = omap_gp_timer_init(omap_l4ta(s->l4, 31),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPTIMER12),\n\n                    omap_findclk(s, \"core_gpt12_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    omap_tap_init(omap_l4ta(s->l4, 2), s);\n\n\n\n    s->synctimer = omap_synctimer_init(omap_l4tao(s->l4, 2), s,\n\n                    omap_findclk(s, \"clk32-kHz\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    s->i2c[0] = qdev_create(NULL, \"omap_i2c\");\n\n    qdev_prop_set_uint8(s->i2c[0], \"revision\", 0x34);\n\n    qdev_prop_set_ptr(s->i2c[0], \"iclk\", omap_findclk(s, \"i2c1.iclk\"));\n\n    qdev_prop_set_ptr(s->i2c[0], \"fclk\", omap_findclk(s, \"i2c1.fclk\"));\n\n    qdev_init_nofail(s->i2c[0]);\n\n    busdev = SYS_BUS_DEVICE(s->i2c[0]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_I2C1_IRQ));\n\n    sysbus_connect_irq(busdev, 1, s->drq[OMAP24XX_DMA_I2C1_TX]);\n\n    sysbus_connect_irq(busdev, 2, s->drq[OMAP24XX_DMA_I2C1_RX]);\n\n    sysbus_mmio_map(busdev, 0, omap_l4_region_base(omap_l4tao(s->l4, 5), 0));\n\n\n\n    s->i2c[1] = qdev_create(NULL, \"omap_i2c\");\n\n    qdev_prop_set_uint8(s->i2c[1], \"revision\", 0x34);\n\n    qdev_prop_set_ptr(s->i2c[1], \"iclk\", omap_findclk(s, \"i2c2.iclk\"));\n\n    qdev_prop_set_ptr(s->i2c[1], \"fclk\", omap_findclk(s, \"i2c2.fclk\"));\n\n    qdev_init_nofail(s->i2c[1]);\n\n    busdev = SYS_BUS_DEVICE(s->i2c[1]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_I2C2_IRQ));\n\n    sysbus_connect_irq(busdev, 1, s->drq[OMAP24XX_DMA_I2C2_TX]);\n\n    sysbus_connect_irq(busdev, 2, s->drq[OMAP24XX_DMA_I2C2_RX]);\n\n    sysbus_mmio_map(busdev, 0, omap_l4_region_base(omap_l4tao(s->l4, 6), 0));\n\n\n\n    s->gpio = qdev_create(NULL, \"omap2-gpio\");\n\n    qdev_prop_set_int32(s->gpio, \"mpu_model\", s->mpu_model);\n\n    qdev_prop_set_ptr(s->gpio, \"iclk\", omap_findclk(s, \"gpio_iclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk0\", omap_findclk(s, \"gpio1_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk1\", omap_findclk(s, \"gpio2_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk2\", omap_findclk(s, \"gpio3_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk3\", omap_findclk(s, \"gpio4_dbclk\"));\n\n    if (s->mpu_model == omap2430) {\n\n        qdev_prop_set_ptr(s->gpio, \"fclk4\", omap_findclk(s, \"gpio5_dbclk\"));\n\n    }\n\n    qdev_init_nofail(s->gpio);\n\n    busdev = SYS_BUS_DEVICE(s->gpio);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPIO_BANK1));\n\n    sysbus_connect_irq(busdev, 3,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPIO_BANK2));\n\n    sysbus_connect_irq(busdev, 6,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPIO_BANK3));\n\n    sysbus_connect_irq(busdev, 9,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPIO_BANK4));\n\n    if (s->mpu_model == omap2430) {\n\n        sysbus_connect_irq(busdev, 12,\n\n                           qdev_get_gpio_in(s->ih[0],\n\n                                            OMAP_INT_243X_GPIO_BANK5));\n\n    }\n\n    ta = omap_l4ta(s->l4, 3);\n\n    sysbus_mmio_map(busdev, 0, omap_l4_region_base(ta, 1));\n\n    sysbus_mmio_map(busdev, 1, omap_l4_region_base(ta, 0));\n\n    sysbus_mmio_map(busdev, 2, omap_l4_region_base(ta, 2));\n\n    sysbus_mmio_map(busdev, 3, omap_l4_region_base(ta, 4));\n\n    sysbus_mmio_map(busdev, 4, omap_l4_region_base(ta, 5));\n\n\n\n    s->sdrc = omap_sdrc_init(sysmem, 0x68009000);\n\n    s->gpmc = omap_gpmc_init(s, 0x6800a000,\n\n                             qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_GPMC_IRQ),\n\n                             s->drq[OMAP24XX_DMA_GPMC]);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = omap2_mmc_init(omap_l4tao(s->l4, 9),\n\n                    blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_MMC_IRQ),\n\n                    &s->drq[OMAP24XX_DMA_MMC1_TX],\n\n                    omap_findclk(s, \"mmc_fclk\"), omap_findclk(s, \"mmc_iclk\"));\n\n\n\n    s->mcspi[0] = omap_mcspi_init(omap_l4ta(s->l4, 35), 4,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_MCSPI1_IRQ),\n\n                    &s->drq[OMAP24XX_DMA_SPI1_TX0],\n\n                    omap_findclk(s, \"spi1_fclk\"),\n\n                    omap_findclk(s, \"spi1_iclk\"));\n\n    s->mcspi[1] = omap_mcspi_init(omap_l4ta(s->l4, 36), 2,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_MCSPI2_IRQ),\n\n                    &s->drq[OMAP24XX_DMA_SPI2_TX0],\n\n                    omap_findclk(s, \"spi2_fclk\"),\n\n                    omap_findclk(s, \"spi2_iclk\"));\n\n\n\n    s->dss = omap_dss_init(omap_l4ta(s->l4, 10), sysmem, 0x68000800,\n\n                    \/* XXX wire M_IRQ_25, D_L2_IRQ_30 and I_IRQ_13 together *\/\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_DSS_IRQ),\n\n                           s->drq[OMAP24XX_DMA_DSS],\n\n                    omap_findclk(s, \"dss_clk1\"), omap_findclk(s, \"dss_clk2\"),\n\n                    omap_findclk(s, \"dss_54m_clk\"),\n\n                    omap_findclk(s, \"dss_l3_iclk\"),\n\n                    omap_findclk(s, \"dss_l4_iclk\"));\n\n\n\n    omap_sti_init(omap_l4ta(s->l4, 18), sysmem, 0x54000000,\n\n                  qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_STI),\n\n                  omap_findclk(s, \"emul_ck\"),\n\n                    serial_hds[0] && serial_hds[1] && serial_hds[2] ?\n\n                    serial_hds[3] : NULL);\n\n\n\n    s->eac = omap_eac_init(omap_l4ta(s->l4, 32),\n\n                           qdev_get_gpio_in(s->ih[0], OMAP_INT_24XX_EAC_IRQ),\n\n                    \/* Ten consecutive lines *\/\n\n                    &s->drq[OMAP24XX_DMA_EAC_AC_RD],\n\n                    omap_findclk(s, \"func_96m_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    \/* All register mappings (includin those not currenlty implemented):\n\n     * SystemControlMod\t48000000 - 48000fff\n\n     * SystemControlL4\t48001000 - 48001fff\n\n     * 32kHz Timer Mod\t48004000 - 48004fff\n\n     * 32kHz Timer L4\t48005000 - 48005fff\n\n     * PRCM ModA\t48008000 - 480087ff\n\n     * PRCM ModB\t48008800 - 48008fff\n\n     * PRCM L4\t\t48009000 - 48009fff\n\n     * TEST-BCM Mod\t48012000 - 48012fff\n\n     * TEST-BCM L4\t48013000 - 48013fff\n\n     * TEST-TAP Mod\t48014000 - 48014fff\n\n     * TEST-TAP L4\t48015000 - 48015fff\n\n     * GPIO1 Mod\t48018000 - 48018fff\n\n     * GPIO Top\t\t48019000 - 48019fff\n\n     * GPIO2 Mod\t4801a000 - 4801afff\n\n     * GPIO L4\t\t4801b000 - 4801bfff\n\n     * GPIO3 Mod\t4801c000 - 4801cfff\n\n     * GPIO4 Mod\t4801e000 - 4801efff\n\n     * WDTIMER1 Mod\t48020000 - 48010fff\n\n     * WDTIMER Top\t48021000 - 48011fff\n\n     * WDTIMER2 Mod\t48022000 - 48012fff\n\n     * WDTIMER L4\t48023000 - 48013fff\n\n     * WDTIMER3 Mod\t48024000 - 48014fff\n\n     * WDTIMER3 L4\t48025000 - 48015fff\n\n     * WDTIMER4 Mod\t48026000 - 48016fff\n\n     * WDTIMER4 L4\t48027000 - 48017fff\n\n     * GPTIMER1 Mod\t48028000 - 48018fff\n\n     * GPTIMER1 L4\t48029000 - 48019fff\n\n     * GPTIMER2 Mod\t4802a000 - 4801afff\n\n     * GPTIMER2 L4\t4802b000 - 4801bfff\n\n     * L4-Config AP\t48040000 - 480407ff\n\n     * L4-Config IP\t48040800 - 48040fff\n\n     * L4-Config LA\t48041000 - 48041fff\n\n     * ARM11ETB Mod\t48048000 - 48049fff\n\n     * ARM11ETB L4\t4804a000 - 4804afff\n\n     * DISPLAY Top\t48050000 - 480503ff\n\n     * DISPLAY DISPC\t48050400 - 480507ff\n\n     * DISPLAY RFBI\t48050800 - 48050bff\n\n     * DISPLAY VENC\t48050c00 - 48050fff\n\n     * DISPLAY L4\t48051000 - 48051fff\n\n     * CAMERA Top\t48052000 - 480523ff\n\n     * CAMERA core\t48052400 - 480527ff\n\n     * CAMERA DMA\t48052800 - 48052bff\n\n     * CAMERA MMU\t48052c00 - 48052fff\n\n     * CAMERA L4\t48053000 - 48053fff\n\n     * SDMA Mod\t\t48056000 - 48056fff\n\n     * SDMA L4\t\t48057000 - 48057fff\n\n     * SSI Top\t\t48058000 - 48058fff\n\n     * SSI GDD\t\t48059000 - 48059fff\n\n     * SSI Port1\t4805a000 - 4805afff\n\n     * SSI Port2\t4805b000 - 4805bfff\n\n     * SSI L4\t\t4805c000 - 4805cfff\n\n     * USB Mod\t\t4805e000 - 480fefff\n\n     * USB L4\t\t4805f000 - 480fffff\n\n     * WIN_TRACER1 Mod\t48060000 - 48060fff\n\n     * WIN_TRACER1 L4\t48061000 - 48061fff\n\n     * WIN_TRACER2 Mod\t48062000 - 48062fff\n\n     * WIN_TRACER2 L4\t48063000 - 48063fff\n\n     * WIN_TRACER3 Mod\t48064000 - 48064fff\n\n     * WIN_TRACER3 L4\t48065000 - 48065fff\n\n     * WIN_TRACER4 Top\t48066000 - 480660ff\n\n     * WIN_TRACER4 ETT\t48066100 - 480661ff\n\n     * WIN_TRACER4 WT\t48066200 - 480662ff\n\n     * WIN_TRACER4 L4\t48067000 - 48067fff\n\n     * XTI Mod\t\t48068000 - 48068fff\n\n     * XTI L4\t\t48069000 - 48069fff\n\n     * UART1 Mod\t4806a000 - 4806afff\n\n     * UART1 L4\t\t4806b000 - 4806bfff\n\n     * UART2 Mod\t4806c000 - 4806cfff\n\n     * UART2 L4\t\t4806d000 - 4806dfff\n\n     * UART3 Mod\t4806e000 - 4806efff\n\n     * UART3 L4\t\t4806f000 - 4806ffff\n\n     * I2C1 Mod\t\t48070000 - 48070fff\n\n     * I2C1 L4\t\t48071000 - 48071fff\n\n     * I2C2 Mod\t\t48072000 - 48072fff\n\n     * I2C2 L4\t\t48073000 - 48073fff\n\n     * McBSP1 Mod\t48074000 - 48074fff\n\n     * McBSP1 L4\t48075000 - 48075fff\n\n     * McBSP2 Mod\t48076000 - 48076fff\n\n     * McBSP2 L4\t48077000 - 48077fff\n\n     * GPTIMER3 Mod\t48078000 - 48078fff\n\n     * GPTIMER3 L4\t48079000 - 48079fff\n\n     * GPTIMER4 Mod\t4807a000 - 4807afff\n\n     * GPTIMER4 L4\t4807b000 - 4807bfff\n\n     * GPTIMER5 Mod\t4807c000 - 4807cfff\n\n     * GPTIMER5 L4\t4807d000 - 4807dfff\n\n     * GPTIMER6 Mod\t4807e000 - 4807efff\n\n     * GPTIMER6 L4\t4807f000 - 4807ffff\n\n     * GPTIMER7 Mod\t48080000 - 48080fff\n\n     * GPTIMER7 L4\t48081000 - 48081fff\n\n     * GPTIMER8 Mod\t48082000 - 48082fff\n\n     * GPTIMER8 L4\t48083000 - 48083fff\n\n     * GPTIMER9 Mod\t48084000 - 48084fff\n\n     * GPTIMER9 L4\t48085000 - 48085fff\n\n     * GPTIMER10 Mod\t48086000 - 48086fff\n\n     * GPTIMER10 L4\t48087000 - 48087fff\n\n     * GPTIMER11 Mod\t48088000 - 48088fff\n\n     * GPTIMER11 L4\t48089000 - 48089fff\n\n     * GPTIMER12 Mod\t4808a000 - 4808afff\n\n     * GPTIMER12 L4\t4808b000 - 4808bfff\n\n     * EAC Mod\t\t48090000 - 48090fff\n\n     * EAC L4\t\t48091000 - 48091fff\n\n     * FAC Mod\t\t48092000 - 48092fff\n\n     * FAC L4\t\t48093000 - 48093fff\n\n     * MAILBOX Mod\t48094000 - 48094fff\n\n     * MAILBOX L4\t48095000 - 48095fff\n\n     * SPI1 Mod\t\t48098000 - 48098fff\n\n     * SPI1 L4\t\t48099000 - 48099fff\n\n     * SPI2 Mod\t\t4809a000 - 4809afff\n\n     * SPI2 L4\t\t4809b000 - 4809bfff\n\n     * MMC\/SDIO Mod\t4809c000 - 4809cfff\n\n     * MMC\/SDIO L4\t4809d000 - 4809dfff\n\n     * MS_PRO Mod\t4809e000 - 4809efff\n\n     * MS_PRO L4\t4809f000 - 4809ffff\n\n     * RNG Mod\t\t480a0000 - 480a0fff\n\n     * RNG L4\t\t480a1000 - 480a1fff\n\n     * DES3DES Mod\t480a2000 - 480a2fff\n\n     * DES3DES L4\t480a3000 - 480a3fff\n\n     * SHA1MD5 Mod\t480a4000 - 480a4fff\n\n     * SHA1MD5 L4\t480a5000 - 480a5fff\n\n     * AES Mod\t\t480a6000 - 480a6fff\n\n     * AES L4\t\t480a7000 - 480a7fff\n\n     * PKA Mod\t\t480a8000 - 480a9fff\n\n     * PKA L4\t\t480aa000 - 480aafff\n\n     * MG Mod\t\t480b0000 - 480b0fff\n\n     * MG L4\t\t480b1000 - 480b1fff\n\n     * HDQ\/1-wire Mod\t480b2000 - 480b2fff\n\n     * HDQ\/1-wire L4\t480b3000 - 480b3fff\n\n     * MPU interrupt\t480fe000 - 480fefff\n\n     * STI channel base\t54000000 - 5400ffff\n\n     * IVA RAM\t\t5c000000 - 5c01ffff\n\n     * IVA ROM\t\t5c020000 - 5c027fff\n\n     * IMG_BUF_A\t5c040000 - 5c040fff\n\n     * IMG_BUF_B\t5c042000 - 5c042fff\n\n     * VLCDS\t\t5c048000 - 5c0487ff\n\n     * IMX_COEF\t\t5c049000 - 5c04afff\n\n     * IMX_CMD\t\t5c051000 - 5c051fff\n\n     * VLCDQ\t\t5c053000 - 5c0533ff\n\n     * VLCDH\t\t5c054000 - 5c054fff\n\n     * SEQ_CMD\t\t5c055000 - 5c055fff\n\n     * IMX_REG\t\t5c056000 - 5c0560ff\n\n     * VLCD_REG\t\t5c056100 - 5c0561ff\n\n     * SEQ_REG\t\t5c056200 - 5c0562ff\n\n     * IMG_BUF_REG\t5c056300 - 5c0563ff\n\n     * SEQIRQ_REG\t5c056400 - 5c0564ff\n\n     * OCP_REG\t\t5c060000 - 5c060fff\n\n     * SYSC_REG\t\t5c070000 - 5c070fff\n\n     * MMU_REG\t\t5d000000 - 5d000fff\n\n     * sDMA R\t\t68000400 - 680005ff\n\n     * sDMA W\t\t68000600 - 680007ff\n\n     * Display Control\t68000800 - 680009ff\n\n     * DSP subsystem\t68000a00 - 68000bff\n\n     * MPU subsystem\t68000c00 - 68000dff\n\n     * IVA subsystem\t68001000 - 680011ff\n\n     * USB\t\t68001200 - 680013ff\n\n     * Camera\t\t68001400 - 680015ff\n\n     * VLYNQ (firewall)\t68001800 - 68001bff\n\n     * VLYNQ\t\t68001e00 - 68001fff\n\n     * SSI\t\t68002000 - 680021ff\n\n     * L4\t\t68002400 - 680025ff\n\n     * DSP (firewall)\t68002800 - 68002bff\n\n     * DSP subsystem\t68002e00 - 68002fff\n\n     * IVA (firewall)\t68003000 - 680033ff\n\n     * IVA\t\t68003600 - 680037ff\n\n     * GFX\t\t68003a00 - 68003bff\n\n     * CMDWR emulation\t68003c00 - 68003dff\n\n     * SMS\t\t68004000 - 680041ff\n\n     * OCM\t\t68004200 - 680043ff\n\n     * GPMC\t\t68004400 - 680045ff\n\n     * RAM (firewall)\t68005000 - 680053ff\n\n     * RAM (err login)\t68005400 - 680057ff\n\n     * ROM (firewall)\t68005800 - 68005bff\n\n     * ROM (err login)\t68005c00 - 68005fff\n\n     * GPMC (firewall)\t68006000 - 680063ff\n\n     * GPMC (err login)\t68006400 - 680067ff\n\n     * SMS (err login)\t68006c00 - 68006fff\n\n     * SMS registers\t68008000 - 68008fff\n\n     * SDRC registers\t68009000 - 68009fff\n\n     * GPMC registers\t6800a000   6800afff\n\n     *\/\n\n\n\n    qemu_register_reset(omap2_mpu_reset, s);\n\n\n\n    return s;\n\n}\n"},{"project":"qemu","commit_id":"47d4be12c3997343e436c6cca89aefbbbeb70863","target":1,"func":"static void test_qemu_strtoull_full_empty(void)\n\n{\n\n    const char *str = \"\";\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n}\n"},{"project":"qemu","commit_id":"cc3c7384ac61728e9949d5e64c10664fe4510179","target":0,"func":"static void s390_init(ram_addr_t my_ram_size,\n\n                      const char *boot_device,\n\n                      const char *kernel_filename,\n\n                      const char *kernel_cmdline,\n\n                      const char *initrd_filename,\n\n                      const char *cpu_model)\n\n{\n\n    CPUS390XState *env = NULL;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    ram_addr_t kernel_size = 0;\n\n    ram_addr_t initrd_offset;\n\n    ram_addr_t initrd_size = 0;\n\n    int shift = 0;\n\n    uint8_t *storage_keys;\n\n    void *virtio_region;\n\n    target_phys_addr_t virtio_region_len;\n\n    target_phys_addr_t virtio_region_start;\n\n    int i;\n\n\n\n    \/* s390x ram size detection needs a 16bit multiplier + an increment. So\n\n       guests > 64GB can be specified in 2MB steps etc. *\/\n\n    while ((my_ram_size >> (20 + shift)) > 65535) {\n\n        shift++;\n\n    }\n\n    my_ram_size = my_ram_size >> (20 + shift) << (20 + shift);\n\n\n\n    \/* lets propagate the changed ram size into the global variable. *\/\n\n    ram_size = my_ram_size;\n\n\n\n    \/* get a BUS *\/\n\n    s390_bus = s390_virtio_bus_init(&my_ram_size);\n\n\n\n    \/* allocate RAM *\/\n\n    memory_region_init_ram(ram, \"s390.ram\", my_ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    \/* clear virtio region *\/\n\n    virtio_region_len = my_ram_size - ram_size;\n\n    virtio_region_start = ram_size;\n\n    virtio_region = cpu_physical_memory_map(virtio_region_start,\n\n                                            &virtio_region_len, true);\n\n    memset(virtio_region, 0, virtio_region_len);\n\n    cpu_physical_memory_unmap(virtio_region, virtio_region_len, 1,\n\n                              virtio_region_len);\n\n\n\n    \/* allocate storage keys *\/\n\n    storage_keys = g_malloc0(my_ram_size \/ TARGET_PAGE_SIZE);\n\n\n\n    \/* init CPUs *\/\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"host\";\n\n    }\n\n\n\n    ipi_states = g_malloc(sizeof(CPUS390XState *) * smp_cpus);\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        CPUS390XState *tmp_env;\n\n\n\n        tmp_env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            env = tmp_env;\n\n        }\n\n        ipi_states[i] = tmp_env;\n\n        tmp_env->halted = 1;\n\n        tmp_env->exception_index = EXCP_HLT;\n\n        tmp_env->storage_keys = storage_keys;\n\n    }\n\n\n\n    \/* One CPU has to run *\/\n\n    s390_add_running_cpu(env);\n\n\n\n    if (kernel_filename) {\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, NULL, NULL,\n\n                               NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size == -1UL) {\n\n            kernel_size = load_image_targphys(kernel_filename, 0, ram_size);\n\n        }\n\n        \/*\n\n         * we can not rely on the ELF entry point, since up to 3.2 this\n\n         * value was 0x800 (the SALIPL loader) and it wont work. For\n\n         * all (Linux) cases 0x10000 (KERN_IMAGE_START) should be fine.\n\n         *\/\n\n        env->psw.addr = KERN_IMAGE_START;\n\n        env->psw.mask = 0x0000000180000000ULL;\n\n    } else {\n\n        ram_addr_t bios_size = 0;\n\n        char *bios_filename;\n\n\n\n        \/* Load zipl bootloader *\/\n\n        if (bios_name == NULL) {\n\n            bios_name = ZIPL_FILENAME;\n\n        }\n\n\n\n        bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        bios_size = load_image_targphys(bios_filename, ZIPL_LOAD_ADDR, 4096);\n\n        g_free(bios_filename);\n\n\n\n        if ((long)bios_size < 0) {\n\n            hw_error(\"could not load bootloader '%s'\\n\", bios_name);\n\n        }\n\n\n\n        if (bios_size > 4096) {\n\n            hw_error(\"stage1 bootloader is > 4k\\n\");\n\n        }\n\n\n\n        env->psw.addr = ZIPL_START;\n\n        env->psw.mask = 0x0000000180000000ULL;\n\n    }\n\n\n\n    if (initrd_filename) {\n\n        initrd_offset = INITRD_START;\n\n        while (kernel_size + 0x100000 > initrd_offset) {\n\n            initrd_offset += 0x100000;\n\n        }\n\n        initrd_size = load_image_targphys(initrd_filename, initrd_offset,\n\n                                          ram_size - initrd_offset);\n\n        \/* we have to overwrite values in the kernel image, which are \"rom\" *\/\n\n        memcpy(rom_ptr(INITRD_PARM_START), &initrd_offset, 8);\n\n        memcpy(rom_ptr(INITRD_PARM_SIZE), &initrd_size, 8);\n\n    }\n\n\n\n    if (kernel_cmdline) {\n\n        \/* we have to overwrite values in the kernel image, which are \"rom\" *\/\n\n        memcpy(rom_ptr(KERN_PARM_AREA), kernel_cmdline,\n\n               strlen(kernel_cmdline) + 1);\n\n    }\n\n\n\n    \/* Create VirtIO network adapters *\/\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n        DeviceState *dev;\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"virtio\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"virtio\")) {\n\n            fprintf(stderr, \"S390 only supports VirtIO nics\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        dev = qdev_create((BusState *)s390_bus, \"virtio-net-s390\");\n\n        qdev_set_nic_properties(dev, nd);\n\n        qdev_init_nofail(dev);\n\n    }\n\n\n\n    \/* Create VirtIO disk drives *\/\n\n    for(i = 0; i < MAX_BLK_DEVS; i++) {\n\n        DriveInfo *dinfo;\n\n        DeviceState *dev;\n\n\n\n        dinfo = drive_get(IF_IDE, 0, i);\n\n        if (!dinfo) {\n\n            continue;\n\n        }\n\n\n\n        dev = qdev_create((BusState *)s390_bus, \"virtio-blk-s390\");\n\n        qdev_prop_set_drive_nofail(dev, \"drive\", dinfo->bdrv);\n\n        qdev_init_nofail(dev);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"cc05c43ad942165ecc6ffd39e41991bee43af044","target":1,"func":"bool io_mem_write(MemoryRegion *mr, hwaddr addr,\n\n                  uint64_t val, unsigned size)\n\n{\n\n    return memory_region_dispatch_write(mr, addr, val, size);\n\n}\n"},{"project":"qemu","commit_id":"a0efbf16604770b9d805bcf210ec29942321134f","target":0,"func":"static void i440fx_pcihost_get_pci_hole64_start(Object *obj, Visitor *v,\n\n                                                const char *name,\n\n                                                void *opaque, Error **errp)\n\n{\n\n    PCIHostState *h = PCI_HOST_BRIDGE(obj);\n\n    Range w64;\n\n\n\n    pci_bus_get_w64_range(h->bus, &w64);\n\n\n\n    visit_type_uint64(v, name, &w64.begin, errp);\n\n}\n"},{"project":"qemu","commit_id":"b92ad3949bc9cacd1652b4e07e7f6003b9e512af","target":0,"func":"build_madt(GArray *table_data, GArray *linker, VirtGuestInfo *guest_info,\n\n           VirtAcpiCpuInfo *cpuinfo)\n\n{\n\n    int madt_start = table_data->len;\n\n    const MemMapEntry *memmap = guest_info->memmap;\n\n    const int *irqmap = guest_info->irqmap;\n\n    AcpiMultipleApicTable *madt;\n\n    AcpiMadtGenericDistributor *gicd;\n\n    AcpiMadtGenericMsiFrame *gic_msi;\n\n    int i;\n\n\n\n    madt = acpi_data_push(table_data, sizeof *madt);\n\n\n\n    for (i = 0; i < guest_info->smp_cpus; i++) {\n\n        AcpiMadtGenericInterrupt *gicc = acpi_data_push(table_data,\n\n                                                     sizeof *gicc);\n\n        gicc->type = ACPI_APIC_GENERIC_INTERRUPT;\n\n        gicc->length = sizeof(*gicc);\n\n        gicc->base_address = memmap[VIRT_GIC_CPU].base;\n\n        gicc->cpu_interface_number = i;\n\n        gicc->arm_mpidr = i;\n\n        gicc->uid = i;\n\n        if (test_bit(i, cpuinfo->found_cpus)) {\n\n            gicc->flags = cpu_to_le32(ACPI_GICC_ENABLED);\n\n        }\n\n    }\n\n\n\n    gicd = acpi_data_push(table_data, sizeof *gicd);\n\n    gicd->type = ACPI_APIC_GENERIC_DISTRIBUTOR;\n\n    gicd->length = sizeof(*gicd);\n\n    gicd->base_address = memmap[VIRT_GIC_DIST].base;\n\n\n\n    gic_msi = acpi_data_push(table_data, sizeof *gic_msi);\n\n    gic_msi->type = ACPI_APIC_GENERIC_MSI_FRAME;\n\n    gic_msi->length = sizeof(*gic_msi);\n\n    gic_msi->gic_msi_frame_id = 0;\n\n    gic_msi->base_address = cpu_to_le64(memmap[VIRT_GIC_V2M].base);\n\n    gic_msi->flags = cpu_to_le32(1);\n\n    gic_msi->spi_count = cpu_to_le16(NUM_GICV2M_SPIS);\n\n    gic_msi->spi_base = cpu_to_le16(irqmap[VIRT_GIC_V2M] + ARM_SPI_BASE);\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + madt_start), \"APIC\",\n\n                 table_data->len - madt_start, 3);\n\n}\n"},{"project":"qemu","commit_id":"b7680cb6078bd7294a3dd86473d3f2fdee991dd0","target":0,"func":"int kvm_arch_put_registers(CPUState *env, int level)\n\n{\n\n    int ret;\n\n\n\n    assert(cpu_is_stopped(env) || qemu_cpu_self(env));\n\n\n\n    ret = kvm_getput_regs(env, 1);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    ret = kvm_put_xsave(env);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    ret = kvm_put_xcrs(env);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    ret = kvm_put_sregs(env);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    ret = kvm_put_msrs(env, level);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    if (level >= KVM_PUT_RESET_STATE) {\n\n        ret = kvm_put_mp_state(env);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = kvm_put_vcpu_events(env, level);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    ret = kvm_put_debugregs(env);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    \/* must be last *\/\n\n    ret = kvm_guest_debug_workarounds(env);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"5c843af22604edecda10d4bb89d4eede9e1bd3d0","target":1,"func":"int net_init_slirp(const Netdev *netdev, const char *name,\n\n                   NetClientState *peer, Error **errp)\n\n{\n\n    \/* FIXME error_setg(errp, ...) on failure *\/\n\n    struct slirp_config_str *config;\n\n    char *vnet;\n\n    int ret;\n\n    const NetdevUserOptions *user;\n\n    const char **dnssearch;\n\n    bool ipv4 = true, ipv6 = true;\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_USER);\n\n    user = &netdev->u.user;\n\n\n\n    if ((user->has_ipv6 && user->ipv6 && !user->has_ipv4) ||\n\n        (user->has_ipv4 && !user->ipv4)) {\n\n        ipv4 = 0;\n\n    }\n\n    if ((user->has_ipv4 && user->ipv4 && !user->has_ipv6) ||\n\n        (user->has_ipv6 && !user->ipv6)) {\n\n        ipv6 = 0;\n\n    }\n\n\n\n    vnet = user->has_net ? g_strdup(user->net) :\n\n           user->has_ip  ? g_strdup_printf(\"%s\/24\", user->ip) :\n\n           NULL;\n\n\n\n    dnssearch = slirp_dnssearch(user->dnssearch);\n\n\n\n    \/* all optional fields are initialized to \"all bits zero\" *\/\n\n\n\n    net_init_slirp_configs(user->hostfwd, SLIRP_CFG_HOSTFWD);\n\n    net_init_slirp_configs(user->guestfwd, 0);\n\n\n\n    ret = net_slirp_init(peer, \"user\", name, user->q_restrict,\n\n                         ipv4, vnet, user->host,\n\n                         ipv6, user->ipv6_prefix, user->ipv6_prefixlen,\n\n                         user->ipv6_host, user->hostname, user->tftp,\n\n                         user->bootfile, user->dhcpstart,\n\n                         user->dns, user->ipv6_dns, user->smb,\n\n                         user->smbserver, dnssearch);\n\n\n\n    while (slirp_configs) {\n\n        config = slirp_configs;\n\n        slirp_configs = config->next;\n\n        g_free(config);\n\n    }\n\n\n\n    g_free(vnet);\n\n    g_free(dnssearch);\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"a0efbf16604770b9d805bcf210ec29942321134f","target":0,"func":"static void q35_host_get_pci_hole_start(Object *obj, Visitor *v,\n\n                                        const char *name, void *opaque,\n\n                                        Error **errp)\n\n{\n\n    Q35PCIHost *s = Q35_HOST_DEVICE(obj);\n\n    uint32_t value = s->mch.pci_hole.begin;\n\n\n\n    visit_type_uint32(v, name, &value, errp);\n\n}\n"},{"project":"qemu","commit_id":"e0498daab50d42f3948fc5607683c971fe9416fd","target":1,"func":"static void gen_lq(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    int ra, rd;\n\n    TCGv EA;\n\n\n\n    \/* Restore CPU state *\/\n\n    if (unlikely(ctx->mem_idx == 0)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    ra = rA(ctx->opcode);\n\n    rd = rD(ctx->opcode);\n\n    if (unlikely((rd & 1) || rd == ra)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n        return;\n\n    }\n\n    if (unlikely(ctx->le_mode)) {\n\n        \/* Little-endian mode is not handled *\/\n\n        gen_exception_err(ctx, POWERPC_EXCP_ALIGN, POWERPC_EXCP_ALIGN_LE);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_INT);\n\n    EA = tcg_temp_new();\n\n    gen_addr_imm_index(ctx, EA, 0x0F);\n\n    gen_qemu_ld64(ctx, cpu_gpr[rd], EA);\n\n    gen_addr_add(ctx, EA, EA, 8);\n\n    gen_qemu_ld64(ctx, cpu_gpr[rd+1], EA);\n\n    tcg_temp_free(EA);\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,\n\n                            int len, int is_write)\n\n{\n\n    return address_space_rw(&address_space_memory, addr, buf, len, is_write);\n\n}\n"},{"project":"qemu","commit_id":"c363acef772647f66becdbf46dd54e70e67f3cc9","target":0,"func":"static void test_visitor_in_alternate_number(TestInputVisitorData *data,\n\n                                             const void *unused)\n\n{\n\n    Visitor *v;\n\n    Error *err = NULL;\n\n    AltStrBool *asb;\n\n    AltStrNum *asn;\n\n    AltNumStr *ans;\n\n    AltStrInt *asi;\n\n    AltIntNum *ain;\n\n    AltNumInt *ani;\n\n\n\n    \/* Parsing an int *\/\n\n\n\n    v = visitor_input_test_init(data, \"42\");\n\n    visit_type_AltStrBool(v, &asb, NULL, &err);\n\n    g_assert(err);\n\n    error_free(err);\n\n    err = NULL;\n\n    qapi_free_AltStrBool(asb);\n\n    visitor_input_teardown(data, NULL);\n\n\n\n    \/* FIXME: Order of alternate should not affect semantics; asn should\n\n     * parse the same as ans *\/\n\n    v = visitor_input_test_init(data, \"42\");\n\n    visit_type_AltStrNum(v, &asn, NULL, &err);\n\n    \/* FIXME g_assert_cmpint(asn->kind, == ALT_STR_NUM_KIND_N); *\/\n\n    \/* FIXME g_assert_cmpfloat(asn->n, ==, 42); *\/\n\n    g_assert(err);\n\n    error_free(err);\n\n    err = NULL;\n\n    qapi_free_AltStrNum(asn);\n\n    visitor_input_teardown(data, NULL);\n\n\n\n    v = visitor_input_test_init(data, \"42\");\n\n    visit_type_AltNumStr(v, &ans, NULL, &error_abort);\n\n    g_assert_cmpint(ans->kind, ==, ALT_NUM_STR_KIND_N);\n\n    g_assert_cmpfloat(ans->n, ==, 42);\n\n    qapi_free_AltNumStr(ans);\n\n    visitor_input_teardown(data, NULL);\n\n\n\n    v = visitor_input_test_init(data, \"42\");\n\n    visit_type_AltStrInt(v, &asi, NULL, &error_abort);\n\n    g_assert_cmpint(asi->kind, ==, ALT_STR_INT_KIND_I);\n\n    g_assert_cmpint(asi->i, ==, 42);\n\n    qapi_free_AltStrInt(asi);\n\n    visitor_input_teardown(data, NULL);\n\n\n\n    v = visitor_input_test_init(data, \"42\");\n\n    visit_type_AltIntNum(v, &ain, NULL, &error_abort);\n\n    g_assert_cmpint(ain->kind, ==, ALT_INT_NUM_KIND_I);\n\n    g_assert_cmpint(ain->i, ==, 42);\n\n    qapi_free_AltIntNum(ain);\n\n    visitor_input_teardown(data, NULL);\n\n\n\n    v = visitor_input_test_init(data, \"42\");\n\n    visit_type_AltNumInt(v, &ani, NULL, &error_abort);\n\n    g_assert_cmpint(ani->kind, ==, ALT_NUM_INT_KIND_I);\n\n    g_assert_cmpint(ani->i, ==, 42);\n\n    qapi_free_AltNumInt(ani);\n\n    visitor_input_teardown(data, NULL);\n\n\n\n    \/* Parsing a double *\/\n\n\n\n    v = visitor_input_test_init(data, \"42.5\");\n\n    visit_type_AltStrBool(v, &asb, NULL, &err);\n\n    g_assert(err);\n\n    error_free(err);\n\n    err = NULL;\n\n    qapi_free_AltStrBool(asb);\n\n    visitor_input_teardown(data, NULL);\n\n\n\n    v = visitor_input_test_init(data, \"42.5\");\n\n    visit_type_AltStrNum(v, &asn, NULL, &error_abort);\n\n    g_assert_cmpint(asn->kind, ==, ALT_STR_NUM_KIND_N);\n\n    g_assert_cmpfloat(asn->n, ==, 42.5);\n\n    qapi_free_AltStrNum(asn);\n\n    visitor_input_teardown(data, NULL);\n\n\n\n    v = visitor_input_test_init(data, \"42.5\");\n\n    visit_type_AltNumStr(v, &ans, NULL, &error_abort);\n\n    g_assert_cmpint(ans->kind, ==, ALT_NUM_STR_KIND_N);\n\n    g_assert_cmpfloat(ans->n, ==, 42.5);\n\n    qapi_free_AltNumStr(ans);\n\n    visitor_input_teardown(data, NULL);\n\n\n\n    v = visitor_input_test_init(data, \"42.5\");\n\n    visit_type_AltStrInt(v, &asi, NULL, &err);\n\n    g_assert(err);\n\n    error_free(err);\n\n    err = NULL;\n\n    qapi_free_AltStrInt(asi);\n\n    visitor_input_teardown(data, NULL);\n\n\n\n    v = visitor_input_test_init(data, \"42.5\");\n\n    visit_type_AltIntNum(v, &ain, NULL, &error_abort);\n\n    g_assert_cmpint(ain->kind, ==, ALT_INT_NUM_KIND_N);\n\n    g_assert_cmpfloat(ain->n, ==, 42.5);\n\n    qapi_free_AltIntNum(ain);\n\n    visitor_input_teardown(data, NULL);\n\n\n\n    v = visitor_input_test_init(data, \"42.5\");\n\n    visit_type_AltNumInt(v, &ani, NULL, &error_abort);\n\n    g_assert_cmpint(ani->kind, ==, ALT_NUM_INT_KIND_N);\n\n    g_assert_cmpfloat(ani->n, ==, 42.5);\n\n    qapi_free_AltNumInt(ani);\n\n    visitor_input_teardown(data, NULL);\n\n}\n"},{"project":"qemu","commit_id":"245f7b51c0ea04fb2224b1127430a096c91aee70","target":0,"func":"static void vnc_tight_stop(VncState *vs)\n\n{\n\n    \/\/ switch back to normal output\/zlib buffers\n\n    vs->tight = vs->output;\n\n    vs->output = vs->tight_tmp;\n\n}\n"},{"project":"qemu","commit_id":"9ef91a677110ec200d7b2904fc4bcae5a77329ad","target":0,"func":"static int posix_aio_flush(void *opaque)\n\n{\n\n    PosixAioState *s = opaque;\n\n    return !!s->first_aio;\n\n}\n"},{"project":"qemu","commit_id":"56a6f02b8ce1fe41a2a9077593e46eca7d98267d","target":0,"func":"static void qmp_output_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qmp_output_pop(qov);\n\n}\n"},{"project":"qemu","commit_id":"56439e9d55626b65ecb887f1ac3714652555312e","target":1,"func":"static int64_t coroutine_fn qcow_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum, BlockDriverState **file)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster, n;\n\n    uint64_t cluster_offset;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    cluster_offset = get_cluster_offset(bs, sector_num << 9, 0, 0, 0, 0);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n    n = s->cluster_sectors - index_in_cluster;\n\n    if (n > nb_sectors)\n\n        n = nb_sectors;\n\n    *pnum = n;\n\n    if (!cluster_offset) {\n\n        return 0;\n\n    }\n\n    if ((cluster_offset & QCOW_OFLAG_COMPRESSED) || s->crypto) {\n\n        return BDRV_BLOCK_DATA;\n\n    }\n\n    cluster_offset |= (index_in_cluster << BDRV_SECTOR_BITS);\n\n    *file = bs->file->bs;\n\n    return BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID | cluster_offset;\n\n}\n"},{"project":"qemu","commit_id":"d0cc2fbfa607678866475383c508be84818ceb64","target":0,"func":"void event_notifier_cleanup(EventNotifier *e)\n\n{\n\n    close(e->fd);\n\n}\n"},{"project":"qemu","commit_id":"d59f8ba938afd837182e666cce777dfb860559e4","target":0,"func":"static int usb_net_handle_control(USBDevice *dev, int request, int value,\n\n                int index, int length, uint8_t *data)\n\n{\n\n    USBNetState *s = (USBNetState *) dev;\n\n    int ret = 0;\n\n\n\n    switch(request) {\n\n    case DeviceRequest | USB_REQ_GET_STATUS:\n\n        data[0] = (1 << USB_DEVICE_SELF_POWERED) |\n\n                (dev->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP);\n\n        data[1] = 0x00;\n\n        ret = 2;\n\n        break;\n\n\n\n    case DeviceOutRequest | USB_REQ_CLEAR_FEATURE:\n\n        if (value == USB_DEVICE_REMOTE_WAKEUP) {\n\n            dev->remote_wakeup = 0;\n\n        } else {\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n\n\n    case DeviceOutRequest | USB_REQ_SET_FEATURE:\n\n        if (value == USB_DEVICE_REMOTE_WAKEUP) {\n\n            dev->remote_wakeup = 1;\n\n        } else {\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n\n\n    case DeviceOutRequest | USB_REQ_SET_ADDRESS:\n\n        dev->addr = value;\n\n        ret = 0;\n\n        break;\n\n\n\n    case ClassInterfaceOutRequest | USB_CDC_SEND_ENCAPSULATED_COMMAND:\n\n        if (!s->rndis || value || index != 0)\n\n            goto fail;\n\n#ifdef TRAFFIC_DEBUG\n\n        {\n\n            unsigned int i;\n\n            fprintf(stderr, \"SEND_ENCAPSULATED_COMMAND:\");\n\n            for (i = 0; i < length; i++) {\n\n                if (!(i & 15))\n\n                    fprintf(stderr, \"\\n%04x:\", i);\n\n                fprintf(stderr, \" %02x\", data[i]);\n\n            }\n\n            fprintf(stderr, \"\\n\\n\");\n\n        }\n\n#endif\n\n        ret = rndis_parse(s, data, length);\n\n        break;\n\n\n\n    case ClassInterfaceRequest | USB_CDC_GET_ENCAPSULATED_RESPONSE:\n\n        if (!s->rndis || value || index != 0)\n\n            goto fail;\n\n        ret = rndis_get_response(s, data);\n\n        if (!ret) {\n\n            data[0] = 0;\n\n            ret = 1;\n\n        }\n\n#ifdef TRAFFIC_DEBUG\n\n        {\n\n            unsigned int i;\n\n            fprintf(stderr, \"GET_ENCAPSULATED_RESPONSE:\");\n\n            for (i = 0; i < ret; i++) {\n\n                if (!(i & 15))\n\n                    fprintf(stderr, \"\\n%04x:\", i);\n\n                fprintf(stderr, \" %02x\", data[i]);\n\n            }\n\n            fprintf(stderr, \"\\n\\n\");\n\n        }\n\n#endif\n\n        break;\n\n\n\n    case DeviceRequest | USB_REQ_GET_DESCRIPTOR:\n\n        switch(value >> 8) {\n\n        case USB_DT_DEVICE:\n\n            ret = sizeof(qemu_net_dev_descriptor);\n\n            memcpy(data, qemu_net_dev_descriptor, ret);\n\n            break;\n\n\n\n        case USB_DT_CONFIG:\n\n            switch (value & 0xff) {\n\n            case 0:\n\n                ret = sizeof(qemu_net_rndis_config_descriptor);\n\n                memcpy(data, qemu_net_rndis_config_descriptor, ret);\n\n                break;\n\n\n\n            case 1:\n\n                ret = sizeof(qemu_net_cdc_config_descriptor);\n\n                memcpy(data, qemu_net_cdc_config_descriptor, ret);\n\n                break;\n\n\n\n            default:\n\n                goto fail;\n\n            }\n\n\n\n            data[2] = ret & 0xff;\n\n            data[3] = ret >> 8;\n\n            break;\n\n\n\n        case USB_DT_STRING:\n\n            switch (value & 0xff) {\n\n            case 0:\n\n                \/* language ids *\/\n\n                data[0] = 4;\n\n                data[1] = 3;\n\n                data[2] = 0x09;\n\n                data[3] = 0x04;\n\n                ret = 4;\n\n                break;\n\n\n\n            case STRING_ETHADDR:\n\n                ret = set_usb_string(data, s->usbstring_mac);\n\n                break;\n\n\n\n            default:\n\n                if (usb_net_stringtable[value & 0xff]) {\n\n                    ret = set_usb_string(data,\n\n                                    usb_net_stringtable[value & 0xff]);\n\n                    break;\n\n                }\n\n\n\n                goto fail;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case DeviceRequest | USB_REQ_GET_CONFIGURATION:\n\n        data[0] = s->rndis ? DEV_RNDIS_CONFIG_VALUE : DEV_CONFIG_VALUE;\n\n        ret = 1;\n\n        break;\n\n\n\n    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n\n        switch (value & 0xff) {\n\n        case DEV_CONFIG_VALUE:\n\n            s->rndis = 0;\n\n            break;\n\n\n\n        case DEV_RNDIS_CONFIG_VALUE:\n\n            s->rndis = 1;\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n\n\n    case DeviceRequest | USB_REQ_GET_INTERFACE:\n\n    case InterfaceRequest | USB_REQ_GET_INTERFACE:\n\n        data[0] = 0;\n\n        ret = 1;\n\n        break;\n\n\n\n    case DeviceOutRequest | USB_REQ_SET_INTERFACE:\n\n    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:\n\n        ret = 0;\n\n        break;\n\n\n\n    default:\n\n    fail:\n\n        fprintf(stderr, \"usbnet: failed control transaction: \"\n\n                        \"request 0x%x value 0x%x index 0x%x length 0x%x\\n\",\n\n                        request, value, index, length);\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"0ff0fad23d3693ecf7a0c462cdb48f0e60f93808","target":0,"func":"static int win_chr_pipe_init(CharDriverState *chr, const char *filename,\n\n                             Error **errp)\n\n{\n\n    WinCharState *s = chr->opaque;\n\n    OVERLAPPED ov;\n\n    int ret;\n\n    DWORD size;\n\n    char openname[CHR_MAX_FILENAME_SIZE];\n\n\n\n    s->fpipe = TRUE;\n\n\n\n    s->hsend = CreateEvent(NULL, TRUE, FALSE, NULL);\n\n    if (!s->hsend) {\n\n        error_setg(errp, \"Failed CreateEvent\");\n\n        goto fail;\n\n    }\n\n    s->hrecv = CreateEvent(NULL, TRUE, FALSE, NULL);\n\n    if (!s->hrecv) {\n\n        error_setg(errp, \"Failed CreateEvent\");\n\n        goto fail;\n\n    }\n\n\n\n    snprintf(openname, sizeof(openname), \"\\\\\\\\.\\\\pipe\\\\%s\", filename);\n\n    s->hcom = CreateNamedPipe(openname, PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,\n\n                              PIPE_TYPE_BYTE | PIPE_READMODE_BYTE |\n\n                              PIPE_WAIT,\n\n                              MAXCONNECT, NSENDBUF, NRECVBUF, NTIMEOUT, NULL);\n\n    if (s->hcom == INVALID_HANDLE_VALUE) {\n\n        error_setg(errp, \"Failed CreateNamedPipe (%lu)\", GetLastError());\n\n        s->hcom = NULL;\n\n        goto fail;\n\n    }\n\n\n\n    ZeroMemory(&ov, sizeof(ov));\n\n    ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n\n    ret = ConnectNamedPipe(s->hcom, &ov);\n\n    if (ret) {\n\n        error_setg(errp, \"Failed ConnectNamedPipe\");\n\n        goto fail;\n\n    }\n\n\n\n    ret = GetOverlappedResult(s->hcom, &ov, &size, TRUE);\n\n    if (!ret) {\n\n        error_setg(errp, \"Failed GetOverlappedResult\");\n\n        if (ov.hEvent) {\n\n            CloseHandle(ov.hEvent);\n\n            ov.hEvent = NULL;\n\n        }\n\n        goto fail;\n\n    }\n\n\n\n    if (ov.hEvent) {\n\n        CloseHandle(ov.hEvent);\n\n        ov.hEvent = NULL;\n\n    }\n\n    qemu_add_polling_cb(win_chr_pipe_poll, chr);\n\n    return 0;\n\n\n\n fail:\n\n    win_chr_close(chr);\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"4154c7e03fa55b4cf52509a83d50d6c09d743b77","target":1,"func":"e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n\n{\n\n    return core->mac[r->dh] == core->mac[r->dt];\n\n}\n"},{"project":"qemu","commit_id":"7bd427d801e1e3293a634d3c83beadaa90ffb911","target":0,"func":"static int pxa2xx_rtc_init(SysBusDevice *dev)\n\n{\n\n    PXA2xxRTCState *s = FROM_SYSBUS(PXA2xxRTCState, dev);\n\n    struct tm tm;\n\n    int wom;\n\n    int iomemtype;\n\n\n\n    s->rttr = 0x7fff;\n\n    s->rtsr = 0;\n\n\n\n    qemu_get_timedate(&tm, 0);\n\n    wom = ((tm.tm_mday - 1) \/ 7) + 1;\n\n\n\n    s->last_rcnr = (uint32_t) mktimegm(&tm);\n\n    s->last_rdcr = (wom << 20) | ((tm.tm_wday + 1) << 17) |\n\n            (tm.tm_hour << 12) | (tm.tm_min << 6) | tm.tm_sec;\n\n    s->last_rycr = ((tm.tm_year + 1900) << 9) |\n\n            ((tm.tm_mon + 1) << 5) | tm.tm_mday;\n\n    s->last_swcr = (tm.tm_hour << 19) |\n\n            (tm.tm_min << 13) | (tm.tm_sec << 7);\n\n    s->last_rtcpicr = 0;\n\n    s->last_hz = s->last_sw = s->last_pi = qemu_get_clock(rt_clock);\n\n\n\n    s->rtc_hz    = qemu_new_timer(rt_clock, pxa2xx_rtc_hz_tick,    s);\n\n    s->rtc_rdal1 = qemu_new_timer(rt_clock, pxa2xx_rtc_rdal1_tick, s);\n\n    s->rtc_rdal2 = qemu_new_timer(rt_clock, pxa2xx_rtc_rdal2_tick, s);\n\n    s->rtc_swal1 = qemu_new_timer(rt_clock, pxa2xx_rtc_swal1_tick, s);\n\n    s->rtc_swal2 = qemu_new_timer(rt_clock, pxa2xx_rtc_swal2_tick, s);\n\n    s->rtc_pi    = qemu_new_timer(rt_clock, pxa2xx_rtc_pi_tick,    s);\n\n\n\n    sysbus_init_irq(dev, &s->rtc_irq);\n\n\n\n    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,\n\n                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    sysbus_init_mmio(dev, 0x10000, iomemtype);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"711e2f1e9ecad845e142fdddbbf1e8037bce902b","target":1,"func":"static void test_dynamic_globalprop(void)\n\n{\n\n    MyType *mt;\n\n    static GlobalProperty props[] = {\n\n        { TYPE_DYNAMIC_PROPS, \"prop1\", \"101\" },\n\n        { TYPE_DYNAMIC_PROPS, \"prop2\", \"102\" },\n\n        { TYPE_DYNAMIC_PROPS\"-bad\", \"prop3\", \"103\", true },\n\n        {}\n\n    };\n\n    int all_used;\n\n\n\n    qdev_prop_register_global_list(props);\n\n\n\n    mt = DYNAMIC_TYPE(object_new(TYPE_DYNAMIC_PROPS));\n\n    qdev_init_nofail(DEVICE(mt));\n\n\n\n    g_assert_cmpuint(mt->prop1, ==, 101);\n\n    g_assert_cmpuint(mt->prop2, ==, 102);\n\n\n\n}"},{"project":"qemu","commit_id":"43ae8fb10c5f6ca78f242624c1f446e0050a9d43","target":0,"func":"static int iscsi_reopen_prepare(BDRVReopenState *state,\n\n                                BlockReopenQueue *queue, Error **errp)\n\n{\n\n    \/* NOP *\/\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"a89f364ae8740dfc31b321eed9ee454e996dc3c1","target":0,"func":"static uint64_t onenand_read(void *opaque, hwaddr addr,\n\n                             unsigned size)\n\n{\n\n    OneNANDState *s = (OneNANDState *) opaque;\n\n    int offset = addr >> s->shift;\n\n\n\n    switch (offset) {\n\n    case 0x0000 ... 0xc000:\n\n        return lduw_le_p(s->boot[0] + addr);\n\n\n\n    case 0xf000:\t\/* Manufacturer ID *\/\n\n        return s->id.man;\n\n    case 0xf001:\t\/* Device ID *\/\n\n        return s->id.dev;\n\n    case 0xf002:\t\/* Version ID *\/\n\n        return s->id.ver;\n\n    \/* TODO: get the following values from a real chip!  *\/\n\n    case 0xf003:\t\/* Data Buffer size *\/\n\n        return 1 << PAGE_SHIFT;\n\n    case 0xf004:\t\/* Boot Buffer size *\/\n\n        return 0x200;\n\n    case 0xf005:\t\/* Amount of buffers *\/\n\n        return 1 | (2 << 8);\n\n    case 0xf006:\t\/* Technology *\/\n\n        return 0;\n\n\n\n    case 0xf100 ... 0xf107:\t\/* Start addresses *\/\n\n        return s->addr[offset - 0xf100];\n\n\n\n    case 0xf200:\t\/* Start buffer *\/\n\n        return (s->bufaddr << 8) | ((s->count - 1) & (1 << (PAGE_SHIFT - 10)));\n\n\n\n    case 0xf220:\t\/* Command *\/\n\n        return s->command;\n\n    case 0xf221:\t\/* System Configuration 1 *\/\n\n        return s->config[0] & 0xffe0;\n\n    case 0xf222:\t\/* System Configuration 2 *\/\n\n        return s->config[1];\n\n\n\n    case 0xf240:\t\/* Controller Status *\/\n\n        return s->status;\n\n    case 0xf241:\t\/* Interrupt *\/\n\n        return s->intstatus;\n\n    case 0xf24c:\t\/* Unlock Start Block Address *\/\n\n        return s->unladdr[0];\n\n    case 0xf24d:\t\/* Unlock End Block Address *\/\n\n        return s->unladdr[1];\n\n    case 0xf24e:\t\/* Write Protection Status *\/\n\n        return s->wpstatus;\n\n\n\n    case 0xff00:\t\/* ECC Status *\/\n\n        return 0x00;\n\n    case 0xff01:\t\/* ECC Result of main area data *\/\n\n    case 0xff02:\t\/* ECC Result of spare area data *\/\n\n    case 0xff03:\t\/* ECC Result of main area data *\/\n\n    case 0xff04:\t\/* ECC Result of spare area data *\/\n\n        hw_error(\"%s: imeplement ECC\\n\", __FUNCTION__);\n\n        return 0x0000;\n\n    }\n\n\n\n    fprintf(stderr, \"%s: unknown OneNAND register %x\\n\",\n\n                    __FUNCTION__, offset);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static uint64_t lance_mem_read(void *opaque, target_phys_addr_t addr,\n\n                               unsigned size)\n\n{\n\n    SysBusPCNetState *d = opaque;\n\n    uint32_t val;\n\n\n\n    val = pcnet_ioport_readw(&d->state, addr);\n\n    trace_lance_mem_readw(addr, val & 0xffff);\n\n    return val & 0xffff;\n\n}\n"},{"project":"qemu","commit_id":"a8cf66bb393ff420d40ae172a4c817bf2752918a","target":0,"func":"void  helper_evaluate_flags_alu_4(void)\n\n{\n\n\tuint32_t src;\n\n\tuint32_t dst;\n\n\tuint32_t res;\n\n\tuint32_t flags = 0;\n\n\n\n\tsrc = env->cc_src;\n\n\tdst = env->cc_dest;\n\n\n\n\t\/* Reconstruct the result.  *\/\n\n\tswitch (env->cc_op)\n\n\t{\n\n\t\tcase CC_OP_SUB:\n\n\t\t\tres = dst - src;\n\n\t\t\tbreak;\n\n\t\tcase CC_OP_ADD:\n\n\t\t\tres = dst + src;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tres = env->cc_result;\n\n\t\t\tbreak;\n\n\t}\n\n\n\n\tif (env->cc_op == CC_OP_SUB || env->cc_op == CC_OP_CMP)\n\n\t\tsrc = ~src;\n\n\n\n\tif ((res & 0x80000000L) != 0L)\n\n\t{\n\n\t\tflags |= N_FLAG;\n\n\t\tif (((src & 0x80000000L) == 0L)\n\n\t\t    && ((dst & 0x80000000L) == 0L))\n\n\t\t{\n\n\t\t\tflags |= V_FLAG;\n\n\t\t}\n\n\t\telse if (((src & 0x80000000L) != 0L) &&\n\n\t\t\t ((dst & 0x80000000L) != 0L))\n\n\t\t{\n\n\t\t\tflags |= C_FLAG;\n\n\t\t}\n\n\t}\n\n\telse\n\n\t{\n\n\t\tif (res == 0L)\n\n\t\t\tflags |= Z_FLAG;\n\n\t\tif (((src & 0x80000000L) != 0L)\n\n\t\t    && ((dst & 0x80000000L) != 0L))\n\n\t\t\tflags |= V_FLAG;\n\n\t\tif ((dst & 0x80000000L) != 0L\n\n\t\t    || (src & 0x80000000L) != 0L)\n\n\t\t\tflags |= C_FLAG;\n\n\t}\n\n\n\n\tif (env->cc_op == CC_OP_SUB\n\n\t    || env->cc_op == CC_OP_CMP) {\n\n\t\tflags ^= C_FLAG;\n\n\t}\n\n\tevaluate_flags_writeback(flags);\n\n}\n"},{"project":"qemu","commit_id":"4f9242fc931ab5e5b1b753c8e5a76c50c0b0612e","target":0,"func":"static void spapr_add_lmbs(DeviceState *dev, uint64_t addr_start, uint64_t size,\n\n                           uint32_t node, bool dedicated_hp_event_source,\n\n                           Error **errp)\n\n{\n\n    sPAPRDRConnector *drc;\n\n    uint32_t nr_lmbs = size\/SPAPR_MEMORY_BLOCK_SIZE;\n\n    int i, fdt_offset, fdt_size;\n\n    void *fdt;\n\n    uint64_t addr = addr_start;\n\n\n\n    for (i = 0; i < nr_lmbs; i++) {\n\n        drc = spapr_drc_by_id(TYPE_SPAPR_DRC_LMB,\n\n                              addr \/ SPAPR_MEMORY_BLOCK_SIZE);\n\n        g_assert(drc);\n\n\n\n        fdt = create_device_tree(&fdt_size);\n\n        fdt_offset = spapr_populate_memory_node(fdt, node, addr,\n\n                                                SPAPR_MEMORY_BLOCK_SIZE);\n\n\n\n        spapr_drc_attach(drc, dev, fdt, fdt_offset, !dev->hotplugged, errp);\n\n        addr += SPAPR_MEMORY_BLOCK_SIZE;\n\n        if (!dev->hotplugged) {\n\n            sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n            \/* guests expect coldplugged LMBs to be pre-allocated *\/\n\n            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_USABLE);\n\n            drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_UNISOLATED);\n\n        }\n\n    }\n\n    \/* send hotplug notification to the\n\n     * guest only in case of hotplugged memory\n\n     *\/\n\n    if (dev->hotplugged) {\n\n        if (dedicated_hp_event_source) {\n\n            drc = spapr_drc_by_id(TYPE_SPAPR_DRC_LMB,\n\n                                  addr_start \/ SPAPR_MEMORY_BLOCK_SIZE);\n\n            spapr_hotplug_req_add_by_count_indexed(SPAPR_DR_CONNECTOR_TYPE_LMB,\n\n                                                   nr_lmbs,\n\n                                                   spapr_drc_index(drc));\n\n        } else {\n\n            spapr_hotplug_req_add_by_count(SPAPR_DR_CONNECTOR_TYPE_LMB,\n\n                                           nr_lmbs);\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a1aff5bf6786e6e8478373e4ada869a4ef2a7fc4","target":1,"func":"static inline int media_present(IDEState *s)\n\n{\n\n    return (s->nb_sectors > 0);\n\n}\n"},{"project":"qemu","commit_id":"98f343395e937fa1db3a28dfb4f303f97cfddd6c","target":1,"func":"static void packet_id_queue_add(struct PacketIdQueue *q, uint64_t id)\n\n{\n\n    USBRedirDevice *dev = q->dev;\n\n    struct PacketIdQueueEntry *e;\n\n\n\n    DPRINTF(\"adding packet id %\"PRIu64\" to %s queue\\n\", id, q->name);\n\n\n\n    e = g_malloc0(sizeof(struct PacketIdQueueEntry));\n\n    e->id = id;\n\n    QTAILQ_INSERT_TAIL(&q->head, e, next);\n\n    q->size++;\n\n}\n"},{"project":"qemu","commit_id":"c2b38b277a7882a592f4f2ec955084b2b756daaa","target":0,"func":"aio_ctx_dispatch(GSource     *source,\n\n                 GSourceFunc  callback,\n\n                 gpointer     user_data)\n\n{\n\n    AioContext *ctx = (AioContext *) source;\n\n\n\n    assert(callback == NULL);\n\n    aio_dispatch(ctx, true);\n\n    return true;\n\n}\n"},{"project":"qemu","commit_id":"5c6c0e513600ba57c3e73b7151d3c0664438f7b5","target":1,"func":"static uint8_t *scsi_get_buf(SCSIDevice *d, uint32_t tag)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n    SCSIDiskReq *r;\n\n\n\n    r = scsi_find_request(s, tag);\n\n    if (!r) {\n\n        BADF(\"Bad buffer tag 0x%x\\n\", tag);\n\n        return NULL;\n\n    }\n\n    return (uint8_t *)r->iov.iov_base;\n\n}\n"},{"project":"qemu","commit_id":"dfd100f242370886bb6732f70f1f7cbd8eb9fedc","target":0,"func":"static int vnc_display_connect(VncDisplay *vd,\n\n                               SocketAddress **saddr,\n\n                               size_t nsaddr,\n\n                               SocketAddress **wsaddr,\n\n                               size_t nwsaddr,\n\n                               Error **errp)\n\n{\n\n    \/* connect to viewer *\/\n\n    QIOChannelSocket *sioc = NULL;\n\n    if (nwsaddr != 0) {\n\n        error_setg(errp, \"Cannot use websockets in reverse mode\");\n\n        return -1;\n\n    }\n\n    if (nsaddr != 1) {\n\n        error_setg(errp, \"Expected a single address in reverse mode\");\n\n        return -1;\n\n    }\n\n    \/* TODO SOCKET_ADDRESS_KIND_FD when fd has AF_UNIX *\/\n\n    vd->is_unix = saddr[0]->type == SOCKET_ADDRESS_KIND_UNIX;\n\n    sioc = qio_channel_socket_new();\n\n    qio_channel_set_name(QIO_CHANNEL(sioc), \"vnc-reverse\");\n\n    if (qio_channel_socket_connect_sync(sioc, saddr[0], errp) < 0) {\n\n        return -1;\n\n    }\n\n    vnc_connect(vd, sioc, false, false);\n\n    object_unref(OBJECT(sioc));\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"765003db029ed4660a09807958276e251de84fac","target":1,"func":"int bdrv_file_open(BlockDriverState **pbs, const char *filename,\n\n                   const char *reference, QDict *options, int flags,\n\n                   Error **errp)\n\n{\n\n    BlockDriverState *bs = NULL;\n\n    BlockDriver *drv;\n\n    const char *drvname;\n\n    bool allow_protocol_prefix = false;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    \/* NULL means an empty set of options *\/\n\n    if (options == NULL) {\n\n        options = qdict_new();\n\n    }\n\n\n\n    if (reference) {\n\n        if (filename || qdict_size(options)) {\n\n            error_setg(errp, \"Cannot reference an existing block device with \"\n\n                       \"additional options or a new filename\");\n\n            return -EINVAL;\n\n        }\n\n        QDECREF(options);\n\n\n\n        bs = bdrv_find(reference);\n\n        if (!bs) {\n\n            error_setg(errp, \"Cannot find block device '%s'\", reference);\n\n            return -ENODEV;\n\n        }\n\n        bdrv_ref(bs);\n\n        *pbs = bs;\n\n        return 0;\n\n    }\n\n\n\n    bs = bdrv_new(\"\");\n\n    bs->options = options;\n\n    options = qdict_clone_shallow(options);\n\n\n\n    \/* Fetch the file name from the options QDict if necessary *\/\n\n    if (!filename) {\n\n        filename = qdict_get_try_str(options, \"filename\");\n\n    } else if (filename && !qdict_haskey(options, \"filename\")) {\n\n        qdict_put(options, \"filename\", qstring_from_str(filename));\n\n        allow_protocol_prefix = true;\n\n    } else {\n\n        error_setg(errp, \"Can't specify 'file' and 'filename' options at the \"\n\n                   \"same time\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    \/* Find the right block driver *\/\n\n    drvname = qdict_get_try_str(options, \"driver\");\n\n    if (drvname) {\n\n        drv = bdrv_find_format(drvname);\n\n        if (!drv) {\n\n            error_setg(errp, \"Unknown driver '%s'\", drvname);\n\n        }\n\n        qdict_del(options, \"driver\");\n\n    } else if (filename) {\n\n        drv = bdrv_find_protocol(filename, allow_protocol_prefix);\n\n        if (!drv) {\n\n            error_setg(errp, \"Unknown protocol\");\n\n        }\n\n    } else {\n\n        error_setg(errp, \"Must specify either driver or file\");\n\n        drv = NULL;\n\n    }\n\n\n\n    if (!drv) {\n\n        \/* errp has been set already *\/\n\n        ret = -ENOENT;\n\n        goto fail;\n\n    }\n\n\n\n    \/* Parse the filename and open it *\/\n\n    if (drv->bdrv_parse_filename && filename) {\n\n        drv->bdrv_parse_filename(filename, options, &local_err);\n\n        if (error_is_set(&local_err)) {\n\n            error_propagate(errp, local_err);\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n        qdict_del(options, \"filename\");\n\n    } else if (drv->bdrv_needs_filename && !filename) {\n\n        error_setg(errp, \"The '%s' block driver requires a file name\",\n\n                   drv->format_name);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    if (!drv->bdrv_file_open) {\n\n        ret = bdrv_open(bs, filename, options, flags, drv, &local_err);\n\n        options = NULL;\n\n    } else {\n\n        ret = bdrv_open_common(bs, NULL, options, flags, drv, &local_err);\n\n    }\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    \/* Check if any unknown options were used *\/\n\n    if (options && (qdict_size(options) != 0)) {\n\n        const QDictEntry *entry = qdict_first(options);\n\n        error_setg(errp, \"Block protocol '%s' doesn't support the option '%s'\",\n\n                   drv->format_name, entry->key);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    QDECREF(options);\n\n\n\n    bs->growable = 1;\n\n    *pbs = bs;\n\n    return 0;\n\n\n\nfail:\n\n    QDECREF(options);\n\n    if (!bs->drv) {\n\n        QDECREF(bs->options);\n\n    }\n\n    bdrv_unref(bs);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"45a50b1668822c23afc2a89f724654e176518bc4","target":0,"func":"int read_targphys(int fd, target_phys_addr_t dst_addr, size_t nbytes)\n\n{\n\n    uint8_t buf[4096];\n\n    target_phys_addr_t dst_begin = dst_addr;\n\n    size_t want, did;\n\n\n\n    while (nbytes) {\n\n\twant = nbytes > sizeof(buf) ? sizeof(buf) : nbytes;\n\n\tdid = read(fd, buf, want);\n\n\tif (did != want) break;\n\n\n\n\tcpu_physical_memory_write_rom(dst_addr, buf, did);\n\n\tdst_addr += did;\n\n\tnbytes -= did;\n\n    }\n\n    return dst_addr - dst_begin;\n\n}\n"},{"project":"qemu","commit_id":"4d6a0680fa425230748a2d91d81be9afe050eeb3","target":1,"func":"static void gen_mtspr(DisasContext *ctx)\n\n{\n\n    void (*write_cb)(DisasContext *ctx, int sprn, int gprn);\n\n    uint32_t sprn = SPR(ctx->opcode);\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n    write_cb = ctx->spr_cb[sprn].uea_write;\n\n#else\n\n    if (ctx->pr) {\n\n        write_cb = ctx->spr_cb[sprn].uea_write;\n\n    } else if (ctx->hv) {\n\n        write_cb = ctx->spr_cb[sprn].hea_write;\n\n    } else {\n\n        write_cb = ctx->spr_cb[sprn].oea_write;\n\n    }\n\n#endif\n\n    if (likely(write_cb != NULL)) {\n\n        if (likely(write_cb != SPR_NOACCESS)) {\n\n            (*write_cb)(ctx, sprn, rS(ctx->opcode));\n\n        } else {\n\n            \/* Privilege exception *\/\n\n            fprintf(stderr, \"Trying to write privileged spr %d (0x%03x) at \"\n\n                    TARGET_FMT_lx \"\\n\", sprn, sprn, ctx->nip - 4);\n\n            if (qemu_log_separate()) {\n\n                qemu_log(\"Trying to write privileged spr %d (0x%03x) at \"\n\n                         TARGET_FMT_lx \"\\n\", sprn, sprn, ctx->nip - 4);\n\n            }\n\n            gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        }\n\n    } else {\n\n        \/* Not defined *\/\n\n        if (qemu_log_separate()) {\n\n            qemu_log(\"Trying to write invalid spr %d (0x%03x) at \"\n\n                     TARGET_FMT_lx \"\\n\", sprn, sprn, ctx->nip - 4);\n\n        }\n\n        fprintf(stderr, \"Trying to write invalid spr %d (0x%03x) at \"\n\n                TARGET_FMT_lx \"\\n\", sprn, sprn, ctx->nip - 4);\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_SPR);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a4d8e8daee324e230b0155915f562743f4fff5d8","target":1,"func":"static void vscsi_got_payload(VSCSIState *s, vscsi_crq *crq)\n\n{\n\n    vscsi_req *req;\n\n    int done;\n\n\n\n    req = vscsi_get_req(s);\n\n    if (req == NULL) {\n\n        fprintf(stderr, \"VSCSI: Failed to get a request !\\n\");\n\n        return;\n\n    }\n\n\n\n    \/* We only support a limited number of descriptors, we know\n\n     * the ibmvscsi driver uses up to 10 max, so it should fit\n\n     * in our 256 bytes IUs. If not we'll have to increase the size\n\n     * of the structure.\n\n     *\/\n\n    if (crq->s.IU_length > sizeof(union viosrp_iu)) {\n\n        fprintf(stderr, \"VSCSI: SRP IU too long (%d bytes) !\\n\",\n\n                crq->s.IU_length);\n\n        return;\n\n    }\n\n\n\n    \/* XXX Handle failure differently ? *\/\n\n    if (spapr_tce_dma_read(&s->vdev, crq->s.IU_data_ptr, &req->iu,\n\n                           crq->s.IU_length)) {\n\n        fprintf(stderr, \"vscsi_got_payload: DMA read failure !\\n\");\n\n        g_free(req);\n\n    }\n\n    memcpy(&req->crq, crq, sizeof(vscsi_crq));\n\n\n\n    if (crq->s.format == VIOSRP_MAD_FORMAT) {\n\n        done = vscsi_handle_mad_req(s, req);\n\n    } else {\n\n        done = vscsi_handle_srp_req(s, req);\n\n    }\n\n\n\n    if (done) {\n\n        vscsi_put_req(req);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a307d59434ba78b97544b42b8cfd24a1b62e39a6","target":0,"func":"static void vty_receive(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    VIOsPAPRVTYDevice *dev = (VIOsPAPRVTYDevice *)opaque;\n\n    int i;\n\n\n\n    if ((dev->in == dev->out) && size) {\n\n        \/* toggle line to simulate edge interrupt *\/\n\n        qemu_irq_pulse(dev->sdev.qirq);\n\n    }\n\n    for (i = 0; i < size; i++) {\n\n        assert((dev->in - dev->out) < VTERM_BUFSIZE);\n\n        dev->buf[dev->in++ % VTERM_BUFSIZE] = buf[i];\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"44701ab71ad854e6be567a6294f4665f36651076","target":0,"func":"void msix_load(PCIDevice *dev, QEMUFile *f)\n\n{\n\n    unsigned n = dev->msix_entries_nr;\n\n    unsigned int vector;\n\n\n\n    if (!(dev->cap_present & QEMU_PCI_CAP_MSIX)) {\n\n        return;\n\n    }\n\n\n\n    msix_free_irq_entries(dev);\n\n    qemu_get_buffer(f, dev->msix_table_page, n * PCI_MSIX_ENTRY_SIZE);\n\n    qemu_get_buffer(f, dev->msix_table_page + MSIX_PAGE_PENDING, (n + 7) \/ 8);\n\n    msix_update_function_masked(dev);\n\n\n\n    for (vector = 0; vector < n; vector++) {\n\n        msix_handle_mask_update(dev, vector, true);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"384acbf46b70edf0d2c1648aa1a92a90bcf7057d","target":0,"func":"static int bdrv_qed_is_allocated(BlockDriverState *bs, int64_t sector_num,\n\n                                  int nb_sectors, int *pnum)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n    uint64_t pos = (uint64_t)sector_num * BDRV_SECTOR_SIZE;\n\n    size_t len = (size_t)nb_sectors * BDRV_SECTOR_SIZE;\n\n    QEDIsAllocatedCB cb = {\n\n        .is_allocated = -1,\n\n        .pnum = pnum,\n\n    };\n\n    QEDRequest request = { .l2_table = NULL };\n\n\n\n    async_context_push();\n\n\n\n    qed_find_cluster(s, &request, pos, len, qed_is_allocated_cb, &cb);\n\n\n\n    while (cb.is_allocated == -1) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\n    async_context_pop();\n\n\n\n    qed_unref_l2_cache_entry(request.l2_table);\n\n\n\n    return cb.is_allocated;\n\n}\n"},{"project":"qemu","commit_id":"10a412dab3f54439ea3d60274eb41668f7d83bd2","target":0,"func":"static void sd_response_r1_make(SDState *sd,\n\n                                uint8_t *response, uint32_t last_status)\n\n{\n\n    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;\n\n    uint32_t status;\n\n\n\n    status = (sd->card_status & ~mask) | (last_status & mask);\n\n    sd->card_status &= ~CARD_STATUS_C | APP_CMD;\n\n\n\n    response[0] = (status >> 24) & 0xff;\n\n    response[1] = (status >> 16) & 0xff;\n\n    response[2] = (status >> 8) & 0xff;\n\n    response[3] = (status >> 0) & 0xff;\n\n}\n"},{"project":"qemu","commit_id":"e3ff9f0e57472e6411dc446b41789cbd9e2cf887","target":0,"func":"static void test_to_from_buf_1(void)\n\n{\n\n     unsigned niov;\n\n     struct iovec *iov;\n\n     size_t sz;\n\n     unsigned char *ibuf, *obuf;\n\n     unsigned i, j, n;\n\n\n\n     iov_random(&iov, &niov);\n\n\n\n     sz = iov_size(iov, niov);\n\n\n\n     ibuf = g_malloc(sz + 8) + 4;\n\n     memcpy(ibuf-4, \"aaaa\", 4); memcpy(ibuf + sz, \"bbbb\", 4);\n\n     obuf = g_malloc(sz + 8) + 4;\n\n     memcpy(obuf-4, \"xxxx\", 4); memcpy(obuf + sz, \"yyyy\", 4);\n\n\n\n     \/* fill in ibuf with 0123456... *\/\n\n     for (i = 0; i < sz; ++i) {\n\n         ibuf[i] = i & 255;\n\n     }\n\n\n\n     for (i = 0; i <= sz; ++i) {\n\n\n\n         \/* Test from\/to buf for offset(i) in [0..sz] up to the end of buffer.\n\n          * For last iteration with offset == sz, the procedure should\n\n          * skip whole vector and process exactly 0 bytes *\/\n\n\n\n         \/* first set bytes [i..sz) to some \"random\" value *\/\n\n         n = iov_memset(iov, niov, 0, 0xff, -1);\n\n         g_assert(n == sz);\n\n\n\n         \/* next copy bytes [i..sz) from ibuf to iovec *\/\n\n         n = iov_from_buf(iov, niov, i, ibuf + i, -1);\n\n         g_assert(n == sz - i);\n\n\n\n         \/* clear part of obuf *\/\n\n         memset(obuf + i, 0, sz - i);\n\n         \/* and set this part of obuf to values from iovec *\/\n\n         n = iov_to_buf(iov, niov, i, obuf + i, -1);\n\n         g_assert(n == sz - i);\n\n\n\n         \/* now compare resulting buffers *\/\n\n         g_assert(memcmp(ibuf, obuf, sz) == 0);\n\n\n\n         \/* test just one char *\/\n\n         n = iov_to_buf(iov, niov, i, obuf + i, 1);\n\n         g_assert(n == (i < sz));\n\n         if (n) {\n\n             g_assert(obuf[i] == (i & 255));\n\n         }\n\n\n\n         for (j = i; j <= sz; ++j) {\n\n             \/* now test num of bytes cap up to byte no. j,\n\n              * with j in [i..sz]. *\/\n\n\n\n             \/* clear iovec *\/\n\n             n = iov_memset(iov, niov, 0, 0xff, -1);\n\n             g_assert(n == sz);\n\n\n\n             \/* copy bytes [i..j) from ibuf to iovec *\/\n\n             n = iov_from_buf(iov, niov, i, ibuf + i, j - i);\n\n             g_assert(n == j - i);\n\n\n\n             \/* clear part of obuf *\/\n\n             memset(obuf + i, 0, j - i);\n\n\n\n             \/* copy bytes [i..j) from iovec to obuf *\/\n\n             n = iov_to_buf(iov, niov, i, obuf + i, j - i);\n\n             g_assert(n == j - i);\n\n\n\n             \/* verify result *\/\n\n             g_assert(memcmp(ibuf, obuf, sz) == 0);\n\n\n\n             \/* now actually check if the iovec contains the right data *\/\n\n             test_iov_bytes(iov, niov, i, j - i);\n\n         }\n\n    }\n\n    g_assert(!memcmp(ibuf-4, \"aaaa\", 4) && !memcmp(ibuf+sz, \"bbbb\", 4));\n\n    g_free(ibuf-4);\n\n    g_assert(!memcmp(obuf-4, \"xxxx\", 4) && !memcmp(obuf+sz, \"yyyy\", 4));\n\n    g_free(obuf-4);\n\n    iov_free(iov, niov);\n\n}\n"},{"project":"qemu","commit_id":"5dafc53f1fb091d242f2179ffcb43bb28af36d1e","target":0,"func":"QEMUFile *qemu_fopen(const char *filename, const char *mode)\n\n{\n\n    QEMUFile *f;\n\n\n\n    f = qemu_mallocz(sizeof(QEMUFile));\n\n    if (!f)\n\n        return NULL;\n\n    if (!strcmp(mode, \"wb\")) {\n\n        f->is_writable = 1;\n\n    } else if (!strcmp(mode, \"rb\")) {\n\n        f->is_writable = 0;\n\n    } else {\n\n        goto fail;\n\n    }\n\n    f->outfile = fopen(filename, mode);\n\n    if (!f->outfile)\n\n        goto fail;\n\n    f->is_file = 1;\n\n    return f;\n\n fail:\n\n    if (f->outfile)\n\n        fclose(f->outfile);\n\n    qemu_free(f);\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"baf35cb90204d75404892aa4e52628ae7a00669b","target":1,"func":"static int bdrv_write_em(BlockDriverState *bs, int64_t sector_num,\n\n                         const uint8_t *buf, int nb_sectors)\n\n{\n\n    int async_ret;\n\n    BlockDriverAIOCB *acb;\n\n\n\n    async_ret = NOT_DONE;\n\n    qemu_aio_wait_start();\n\n    acb = bdrv_aio_write(bs, sector_num, buf, nb_sectors,\n\n                         bdrv_rw_em_cb, &async_ret);\n\n    if (acb == NULL) {\n\n        qemu_aio_wait_end();\n\n        return -1;\n\n    }\n\n    while (async_ret == NOT_DONE) {\n\n        qemu_aio_wait();\n\n    }\n\n    qemu_aio_wait_end();\n\n    return async_ret;\n\n}\n"},{"project":"qemu","commit_id":"2e84849aa2cc7f220d3b3668f5f7e3c57bb1b590","target":0,"func":"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,\n\n                                   const char *name, Error **errp)\n\n{\n\n    X86CPU *cpu = X86_CPU(obj);\n\n    const int64_t min = 0;\n\n    const int64_t max = INT_MAX;\n\n    int64_t value;\n\n\n\n    visit_type_int(v, &value, name, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n    if (value < min || value > max) {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, \"\",\n\n                  name ? name : \"null\", value, min, max);\n\n        return;\n\n    }\n\n\n\n    cpu->env.tsc_khz = value \/ 1000;\n\n}\n"},{"project":"qemu","commit_id":"51b19ebe4320f3dcd93cea71235c1219318ddfd2","target":0,"func":"VirtIOBlockReq *virtio_blk_alloc_request(VirtIOBlock *s)\n\n{\n\n    VirtIOBlockReq *req = g_new(VirtIOBlockReq, 1);\n\n    req->dev = s;\n\n    req->qiov.size = 0;\n\n    req->in_len = 0;\n\n    req->next = NULL;\n\n    req->mr_next = NULL;\n\n    return req;\n\n}\n"},{"project":"qemu","commit_id":"364031f17932814484657e5551ba12957d993d7e","target":0,"func":"static off_t v9fs_synth_telldir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    V9fsSynthOpenState *synth_open = fs->private;\n\n    return synth_open->offset;\n\n}\n"},{"project":"qemu","commit_id":"27af7d6ea5015e5ef1f7985eab94a8a218267a2b","target":1,"func":"int cache_insert(PageCache *cache, uint64_t addr, const uint8_t *pdata)\n\n{\n\n\n\n    CacheItem *it = NULL;\n\n\n\n    g_assert(cache);\n\n    g_assert(cache->page_cache);\n\n\n\n    \/* actual update of entry *\/\n\n    it = cache_get_by_addr(cache, addr);\n\n\n\n    \/* allocate page *\/\n\n    if (!it->it_data) {\n\n        it->it_data = g_try_malloc(cache->page_size);\n\n        if (!it->it_data) {\n\n            DPRINTF(\"Error allocating page\\n\");\n\n            return -1;\n\n        }\n\n        cache->num_items++;\n\n    }\n\n\n\n    memcpy(it->it_data, pdata, cache->page_size);\n\n\n\n    it->it_age = ++cache->max_item_age;\n\n    it->it_addr = addr;\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"8297be80f7cf71e09617669a8bd8b2836dcfd4c3","target":0,"func":"static void hax_process_section(MemoryRegionSection *section, uint8_t flags)\n\n{\n\n    MemoryRegion *mr = section->mr;\n\n    hwaddr start_pa = section->offset_within_address_space;\n\n    ram_addr_t size = int128_get64(section->size);\n\n    unsigned int delta;\n\n    uint64_t host_va;\n\n\n\n    \/* We only care about RAM and ROM regions *\/\n\n    if (!memory_region_is_ram(mr)) {\n\n        if (memory_region_is_romd(mr)) {\n\n            \/* HAXM kernel module does not support ROMD yet  *\/\n\n            fprintf(stderr, \"%s: Warning: Ignoring ROMD region 0x%016\" PRIx64\n\n                    \"->0x%016\" PRIx64 \"\\n\", __func__, start_pa,\n\n                    start_pa + size);\n\n        }\n\n        return;\n\n    }\n\n\n\n    \/* Adjust start_pa and size so that they are page-aligned. (Cf\n\n     * kvm_set_phys_mem() in kvm-all.c).\n\n     *\/\n\n    delta = qemu_real_host_page_size - (start_pa & ~qemu_real_host_page_mask);\n\n    delta &= ~qemu_real_host_page_mask;\n\n    if (delta > size) {\n\n        return;\n\n    }\n\n    start_pa += delta;\n\n    size -= delta;\n\n    size &= qemu_real_host_page_mask;\n\n    if (!size || (start_pa & ~qemu_real_host_page_mask)) {\n\n        return;\n\n    }\n\n\n\n    host_va = (uintptr_t)memory_region_get_ram_ptr(mr)\n\n            + section->offset_within_region + delta;\n\n    if (memory_region_is_rom(section->mr)) {\n\n        flags |= HAX_RAM_INFO_ROM;\n\n    }\n\n\n\n    \/* the kernel module interface uses 32-bit sizes (but we could split...) *\/\n\n    g_assert(size <= UINT32_MAX);\n\n\n\n    hax_update_mapping(start_pa, size, host_va, flags);\n\n}\n"},{"project":"qemu","commit_id":"ec05ec26f940564b1e07bf88857035ec27e21dd8","target":0,"func":"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,\n\n                             hwaddr size)\n\n{\n\n    assert(mr->terminates);\n\n    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,\n\n                                        memory_region_get_dirty_log_mask(mr));\n\n}\n"},{"project":"qemu","commit_id":"91b0a8f33419573c1d741e49559bfb666fd8b1f0","target":0,"func":"static void do_io_interrupt(CPUS390XState *env)\n\n{\n\n    LowCore *lowcore;\n\n    IOIntQueue *q;\n\n    uint8_t isc;\n\n    int disable = 1;\n\n    int found = 0;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_IO)) {\n\n        cpu_abort(env, \"I\/O int w\/o I\/O mask\\n\");\n\n    }\n\n\n\n    for (isc = 0; isc < ARRAY_SIZE(env->io_index); isc++) {\n\n        if (env->io_index[isc] < 0) {\n\n            continue;\n\n        }\n\n        if (env->io_index[isc] > MAX_IO_QUEUE) {\n\n            cpu_abort(env, \"I\/O queue overrun for isc %d: %d\\n\",\n\n                      isc, env->io_index[isc]);\n\n        }\n\n\n\n        q = &env->io_queue[env->io_index[isc]][isc];\n\n        if (!(env->cregs[6] & q->word)) {\n\n            disable = 0;\n\n            continue;\n\n        }\n\n        if (!found) {\n\n            uint64_t mask, addr;\n\n\n\n            found = 1;\n\n            lowcore = cpu_map_lowcore(env);\n\n\n\n            lowcore->subchannel_id = cpu_to_be16(q->id);\n\n            lowcore->subchannel_nr = cpu_to_be16(q->nr);\n\n            lowcore->io_int_parm = cpu_to_be32(q->parm);\n\n            lowcore->io_int_word = cpu_to_be32(q->word);\n\n            lowcore->io_old_psw.mask = cpu_to_be64(get_psw_mask(env));\n\n            lowcore->io_old_psw.addr = cpu_to_be64(env->psw.addr);\n\n            mask = be64_to_cpu(lowcore->io_new_psw.mask);\n\n            addr = be64_to_cpu(lowcore->io_new_psw.addr);\n\n\n\n            cpu_unmap_lowcore(lowcore);\n\n\n\n            env->io_index[isc]--;\n\n\n\n            DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__,\n\n                    env->psw.mask, env->psw.addr);\n\n            load_psw(env, mask, addr);\n\n        }\n\n        if (env->io_index[isc] >= 0) {\n\n            disable = 0;\n\n        }\n\n        continue;\n\n    }\n\n\n\n    if (disable) {\n\n        env->pending_int &= ~INTERRUPT_IO;\n\n    }\n\n\n\n}\n"},{"project":"qemu","commit_id":"a153bf52b37e148f052b0869600877130671a03d","target":0,"func":"bool aio_dispatch(AioContext *ctx, bool dispatch_fds)\n\n{\n\n    bool progress;\n\n\n\n    progress = aio_bh_poll(ctx);\n\n    if (dispatch_fds) {\n\n        progress |= aio_dispatch_handlers(ctx, INVALID_HANDLE_VALUE);\n\n    }\n\n    progress |= timerlistgroup_run_timers(&ctx->tlg);\n\n    return progress;\n\n}\n"},{"project":"qemu","commit_id":"39355c3826f5d9a2eb1ce3dc9b4cdd68893769d6","target":0,"func":"void qbus_create_inplace(BusState *bus, const char *typename,\n\n                         DeviceState *parent, const char *name)\n\n{\n\n    object_initialize(bus, typename);\n\n    qbus_realize(bus, parent, name);\n\n}\n"},{"project":"qemu","commit_id":"f678f671ba654d4610f0e43d175c8c1b2fad10df","target":1,"func":"static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    int32_t op2;\n\n    int32_t r1;\n\n    uint32_t address;\n\n    TCGv temp;\n\n\n\n    r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n    address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n    op2 = MASK_OP_ABS_OP2(ctx->opcode);\n\n\n\n    temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n\n\n    switch (op2) {\n\n    case OPC2_32_ABS_ST_A:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n    case OPC2_32_ABS_ST_D:\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_DA:\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_W:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n\n\n    }\n\n    tcg_temp_free(temp);\n\n}\n"},{"project":"qemu","commit_id":"c18ad9a54b75495ce61e8b28d353f8eec51768fc","target":0,"func":"static target_ulong h_protect(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                              target_ulong opcode, target_ulong *args)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    target_ulong flags = args[0];\n\n    target_ulong pte_index = args[1];\n\n    target_ulong avpn = args[2];\n\n    uint64_t token;\n\n    target_ulong v, r;\n\n\n\n    if (!valid_pte_index(env, pte_index)) {\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    token = ppc_hash64_start_access(cpu, pte_index);\n\n    v = ppc_hash64_load_hpte0(cpu, token, 0);\n\n    r = ppc_hash64_load_hpte1(cpu, token, 0);\n\n    ppc_hash64_stop_access(token);\n\n\n\n    if ((v & HPTE64_V_VALID) == 0 ||\n\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn)) {\n\n        return H_NOT_FOUND;\n\n    }\n\n\n\n    r &= ~(HPTE64_R_PP0 | HPTE64_R_PP | HPTE64_R_N |\n\n           HPTE64_R_KEY_HI | HPTE64_R_KEY_LO);\n\n    r |= (flags << 55) & HPTE64_R_PP0;\n\n    r |= (flags << 48) & HPTE64_R_KEY_HI;\n\n    r |= flags & (HPTE64_R_PP | HPTE64_R_N | HPTE64_R_KEY_LO);\n\n    ppc_hash64_store_hpte(cpu, pte_index,\n\n                          (v & ~HPTE64_V_VALID) | HPTE64_V_HPTE_DIRTY, 0);\n\n    ppc_hash64_tlb_flush_hpte(cpu, pte_index, v, r);\n\n    \/* Don't need a memory barrier, due to qemu's global lock *\/\n\n    ppc_hash64_store_hpte(cpu, pte_index, v | HPTE64_V_HPTE_DIRTY, r);\n\n    return H_SUCCESS;\n\n}\n"},{"project":"qemu","commit_id":"f0afa73164778570083504a185d7498884c68d65","target":0,"func":"static void bcm2835_property_mbox_push(BCM2835PropertyState *s, uint32_t value)\n\n{\n\n    uint32_t tag;\n\n    uint32_t bufsize;\n\n    uint32_t tot_len;\n\n    size_t resplen;\n\n    uint32_t tmp;\n\n\n\n    value &= ~0xf;\n\n\n\n    s->addr = value;\n\n\n\n    tot_len = ldl_phys(&s->dma_as, value);\n\n\n\n    \/* @(addr + 4) : Buffer response code *\/\n\n    value = s->addr + 8;\n\n    while (value + 8 <= s->addr + tot_len) {\n\n        tag = ldl_phys(&s->dma_as, value);\n\n        bufsize = ldl_phys(&s->dma_as, value + 4);\n\n        \/* @(value + 8) : Request\/response indicator *\/\n\n        resplen = 0;\n\n        switch (tag) {\n\n        case 0x00000000: \/* End tag *\/\n\n            break;\n\n        case 0x00000001: \/* Get firmware revision *\/\n\n            stl_phys(&s->dma_as, value + 12, 346337);\n\n            resplen = 4;\n\n            break;\n\n        case 0x00010001: \/* Get board model *\/\n\n            qemu_log_mask(LOG_UNIMP,\n\n                          \"bcm2835_property: %x get board model NYI\\n\", tag);\n\n            resplen = 4;\n\n            break;\n\n        case 0x00010002: \/* Get board revision *\/\n\n            qemu_log_mask(LOG_UNIMP,\n\n                          \"bcm2835_property: %x get board revision NYI\\n\", tag);\n\n            resplen = 4;\n\n            break;\n\n        case 0x00010003: \/* Get board MAC address *\/\n\n            resplen = sizeof(s->macaddr.a);\n\n            dma_memory_write(&s->dma_as, value + 12, s->macaddr.a, resplen);\n\n            break;\n\n        case 0x00010004: \/* Get board serial *\/\n\n            qemu_log_mask(LOG_UNIMP,\n\n                          \"bcm2835_property: %x get board serial NYI\\n\", tag);\n\n            resplen = 8;\n\n            break;\n\n        case 0x00010005: \/* Get ARM memory *\/\n\n            \/* base *\/\n\n            stl_phys(&s->dma_as, value + 12, 0);\n\n            \/* size *\/\n\n            stl_phys(&s->dma_as, value + 16, s->ram_size);\n\n            resplen = 8;\n\n            break;\n\n        case 0x00028001: \/* Set power state *\/\n\n            \/* Assume that whatever device they asked for exists,\n\n             * and we'll just claim we set it to the desired state\n\n             *\/\n\n            tmp = ldl_phys(&s->dma_as, value + 16);\n\n            stl_phys(&s->dma_as, value + 16, (tmp & 1));\n\n            resplen = 8;\n\n            break;\n\n\n\n        \/* Clocks *\/\n\n\n\n        case 0x00030001: \/* Get clock state *\/\n\n            stl_phys(&s->dma_as, value + 16, 0x1);\n\n            resplen = 8;\n\n            break;\n\n\n\n        case 0x00038001: \/* Set clock state *\/\n\n            qemu_log_mask(LOG_UNIMP,\n\n                          \"bcm2835_property: %x set clock state NYI\\n\", tag);\n\n            resplen = 8;\n\n            break;\n\n\n\n        case 0x00030002: \/* Get clock rate *\/\n\n        case 0x00030004: \/* Get max clock rate *\/\n\n        case 0x00030007: \/* Get min clock rate *\/\n\n            switch (ldl_phys(&s->dma_as, value + 12)) {\n\n            case 1: \/* EMMC *\/\n\n                stl_phys(&s->dma_as, value + 16, 50000000);\n\n                break;\n\n            case 2: \/* UART *\/\n\n                stl_phys(&s->dma_as, value + 16, 3000000);\n\n                break;\n\n            default:\n\n                stl_phys(&s->dma_as, value + 16, 700000000);\n\n                break;\n\n            }\n\n            resplen = 8;\n\n            break;\n\n\n\n        case 0x00038002: \/* Set clock rate *\/\n\n        case 0x00038004: \/* Set max clock rate *\/\n\n        case 0x00038007: \/* Set min clock rate *\/\n\n            qemu_log_mask(LOG_UNIMP,\n\n                          \"bcm2835_property: %x set clock rates NYI\\n\", tag);\n\n            resplen = 8;\n\n            break;\n\n\n\n        \/* Temperature *\/\n\n\n\n        case 0x00030006: \/* Get temperature *\/\n\n            stl_phys(&s->dma_as, value + 16, 25000);\n\n            resplen = 8;\n\n            break;\n\n\n\n        case 0x0003000A: \/* Get max temperature *\/\n\n            stl_phys(&s->dma_as, value + 16, 99000);\n\n            resplen = 8;\n\n            break;\n\n\n\n\n\n        case 0x00060001: \/* Get DMA channels *\/\n\n            \/* channels 2-5 *\/\n\n            stl_phys(&s->dma_as, value + 12, 0x003C);\n\n            resplen = 4;\n\n            break;\n\n\n\n        case 0x00050001: \/* Get command line *\/\n\n            resplen = 0;\n\n            break;\n\n\n\n        default:\n\n            qemu_log_mask(LOG_GUEST_ERROR,\n\n                          \"bcm2835_property: unhandled tag %08x\\n\", tag);\n\n            break;\n\n        }\n\n\n\n        if (tag == 0) {\n\n            break;\n\n        }\n\n\n\n        stl_phys(&s->dma_as, value + 8, (1 << 31) | resplen);\n\n        value += bufsize + 12;\n\n    }\n\n\n\n    \/* Buffer response code *\/\n\n    stl_phys(&s->dma_as, s->addr + 4, (1 << 31));\n\n}\n"},{"project":"qemu","commit_id":"61007b316cd71ee7333ff7a0a749a8949527575f","target":0,"func":"static void coroutine_fn bdrv_discard_co_entry(void *opaque)\n\n{\n\n    DiscardCo *rwco = opaque;\n\n\n\n    rwco->ret = bdrv_co_discard(rwco->bs, rwco->sector_num, rwco->nb_sectors);\n\n}\n"},{"project":"qemu","commit_id":"d9bce9d99f4656ae0b0127f7472db9067b8f84ab","target":1,"func":"PPC_OP(test_ctr)\n\n{\n\n    T0 = regs->ctr;\n\n    RETURN();\n\n}\n"},{"project":"qemu","commit_id":"2d0d2837dcf786da415cf4165d37f4ddd684ff57","target":0,"func":"static void default_drive(int enable, int snapshot, int use_scsi,\n\n                          BlockInterfaceType type, int index,\n\n                          const char *optstr)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    if (type == IF_DEFAULT) {\n\n        type = use_scsi ? IF_SCSI : IF_IDE;\n\n    }\n\n\n\n    if (!enable || drive_get_by_index(type, index)) {\n\n        return;\n\n    }\n\n\n\n    opts = drive_add(type, index, NULL, optstr);\n\n    if (snapshot) {\n\n        drive_enable_snapshot(opts, NULL);\n\n    }\n\n    if (!drive_init(opts, use_scsi)) {\n\n        exit(1);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"48a402e693cbea9582472159931aa6799a6c80c7","target":0,"func":"static int curl_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVCURLState *s = bs->opaque;\n\n    CURLState *state = NULL;\n\n    double d;\n\n\n\n    #define RA_OPTSTR \":readahead=\"\n\n    char *file;\n\n    char *ra;\n\n    const char *ra_val;\n\n    int parse_state = 0;\n\n\n\n    static int inited = 0;\n\n\n\n    file = strdup(filename);\n\n    s->readahead_size = READ_AHEAD_SIZE;\n\n\n\n    \/* Parse a trailing \":readahead=#:\" param, if present. *\/\n\n    ra = file + strlen(file) - 1;\n\n    while (ra >= file) {\n\n        if (parse_state == 0) {\n\n            if (*ra == ':')\n\n                parse_state++;\n\n            else\n\n                break;\n\n        } else if (parse_state == 1) {\n\n            if (*ra > '9' || *ra < '0') {\n\n                char *opt_start = ra - strlen(RA_OPTSTR) + 1;\n\n                if (opt_start > file &&\n\n                    strncmp(opt_start, RA_OPTSTR, strlen(RA_OPTSTR)) == 0) {\n\n                    ra_val = ra + 1;\n\n                    ra -= strlen(RA_OPTSTR) - 1;\n\n                    *ra = '\\0';\n\n                    s->readahead_size = atoi(ra_val);\n\n                    break;\n\n                } else {\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        ra--;\n\n    }\n\n\n\n    if ((s->readahead_size & 0x1ff) != 0) {\n\n        fprintf(stderr, \"HTTP_READAHEAD_SIZE %Zd is not a multiple of 512\\n\",\n\n                s->readahead_size);\n\n        goto out_noclean;\n\n    }\n\n\n\n    if (!inited) {\n\n        curl_global_init(CURL_GLOBAL_ALL);\n\n        inited = 1;\n\n    }\n\n\n\n    DPRINTF(\"CURL: Opening %s\\n\", file);\n\n    s->url = file;\n\n    state = curl_init_state(s);\n\n    if (!state)\n\n        goto out_noclean;\n\n\n\n    \/\/ Get file size\n\n\n\n    curl_easy_setopt(state->curl, CURLOPT_NOBODY, 1);\n\n    curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION, (void *)curl_size_cb);\n\n    if (curl_easy_perform(state->curl))\n\n        goto out;\n\n    curl_easy_getinfo(state->curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &d);\n\n    curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION, (void *)curl_read_cb);\n\n    curl_easy_setopt(state->curl, CURLOPT_NOBODY, 0);\n\n    if (d)\n\n        s->len = (size_t)d;\n\n    else if(!s->len)\n\n        goto out;\n\n    DPRINTF(\"CURL: Size = %lld\\n\", (long long)s->len);\n\n\n\n    curl_clean_state(state);\n\n    curl_easy_cleanup(state->curl);\n\n    state->curl = NULL;\n\n\n\n    \/\/ Now we know the file exists and its size, so let's\n\n    \/\/ initialize the multi interface!\n\n\n\n    s->multi = curl_multi_init();\n\n    curl_multi_setopt( s->multi, CURLMOPT_SOCKETDATA, s); \n\n    curl_multi_setopt( s->multi, CURLMOPT_SOCKETFUNCTION, curl_sock_cb ); \n\n    curl_multi_do(s);\n\n\n\n    return 0;\n\n\n\nout:\n\n    fprintf(stderr, \"CURL: Error opening file: %s\\n\", state->errmsg);\n\n    curl_easy_cleanup(state->curl);\n\n    state->curl = NULL;\n\nout_noclean:\n\n    qemu_free(file);\n\n    return -EINVAL;\n\n}\n"},{"project":"qemu","commit_id":"1a01716a307387e5cf1336f61a96f772dddadc90","target":1,"func":"static void gd_menu_switch_vc(GtkMenuItem *item, void *opaque)\n{\n    GtkDisplayState *s = opaque;\n    VirtualConsole *vc = gd_vc_find_by_menu(s);\n    GtkNotebook *nb = GTK_NOTEBOOK(s->notebook);\n    gint page;\n    gtk_release_modifiers(s);\n    if (vc) {\n        page = gtk_notebook_page_num(nb, vc->tab_item);\n        gtk_notebook_set_current_page(nb, page);\n        gtk_widget_grab_focus(vc->focus);\n    }\n}"},{"project":"qemu","commit_id":"a5b8dd2ce83208cd7d6eb4562339ecf5aae13574","target":0,"func":"static void bochs_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    bs->request_alignment = BDRV_SECTOR_SIZE; \/* No sub-sector I\/O supported *\/\n\n}\n"},{"project":"qemu","commit_id":"9eaaf971683c99ed197fa1b7d1a3ca9baabfb3ee","target":0,"func":"static void simple_varargs(void)\n\n{\n\n    QObject *embedded_obj;\n\n    QObject *obj;\n\n    LiteralQObject decoded = QLIT_QLIST(((LiteralQObject[]){\n\n            QLIT_QINT(1),\n\n            QLIT_QINT(2),\n\n            QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(32),\n\n                        QLIT_QINT(42),\n\n                        {}})),\n\n            {}}));\n\n\n\n    embedded_obj = qobject_from_json(\"[32, 42]\");\n\n    g_assert(embedded_obj != NULL);\n\n\n\n    obj = qobject_from_jsonf(\"[%d, 2, %p]\", 1, embedded_obj);\n\n    g_assert(obj != NULL);\n\n\n\n    g_assert(compare_litqobj_to_qobj(&decoded, obj) == 1);\n\n\n\n    qobject_decref(obj);\n\n}\n"},{"project":"qemu","commit_id":"b192af8acc597a6e8068873434e56e0c7de1b7d3","target":0,"func":"static int find_image_format(BlockDriverState *bs, const char *filename,\n\n                             BlockDriver **pdrv, Error **errp)\n\n{\n\n    BlockDriver *drv;\n\n    uint8_t buf[BLOCK_PROBE_BUF_SIZE];\n\n    int ret = 0;\n\n\n\n    \/* Return the raw BlockDriver * to scsi-generic devices or empty drives *\/\n\n    if (bs->sg || !bdrv_is_inserted(bs) || bdrv_getlength(bs) == 0) {\n\n        *pdrv = &bdrv_raw;\n\n        return ret;\n\n    }\n\n\n\n    ret = bdrv_pread(bs, 0, buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not read image for determining its \"\n\n                         \"format\");\n\n        *pdrv = NULL;\n\n        return ret;\n\n    }\n\n\n\n    drv = bdrv_probe_all(buf, ret, filename);\n\n    if (!drv) {\n\n        error_setg(errp, \"Could not determine image format: No compatible \"\n\n                   \"driver found\");\n\n        ret = -ENOENT;\n\n    }\n\n    *pdrv = drv;\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"81145834d39897c6f153ac26a4077f90f269c5fc","target":1,"func":"static int cow_read(BlockDriverState *bs, int64_t sector_num,\n\n                    uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVCowState *s = bs->opaque;\n\n    int ret, n;\n\n\n\n    while (nb_sectors > 0) {\n\n        if (cow_is_allocated(bs, sector_num, nb_sectors, &n)) {\n\n            ret = bdrv_pread(bs->file,\n\n                        s->cow_sectors_offset + sector_num * 512,\n\n                        buf, n * 512);\n\n            if (ret != n * 512)\n\n                return -1;\n\n        } else {\n\n            if (bs->backing_hd) {\n\n                \/* read from the base image *\/\n\n                ret = bdrv_read(bs->backing_hd, sector_num, buf, n);\n\n                if (ret < 0)\n\n                    return -1;\n\n            } else {\n\n            memset(buf, 0, n * 512);\n\n        }\n\n        }\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static int megasas_dcmd_ld_get_list(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    struct mfi_ld_list info;\n\n    size_t dcmd_size = sizeof(info), resid;\n\n    uint32_t num_ld_disks = 0, max_ld_disks = s->fw_luns;\n\n    uint64_t ld_size;\n\n    BusChild *kid;\n\n\n\n    memset(&info, 0, dcmd_size);\n\n    if (cmd->iov_size < dcmd_size) {\n\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n\n                                            dcmd_size);\n\n        return MFI_STAT_INVALID_PARAMETER;\n\n    }\n\n\n\n    if (megasas_is_jbod(s)) {\n\n        max_ld_disks = 0;\n\n    }\n\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n\n        SCSIDevice *sdev = DO_UPCAST(SCSIDevice, qdev, kid->child);\n\n        BlockConf *conf = &sdev->conf;\n\n\n\n        if (num_ld_disks >= max_ld_disks) {\n\n            break;\n\n        }\n\n        \/* Logical device size is in blocks *\/\n\n        bdrv_get_geometry(conf->bs, &ld_size);\n\n        info.ld_list[num_ld_disks].ld.v.target_id = sdev->id;\n\n        info.ld_list[num_ld_disks].ld.v.lun_id = sdev->lun;\n\n        info.ld_list[num_ld_disks].state = MFI_LD_STATE_OPTIMAL;\n\n        info.ld_list[num_ld_disks].size = cpu_to_le64(ld_size);\n\n        num_ld_disks++;\n\n    }\n\n    info.ld_count = cpu_to_le32(num_ld_disks);\n\n    trace_megasas_dcmd_ld_get_list(cmd->index, num_ld_disks, max_ld_disks);\n\n\n\n    resid = dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n\n    cmd->iov_size = dcmd_size - resid;\n\n    return MFI_STAT_OK;\n\n}\n"},{"project":"qemu","commit_id":"6a5b69a959483c7404576a7dc54221ced41e6515","target":1,"func":"static target_ulong helper_sdiv_common(CPUSPARCState *env, target_ulong a,\n\n                                       target_ulong b, int cc)\n\n{\n\n    SPARCCPU *cpu = sparc_env_get_cpu(env);\n\n    int overflow = 0;\n\n    int64_t x0;\n\n    int32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        cpu_restore_state(CPU(cpu), GETPC());\n\n        helper_raise_exception(env, TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 \/ x1;\n\n    if ((int32_t) x0 != x0) {\n\n        x0 = x0 < 0 ? 0x80000000 : 0x7fffffff;\n\n        overflow = 1;\n\n    }\n\n\n\n    if (cc) {\n\n        env->cc_dst = x0;\n\n        env->cc_src2 = overflow;\n\n        env->cc_op = CC_OP_DIV;\n\n    }\n\n    return x0;\n\n}\n"},{"project":"qemu","commit_id":"4f4321c11ff6e98583846bfd6f0e81954924b003","target":1,"func":"static int usb_msd_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    MSDState *s = (MSDState *)dev;\n\n    int ret = 0;\n\n    struct usb_msd_cbw cbw;\n\n    uint8_t devep = p->devep;\n\n    uint8_t *data = p->data;\n\n    int len = p->len;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_OUT:\n\n        if (devep != 2)\n\n            goto fail;\n\n\n\n        switch (s->mode) {\n\n        case USB_MSDM_CBW:\n\n            if (len != 31) {\n\n                fprintf(stderr, \"usb-msd: Bad CBW size\");\n\n                goto fail;\n\n            }\n\n            memcpy(&cbw, data, 31);\n\n            if (le32_to_cpu(cbw.sig) != 0x43425355) {\n\n                fprintf(stderr, \"usb-msd: Bad signature %08x\\n\",\n\n                        le32_to_cpu(cbw.sig));\n\n                goto fail;\n\n            }\n\n            DPRINTF(\"Command on LUN %d\\n\", cbw.lun);\n\n            if (cbw.lun != 0) {\n\n                fprintf(stderr, \"usb-msd: Bad LUN %d\\n\", cbw.lun);\n\n                goto fail;\n\n            }\n\n            s->tag = le32_to_cpu(cbw.tag);\n\n            s->data_len = le32_to_cpu(cbw.data_len);\n\n            if (s->data_len == 0) {\n\n                s->mode = USB_MSDM_CSW;\n\n            } else if (cbw.flags & 0x80) {\n\n                s->mode = USB_MSDM_DATAIN;\n\n            } else {\n\n                s->mode = USB_MSDM_DATAOUT;\n\n            }\n\n            DPRINTF(\"Command tag 0x%x flags %08x len %d data %d\\n\",\n\n                    s->tag, cbw.flags, cbw.cmd_len, s->data_len);\n\n            s->residue = 0;\n\n            s->scsi_len = 0;\n\n            s->req = scsi_req_new(s->scsi_dev, s->tag, 0, NULL);\n\n            scsi_req_enqueue(s->req, cbw.cmd);\n\n            \/* ??? Should check that USB and SCSI data transfer\n\n               directions match.  *\/\n\n            if (s->mode != USB_MSDM_CSW && s->residue == 0) {\n\n                scsi_req_continue(s->req);\n\n            }\n\n            ret = len;\n\n            break;\n\n\n\n        case USB_MSDM_DATAOUT:\n\n            DPRINTF(\"Data out %d\/%d\\n\", len, s->data_len);\n\n            if (len > s->data_len)\n\n                goto fail;\n\n\n\n            s->usb_buf = data;\n\n            s->usb_len = len;\n\n            if (s->scsi_len) {\n\n                usb_msd_copy_data(s);\n\n            }\n\n            if (s->residue && s->usb_len) {\n\n                s->data_len -= s->usb_len;\n\n                if (s->data_len == 0)\n\n                    s->mode = USB_MSDM_CSW;\n\n                s->usb_len = 0;\n\n            }\n\n            if (s->usb_len) {\n\n                DPRINTF(\"Deferring packet %p\\n\", p);\n\n                s->packet = p;\n\n                ret = USB_RET_ASYNC;\n\n            } else {\n\n                ret = len;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"Unexpected write (len %d)\\n\", len);\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_IN:\n\n        if (devep != 1)\n\n            goto fail;\n\n\n\n        switch (s->mode) {\n\n        case USB_MSDM_DATAOUT:\n\n            if (s->data_len != 0 || len < 13)\n\n                goto fail;\n\n            \/* Waiting for SCSI write to complete.  *\/\n\n            s->packet = p;\n\n            ret = USB_RET_ASYNC;\n\n            break;\n\n\n\n        case USB_MSDM_CSW:\n\n            DPRINTF(\"Command status %d tag 0x%x, len %d\\n\",\n\n                    s->result, s->tag, len);\n\n            if (len < 13)\n\n                goto fail;\n\n\n\n            usb_msd_send_status(s, p);\n\n            s->mode = USB_MSDM_CBW;\n\n            ret = 13;\n\n            break;\n\n\n\n        case USB_MSDM_DATAIN:\n\n            DPRINTF(\"Data in %d\/%d, scsi_len %d\\n\", len, s->data_len, s->scsi_len);\n\n            if (len > s->data_len)\n\n                len = s->data_len;\n\n            s->usb_buf = data;\n\n            s->usb_len = len;\n\n            if (s->scsi_len) {\n\n                usb_msd_copy_data(s);\n\n            }\n\n            if (s->residue && s->usb_len) {\n\n                s->data_len -= s->usb_len;\n\n                memset(s->usb_buf, 0, s->usb_len);\n\n                if (s->data_len == 0)\n\n                    s->mode = USB_MSDM_CSW;\n\n                s->usb_len = 0;\n\n            }\n\n            if (s->usb_len) {\n\n                DPRINTF(\"Deferring packet %p\\n\", p);\n\n                s->packet = p;\n\n                ret = USB_RET_ASYNC;\n\n            } else {\n\n                ret = len;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"Unexpected read (len %d)\\n\", len);\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        DPRINTF(\"Bad token\\n\");\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"8dfbaa6ac450c4ec2646b1ca08a4017052a90c1d","target":0,"func":"static void virtio_ccw_notify(DeviceState *d, uint16_t vector)\n\n{\n\n    VirtioCcwDevice *dev = to_virtio_ccw_dev_fast(d);\n\n    SubchDev *sch = dev->sch;\n\n    uint64_t indicators;\n\n\n\n    if (vector >= 128) {\n\n        return;\n\n    }\n\n\n\n    if (vector < VIRTIO_PCI_QUEUE_MAX) {\n\n        if (!dev->indicators) {\n\n            return;\n\n        }\n\n        if (sch->thinint_active) {\n\n            \/*\n\n             * In the adapter interrupt case, indicators points to a\n\n             * memory area that may be (way) larger than 64 bit and\n\n             * ind_bit indicates the start of the indicators in a big\n\n             * endian notation.\n\n             *\/\n\n            uint64_t ind_bit = dev->routes.adapter.ind_offset;\n\n\n\n            virtio_set_ind_atomic(sch, dev->indicators->addr +\n\n                                  (ind_bit + vector) \/ 8,\n\n                                  0x80 >> ((ind_bit + vector) % 8));\n\n            if (!virtio_set_ind_atomic(sch, dev->summary_indicator->addr,\n\n                                       0x01)) {\n\n                css_adapter_interrupt(dev->thinint_isc);\n\n            }\n\n        } else {\n\n            indicators = address_space_ldq(&address_space_memory,\n\n                                           dev->indicators->addr,\n\n                                           MEMTXATTRS_UNSPECIFIED,\n\n                                           NULL);\n\n            indicators |= 1ULL << vector;\n\n            address_space_stq(&address_space_memory, dev->indicators->addr,\n\n                              indicators, MEMTXATTRS_UNSPECIFIED, NULL);\n\n            css_conditional_io_interrupt(sch);\n\n        }\n\n    } else {\n\n        if (!dev->indicators2) {\n\n            return;\n\n        }\n\n        vector = 0;\n\n        indicators = address_space_ldq(&address_space_memory,\n\n                                       dev->indicators2->addr,\n\n                                       MEMTXATTRS_UNSPECIFIED,\n\n                                       NULL);\n\n        indicators |= 1ULL << vector;\n\n        address_space_stq(&address_space_memory, dev->indicators2->addr,\n\n                          indicators, MEMTXATTRS_UNSPECIFIED, NULL);\n\n        css_conditional_io_interrupt(sch);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"0ac7cc2af500b948510f2481c22e84a57b0a2447","target":0,"func":"START_TEST(qstring_from_str_test)\n\n{\n\n    QString *qstring;\n\n    const char *str = \"QEMU\";\n\n\n\n    qstring = qstring_from_str(str);\n\n    fail_unless(qstring != NULL);\n\n    fail_unless(qstring->base.refcnt == 1);\n\n    fail_unless(strcmp(str, qstring->string) == 0);\n\n    fail_unless(qobject_type(QOBJECT(qstring)) == QTYPE_QSTRING);\n\n\n\n    \/\/ destroy doesn't exit yet\n\n    g_free(qstring->string);\n\n    g_free(qstring);\n\n}\n"},{"project":"qemu","commit_id":"ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43","target":0,"func":"void tb_invalidate_phys_addr(target_phys_addr_t addr)\n\n{\n\n    ram_addr_t ram_addr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(addr >> TARGET_PAGE_BITS);\n\n    if (!(memory_region_is_ram(section->mr)\n\n          || (section->mr->rom_device && section->mr->readable))) {\n\n        return;\n\n    }\n\n    ram_addr = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)\n\n        + memory_region_section_addr(section, addr);\n\n    tb_invalidate_phys_page_range(ram_addr, ram_addr + 1, 0);\n\n}\n"},{"project":"qemu","commit_id":"ec990eb622ad46df5ddcb1e94c418c271894d416","target":0,"func":"int qdev_init(DeviceState *dev)\n\n{\n\n    int rc;\n\n\n\n    assert(dev->state == DEV_STATE_CREATED);\n\n    rc = dev->info->init(dev, dev->info);\n\n    if (rc < 0) {\n\n        qdev_free(dev);\n\n        return rc;\n\n    }\n\n    qemu_register_reset(qdev_reset, dev);\n\n    if (dev->info->vmsd) {\n\n        vmstate_register_with_alias_id(dev, -1, dev->info->vmsd, dev,\n\n                                       dev->instance_id_alias,\n\n                                       dev->alias_required_for_version);\n\n    }\n\n    dev->state = DEV_STATE_INITIALIZED;\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"d9bce9d99f4656ae0b0127f7472db9067b8f84ab","target":1,"func":"void do_load_fpscr (void)\n\n{\n\n    \/* The 32 MSB of the target fpr are undefined.\n\n     * They'll be zero...\n\n     *\/\n\n    union {\n\n        float64 d;\n\n        struct {\n\n            uint32_t u[2];\n\n        } s;\n\n    } u;\n\n    int i;\n\n\n\n#ifdef WORDS_BIGENDIAN\n\n#define WORD0 0\n\n#define WORD1 1\n\n#else\n\n#define WORD0 1\n\n#define WORD1 0\n\n#endif\n\n    u.s.u[WORD0] = 0;\n\n    u.s.u[WORD1] = 0;\n\n    for (i = 0; i < 8; i++)\n\n        u.s.u[WORD1] |= env->fpscr[i] << (4 * i);\n\n    FT0 = u.d;\n\n}\n"},{"project":"qemu","commit_id":"e6ae5981ea4b0f6feb223009a5108582e7644f8f","target":0,"func":"static inline int nvic_exec_prio(NVICState *s)\n\n{\n\n    CPUARMState *env = &s->cpu->env;\n\n    int running;\n\n\n\n    if (env->daif & PSTATE_F) { \/* FAULTMASK *\/\n\n        running = -1;\n\n    } else if (env->daif & PSTATE_I) { \/* PRIMASK *\/\n\n        running = 0;\n\n    } else if (env->v7m.basepri > 0) {\n\n        running = env->v7m.basepri & nvic_gprio_mask(s);\n\n    } else {\n\n        running = NVIC_NOEXC_PRIO; \/* lower than any possible priority *\/\n\n    }\n\n    \/* consider priority of active handler *\/\n\n    return MIN(running, s->exception_prio);\n\n}\n"},{"project":"qemu","commit_id":"554f802da3f8b09b16b9a84ad5847b2eb0e9ad2b","target":1,"func":"void pcie_cap_slot_hotplug_cb(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                              Error **errp)\n\n{\n\n    uint8_t *exp_cap;\n\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n\n\n    pcie_cap_slot_hotplug_common(PCI_DEVICE(hotplug_dev), dev, &exp_cap, errp);\n\n\n\n    \/* Don't send event when device is enabled during qemu machine creation:\n\n     * it is present on boot, no hotplug event is necessary. We do send an\n\n     * event when the device is disabled later. *\/\n\n    if (!dev->hotplugged) {\n\n        pci_word_test_and_set_mask(exp_cap + PCI_EXP_SLTSTA,\n\n                                   PCI_EXP_SLTSTA_PDS);\n\n        return;\n\n    }\n\n\n\n    \/* TODO: multifunction hot-plug.\n\n     * Right now, only a device of function = 0 is allowed to be\n\n     * hot plugged\/unplugged.\n\n     *\/\n\n    assert(PCI_FUNC(pci_dev->devfn) == 0);\n\n\n\n    pci_word_test_and_set_mask(exp_cap + PCI_EXP_SLTSTA,\n\n                               PCI_EXP_SLTSTA_PDS);\n\n    pcie_cap_slot_event(PCI_DEVICE(hotplug_dev), PCI_EXP_HP_EV_PDC);\n\n}\n"},{"project":"qemu","commit_id":"bf55b7afce53718ef96f4e6616da62c0ccac37dd","target":0,"func":"static IOMMUTLBEntry pbm_translate_iommu(MemoryRegion *iommu, hwaddr addr,\n\n                                         bool is_write)\n\n{\n\n    IOMMUState *is = container_of(iommu, IOMMUState, iommu);\n\n    hwaddr baseaddr, offset;\n\n    uint64_t tte;\n\n    uint32_t tsbsize;\n\n    IOMMUTLBEntry ret = {\n\n        .target_as = &address_space_memory,\n\n        .iova = 0,\n\n        .translated_addr = 0,\n\n        .addr_mask = ~(hwaddr)0,\n\n        .perm = IOMMU_NONE,\n\n    };\n\n\n\n    if (!(is->regs[IOMMU_CTRL >> 3] & IOMMU_CTRL_MMU_EN)) {\n\n        \/* IOMMU disabled, passthrough using standard 8K page *\/\n\n        ret.iova = addr & IOMMU_PAGE_MASK_8K;\n\n        ret.translated_addr = addr;\n\n        ret.addr_mask = IOMMU_PAGE_MASK_8K;\n\n        ret.perm = IOMMU_RW;\n\n\n\n        return ret;\n\n    }\n\n\n\n    baseaddr = is->regs[IOMMU_BASE >> 3];\n\n    tsbsize = (is->regs[IOMMU_CTRL >> 3] >> IOMMU_CTRL_TSB_SHIFT) & 0x7;\n\n\n\n    if (is->regs[IOMMU_CTRL >> 3] & IOMMU_CTRL_TBW_SIZE) {\n\n        \/* 64K *\/\n\n        switch (tsbsize) {\n\n        case 0:\n\n            offset = (addr & IOMMU_TSB_64K_OFFSET_MASK_64M) >> 13;\n\n            break;\n\n        case 1:\n\n            offset = (addr & IOMMU_TSB_64K_OFFSET_MASK_128M) >> 13;\n\n            break;\n\n        case 2:\n\n            offset = (addr & IOMMU_TSB_64K_OFFSET_MASK_256M) >> 13;\n\n            break;\n\n        case 3:\n\n            offset = (addr & IOMMU_TSB_64K_OFFSET_MASK_512M) >> 13;\n\n            break;\n\n        case 4:\n\n            offset = (addr & IOMMU_TSB_64K_OFFSET_MASK_1G) >> 13;\n\n            break;\n\n        case 5:\n\n            offset = (addr & IOMMU_TSB_64K_OFFSET_MASK_2G) >> 13;\n\n            break;\n\n        default:\n\n            \/* Not implemented, error *\/\n\n            return ret;\n\n        }\n\n    } else {\n\n        \/* 8K *\/\n\n        switch (tsbsize) {\n\n        case 0:\n\n            offset = (addr & IOMMU_TSB_8K_OFFSET_MASK_8M) >> 10;\n\n            break;\n\n        case 1:\n\n            offset = (addr & IOMMU_TSB_8K_OFFSET_MASK_16M) >> 10;\n\n            break;\n\n        case 2:\n\n            offset = (addr & IOMMU_TSB_8K_OFFSET_MASK_32M) >> 10;\n\n            break;\n\n        case 3:\n\n            offset = (addr & IOMMU_TSB_8K_OFFSET_MASK_64M) >> 10;\n\n            break;\n\n        case 4:\n\n            offset = (addr & IOMMU_TSB_8K_OFFSET_MASK_128M) >> 10;\n\n            break;\n\n        case 5:\n\n            offset = (addr & IOMMU_TSB_8K_OFFSET_MASK_256M) >> 10;\n\n            break;\n\n        case 6:\n\n            offset = (addr & IOMMU_TSB_8K_OFFSET_MASK_512M) >> 10;\n\n            break;\n\n        case 7:\n\n            offset = (addr & IOMMU_TSB_8K_OFFSET_MASK_1G) >> 10;\n\n            break;\n\n        }\n\n    }\n\n\n\n    tte = address_space_ldq_be(&address_space_memory, baseaddr + offset,\n\n                               MEMTXATTRS_UNSPECIFIED, NULL);\n\n\n\n    if (!(tte & IOMMU_TTE_DATA_V)) {\n\n        \/* Invalid mapping *\/\n\n        return ret;\n\n    }\n\n\n\n    if (tte & IOMMU_TTE_DATA_W) {\n\n        \/* Writeable *\/\n\n        ret.perm = IOMMU_RW;\n\n    } else {\n\n        ret.perm = IOMMU_RO;\n\n    }\n\n\n\n    \/* Extract phys *\/\n\n    if (tte & IOMMU_TTE_DATA_SIZE) {\n\n        \/* 64K *\/\n\n        ret.iova = addr & IOMMU_PAGE_MASK_64K;\n\n        ret.translated_addr = tte & IOMMU_TTE_PHYS_MASK_64K;\n\n        ret.addr_mask = (IOMMU_PAGE_SIZE_64K - 1);\n\n    } else {\n\n        \/* 8K *\/\n\n        ret.iova = addr & IOMMU_PAGE_MASK_8K;\n\n        ret.translated_addr = tte & IOMMU_TTE_PHYS_MASK_8K;\n\n        ret.addr_mask = (IOMMU_PAGE_SIZE_8K - 1);\n\n    }\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"262a69f4282e44426c7a132138581d400053e0a1","target":1,"func":"void *qemu_get_virtqueue_element(VirtIODevice *vdev, QEMUFile *f, size_t sz)\n\n{\n\n    VirtQueueElement *elem;\n\n    VirtQueueElementOld data;\n\n    int i;\n\n\n\n    qemu_get_buffer(f, (uint8_t *)&data, sizeof(VirtQueueElementOld));\n\n\n\n    \/* TODO: teach all callers that this can fail, and return failure instead\n\n     * of asserting here.\n\n     * When we do, we might be able to re-enable NDEBUG below.\n\n     *\/\n\n#ifdef NDEBUG\n\n#error building with NDEBUG is not supported\n\n#endif\n\n    assert(ARRAY_SIZE(data.in_addr) >= data.in_num);\n\n    assert(ARRAY_SIZE(data.out_addr) >= data.out_num);\n\n\n\n    elem = virtqueue_alloc_element(sz, data.out_num, data.in_num);\n\n    elem->index = data.index;\n\n\n\n    for (i = 0; i < elem->in_num; i++) {\n\n        elem->in_addr[i] = data.in_addr[i];\n\n    }\n\n\n\n    for (i = 0; i < elem->out_num; i++) {\n\n        elem->out_addr[i] = data.out_addr[i];\n\n    }\n\n\n\n    for (i = 0; i < elem->in_num; i++) {\n\n        \/* Base is overwritten by virtqueue_map.  *\/\n\n        elem->in_sg[i].iov_base = 0;\n\n        elem->in_sg[i].iov_len = data.in_sg[i].iov_len;\n\n    }\n\n\n\n    for (i = 0; i < elem->out_num; i++) {\n\n        \/* Base is overwritten by virtqueue_map.  *\/\n\n        elem->out_sg[i].iov_base = 0;\n\n        elem->out_sg[i].iov_len = data.out_sg[i].iov_len;\n\n    }\n\n\n\n    virtqueue_map(vdev, elem);\n\n    return elem;\n\n}\n"},{"project":"qemu","commit_id":"b80bb016d8c8e9d74345a90ab6dac1cb547904e0","target":0,"func":"static void tcg_opt_gen_mov(TCGArg *gen_args, TCGArg dst, TCGArg src,\n\n                            int nb_temps, int nb_globals)\n\n{\n\n        reset_temp(dst, nb_temps, nb_globals);\n\n        assert(temps[src].state != TCG_TEMP_COPY);\n\n        if (src >= nb_globals) {\n\n            assert(temps[src].state != TCG_TEMP_CONST);\n\n            if (temps[src].state != TCG_TEMP_HAS_COPY) {\n\n                temps[src].state = TCG_TEMP_HAS_COPY;\n\n                temps[src].next_copy = src;\n\n                temps[src].prev_copy = src;\n\n            }\n\n            temps[dst].state = TCG_TEMP_COPY;\n\n            temps[dst].val = src;\n\n            temps[dst].next_copy = temps[src].next_copy;\n\n            temps[dst].prev_copy = src;\n\n            temps[temps[dst].next_copy].prev_copy = dst;\n\n            temps[src].next_copy = dst;\n\n        }\n\n        gen_args[0] = dst;\n\n        gen_args[1] = src;\n\n}\n"},{"project":"qemu","commit_id":"ef5a788527b2038d742b057a415ab4d0e735e98f","target":0,"func":"static int64_t cvtnum(const char *s)\n\n{\n\n    char *end;\n\n    return qemu_strtosz_suffix(s, &end, QEMU_STRTOSZ_DEFSUFFIX_B);\n\n}\n"},{"project":"qemu","commit_id":"0e1dac6c41f337f997814344a847162968c20c64","target":1,"func":"int kvm_init(MachineClass *mc)\n\n{\n\n    static const char upgrade_note[] =\n\n        \"Please upgrade to at least kernel 2.6.29 or recent kvm-kmod\\n\"\n\n        \"(see http:\/\/sourceforge.net\/projects\/kvm).\\n\";\n\n    struct {\n\n        const char *name;\n\n        int num;\n\n    } num_cpus[] = {\n\n        { \"SMP\",          smp_cpus },\n\n        { \"hotpluggable\", max_cpus },\n\n        { NULL, }\n\n    }, *nc = num_cpus;\n\n    int soft_vcpus_limit, hard_vcpus_limit;\n\n    KVMState *s;\n\n    const KVMCapabilityInfo *missing_cap;\n\n    int ret;\n\n    int i, type = 0;\n\n    const char *kvm_type;\n\n\n\n    s = g_malloc0(sizeof(KVMState));\n\n\n\n    \/*\n\n     * On systems where the kernel can support different base page\n\n     * sizes, host page size may be different from TARGET_PAGE_SIZE,\n\n     * even with KVM.  TARGET_PAGE_SIZE is assumed to be the minimum\n\n     * page size for the system though.\n\n     *\/\n\n    assert(TARGET_PAGE_SIZE <= getpagesize());\n\n    page_size_init();\n\n\n\n#ifdef KVM_CAP_SET_GUEST_DEBUG\n\n    QTAILQ_INIT(&s->kvm_sw_breakpoints);\n\n#endif\n\n    s->vmfd = -1;\n\n    s->fd = qemu_open(\"\/dev\/kvm\", O_RDWR);\n\n    if (s->fd == -1) {\n\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n\n        ret = -errno;\n\n        goto err;\n\n    }\n\n\n\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n\n    if (ret < KVM_API_VERSION) {\n\n        if (ret > 0) {\n\n            ret = -EINVAL;\n\n        }\n\n        fprintf(stderr, \"kvm version too old\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if (ret > KVM_API_VERSION) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"kvm version not supported\\n\");\n\n        goto err;\n\n    }\n\n\n\n    s->nr_slots = kvm_check_extension(s, KVM_CAP_NR_MEMSLOTS);\n\n\n\n    \/* If unspecified, use the default value *\/\n\n    if (!s->nr_slots) {\n\n        s->nr_slots = 32;\n\n    }\n\n\n\n    s->slots = g_malloc0(s->nr_slots * sizeof(KVMSlot));\n\n\n\n    for (i = 0; i < s->nr_slots; i++) {\n\n        s->slots[i].slot = i;\n\n    }\n\n\n\n    \/* check the vcpu limits *\/\n\n    soft_vcpus_limit = kvm_recommended_vcpus(s);\n\n    hard_vcpus_limit = kvm_max_vcpus(s);\n\n\n\n    while (nc->name) {\n\n        if (nc->num > soft_vcpus_limit) {\n\n            fprintf(stderr,\n\n                    \"Warning: Number of %s cpus requested (%d) exceeds \"\n\n                    \"the recommended cpus supported by KVM (%d)\\n\",\n\n                    nc->name, nc->num, soft_vcpus_limit);\n\n\n\n            if (nc->num > hard_vcpus_limit) {\n\n                fprintf(stderr, \"Number of %s cpus requested (%d) exceeds \"\n\n                        \"the maximum cpus supported by KVM (%d)\\n\",\n\n                        nc->name, nc->num, hard_vcpus_limit);\n\n                exit(1);\n\n            }\n\n        }\n\n        nc++;\n\n    }\n\n\n\n    kvm_type = qemu_opt_get(qemu_get_machine_opts(), \"kvm-type\");\n\n    if (mc->kvm_type) {\n\n        type = mc->kvm_type(kvm_type);\n\n    } else if (kvm_type) {\n\n        fprintf(stderr, \"Invalid argument kvm-type=%s\\n\", kvm_type);\n\n        goto err;\n\n    }\n\n\n\n    do {\n\n        ret = kvm_ioctl(s, KVM_CREATE_VM, type);\n\n    } while (ret == -EINTR);\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ioctl(KVM_CREATE_VM) failed: %d %s\\n\", -ret,\n\n                strerror(-ret));\n\n\n\n#ifdef TARGET_S390X\n\n        fprintf(stderr, \"Please add the 'switch_amode' kernel parameter to \"\n\n                        \"your host kernel command line\\n\");\n\n#endif\n\n        goto err;\n\n    }\n\n\n\n    s->vmfd = ret;\n\n    missing_cap = kvm_check_extension_list(s, kvm_required_capabilites);\n\n    if (!missing_cap) {\n\n        missing_cap =\n\n            kvm_check_extension_list(s, kvm_arch_required_capabilities);\n\n    }\n\n    if (missing_cap) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"kvm does not support %s\\n%s\",\n\n                missing_cap->name, upgrade_note);\n\n        goto err;\n\n    }\n\n\n\n    s->coalesced_mmio = kvm_check_extension(s, KVM_CAP_COALESCED_MMIO);\n\n\n\n    s->broken_set_mem_region = 1;\n\n    ret = kvm_check_extension(s, KVM_CAP_JOIN_MEMORY_REGIONS_WORKS);\n\n    if (ret > 0) {\n\n        s->broken_set_mem_region = 0;\n\n    }\n\n\n\n#ifdef KVM_CAP_VCPU_EVENTS\n\n    s->vcpu_events = kvm_check_extension(s, KVM_CAP_VCPU_EVENTS);\n\n#endif\n\n\n\n    s->robust_singlestep =\n\n        kvm_check_extension(s, KVM_CAP_X86_ROBUST_SINGLESTEP);\n\n\n\n#ifdef KVM_CAP_DEBUGREGS\n\n    s->debugregs = kvm_check_extension(s, KVM_CAP_DEBUGREGS);\n\n#endif\n\n\n\n#ifdef KVM_CAP_XSAVE\n\n    s->xsave = kvm_check_extension(s, KVM_CAP_XSAVE);\n\n#endif\n\n\n\n#ifdef KVM_CAP_XCRS\n\n    s->xcrs = kvm_check_extension(s, KVM_CAP_XCRS);\n\n#endif\n\n\n\n#ifdef KVM_CAP_PIT_STATE2\n\n    s->pit_state2 = kvm_check_extension(s, KVM_CAP_PIT_STATE2);\n\n#endif\n\n\n\n#ifdef KVM_CAP_IRQ_ROUTING\n\n    s->direct_msi = (kvm_check_extension(s, KVM_CAP_SIGNAL_MSI) > 0);\n\n#endif\n\n\n\n    s->intx_set_mask = kvm_check_extension(s, KVM_CAP_PCI_2_3);\n\n\n\n    s->irq_set_ioctl = KVM_IRQ_LINE;\n\n    if (kvm_check_extension(s, KVM_CAP_IRQ_INJECT_STATUS)) {\n\n        s->irq_set_ioctl = KVM_IRQ_LINE_STATUS;\n\n    }\n\n\n\n#ifdef KVM_CAP_READONLY_MEM\n\n    kvm_readonly_mem_allowed =\n\n        (kvm_check_extension(s, KVM_CAP_READONLY_MEM) > 0);\n\n#endif\n\n\n\n    ret = kvm_arch_init(s);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    ret = kvm_irqchip_create(s);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    kvm_state = s;\n\n    memory_listener_register(&kvm_memory_listener, &address_space_memory);\n\n    memory_listener_register(&kvm_io_listener, &address_space_io);\n\n\n\n    s->many_ioeventfds = kvm_check_many_ioeventfds();\n\n\n\n    cpu_interrupt_handler = kvm_handle_interrupt;\n\n\n\n    return 0;\n\n\n\nerr:\n\n    if (s->vmfd >= 0) {\n\n        close(s->vmfd);\n\n    }\n\n    if (s->fd != -1) {\n\n        close(s->fd);\n\n    }\n\n    g_free(s->slots);\n\n    g_free(s);\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"0fcec41eec0432c77645b4a407d3a3e030c4abc4","target":1,"func":"target_ulong helper_sdiv(target_ulong a, target_ulong b)\n\n{\n\n    int64_t x0;\n\n    int32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 \/ x1;\n\n    if ((int32_t) x0 != x0) {\n\n        env->cc_src2 = 1;\n\n        return x0 < 0? 0x80000000: 0x7fffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"d5aa3e6e0cd6259003790769c448d4fbb5b5c810","target":0,"func":"uint32_t net_checksum_add_cont(int len, uint8_t *buf, int seq)\n\n{\n\n    uint32_t sum = 0;\n\n    int i;\n\n\n\n    for (i = seq; i < seq + len; i++) {\n\n        if (i & 1) {\n\n            sum += (uint32_t)buf[i - seq];\n\n        } else {\n\n            sum += (uint32_t)buf[i - seq] << 8;\n\n        }\n\n    }\n\n    return sum;\n\n}\n"},{"project":"qemu","commit_id":"079d0b7f1eedcc634c371fe05b617fdc55c8b762","target":0,"func":"int usb_handle_packet(USBDevice *dev, USBPacket *p)\n\n{\n\n    int ret;\n\n\n\n    if (dev == NULL) {\n\n        return USB_RET_NODEV;\n\n    }\n\n    assert(dev->addr == p->devaddr);\n\n    assert(dev->state == USB_STATE_DEFAULT);\n\n    assert(p->state == USB_PACKET_SETUP);\n\n\n\n    if (p->devep == 0) {\n\n        \/* control pipe *\/\n\n        switch (p->pid) {\n\n        case USB_TOKEN_SETUP:\n\n            ret = do_token_setup(dev, p);\n\n            break;\n\n        case USB_TOKEN_IN:\n\n            ret = do_token_in(dev, p);\n\n            break;\n\n        case USB_TOKEN_OUT:\n\n            ret = do_token_out(dev, p);\n\n            break;\n\n        default:\n\n            ret = USB_RET_STALL;\n\n            break;\n\n        }\n\n    } else {\n\n        \/* data pipe *\/\n\n        ret = usb_device_handle_data(dev, p);\n\n    }\n\n\n\n    if (ret == USB_RET_ASYNC) {\n\n        p->ep = usb_ep_get(dev, p->pid, p->devep);\n\n        p->state = USB_PACKET_ASYNC;\n\n    }\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"a5068244b4f0c994791303b6186b6f732adab6c2","target":0,"func":"static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n\n{\n\n    ssize_t ret, dropped = size;\n\n    char small[1024];\n\n    char *buffer;\n\n\n\n    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));\n\n    while (size > 0) {\n\n        ret = read_sync(ioc, buffer, MIN(65536, size));\n\n        if (ret < 0) {\n\n            goto cleanup;\n\n        }\n\n        assert(ret <= size);\n\n        size -= ret;\n\n    }\n\n    ret = dropped;\n\n\n\n cleanup:\n\n    if (buffer != small) {\n\n        g_free(buffer);\n\n    }\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"ad0ebb91cd8b5fdc4a583b03645677771f420a46","target":1,"func":"static void ppc_spapr_init(ram_addr_t ram_size,\n                           const char *boot_device,\n                           const char *kernel_filename,\n                           const char *kernel_cmdline,\n                           const char *initrd_filename,\n                           const char *cpu_model)\n{\n    PowerPCCPU *cpu;\n    CPUPPCState *env;\n    int i;\n    MemoryRegion *sysmem = get_system_memory();\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    target_phys_addr_t rma_alloc_size, rma_size;\n    uint32_t initrd_base = 0;\n    long kernel_size = 0, initrd_size = 0;\n    long load_limit, rtas_limit, fw_size;\n    long pteg_shift = 17;\n    char *filename;\n    spapr = g_malloc0(sizeof(*spapr));\n    QLIST_INIT(&spapr->phbs);\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n    \/* Allocate RMA if necessary *\/\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n    if (rma_alloc_size == -1) {\n        hw_error(\"qemu: Unable to create RMA\\n\");\n        exit(1);\n    }\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n        rma_size = rma_alloc_size;\n    } else {\n        rma_size = ram_size;\n    }\n    \/* We place the device tree and RTAS just below either the top of the RMA,\n     * or just below 2GB, whichever is lowere, so that it can be\n     * processed with 32-bit real mode code if necessary *\/\n    rtas_limit = MIN(rma_size, 0x80000000);\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n    \/* init CPUs *\/\n    if (cpu_model == NULL) {\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n    }\n    for (i = 0; i < smp_cpus; i++) {\n        cpu = cpu_ppc_init(cpu_model);\n        if (cpu == NULL) {\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n            exit(1);\n        }\n        env = &cpu->env;\n        \/* Set time-base frequency to 512 MHz *\/\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n        qemu_register_reset(spapr_cpu_reset, cpu);\n        env->hreset_vector = 0x60;\n        env->hreset_excp_prefix = 0;\n        env->gpr[3] = env->cpu_index;\n    }\n    \/* allocate RAM *\/\n    spapr->ram_limit = ram_size;\n    if (spapr->ram_limit > rma_alloc_size) {\n        ram_addr_t nonrma_base = rma_alloc_size;\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n        memory_region_init_ram(ram, \"ppc_spapr.ram\", nonrma_size);\n        vmstate_register_ram_global(ram);\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n    }\n    \/* allocate hash page table.  For now we always make this 16mb,\n     * later we should probably make it scale to the size of guest\n     * RAM *\/\n    spapr->htab_size = 1ULL << (pteg_shift + 7);\n    spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size);\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n        env->external_htab = spapr->htab;\n        env->htab_base = -1;\n        env->htab_mask = spapr->htab_size - 1;\n        \/* Tell KVM that we're in PAPR mode *\/\n        env->spr[SPR_SDR1] = (unsigned long)spapr->htab |\n                             ((pteg_shift + 7) - 18);\n        env->spr[SPR_HIOR] = 0;\n        if (kvm_enabled()) {\n            kvmppc_set_papr(env);\n        }\n    }\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n                                           rtas_limit - spapr->rtas_addr);\n    if (spapr->rtas_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n    }\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n        exit(1);\n    }\n    g_free(filename);\n    \/* Set up Interrupt Controller *\/\n    spapr->icp = xics_system_init(XICS_IRQS);\n    spapr->next_irq = 16;\n    \/* Set up VIO bus *\/\n    spapr->vio_bus = spapr_vio_bus_init();\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n        if (serial_hds[i]) {\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n        }\n    }\n    \/* Set up PCI *\/\n    spapr_create_phb(spapr, \"pci\", SPAPR_PCI_BUID,\n                     SPAPR_PCI_MEM_WIN_ADDR,\n                     SPAPR_PCI_MEM_WIN_SIZE,\n                     SPAPR_PCI_IO_WIN_ADDR);\n    for (i = 0; i < nb_nics; i++) {\n        NICInfo *nd = &nd_table[i];\n        if (!nd->model) {\n            nd->model = g_strdup(\"ibmveth\");\n        }\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n            spapr_vlan_create(spapr->vio_bus, nd);\n        } else {\n            pci_nic_init_nofail(&nd_table[i], nd->model, NULL);\n        }\n    }\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n        spapr_vscsi_create(spapr->vio_bus);\n    }\n    if (rma_size < (MIN_RMA_SLOF << 20)) {\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n        exit(1);\n    }\n    fprintf(stderr, \"sPAPR memory map:\\n\");\n    fprintf(stderr, \"RTAS                 : 0x%08lx..%08lx\\n\",\n            (unsigned long)spapr->rtas_addr,\n            (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));\n    fprintf(stderr, \"FDT                  : 0x%08lx..%08lx\\n\",\n            (unsigned long)spapr->fdt_addr,\n            (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));\n    if (kernel_filename) {\n        uint64_t lowaddr = 0;\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n        if (kernel_size < 0) {\n            kernel_size = load_image_targphys(kernel_filename,\n                                              KERNEL_LOAD_ADDR,\n                                              load_limit - KERNEL_LOAD_ADDR);\n        }\n        if (kernel_size < 0) {\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n                    kernel_filename);\n            exit(1);\n        }\n        fprintf(stderr, \"Kernel               : 0x%08x..%08lx\\n\",\n                KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);\n        \/* load initrd *\/\n        if (initrd_filename) {\n            \/* Try to locate the initrd in the gap between the kernel\n             * and the firmware. Add a bit of space just in case\n             *\/\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n                                              load_limit - initrd_base);\n            if (initrd_size < 0) {\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n                        initrd_filename);\n                exit(1);\n            }\n            fprintf(stderr, \"Ramdisk              : 0x%08lx..%08lx\\n\",\n                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));\n        } else {\n            initrd_base = 0;\n            initrd_size = 0;\n        }\n    }\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n    if (fw_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n    }\n    g_free(filename);\n    fprintf(stderr, \"Firmware load        : 0x%08x..%08lx\\n\",\n            0, fw_size);\n    fprintf(stderr, \"Firmware runtime     : 0x%08lx..%08lx\\n\",\n            load_limit, (unsigned long)spapr->fdt_addr);\n    spapr->entry_point = 0x100;\n    \/* SLOF will startup the secondary CPUs using RTAS *\/\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n        env->halted = 1;\n    }\n    \/* Prepare the device tree *\/\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size,\n                                            initrd_base, initrd_size,\n                                            kernel_size,\n                                            boot_device, kernel_cmdline,\n                                            pteg_shift + 7);\n    assert(spapr->fdt_skel != NULL);\n    qemu_register_reset(spapr_reset, spapr);\n}"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void exynos4210_pmu_write(void *opaque, target_phys_addr_t offset,\n\n                                 uint64_t val, unsigned size)\n\n{\n\n    Exynos4210PmuState *s = (Exynos4210PmuState *)opaque;\n\n    unsigned i;\n\n    const Exynos4210PmuReg *reg_p = exynos4210_pmu_regs;\n\n\n\n    for (i = 0; i < PMU_NUM_OF_REGISTERS; i++) {\n\n        if (reg_p->offset == offset) {\n\n            PRINT_DEBUG_EXTEND(\"%s <0x%04x> <- 0x%04x\\n\", reg_p->name,\n\n                    (uint32_t)offset, (uint32_t)val);\n\n            s->reg[i] = val;\n\n            return;\n\n        }\n\n        reg_p++;\n\n    }\n\n    PRINT_DEBUG(\"QEMU PMU ERROR: bad write offset 0x%04x\\n\", (uint32_t)offset);\n\n}\n"},{"project":"qemu","commit_id":"5e1b34a3fa0a0fbf46628aab10cc49f6f855520e","target":0,"func":"static void ioq_submit(LinuxAioState *s)\n\n{\n\n    int ret, len;\n\n    struct qemu_laiocb *aiocb;\n\n    struct iocb *iocbs[MAX_QUEUED_IO];\n\n    QSIMPLEQ_HEAD(, qemu_laiocb) completed;\n\n\n\n    do {\n\n        len = 0;\n\n        QSIMPLEQ_FOREACH(aiocb, &s->io_q.pending, next) {\n\n            iocbs[len++] = &aiocb->iocb;\n\n            if (len == MAX_QUEUED_IO) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        ret = io_submit(s->ctx, len, iocbs);\n\n        if (ret == -EAGAIN) {\n\n            break;\n\n        }\n\n        if (ret < 0) {\n\n            abort();\n\n        }\n\n\n\n        s->io_q.n -= ret;\n\n        aiocb = container_of(iocbs[ret - 1], struct qemu_laiocb, iocb);\n\n        QSIMPLEQ_SPLIT_AFTER(&s->io_q.pending, aiocb, next, &completed);\n\n    } while (ret == len && !QSIMPLEQ_EMPTY(&s->io_q.pending));\n\n    s->io_q.blocked = (s->io_q.n > 0);\n\n}\n"},{"project":"qemu","commit_id":"ff71f2e8cacefae99179993204172bc65e4303df","target":1,"func":"static int rtl8139_can_receive(VLANClientState *nc)\n\n{\n\n    RTL8139State *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n    int avail;\n\n\n\n    \/* Receive (drop) packets if card is disabled.  *\/\n\n    if (!s->clock_enabled)\n\n      return 1;\n\n    if (!rtl8139_receiver_enabled(s))\n\n      return 1;\n\n\n\n\n\n\n    if (rtl8139_cp_receiver_enabled(s)) {\n\n        \/* ??? Flow control not implemented in c+ mode.\n\n           This is a hack to work around slirp deficiencies anyway.  *\/\n\n        return 1;\n\n    } else {\n\n        avail = MOD2(s->RxBufferSize + s->RxBufPtr - s->RxBufAddr,\n\n                     s->RxBufferSize);\n\n        return (avail == 0 || avail >= 1514);\n\n    }\n\n}"},{"project":"qemu","commit_id":"df3c286c53ac51e7267f2761c7a0c62e11b6e815","target":0,"func":"void spapr_core_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                         Error **errp)\n\n{\n\n    MachineState *machine = MACHINE(OBJECT(hotplug_dev));\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(OBJECT(hotplug_dev));\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(OBJECT(hotplug_dev));\n\n    int spapr_max_cores = max_cpus \/ smp_threads;\n\n    int index;\n\n    Error *local_err = NULL;\n\n    CPUCore *cc = CPU_CORE(dev);\n\n    char *base_core_type = spapr_get_cpu_core_type(machine->cpu_model);\n\n    const char *type = object_get_typename(OBJECT(dev));\n\n\n\n    if (!smc->dr_cpu_enabled) {\n\n        error_setg(&local_err, \"CPU hotplug not supported for this machine\");\n\n        goto out;\n\n    }\n\n\n\n    if (strcmp(base_core_type, type)) {\n\n        error_setg(&local_err, \"CPU core type should be %s\", base_core_type);\n\n        goto out;\n\n    }\n\n\n\n    if (cc->nr_threads != smp_threads) {\n\n        error_setg(&local_err, \"threads must be %d\", smp_threads);\n\n        goto out;\n\n    }\n\n\n\n    if (cc->core_id % smp_threads) {\n\n        error_setg(&local_err, \"invalid core id %d\\n\", cc->core_id);\n\n        goto out;\n\n    }\n\n\n\n    index = cc->core_id \/ smp_threads;\n\n    if (index < 0 || index >= spapr_max_cores) {\n\n        error_setg(&local_err, \"core id %d out of range\", cc->core_id);\n\n        goto out;\n\n    }\n\n\n\n    if (spapr->cores[index]) {\n\n        error_setg(&local_err, \"core %d already populated\", cc->core_id);\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    g_free(base_core_type);\n\n    error_propagate(errp, local_err);\n\n}\n"},{"project":"qemu","commit_id":"185698715dfb18c82ad2a5dbc169908602d43e81","target":0,"func":"float64 HELPER(sub_cmp_f64)(CPUState *env, float64 a, float64 b)\n\n{\n\n    \/* ??? This may incorrectly raise exceptions.  *\/\n\n    \/* ??? Should flush denormals to zero.  *\/\n\n    float64 res;\n\n    res = float64_sub(a, b, &env->fp_status);\n\n    if (float64_is_nan(res)) {\n\n        \/* +\/-inf compares equal against itself, but sub returns nan.  *\/\n\n        if (!float64_is_nan(a)\n\n            && !float64_is_nan(b)) {\n\n            res = float64_zero;\n\n            if (float64_lt_quiet(a, res, &env->fp_status))\n\n                res = float64_chs(res);\n\n        }\n\n    }\n\n    return res;\n\n}\n"},{"project":"qemu","commit_id":"3baf720e6b920d583ce2834d05e5a4e9603a1d56","target":1,"func":"static int cdrom_probe_device(const char *filename)\n\n{\n\n    if (strstart(filename, \"\/dev\/cd\", NULL))\n\n        return 100;\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"cfaf6d36ae761da1033159d85d670706ffb24fb9","target":0,"func":"static void unix_accept_incoming_migration(void *opaque)\n\n{\n\n    struct sockaddr_un addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int s = (unsigned long)opaque;\n\n    QEMUFile *f;\n\n    int c, ret;\n\n\n\n    do {\n\n        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);\n\n    } while (c == -1 && socket_error() == EINTR);\n\n\n\n    DPRINTF(\"accepted migration\\n\");\n\n\n\n    if (c == -1) {\n\n        fprintf(stderr, \"could not accept migration connection\\n\");\n\n        return;\n\n    }\n\n\n\n    f = qemu_fopen_socket(c);\n\n    if (f == NULL) {\n\n        fprintf(stderr, \"could not qemu_fopen socket\\n\");\n\n        goto out;\n\n    }\n\n\n\n    ret = qemu_loadvm_state(f);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"load of migration failed\\n\");\n\n        goto out_fopen;\n\n    }\n\n    qemu_announce_self();\n\n    DPRINTF(\"successfully loaded vm state\\n\");\n\n\n\n    \/* we've successfully migrated, close the server socket *\/\n\n    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);\n\n    close(s);\n\n\n\nout_fopen:\n\n    qemu_fclose(f);\n\nout:\n\n    close(c);\n\n}\n"},{"project":"qemu","commit_id":"364031f17932814484657e5551ba12957d993d7e","target":0,"func":"static int v9fs_synth_lsetxattr(FsContext *ctx, V9fsPath *path,\n\n                                const char *name, void *value,\n\n                                size_t size, int flags)\n\n{\n\n    errno = ENOTSUP;\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"16a9e8a5bcc1fb0796828eb654a4f926734e59af","target":0,"func":"static void pc_dimm_plug(HotplugHandler *hotplug_dev,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    HotplugHandlerClass *hhc;\n\n    Error *local_err = NULL;\n\n    PCMachineState *pcms = PC_MACHINE(hotplug_dev);\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);\n\n    MemoryRegion *mr = ddc->get_memory_region(dimm);\n\n    uint64_t align = TARGET_PAGE_SIZE;\n\n\n\n    if (memory_region_get_alignment(mr) && pcms->enforce_aligned_dimm) {\n\n        align = memory_region_get_alignment(mr);\n\n    }\n\n\n\n    if (!pcms->acpi_dev) {\n\n        error_setg(&local_err,\n\n                   \"memory hotplug is not enabled: missing acpi device\");\n\n        goto out;\n\n    }\n\n\n\n    pc_dimm_memory_plug(dev, &pcms->hotplug_memory, mr, align, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    hhc = HOTPLUG_HANDLER_GET_CLASS(pcms->acpi_dev);\n\n    hhc->plug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, &error_abort);\n\nout:\n\n    error_propagate(errp, local_err);\n\n}\n"},{"project":"qemu","commit_id":"651060aba79dc9d0cc77ac3921948ea78dba7409","target":1,"func":"static uint32_t ppc_hash64_pte_size_decode(uint64_t pte1, uint32_t slb_pshift)\n\n{\n\n    switch (slb_pshift) {\n\n    case 12:\n\n        return 12;\n\n    case 16:\n\n        if ((pte1 & 0xf000) == 0x1000) {\n\n            return 16;\n\n        }\n\n        return 0;\n\n    case 24:\n\n        if ((pte1 & 0xff000) == 0) {\n\n            return 24;\n\n        }\n\n        return 0;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"efab87cf79077a9624f675fc5fc8f034eaedfe4d","target":0,"func":"void qemu_clock_warp(QEMUClockType type)\n\n{\n\n    int64_t clock;\n\n    int64_t deadline;\n\n\n\n    \/*\n\n     * There are too many global variables to make the \"warp\" behavior\n\n     * applicable to other clocks.  But a clock argument removes the\n\n     * need for if statements all over the place.\n\n     *\/\n\n    if (type != QEMU_CLOCK_VIRTUAL || !use_icount) {\n\n        return;\n\n    }\n\n\n\n    if (icount_sleep) {\n\n        \/*\n\n         * If the CPUs have been sleeping, advance QEMU_CLOCK_VIRTUAL timer now.\n\n         * This ensures that the deadline for the timer is computed correctly\n\n         * below.\n\n         * This also makes sure that the insn counter is synchronized before\n\n         * the CPU starts running, in case the CPU is woken by an event other\n\n         * than the earliest QEMU_CLOCK_VIRTUAL timer.\n\n         *\/\n\n        icount_warp_rt(NULL);\n\n        timer_del(icount_warp_timer);\n\n    }\n\n    if (!all_cpu_threads_idle()) {\n\n        return;\n\n    }\n\n\n\n    if (qtest_enabled()) {\n\n        \/* When testing, qtest commands advance icount.  *\/\n\n\treturn;\n\n    }\n\n\n\n    \/* We want to use the earliest deadline from ALL vm_clocks *\/\n\n    clock = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_RT);\n\n    deadline = qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL);\n\n    if (deadline < 0) {\n\n        static bool notified;\n\n        if (!icount_sleep && !notified) {\n\n            error_report(\"WARNING: icount sleep disabled and no active timers\");\n\n            notified = true;\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (deadline > 0) {\n\n        \/*\n\n         * Ensure QEMU_CLOCK_VIRTUAL proceeds even when the virtual CPU goes to\n\n         * sleep.  Otherwise, the CPU might be waiting for a future timer\n\n         * interrupt to wake it up, but the interrupt never comes because\n\n         * the vCPU isn't running any insns and thus doesn't advance the\n\n         * QEMU_CLOCK_VIRTUAL.\n\n         *\/\n\n        if (!icount_sleep) {\n\n            \/*\n\n             * We never let VCPUs sleep in no sleep icount mode.\n\n             * If there is a pending QEMU_CLOCK_VIRTUAL timer we just advance\n\n             * to the next QEMU_CLOCK_VIRTUAL event and notify it.\n\n             * It is useful when we want a deterministic execution time,\n\n             * isolated from host latencies.\n\n             *\/\n\n            seqlock_write_lock(&timers_state.vm_clock_seqlock);\n\n            timers_state.qemu_icount_bias += deadline;\n\n            seqlock_write_unlock(&timers_state.vm_clock_seqlock);\n\n            qemu_clock_notify(QEMU_CLOCK_VIRTUAL);\n\n        } else {\n\n            \/*\n\n             * We do stop VCPUs and only advance QEMU_CLOCK_VIRTUAL after some\n\n             * \"real\" time, (related to the time left until the next event) has\n\n             * passed. The QEMU_CLOCK_VIRTUAL_RT clock will do this.\n\n             * This avoids that the warps are visible externally; for example,\n\n             * you will not be sending network packets continuously instead of\n\n             * every 100ms.\n\n             *\/\n\n            seqlock_write_lock(&timers_state.vm_clock_seqlock);\n\n            if (vm_clock_warp_start == -1 || vm_clock_warp_start > clock) {\n\n                vm_clock_warp_start = clock;\n\n            }\n\n            seqlock_write_unlock(&timers_state.vm_clock_seqlock);\n\n            timer_mod_anticipate(icount_warp_timer, clock + deadline);\n\n        }\n\n    } else if (deadline == 0) {\n\n        qemu_clock_notify(QEMU_CLOCK_VIRTUAL);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"d5b93ddfefe63d5869a8eb97ea3474867d3b105b","target":0,"func":"static void ioreq_unmap(struct ioreq *ioreq)\n\n{\n\n    int gnt = ioreq->blkdev->xendev.gnttabdev;\n\n    int i;\n\n\n\n    if (ioreq->v.niov == 0) {\n\n        return;\n\n    }\n\n    if (batch_maps) {\n\n        if (!ioreq->pages) {\n\n            return;\n\n        }\n\n        if (xc_gnttab_munmap(gnt, ioreq->pages, ioreq->v.niov) != 0) {\n\n            xen_be_printf(&ioreq->blkdev->xendev, 0, \"xc_gnttab_munmap failed: %s\\n\",\n\n                          strerror(errno));\n\n        }\n\n        ioreq->blkdev->cnt_map -= ioreq->v.niov;\n\n        ioreq->pages = NULL;\n\n    } else {\n\n        for (i = 0; i < ioreq->v.niov; i++) {\n\n            if (!ioreq->page[i]) {\n\n                continue;\n\n            }\n\n            if (xc_gnttab_munmap(gnt, ioreq->page[i], 1) != 0) {\n\n                xen_be_printf(&ioreq->blkdev->xendev, 0, \"xc_gnttab_munmap failed: %s\\n\",\n\n                              strerror(errno));\n\n            }\n\n            ioreq->blkdev->cnt_map--;\n\n            ioreq->page[i] = NULL;\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"f2ad97ff81da51c064b9e87720ff48a0874f45d4","target":1,"func":"static int usb_xhci_post_load(void *opaque, int version_id)\n\n{\n\n    XHCIState *xhci = opaque;\n\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n\n    XHCISlot *slot;\n\n    XHCIEPContext *epctx;\n\n    dma_addr_t dcbaap, pctx;\n\n    uint32_t slot_ctx[4];\n\n    uint32_t ep_ctx[5];\n\n    int slotid, epid, state, intr;\n\n\n\n    dcbaap = xhci_addr64(xhci->dcbaap_low, xhci->dcbaap_high);\n\n\n\n    for (slotid = 1; slotid <= xhci->numslots; slotid++) {\n\n        slot = &xhci->slots[slotid-1];\n\n        if (!slot->addressed) {\n\n\n\n        slot->ctx =\n\n            xhci_mask64(ldq_le_pci_dma(pci_dev, dcbaap + 8 * slotid));\n\n        xhci_dma_read_u32s(xhci, slot->ctx, slot_ctx, sizeof(slot_ctx));\n\n        slot->uport = xhci_lookup_uport(xhci, slot_ctx);\n\n\n\n\n\n\n\n        assert(slot->uport && slot->uport->dev);\n\n\n\n        for (epid = 1; epid <= 31; epid++) {\n\n            pctx = slot->ctx + 32 * epid;\n\n            xhci_dma_read_u32s(xhci, pctx, ep_ctx, sizeof(ep_ctx));\n\n            state = ep_ctx[0] & EP_STATE_MASK;\n\n            if (state == EP_DISABLED) {\n\n\n\n            epctx = xhci_alloc_epctx(xhci, slotid, epid);\n\n            slot->eps[epid-1] = epctx;\n\n            xhci_init_epctx(epctx, pctx, ep_ctx);\n\n            epctx->state = state;\n\n            if (state == EP_RUNNING) {\n\n                \/* kick endpoint after vmload is finished *\/\n\n                timer_mod(epctx->kick_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL));\n\n\n\n\n\n\n    for (intr = 0; intr < xhci->numintrs; intr++) {\n\n        if (xhci->intr[intr].msix_used) {\n\n            msix_vector_use(pci_dev, intr);\n\n        } else {\n\n            msix_vector_unuse(pci_dev, intr);\n\n\n\n\n\n    return 0;\n"},{"project":"qemu","commit_id":"3178e2755ec5a7fb1afe583fb6ac2622c2c42184","target":1,"func":"static int sd_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    int ret, fd;\n\n    uint32_t vid = 0;\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    char vdi[SD_MAX_VDI_LEN], tag[SD_MAX_VDI_TAG_LEN];\n\n    uint32_t snapid;\n\n    char *buf = NULL;\n\n\n\n    strstart(filename, \"sheepdog:\", (const char **)&filename);\n\n\n\n    QLIST_INIT(&s->inflight_aio_head);\n\n    QLIST_INIT(&s->pending_aio_head);\n\n    s->fd = -1;\n\n\n\n    memset(vdi, 0, sizeof(vdi));\n\n    memset(tag, 0, sizeof(tag));\n\n    if (parse_vdiname(s, filename, vdi, &snapid, tag) < 0) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n    s->fd = get_sheep_fd(s);\n\n    if (s->fd < 0) {\n\n        ret = s->fd;\n\n        goto out;\n\n    }\n\n\n\n    ret = find_vdi_name(s, vdi, snapid, tag, &vid, 0);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    s->cache_enabled = 1;\n\n    s->flush_fd = connect_to_sdog(s->addr, s->port);\n\n    if (s->flush_fd < 0) {\n\n        error_report(\"failed to connect\");\n\n        ret = s->flush_fd;\n\n        goto out;\n\n    }\n\n\n\n    if (snapid || tag[0] != '\\0') {\n\n        dprintf(\"%\" PRIx32 \" snapshot inode was open.\\n\", vid);\n\n        s->is_snapshot = 1;\n\n    }\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        error_report(\"failed to connect\");\n\n        ret = fd;\n\n        goto out;\n\n    }\n\n\n\n    buf = g_malloc(SD_INODE_SIZE);\n\n    ret = read_object(fd, buf, vid_to_vdi_oid(vid), 0, SD_INODE_SIZE, 0,\n\n                      s->cache_enabled);\n\n\n\n    closesocket(fd);\n\n\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    memcpy(&s->inode, buf, sizeof(s->inode));\n\n    s->min_dirty_data_idx = UINT32_MAX;\n\n    s->max_dirty_data_idx = 0;\n\n\n\n    bs->total_sectors = s->inode.vdi_size \/ SECTOR_SIZE;\n\n    strncpy(s->name, vdi, sizeof(s->name));\n\n    qemu_co_mutex_init(&s->lock);\n\n    g_free(buf);\n\n    return 0;\n\nout:\n\n    qemu_aio_set_fd_handler(s->fd, NULL, NULL, NULL, NULL);\n\n    if (s->fd >= 0) {\n\n        closesocket(s->fd);\n\n    }\n\n    g_free(buf);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"3e305e4a4752f70c0b5c3cf5b43ec957881714f7","target":1,"func":"int vnc_tls_client_setup(VncState *vs,\n\n                         int needX509Creds) {\n\n    VNC_DEBUG(\"Do TLS setup\\n\");\n\n    if (vnc_tls_initialize() < 0) {\n\n        VNC_DEBUG(\"Failed to init TLS\\n\");\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n    if (vs->tls.session == NULL) {\n\n        if (gnutls_init(&vs->tls.session, GNUTLS_SERVER) < 0) {\n\n            vnc_client_error(vs);\n\n            return -1;\n\n        }\n\n\n\n        if (gnutls_set_default_priority(vs->tls.session) < 0) {\n\n            gnutls_deinit(vs->tls.session);\n\n            vs->tls.session = NULL;\n\n            vnc_client_error(vs);\n\n            return -1;\n\n        }\n\n\n\n        if (vnc_set_gnutls_priority(vs->tls.session, needX509Creds) < 0) {\n\n            gnutls_deinit(vs->tls.session);\n\n            vs->tls.session = NULL;\n\n            vnc_client_error(vs);\n\n            return -1;\n\n        }\n\n\n\n        if (needX509Creds) {\n\n            gnutls_certificate_server_credentials x509_cred =\n\n                vnc_tls_initialize_x509_cred(vs->vd);\n\n            if (!x509_cred) {\n\n                gnutls_deinit(vs->tls.session);\n\n                vs->tls.session = NULL;\n\n                vnc_client_error(vs);\n\n                return -1;\n\n            }\n\n            if (gnutls_credentials_set(vs->tls.session,\n\n                                       GNUTLS_CRD_CERTIFICATE, x509_cred) < 0) {\n\n                gnutls_deinit(vs->tls.session);\n\n                vs->tls.session = NULL;\n\n                gnutls_certificate_free_credentials(x509_cred);\n\n                vnc_client_error(vs);\n\n                return -1;\n\n            }\n\n            if (vs->vd->tls.x509verify) {\n\n                VNC_DEBUG(\"Requesting a client certificate\\n\");\n\n                gnutls_certificate_server_set_request(vs->tls.session,\n\n                                                      GNUTLS_CERT_REQUEST);\n\n            }\n\n\n\n        } else {\n\n            gnutls_anon_server_credentials_t anon_cred =\n\n                vnc_tls_initialize_anon_cred();\n\n            if (!anon_cred) {\n\n                gnutls_deinit(vs->tls.session);\n\n                vs->tls.session = NULL;\n\n                vnc_client_error(vs);\n\n                return -1;\n\n            }\n\n            if (gnutls_credentials_set(vs->tls.session,\n\n                                       GNUTLS_CRD_ANON, anon_cred) < 0) {\n\n                gnutls_deinit(vs->tls.session);\n\n                vs->tls.session = NULL;\n\n                gnutls_anon_free_server_credentials(anon_cred);\n\n                vnc_client_error(vs);\n\n                return -1;\n\n            }\n\n        }\n\n\n\n        gnutls_transport_set_ptr(vs->tls.session, (gnutls_transport_ptr_t)vs);\n\n        gnutls_transport_set_push_function(vs->tls.session, vnc_tls_push);\n\n        gnutls_transport_set_pull_function(vs->tls.session, vnc_tls_pull);\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"72cf2d4f0e181d0d3a3122e04129c58a95da713e","target":0,"func":"DriveInfo *drive_get_by_id(const char *id)\n\n{\n\n    DriveInfo *dinfo;\n\n\n\n    TAILQ_FOREACH(dinfo, &drives, next) {\n\n        if (strcmp(id, dinfo->id))\n\n            continue;\n\n        return dinfo;\n\n    }\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"6735d433729f80fab80c0a1f70ae131398645613","target":1,"func":"USBPacket *usb_ep_find_packet_by_id(USBDevice *dev, int pid, int ep,\n\n                                    uint64_t id)\n\n{\n\n    struct USBEndpoint *uep = usb_ep_get(dev, pid, ep);\n\n    USBPacket *p;\n\n\n\n    while ((p = QTAILQ_FIRST(&uep->queue)) != NULL) {\n\n        if (p->id == id) {\n\n            return p;\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"5b5cb08683b6715a2aca5314168e68ff0665912b","target":0,"func":"static int msix_is_masked(PCIDevice *dev, int vector)\n\n{\n\n    unsigned offset = vector * MSIX_ENTRY_SIZE + MSIX_VECTOR_CTRL;\n\n    return dev->msix_table_page[offset] & MSIX_VECTOR_MASK;\n\n}\n"},{"project":"qemu","commit_id":"265ca29a7162a9437efabdb3b133237eef49ab7b","target":1,"func":"int load_uboot(const char *filename, target_ulong *ep, int *is_linux)\n\n{\n\n\n\n    int fd;\n\n    int size;\n\n    uboot_image_header_t h;\n\n    uboot_image_header_t *hdr = &h;\n\n    uint8_t *data = NULL;\n\n\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (fd < 0)\n\n        return -1;\n\n\n\n    size = read(fd, hdr, sizeof(uboot_image_header_t));\n\n    if (size < 0)\n\n        goto fail;\n\n\n\n    bswap_uboot_header(hdr);\n\n\n\n    if (hdr->ih_magic != IH_MAGIC)\n\n        goto fail;\n\n\n\n    \/* TODO: Implement Multi-File images.  *\/\n\n    if (hdr->ih_type == IH_TYPE_MULTI) {\n\n        fprintf(stderr, \"Unable to load multi-file u-boot images\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    \/* TODO: Implement compressed images.  *\/\n\n    if (hdr->ih_comp != IH_COMP_NONE) {\n\n        fprintf(stderr, \"Unable to load compressed u-boot images\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    \/* TODO: Check CPU type.  *\/\n\n    if (is_linux) {\n\n        if (hdr->ih_type == IH_TYPE_KERNEL && hdr->ih_os == IH_OS_LINUX)\n\n            *is_linux = 1;\n\n        else\n\n            *is_linux = 0;\n\n    }\n\n\n\n    *ep = hdr->ih_ep;\n\n    data = qemu_malloc(hdr->ih_size);\n\n    if (!data)\n\n        goto fail;\n\n\n\n    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n\n        fprintf(stderr, \"Error reading file\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    cpu_physical_memory_write_rom(hdr->ih_load, data, hdr->ih_size);\n\n\n\n    return hdr->ih_size;\n\n\n\nfail:\n\n    if (data)\n\n        qemu_free(data);\n\n    close(fd);\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"3daa41078aedf227ec98b0d1c9d56b77b6d20153","target":1,"func":"void scsi_req_cancel(SCSIRequest *req)\n\n{\n\n    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->aiocb) {\n\n        blk_aio_cancel(req->aiocb);\n\n    } else {\n\n        scsi_req_cancel_complete(req);\n\n    }\n\n}"},{"project":"qemu","commit_id":"ac58fe7b2c67a9be142beacd4c6ee51f3264d90f","target":1,"func":"static void pmac_ide_transfer_cb(void *opaque, int ret)\n\n{\n\n    DBDMA_io *io = opaque;\n\n    MACIOIDEState *m = io->opaque;\n\n    IDEState *s = idebus_active_if(&m->bus);\n\n    int64_t sector_num;\n\n    int nsector, remainder;\n\n    int64_t offset;\n\n\n\n    MACIO_DPRINTF(\"pmac_ide_transfer_cb\\n\");\n\n\n\n    if (ret < 0) {\n\n        MACIO_DPRINTF(\"DMA error\\n\");\n\n        m->aiocb = NULL;\n\n        ide_dma_error(s);\n\n        io->remainder_len = 0;\n\n        goto done;\n\n    }\n\n\n\n    if (!m->dma_active) {\n\n        MACIO_DPRINTF(\"waiting for data (%#x - %#x - %x)\\n\",\n\n                      s->nsector, io->len, s->status);\n\n        \/* data not ready yet, wait for the channel to get restarted *\/\n\n        io->processing = false;\n\n        return;\n\n    }\n\n\n\n    if (s->io_buffer_size <= 0) {\n\n        MACIO_DPRINTF(\"end of transfer\\n\");\n\n        s->status = READY_STAT | SEEK_STAT;\n\n        ide_set_irq(s->bus);\n\n        m->dma_active = false;\n\n        goto done;\n\n    }\n\n\n\n    if (io->len == 0) {\n\n        MACIO_DPRINTF(\"End of DMA transfer\\n\");\n\n        goto done;\n\n    }\n\n\n\n    \/* Calculate number of sectors *\/\n\n    sector_num = ide_get_sector(s) + (s->io_buffer_index >> 9);\n\n    offset = (ide_get_sector(s) << 9) + s->io_buffer_index;\n\n    nsector = (io->len + 0x1ff) >> 9;\n\n    remainder = io->len & 0x1ff;\n\n\n\n    s->nsector -= nsector;\n\n\n\n    MACIO_DPRINTF(\"nsector: %d   remainder: %x\\n\", nsector, remainder);\n\n    MACIO_DPRINTF(\"sector: %\"PRIx64\"   %x\\n\", sector_num, nsector);\n\n\n\n    switch (s->dma_cmd) {\n\n    case IDE_DMA_READ:\n\n        pmac_dma_read(s->blk, offset, io->len, pmac_ide_transfer_cb, io);\n\n        break;\n\n    case IDE_DMA_WRITE:\n\n        pmac_dma_write(s->blk, sector_num, nsector, pmac_ide_transfer_cb, io);\n\n        break;\n\n    case IDE_DMA_TRIM:\n\n        MACIO_DPRINTF(\"TRIM command issued!\");\n\n        break;\n\n    }\n\n\n\n    return;\n\n\n\ndone:\n\n    if (s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) {\n\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n\n    }\n\n    io->dma_end(opaque);\n\n}\n"},{"project":"qemu","commit_id":"9307c4c1d93939db9b04117b654253af5113dc21","target":0,"func":"static void do_quit(int argc, const char **argv)\n\n{\n\n    exit(0);\n\n}\n"},{"project":"qemu","commit_id":"9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456","target":1,"func":"static void init_proc_power5plus(CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    \/* Time base *\/\n\n    gen_tbl(env);\n\n    \/* Hardware implementation registers *\/\n\n    \/* XXX : not implemented *\/\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_clear,\n\n                 0x60000000);\n\n    \/* XXX : not implemented *\/\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    \/* XXX : not implemented *\/\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    \/* XXX : not implemented *\/\n\n    spr_register(env, SPR_970_HID5, \"HID5\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 POWERPC970_HID5_INIT);\n\n    \/* XXX : not implemented *\/\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    \/* Memory management *\/\n\n    \/* XXX: not correct *\/\n\n    gen_low_BATs(env);\n\n    \/* XXX : not implemented *\/\n\n    spr_register(env, SPR_MMUCFG, \"MMUCFG\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, SPR_NOACCESS,\n\n                 0x00000000); \/* TOFIX *\/\n\n    \/* XXX : not implemented *\/\n\n    spr_register(env, SPR_MMUCSR0, \"MMUCSR0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000); \/* TOFIX *\/\n\n    spr_register(env, SPR_HIOR, \"SPR_HIOR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_hior, &spr_write_hior,\n\n                 0x00000000);\n\n    spr_register(env, SPR_CTRL, \"SPR_CTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_UCTRL, \"SPR_UCTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_VRSAVE, \"SPR_VRSAVE\",\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->slb_nr = 64;\n\n#endif\n\n    init_excp_970(env);\n\n    env->dcache_line_size = 128;\n\n    env->icache_line_size = 128;\n\n    \/* Allocate hardware IRQ controller *\/\n\n    ppc970_irq_init(env);\n\n    \/* Can't find information on what this should be on reset.  This\n\n     * value is the one used by 74xx processors. *\/\n\n    vscr_init(env, 0x00010000);\n\n}\n"},{"project":"qemu","commit_id":"81cf8d8adc64203567e03326c13ea4abec9fe5df","target":0,"func":"void helper_check_iob(CPUX86State *env, uint32_t t0)\n\n{\n\n    check_io(env, t0, 1);\n\n}\n"},{"project":"qemu","commit_id":"faadf50e2962dd54175647a80bd6fc4319c91973","target":1,"func":"static void init_proc_620 (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_620(env);\n\n    \/* Time base *\/\n\n    gen_tbl(env);\n\n    \/* Hardware implementation registers *\/\n\n    \/* XXX : not implemented *\/\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    \/* Memory management *\/\n\n    gen_low_BATs(env);\n\n    gen_high_BATs(env);\n\n    init_excp_620(env);\n\n    env->dcache_line_size = 64;\n\n    env->icache_line_size = 64;\n\n    \/* XXX: TODO: initialize internal interrupt controller *\/\n\n}\n"},{"project":"qemu","commit_id":"a8cf66bb393ff420d40ae172a4c817bf2752918a","target":0,"func":"static inline void cris_update_result(DisasContext *dc, TCGv res)\n\n{\n\n\tif (dc->update_cc) {\n\n\t\tif (dc->cc_size == 4 && \n\n\t\t    (dc->cc_op == CC_OP_SUB\n\n\t\t     || dc->cc_op == CC_OP_ADD))\n\n\t\t\treturn;\n\n\t\ttcg_gen_mov_tl(cc_result, res);\n\n\t}\n\n}\n"},{"project":"qemu","commit_id":"9561fda8d90e176bef598ba87c42a1bd6ad03ef7","target":1,"func":"void object_property_add_link(Object *obj, const char *name,\n\n                              const char *type, Object **child,\n\n                              Error **errp)\n\n{\n\n    gchar *full_type;\n\n\n\n    full_type = g_strdup_printf(\"link<%s>\", type);\n\n\n\n    object_property_add(obj, name, full_type,\n\n                        object_get_link_property,\n\n                        object_set_link_property,\n\n                        NULL, child, errp);\n\n\n\n    g_free(full_type);\n\n}\n"},{"project":"qemu","commit_id":"5f9490de566c5b092a6cfedc3c7a37a9c9dee917","target":1,"func":"static void spapr_tce_table_finalize(Object *obj)\n\n{\n\n    sPAPRTCETable *tcet = SPAPR_TCE_TABLE(obj);\n\n\n\n    QLIST_REMOVE(tcet, list);\n\n\n\n    if (!kvm_enabled() ||\n\n        (kvmppc_remove_spapr_tce(tcet->table, tcet->fd,\n\n                                 tcet->nb_table) != 0)) {\n\n        g_free(tcet->table);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"84a12e6648444f517055138a7d7f25a22d7e1029","target":0,"func":"static BlockDriver *find_protocol(const char *filename)\n\n{\n\n    BlockDriver *drv1;\n\n    char protocol[128];\n\n    int len;\n\n    const char *p;\n\n\n\n#ifdef _WIN32\n\n    if (is_windows_drive(filename) ||\n\n        is_windows_drive_prefix(filename))\n\n        return bdrv_find_format(\"raw\");\n\n#endif\n\n    p = strchr(filename, ':');\n\n    if (!p)\n\n        return bdrv_find_format(\"raw\");\n\n    len = p - filename;\n\n    if (len > sizeof(protocol) - 1)\n\n        len = sizeof(protocol) - 1;\n\n    memcpy(protocol, filename, len);\n\n    protocol[len] = '\\0';\n\n    QLIST_FOREACH(drv1, &bdrv_drivers, list) {\n\n        if (drv1->protocol_name &&\n\n            !strcmp(drv1->protocol_name, protocol)) {\n\n            return drv1;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"2ae39a113af311cb56a0c35b7f212dafcef15303","target":1,"func":"static void vhost_virtqueue_stop(struct vhost_dev *dev,\n\n                                    struct VirtIODevice *vdev,\n\n                                    struct vhost_virtqueue *vq,\n\n                                    unsigned idx)\n\n{\n\n    int vhost_vq_index = dev->vhost_ops->vhost_get_vq_index(dev, idx);\n\n    struct vhost_vring_state state = {\n\n        .index = vhost_vq_index,\n\n    };\n\n    int r;\n\n\n\n    r = dev->vhost_ops->vhost_get_vring_base(dev, &state);\n\n    if (r < 0) {\n\n        VHOST_OPS_DEBUG(\"vhost VQ %d ring restore failed: %d\", idx, r);\n\n\n\n\n\n    } else {\n\n        virtio_queue_set_last_avail_idx(vdev, idx, state.num);\n\n    }\n\n    virtio_queue_invalidate_signalled_used(vdev, idx);\n\n    virtio_queue_update_used_idx(vdev, idx);\n\n\n\n    \/* In the cross-endian case, we need to reset the vring endianness to\n\n     * native as legacy devices expect so by default.\n\n\n    if (vhost_needs_vring_endian(vdev)) {\n\n        vhost_virtqueue_set_vring_endian_legacy(dev,\n\n                                                !virtio_is_big_endian(vdev),\n\n                                                vhost_vq_index);\n\n    }\n\n\n\n    vhost_memory_unmap(dev, vq->used, virtio_queue_get_used_size(vdev, idx),\n\n                       1, virtio_queue_get_used_size(vdev, idx));\n\n    vhost_memory_unmap(dev, vq->avail, virtio_queue_get_avail_size(vdev, idx),\n\n                       0, virtio_queue_get_avail_size(vdev, idx));\n\n    vhost_memory_unmap(dev, vq->desc, virtio_queue_get_desc_size(vdev, idx),\n\n                       0, virtio_queue_get_desc_size(vdev, idx));\n\n}"},{"project":"qemu","commit_id":"c53b1c5114bdf7fc945cbf11436da61789ca2267","target":0,"func":"static int qiov_is_aligned(BlockDriverState *bs, QEMUIOVector *qiov)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < qiov->niov; i++) {\n\n        if ((uintptr_t) qiov->iov[i].iov_base % bs->buffer_alignment) {\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"73d60fa5fae60c8e07e1f295d8c7fd5d04320160","target":1,"func":"static void set_sensor_type(IPMIBmcSim *ibs,\n\n                               uint8_t *cmd, unsigned int cmd_len,\n\n                               uint8_t *rsp, unsigned int *rsp_len,\n\n                               unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n\n\n    IPMI_CHECK_CMD_LEN(5);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n            !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    sens->sensor_type = cmd[3];\n\n    sens->evt_reading_type_code = cmd[4] & 0x7f;\n\n}\n"},{"project":"qemu","commit_id":"a426e122173f36f05ea2cb72dcff77b7408546ce","target":0,"func":"static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,\n\n\t\t\t\t    int enable)\n\n{\n\n\treturn kvm_set_migration_log(enable);\n\n}\n"},{"project":"qemu","commit_id":"a7812ae412311d7d47f8aa85656faadac9d64b56","target":0,"func":"static unsigned int dec_bound_m(DisasContext *dc)\n\n{\n\n\tTCGv l[2];\n\n\tint memsize = memsize_zz(dc);\n\n\tint insn_len;\n\n\tDIS(fprintf (logfile, \"bound.%d [$r%u%s, $r%u\\n\",\n\n\t\t    memsize_char(memsize),\n\n\t\t    dc->op1, dc->postinc ? \"+]\" : \"]\",\n\n\t\t    dc->op2));\n\n\n\n\tl[0] = tcg_temp_local_new(TCG_TYPE_TL);\n\n\tl[1] = tcg_temp_local_new(TCG_TYPE_TL);\n\n\tinsn_len = dec_prep_alu_m(dc, 0, memsize, l[0], l[1]);\n\n\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\tcris_alu(dc, CC_OP_BOUND, cpu_R[dc->op2], l[0], l[1], 4);\n\n\tdo_postinc(dc, memsize);\n\n\ttcg_temp_free(l[0]);\n\n\ttcg_temp_free(l[1]);\n\n\treturn insn_len;\n\n}\n"},{"project":"qemu","commit_id":"6c8d56a2e95712a6206a2671d2b04b2e59cabc0b","target":1,"func":"static uint64_t fw_cfg_comb_read(void *opaque, hwaddr addr,\n\n                                 unsigned size)\n\n{\n\n    return fw_cfg_read(opaque);\n\n}\n"},{"project":"qemu","commit_id":"b51daf003aa42c5c23876739ebd0b64dd2075931","target":0,"func":"int ide_init_drive(IDEState *s, BlockDriverState *bs, IDEDriveKind kind,\n\n                   const char *version, const char *serial, const char *model,\n\n                   uint64_t wwn,\n\n                   uint32_t cylinders, uint32_t heads, uint32_t secs,\n\n                   int chs_trans)\n\n{\n\n    uint64_t nb_sectors;\n\n\n\n    s->bs = bs;\n\n    s->drive_kind = kind;\n\n\n\n    bdrv_get_geometry(bs, &nb_sectors);\n\n    if (cylinders < 1 || cylinders > 16383) {\n\n        error_report(\"cyls must be between 1 and 16383\");\n\n        return -1;\n\n    }\n\n    if (heads < 1 || heads > 16) {\n\n        error_report(\"heads must be between 1 and 16\");\n\n        return -1;\n\n    }\n\n    if (secs < 1 || secs > 63) {\n\n        error_report(\"secs must be between 1 and 63\");\n\n        return -1;\n\n    }\n\n    s->cylinders = cylinders;\n\n    s->heads = heads;\n\n    s->sectors = secs;\n\n    s->chs_trans = chs_trans;\n\n    s->nb_sectors = nb_sectors;\n\n    s->wwn = wwn;\n\n    \/* The SMART values should be preserved across power cycles\n\n       but they aren't.  *\/\n\n    s->smart_enabled = 1;\n\n    s->smart_autosave = 1;\n\n    s->smart_errors = 0;\n\n    s->smart_selftest_count = 0;\n\n    if (kind == IDE_CD) {\n\n        bdrv_set_dev_ops(bs, &ide_cd_block_ops, s);\n\n        bdrv_set_buffer_alignment(bs, 2048);\n\n    } else {\n\n        if (!bdrv_is_inserted(s->bs)) {\n\n            error_report(\"Device needs media, but drive is empty\");\n\n            return -1;\n\n        }\n\n        if (bdrv_is_read_only(bs)) {\n\n            error_report(\"Can't use a read-only drive\");\n\n            return -1;\n\n        }\n\n    }\n\n    if (serial) {\n\n        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);\n\n    } else {\n\n        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n\n                 \"QM%05d\", s->drive_serial);\n\n    }\n\n    if (model) {\n\n        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);\n\n    } else {\n\n        switch (kind) {\n\n        case IDE_CD:\n\n            strcpy(s->drive_model_str, \"QEMU DVD-ROM\");\n\n            break;\n\n        case IDE_CFATA:\n\n            strcpy(s->drive_model_str, \"QEMU MICRODRIVE\");\n\n            break;\n\n        default:\n\n            strcpy(s->drive_model_str, \"QEMU HARDDISK\");\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (version) {\n\n        pstrcpy(s->version, sizeof(s->version), version);\n\n    } else {\n\n        pstrcpy(s->version, sizeof(s->version), qemu_get_version());\n\n    }\n\n\n\n    ide_reset(s);\n\n    bdrv_iostatus_enable(bs);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"8f50c841b374dc90ea604888ca92c37f469c428a","target":1,"func":"static void tcg_out_qemu_st (TCGContext *s, const TCGArg *args, int opc)\n\n{\n\n    int addr_reg, r0, r1, data_reg, data_reg2, bswap, rbase;\n\n#ifdef CONFIG_SOFTMMU\n\n    int mem_index, r2, addr_reg2;\n\n    uint8_t *label_ptr;\n\n#endif\n\n\n\n    data_reg = *args++;\n\n    if (opc == 3)\n\n        data_reg2 = *args++;\n\n    else\n\n        data_reg2 = 0;\n\n    addr_reg = *args++;\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n#if TARGET_LONG_BITS == 64\n\n    addr_reg2 = *args++;\n\n#else\n\n    addr_reg2 = 0;\n\n#endif\n\n    mem_index = *args;\n\n    r0 = 3;\n\n    r1 = 4;\n\n    r2 = 0;\n\n    rbase = 0;\n\n\n\n    tcg_out_tlb_check (\n\n        s, r0, r1, r2, addr_reg, addr_reg2, opc & 3,\n\n        offsetof (CPUArchState, tlb_table[mem_index][0].addr_write),\n\n        offsetof (CPUTLBEntry, addend) - offsetof (CPUTLBEntry, addr_write),\n\n        &label_ptr\n\n        );\n\n#else  \/* !CONFIG_SOFTMMU *\/\n\n    r0 = addr_reg;\n\n    r1 = 3;\n\n    rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0;\n\n#endif\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    bswap = 0;\n\n#else\n\n    bswap = 1;\n\n#endif\n\n    switch (opc) {\n\n    case 0:\n\n        tcg_out32 (s, STBX | SAB (data_reg, rbase, r0));\n\n        break;\n\n    case 1:\n\n        if (bswap)\n\n            tcg_out32 (s, STHBRX | SAB (data_reg, rbase, r0));\n\n        else\n\n            tcg_out32 (s, STHX | SAB (data_reg, rbase, r0));\n\n        break;\n\n    case 2:\n\n        if (bswap)\n\n            tcg_out32 (s, STWBRX | SAB (data_reg, rbase, r0));\n\n        else\n\n            tcg_out32 (s, STWX | SAB (data_reg, rbase, r0));\n\n        break;\n\n    case 3:\n\n        if (bswap) {\n\n            tcg_out32 (s, ADDI | RT (r1) | RA (r0) | 4);\n\n            tcg_out32 (s, STWBRX | SAB (data_reg,  rbase, r0));\n\n            tcg_out32 (s, STWBRX | SAB (data_reg2, rbase, r1));\n\n        }\n\n        else {\n\n#ifdef CONFIG_USE_GUEST_BASE\n\n            tcg_out32 (s, STWX | SAB (data_reg2, rbase, r0));\n\n            tcg_out32 (s, ADDI | RT (r1) | RA (r0) | 4);\n\n            tcg_out32 (s, STWX | SAB (data_reg,  rbase, r1));\n\n#else\n\n            tcg_out32 (s, STW | RS (data_reg2) | RA (r0));\n\n            tcg_out32 (s, STW | RS (data_reg) | RA (r0) | 4);\n\n#endif\n\n        }\n\n        break;\n\n    }\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n    add_qemu_ldst_label (s,\n\n                         0,\n\n                         opc,\n\n                         data_reg,\n\n                         data_reg2,\n\n                         addr_reg,\n\n                         addr_reg2,\n\n                         mem_index,\n\n                         s->code_ptr,\n\n                         label_ptr);\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"c18ad9a54b75495ce61e8b28d353f8eec51768fc","target":0,"func":"void ppc_hash64_set_external_hpt(PowerPCCPU *cpu, void *hpt, int shift,\n\n                                 Error **errp)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    Error *local_err = NULL;\n\n\n\n    cpu_synchronize_state(CPU(cpu));\n\n\n\n    env->external_htab = hpt;\n\n    ppc_hash64_set_sdr1(cpu, (target_ulong)(uintptr_t)hpt | (shift - 18),\n\n                        &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    \/* Not strictly necessary, but makes it clearer that an external\n\n     * htab is in use when debugging *\/\n\n    env->htab_base = -1;\n\n\n\n    if (kvm_enabled()) {\n\n        if (kvmppc_put_books_sregs(cpu) < 0) {\n\n            error_setg(errp, \"Unable to update SDR1 in KVM\");\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e","target":0,"func":"static always_inline int _pte_check (mmu_ctx_t *ctx, int is_64b,\n\n                                     target_ulong pte0, target_ulong pte1,\n\n                                     int h, int rw)\n\n{\n\n    target_ulong ptem, mmask;\n\n    int access, ret, pteh, ptev;\n\n\n\n    access = 0;\n\n    ret = -1;\n\n    \/* Check validity and table match *\/\n\n#if defined(TARGET_PPC64)\n\n    if (is_64b) {\n\n        ptev = pte64_is_valid(pte0);\n\n        pteh = (pte0 >> 1) & 1;\n\n    } else\n\n#endif\n\n    {\n\n        ptev = pte_is_valid(pte0);\n\n        pteh = (pte0 >> 6) & 1;\n\n    }\n\n    if (ptev && h == pteh) {\n\n        \/* Check vsid & api *\/\n\n#if defined(TARGET_PPC64)\n\n        if (is_64b) {\n\n            ptem = pte0 & PTE64_PTEM_MASK;\n\n            mmask = PTE64_CHECK_MASK;\n\n        } else\n\n#endif\n\n        {\n\n            ptem = pte0 & PTE_PTEM_MASK;\n\n            mmask = PTE_CHECK_MASK;\n\n        }\n\n        if (ptem == ctx->ptem) {\n\n            if (ctx->raddr != (target_ulong)-1) {\n\n                \/* all matches should have equal RPN, WIMG & PP *\/\n\n                if ((ctx->raddr & mmask) != (pte1 & mmask)) {\n\n                    if (loglevel != 0)\n\n                        fprintf(logfile, \"Bad RPN\/WIMG\/PP\\n\");\n\n                    return -3;\n\n                }\n\n            }\n\n            \/* Compute access rights *\/\n\n            if (ctx->key == 0) {\n\n                access = PAGE_READ;\n\n                if ((pte1 & 0x00000003) != 0x3)\n\n                    access |= PAGE_WRITE;\n\n            } else {\n\n                switch (pte1 & 0x00000003) {\n\n                case 0x0:\n\n                    access = 0;\n\n                    break;\n\n                case 0x1:\n\n                case 0x3:\n\n                    access = PAGE_READ;\n\n                    break;\n\n                case 0x2:\n\n                    access = PAGE_READ | PAGE_WRITE;\n\n                    break;\n\n                }\n\n            }\n\n            \/* Keep the matching PTE informations *\/\n\n            ctx->raddr = pte1;\n\n            ctx->prot = access;\n\n            if ((rw == 0 && (access & PAGE_READ)) ||\n\n                (rw == 1 && (access & PAGE_WRITE))) {\n\n                \/* Access granted *\/\n\n#if defined (DEBUG_MMU)\n\n                if (loglevel != 0)\n\n                    fprintf(logfile, \"PTE access granted !\\n\");\n\n#endif\n\n                ret = 0;\n\n            } else {\n\n                \/* Access right violation *\/\n\n#if defined (DEBUG_MMU)\n\n                if (loglevel != 0)\n\n                    fprintf(logfile, \"PTE access rejected\\n\");\n\n#endif\n\n                ret = -2;\n\n            }\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"fd859081453f94c3cbd6527289e41b7fddbf645f","target":0,"func":"static void tpm_tis_receive_cb(TPMState *s, uint8_t locty)\n\n{\n\n    TPMTISEmuState *tis = &s->s.tis;\n\n\n\n    assert(s->locty_number == locty);\n\n\n\n    qemu_bh_schedule(tis->bh);\n\n}\n"},{"project":"qemu","commit_id":"7e09797c299712cafa7bc05dd57c1b13afcc6039","target":1,"func":"static void pmsav5_data_ap_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                                 uint64_t value)\n\n{\n\n    env->cp15.c5_data = extended_mpu_ap_bits(value);\n\n}\n"},{"project":"qemu","commit_id":"cf5a13e370afad57f1cfab0a8871ed839f5eda48","target":0,"func":"void fdt_build_clock_node(void *host_fdt, void *guest_fdt,\n\n                         uint32_t host_phandle,\n\n                         uint32_t guest_phandle)\n\n{\n\n    char *node_path = NULL;\n\n    char *nodename;\n\n    const void *r;\n\n    int ret, node_offset, prop_len, path_len = 16;\n\n\n\n    node_offset = fdt_node_offset_by_phandle(host_fdt, host_phandle);\n\n    if (node_offset <= 0) {\n\n        error_setg(&error_fatal,\n\n                   \"not able to locate clock handle %d in host device tree\",\n\n                   host_phandle);\n\n    }\n\n    node_path = g_malloc(path_len);\n\n    while ((ret = fdt_get_path(host_fdt, node_offset, node_path, path_len))\n\n            == -FDT_ERR_NOSPACE) {\n\n        path_len += 16;\n\n        node_path = g_realloc(node_path, path_len);\n\n    }\n\n    if (ret < 0) {\n\n        error_setg(&error_fatal,\n\n                   \"not able to retrieve node path for clock handle %d\",\n\n                   host_phandle);\n\n    }\n\n\n\n    r = qemu_fdt_getprop(host_fdt, node_path, \"compatible\", &prop_len,\n\n                         &error_fatal);\n\n    if (strcmp(r, \"fixed-clock\")) {\n\n        error_setg(&error_fatal,\n\n                   \"clock handle %d is not a fixed clock\", host_phandle);\n\n    }\n\n\n\n    nodename = strrchr(node_path, '\/');\n\n    qemu_fdt_add_subnode(guest_fdt, nodename);\n\n\n\n    copy_properties_from_host(clock_copied_properties,\n\n                              ARRAY_SIZE(clock_copied_properties),\n\n                              host_fdt, guest_fdt,\n\n                              node_path, nodename);\n\n\n\n    qemu_fdt_setprop_cell(guest_fdt, nodename, \"phandle\", guest_phandle);\n\n\n\n    g_free(node_path);\n\n}\n"},{"project":"qemu","commit_id":"3f2cbf0d1a1340bed4a63e05b044c46df93f4768","target":1,"func":"target_phys_addr_t cpu_get_phys_page_debug(CPUState *env, target_ulong addr)\n\n{\n\n    target_ulong pde_addr, pte_addr;\n\n    uint64_t pte;\n\n    target_phys_addr_t paddr;\n\n    uint32_t page_offset;\n\n    int page_size;\n\n\n\n    if (env->cr[4] & CR4_PAE_MASK) {\n\n        target_ulong pdpe_addr;\n\n        uint64_t pde, pdpe;\n\n\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_LMA_MASK) {\n\n            uint64_t pml4e_addr, pml4e;\n\n            int32_t sext;\n\n\n\n            \/* test virtual address sign extension *\/\n\n            sext = (int64_t)addr >> 47;\n\n            if (sext != 0 && sext != -1)\n\n                return -1;\n\n\n\n            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pml4e = ldq_phys(pml4e_addr);\n\n            if (!(pml4e & PG_PRESENT_MASK))\n\n                return -1;\n\n\n\n            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        } else\n\n#endif\n\n        {\n\n            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        }\n\n\n\n        pde_addr = ((pdpe & ~0xfff) + (((addr >> 21) & 0x1ff) << 3)) &\n\n            env->a20_mask;\n\n        pde = ldq_phys(pde_addr);\n\n        if (!(pde & PG_PRESENT_MASK)) {\n\n            return -1;\n\n        }\n\n        if (pde & PG_PSE_MASK) {\n\n            \/* 2 MB page *\/\n\n            page_size = 2048 * 1024;\n\n            pte = pde & ~( (page_size - 1) & ~0xfff); \/* align to page_size *\/\n\n        } else {\n\n            \/* 4 KB page *\/\n\n            pte_addr = ((pde & ~0xfff) + (((addr >> 12) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            page_size = 4096;\n\n            pte = ldq_phys(pte_addr);\n\n        }\n\n        if (!(pte & PG_PRESENT_MASK))\n\n            return -1;\n\n    } else {\n\n        uint32_t pde;\n\n\n\n        if (!(env->cr[0] & CR0_PG_MASK)) {\n\n            pte = addr;\n\n            page_size = 4096;\n\n        } else {\n\n            \/* page directory entry *\/\n\n            pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) & env->a20_mask;\n\n            pde = ldl_phys(pde_addr);\n\n            if (!(pde & PG_PRESENT_MASK))\n\n                return -1;\n\n            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n                pte = pde & ~0x003ff000; \/* align to 4MB *\/\n\n                page_size = 4096 * 1024;\n\n            } else {\n\n                \/* page directory entry *\/\n\n                pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & env->a20_mask;\n\n                pte = ldl_phys(pte_addr);\n\n                if (!(pte & PG_PRESENT_MASK))\n\n                    return -1;\n\n                page_size = 4096;\n\n            }\n\n        }\n\n        pte = pte & env->a20_mask;\n\n    }\n\n\n\n    page_offset = (addr & TARGET_PAGE_MASK) & (page_size - 1);\n\n    paddr = (pte & TARGET_PAGE_MASK) + page_offset;\n\n    return paddr;\n\n}\n"},{"project":"qemu","commit_id":"2d3735d3bf61d5c8e154a197a11535cc65044334","target":0,"func":"void do_commit(Monitor *mon, const QDict *qdict)\n\n{\n\n    const char *device = qdict_get_str(qdict, \"device\");\n\n    BlockDriverState *bs;\n\n\n\n    if (!strcmp(device, \"all\")) {\n\n        bdrv_commit_all();\n\n    } else {\n\n        bs = bdrv_find(device);\n\n        if (!bs) {\n\n            qerror_report(QERR_DEVICE_NOT_FOUND, device);\n\n            return;\n\n        }\n\n        bdrv_commit(bs);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"4828b10bda6a74a22a7695303e0648157d0e3ea4","target":0,"func":"void acpi_memory_plug_cb(ACPIREGS *ar, qemu_irq irq, MemHotplugState *mem_st,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    mdev->dimm = dev;\n\n    mdev->is_enabled = true;\n\n    mdev->is_inserting = true;\n\n\n\n    \/* do ACPI magic *\/\n\n    acpi_send_gpe_event(ar, irq, ACPI_MEMORY_HOTPLUG_STATUS);\n\n    return;\n\n}\n"},{"project":"qemu","commit_id":"7d1b0095bff7157e856d1d0e6c4295641ced2752","target":1,"func":"static inline void gen_neon_widen(TCGv_i64 dest, TCGv src, int size, int u)\n\n{\n\n    if (u) {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_u8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_u16(dest, src); break;\n\n        case 2: tcg_gen_extu_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    } else {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_s8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_s16(dest, src); break;\n\n        case 2: tcg_gen_ext_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    }\n\n    dead_tmp(src);\n\n}\n"},{"project":"qemu","commit_id":"72cf2d4f0e181d0d3a3122e04129c58a95da713e","target":0,"func":"void qemu_purge_queued_packets(VLANClientState *vc)\n\n{\n\n    VLANPacket *packet, *next;\n\n\n\n    TAILQ_FOREACH_SAFE(packet, &vc->vlan->send_queue, entry, next) {\n\n        if (packet->sender == vc) {\n\n            TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);\n\n            qemu_free(packet);\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"9bada8971173345ceb37ed1a47b00a01a4dd48cf","target":0,"func":"static JSONTokenType token_get_type(QObject *obj)\n\n{\n\n    return qdict_get_int(qobject_to_qdict(obj), \"type\");\n\n}\n"},{"project":"qemu","commit_id":"a89f364ae8740dfc31b321eed9ee454e996dc3c1","target":0,"func":"static void omap_prcm_apll_update(struct omap_prcm_s *s)\n\n{\n\n    int mode[2];\n\n\n\n    mode[0] = (s->clken[9] >> 6) & 3;\n\n    s->apll_lock[0] = (mode[0] == 3);\n\n    mode[1] = (s->clken[9] >> 2) & 3;\n\n    s->apll_lock[1] = (mode[1] == 3);\n\n    \/* TODO: update clocks *\/\n\n\n\n    if (mode[0] == 1 || mode[0] == 2 || mode[1] == 1 || mode[1] == 2)\n\n        fprintf(stderr, \"%s: bad EN_54M_PLL or bad EN_96M_PLL\\n\",\n\n                        __FUNCTION__);\n\n}\n"},{"project":"qemu","commit_id":"61007b316cd71ee7333ff7a0a749a8949527575f","target":0,"func":"int bdrv_pwrite_sync(BlockDriverState *bs, int64_t offset,\n\n    const void *buf, int count)\n\n{\n\n    int ret;\n\n\n\n    ret = bdrv_pwrite(bs, offset, buf, count);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* No flush needed for cache modes that already do it *\/\n\n    if (bs->enable_write_cache) {\n\n        bdrv_flush(bs);\n\n    }\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static uint64_t omap_prcm_read(void *opaque, target_phys_addr_t addr,\n\n                               unsigned size)\n\n{\n\n    struct omap_prcm_s *s = (struct omap_prcm_s *) opaque;\n\n    uint32_t ret;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_read32(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x000:\t\/* PRCM_REVISION *\/\n\n        return 0x10;\n\n\n\n    case 0x010:\t\/* PRCM_SYSCONFIG *\/\n\n        return s->sysconfig;\n\n\n\n    case 0x018:\t\/* PRCM_IRQSTATUS_MPU *\/\n\n        return s->irqst[0];\n\n\n\n    case 0x01c:\t\/* PRCM_IRQENABLE_MPU *\/\n\n        return s->irqen[0];\n\n\n\n    case 0x050:\t\/* PRCM_VOLTCTRL *\/\n\n        return s->voltctrl;\n\n    case 0x054:\t\/* PRCM_VOLTST *\/\n\n        return s->voltctrl & 3;\n\n\n\n    case 0x060:\t\/* PRCM_CLKSRC_CTRL *\/\n\n        return s->clksrc[0];\n\n    case 0x070:\t\/* PRCM_CLKOUT_CTRL *\/\n\n        return s->clkout[0];\n\n    case 0x078:\t\/* PRCM_CLKEMUL_CTRL *\/\n\n        return s->clkemul[0];\n\n    case 0x080:\t\/* PRCM_CLKCFG_CTRL *\/\n\n    case 0x084:\t\/* PRCM_CLKCFG_STATUS *\/\n\n        return 0;\n\n\n\n    case 0x090:\t\/* PRCM_VOLTSETUP *\/\n\n        return s->setuptime[0];\n\n\n\n    case 0x094:\t\/* PRCM_CLKSSETUP *\/\n\n        return s->setuptime[1];\n\n\n\n    case 0x098:\t\/* PRCM_POLCTRL *\/\n\n        return s->clkpol[0];\n\n\n\n    case 0x0b0:\t\/* GENERAL_PURPOSE1 *\/\n\n    case 0x0b4:\t\/* GENERAL_PURPOSE2 *\/\n\n    case 0x0b8:\t\/* GENERAL_PURPOSE3 *\/\n\n    case 0x0bc:\t\/* GENERAL_PURPOSE4 *\/\n\n    case 0x0c0:\t\/* GENERAL_PURPOSE5 *\/\n\n    case 0x0c4:\t\/* GENERAL_PURPOSE6 *\/\n\n    case 0x0c8:\t\/* GENERAL_PURPOSE7 *\/\n\n    case 0x0cc:\t\/* GENERAL_PURPOSE8 *\/\n\n    case 0x0d0:\t\/* GENERAL_PURPOSE9 *\/\n\n    case 0x0d4:\t\/* GENERAL_PURPOSE10 *\/\n\n    case 0x0d8:\t\/* GENERAL_PURPOSE11 *\/\n\n    case 0x0dc:\t\/* GENERAL_PURPOSE12 *\/\n\n    case 0x0e0:\t\/* GENERAL_PURPOSE13 *\/\n\n    case 0x0e4:\t\/* GENERAL_PURPOSE14 *\/\n\n    case 0x0e8:\t\/* GENERAL_PURPOSE15 *\/\n\n    case 0x0ec:\t\/* GENERAL_PURPOSE16 *\/\n\n    case 0x0f0:\t\/* GENERAL_PURPOSE17 *\/\n\n    case 0x0f4:\t\/* GENERAL_PURPOSE18 *\/\n\n    case 0x0f8:\t\/* GENERAL_PURPOSE19 *\/\n\n    case 0x0fc:\t\/* GENERAL_PURPOSE20 *\/\n\n        return s->scratch[(addr - 0xb0) >> 2];\n\n\n\n    case 0x140:\t\/* CM_CLKSEL_MPU *\/\n\n        return s->clksel[0];\n\n    case 0x148:\t\/* CM_CLKSTCTRL_MPU *\/\n\n        return s->clkctrl[0];\n\n\n\n    case 0x158:\t\/* RM_RSTST_MPU *\/\n\n        return s->rst[0];\n\n    case 0x1c8:\t\/* PM_WKDEP_MPU *\/\n\n        return s->wkup[0];\n\n    case 0x1d4:\t\/* PM_EVGENCTRL_MPU *\/\n\n        return s->ev;\n\n    case 0x1d8:\t\/* PM_EVEGENONTIM_MPU *\/\n\n        return s->evtime[0];\n\n    case 0x1dc:\t\/* PM_EVEGENOFFTIM_MPU *\/\n\n        return s->evtime[1];\n\n    case 0x1e0:\t\/* PM_PWSTCTRL_MPU *\/\n\n        return s->power[0];\n\n    case 0x1e4:\t\/* PM_PWSTST_MPU *\/\n\n        return 0;\n\n\n\n    case 0x200:\t\/* CM_FCLKEN1_CORE *\/\n\n        return s->clken[0];\n\n    case 0x204:\t\/* CM_FCLKEN2_CORE *\/\n\n        return s->clken[1];\n\n    case 0x210:\t\/* CM_ICLKEN1_CORE *\/\n\n        return s->clken[2];\n\n    case 0x214:\t\/* CM_ICLKEN2_CORE *\/\n\n        return s->clken[3];\n\n    case 0x21c:\t\/* CM_ICLKEN4_CORE *\/\n\n        return s->clken[4];\n\n\n\n    case 0x220:\t\/* CM_IDLEST1_CORE *\/\n\n        \/* TODO: check the actual iclk status *\/\n\n        return 0x7ffffff9;\n\n    case 0x224:\t\/* CM_IDLEST2_CORE *\/\n\n        \/* TODO: check the actual iclk status *\/\n\n        return 0x00000007;\n\n    case 0x22c:\t\/* CM_IDLEST4_CORE *\/\n\n        \/* TODO: check the actual iclk status *\/\n\n        return 0x0000001f;\n\n\n\n    case 0x230:\t\/* CM_AUTOIDLE1_CORE *\/\n\n        return s->clkidle[0];\n\n    case 0x234:\t\/* CM_AUTOIDLE2_CORE *\/\n\n        return s->clkidle[1];\n\n    case 0x238:\t\/* CM_AUTOIDLE3_CORE *\/\n\n        return s->clkidle[2];\n\n    case 0x23c:\t\/* CM_AUTOIDLE4_CORE *\/\n\n        return s->clkidle[3];\n\n\n\n    case 0x240:\t\/* CM_CLKSEL1_CORE *\/\n\n        return s->clksel[1];\n\n    case 0x244:\t\/* CM_CLKSEL2_CORE *\/\n\n        return s->clksel[2];\n\n\n\n    case 0x248:\t\/* CM_CLKSTCTRL_CORE *\/\n\n        return s->clkctrl[1];\n\n\n\n    case 0x2a0:\t\/* PM_WKEN1_CORE *\/\n\n        return s->wken[0];\n\n    case 0x2a4:\t\/* PM_WKEN2_CORE *\/\n\n        return s->wken[1];\n\n\n\n    case 0x2b0:\t\/* PM_WKST1_CORE *\/\n\n        return s->wkst[0];\n\n    case 0x2b4:\t\/* PM_WKST2_CORE *\/\n\n        return s->wkst[1];\n\n    case 0x2c8:\t\/* PM_WKDEP_CORE *\/\n\n        return 0x1e;\n\n\n\n    case 0x2e0:\t\/* PM_PWSTCTRL_CORE *\/\n\n        return s->power[1];\n\n    case 0x2e4:\t\/* PM_PWSTST_CORE *\/\n\n        return 0x000030 | (s->power[1] & 0xfc00);\n\n\n\n    case 0x300:\t\/* CM_FCLKEN_GFX *\/\n\n        return s->clken[5];\n\n    case 0x310:\t\/* CM_ICLKEN_GFX *\/\n\n        return s->clken[6];\n\n    case 0x320:\t\/* CM_IDLEST_GFX *\/\n\n        \/* TODO: check the actual iclk status *\/\n\n        return 0x00000001;\n\n    case 0x340:\t\/* CM_CLKSEL_GFX *\/\n\n        return s->clksel[3];\n\n    case 0x348:\t\/* CM_CLKSTCTRL_GFX *\/\n\n        return s->clkctrl[2];\n\n    case 0x350:\t\/* RM_RSTCTRL_GFX *\/\n\n        return s->rstctrl[0];\n\n    case 0x358:\t\/* RM_RSTST_GFX *\/\n\n        return s->rst[1];\n\n    case 0x3c8:\t\/* PM_WKDEP_GFX *\/\n\n        return s->wkup[1];\n\n\n\n    case 0x3e0:\t\/* PM_PWSTCTRL_GFX *\/\n\n        return s->power[2];\n\n    case 0x3e4:\t\/* PM_PWSTST_GFX *\/\n\n        return s->power[2] & 3;\n\n\n\n    case 0x400:\t\/* CM_FCLKEN_WKUP *\/\n\n        return s->clken[7];\n\n    case 0x410:\t\/* CM_ICLKEN_WKUP *\/\n\n        return s->clken[8];\n\n    case 0x420:\t\/* CM_IDLEST_WKUP *\/\n\n        \/* TODO: check the actual iclk status *\/\n\n        return 0x0000003f;\n\n    case 0x430:\t\/* CM_AUTOIDLE_WKUP *\/\n\n        return s->clkidle[4];\n\n    case 0x440:\t\/* CM_CLKSEL_WKUP *\/\n\n        return s->clksel[4];\n\n    case 0x450:\t\/* RM_RSTCTRL_WKUP *\/\n\n        return 0;\n\n    case 0x454:\t\/* RM_RSTTIME_WKUP *\/\n\n        return s->rsttime_wkup;\n\n    case 0x458:\t\/* RM_RSTST_WKUP *\/\n\n        return s->rst[2];\n\n    case 0x4a0:\t\/* PM_WKEN_WKUP *\/\n\n        return s->wken[2];\n\n    case 0x4b0:\t\/* PM_WKST_WKUP *\/\n\n        return s->wkst[2];\n\n\n\n    case 0x500:\t\/* CM_CLKEN_PLL *\/\n\n        return s->clken[9];\n\n    case 0x520:\t\/* CM_IDLEST_CKGEN *\/\n\n        ret = 0x0000070 | (s->apll_lock[0] << 9) | (s->apll_lock[1] << 8);\n\n        if (!(s->clksel[6] & 3))\n\n            \/* Core uses 32-kHz clock *\/\n\n            ret |= 3 << 0;\n\n        else if (!s->dpll_lock)\n\n            \/* DPLL not locked, core uses ref_clk *\/\n\n            ret |= 1 << 0;\n\n        else\n\n            \/* Core uses DPLL *\/\n\n            ret |= 2 << 0;\n\n        return ret;\n\n    case 0x530:\t\/* CM_AUTOIDLE_PLL *\/\n\n        return s->clkidle[5];\n\n    case 0x540:\t\/* CM_CLKSEL1_PLL *\/\n\n        return s->clksel[5];\n\n    case 0x544:\t\/* CM_CLKSEL2_PLL *\/\n\n        return s->clksel[6];\n\n\n\n    case 0x800:\t\/* CM_FCLKEN_DSP *\/\n\n        return s->clken[10];\n\n    case 0x810:\t\/* CM_ICLKEN_DSP *\/\n\n        return s->clken[11];\n\n    case 0x820:\t\/* CM_IDLEST_DSP *\/\n\n        \/* TODO: check the actual iclk status *\/\n\n        return 0x00000103;\n\n    case 0x830:\t\/* CM_AUTOIDLE_DSP *\/\n\n        return s->clkidle[6];\n\n    case 0x840:\t\/* CM_CLKSEL_DSP *\/\n\n        return s->clksel[7];\n\n    case 0x848:\t\/* CM_CLKSTCTRL_DSP *\/\n\n        return s->clkctrl[3];\n\n    case 0x850:\t\/* RM_RSTCTRL_DSP *\/\n\n        return 0;\n\n    case 0x858:\t\/* RM_RSTST_DSP *\/\n\n        return s->rst[3];\n\n    case 0x8c8:\t\/* PM_WKDEP_DSP *\/\n\n        return s->wkup[2];\n\n    case 0x8e0:\t\/* PM_PWSTCTRL_DSP *\/\n\n        return s->power[3];\n\n    case 0x8e4:\t\/* PM_PWSTST_DSP *\/\n\n        return 0x008030 | (s->power[3] & 0x3003);\n\n\n\n    case 0x8f0:\t\/* PRCM_IRQSTATUS_DSP *\/\n\n        return s->irqst[1];\n\n    case 0x8f4:\t\/* PRCM_IRQENABLE_DSP *\/\n\n        return s->irqen[1];\n\n\n\n    case 0x8f8:\t\/* PRCM_IRQSTATUS_IVA *\/\n\n        return s->irqst[2];\n\n    case 0x8fc:\t\/* PRCM_IRQENABLE_IVA *\/\n\n        return s->irqen[2];\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b","target":0,"func":"static int vnc_client_io_error(VncState *vs, int ret, int last_errno)\n\n{\n\n    if (ret == 0 || ret == -1) {\n\n        if (ret == -1) {\n\n            switch (last_errno) {\n\n                case EINTR:\n\n                case EAGAIN:\n\n#ifdef _WIN32\n\n                case WSAEWOULDBLOCK:\n\n#endif\n\n                    return 0;\n\n                default:\n\n                    break;\n\n            }\n\n        }\n\n\n\n\tVNC_DEBUG(\"Closing down client sock %d %d\\n\", ret, ret < 0 ? last_errno : 0);\n\n\tqemu_set_fd_handler2(vs->csock, NULL, NULL, NULL, NULL);\n\n\tclosesocket(vs->csock);\n\n        qemu_del_timer(vs->timer);\n\n        qemu_free_timer(vs->timer);\n\n        if (vs->input.buffer) qemu_free(vs->input.buffer);\n\n        if (vs->output.buffer) qemu_free(vs->output.buffer);\n\n#ifdef CONFIG_VNC_TLS\n\n\tif (vs->tls_session) {\n\n\t    gnutls_deinit(vs->tls_session);\n\n\t    vs->tls_session = NULL;\n\n\t}\n\n#endif \/* CONFIG_VNC_TLS *\/\n\n        audio_del(vs);\n\n\n\n        VncState *p, *parent = NULL;\n\n        for (p = vs->vd->clients; p != NULL; p = p->next) {\n\n            if (p == vs) {\n\n                if (parent)\n\n                    parent->next = p->next;\n\n                else\n\n                    vs->vd->clients = p->next;\n\n                break;\n\n            }\n\n            parent = p;\n\n        }\n\n        if (!vs->vd->clients)\n\n            dcl->idle = 1;\n\n\n\n        qemu_free(vs->old_data);\n\n        qemu_free(vs);\n\n  \n\n\treturn 0;\n\n    }\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"7d5e199ade76c53ec316ab6779800581bb47c50a","target":0,"func":"static void qmp_output_complete(Visitor *v, void *opaque)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n\n\n    \/* A visit must have occurred, with each start paired with end.  *\/\n\n    assert(qov->root && QSLIST_EMPTY(&qov->stack));\n\n    assert(opaque == qov->result);\n\n\n\n    qobject_incref(qov->root);\n\n    *qov->result = qov->root;\n\n    qov->result = NULL;\n\n}\n"},{"project":"qemu","commit_id":"abd696e4f74a9d30801c6ae2693efe4e5979c2f2","target":0,"func":"static int zipl_run(struct scsi_blockptr *pte)\n\n{\n\n    struct component_header *header;\n\n    struct component_entry *entry;\n\n    uint8_t tmp_sec[SECTOR_SIZE];\n\n\n\n    virtio_read(pte->blockno, tmp_sec);\n\n    header = (struct component_header *)tmp_sec;\n\n\n\n    if (!zipl_magic(tmp_sec)) {\n\n        goto fail;\n\n    }\n\n\n\n    if (header->type != ZIPL_COMP_HEADER_IPL) {\n\n        goto fail;\n\n    }\n\n\n\n    dputs(\"start loading images\\n\");\n\n\n\n    \/* Load image(s) into RAM *\/\n\n    entry = (struct component_entry *)(&header[1]);\n\n    while (entry->component_type == ZIPL_COMP_ENTRY_LOAD) {\n\n        if (zipl_load_segment(entry) < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        entry++;\n\n\n\n        if ((uint8_t*)(&entry[1]) > (tmp_sec + SECTOR_SIZE)) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (entry->component_type != ZIPL_COMP_ENTRY_EXEC) {\n\n        goto fail;\n\n    }\n\n\n\n    \/* should not return *\/\n\n    jump_to_IPL_code(entry->load_address);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    sclp_print(\"failed running zipl\\n\");\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"a7812ae412311d7d47f8aa85656faadac9d64b56","target":0,"func":"static always_inline void gen_store_mem (DisasContext *ctx,\n\n                                         void (*tcg_gen_qemu_store)(TCGv t0, TCGv t1, int flags),\n\n                                         int ra, int rb, int32_t disp16,\n\n                                         int fp, int clear, int local)\n\n{\n\n    TCGv addr;\n\n    if (local)\n\n        addr = tcg_temp_local_new(TCG_TYPE_I64);\n\n    else\n\n        addr = tcg_temp_new(TCG_TYPE_I64);\n\n    if (rb != 31) {\n\n        tcg_gen_addi_i64(addr, cpu_ir[rb], disp16);\n\n        if (clear)\n\n            tcg_gen_andi_i64(addr, addr, ~0x7);\n\n    } else {\n\n        if (clear)\n\n            disp16 &= ~0x7;\n\n        tcg_gen_movi_i64(addr, disp16);\n\n    }\n\n    if (ra != 31) {\n\n        if (fp)\n\n            tcg_gen_qemu_store(cpu_fir[ra], addr, ctx->mem_idx);\n\n        else\n\n            tcg_gen_qemu_store(cpu_ir[ra], addr, ctx->mem_idx);\n\n    } else {\n\n        TCGv zero;\n\n        if (local)\n\n            zero = tcg_const_local_i64(0);\n\n        else\n\n            zero = tcg_const_i64(0);\n\n        tcg_gen_qemu_store(zero, addr, ctx->mem_idx);\n\n        tcg_temp_free(zero);\n\n    }\n\n    tcg_temp_free(addr);\n\n}\n"},{"project":"qemu","commit_id":"e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f","target":1,"func":"static void aux_bus_map_device(AUXBus *bus, AUXSlave *dev, hwaddr addr)\n\n{\n\n    memory_region_add_subregion(bus->aux_io, addr, dev->mmio);\n\n}\n"},{"project":"qemu","commit_id":"260fecf13b0d30621dc88da03dc1b502b7358c6b","target":0,"func":"BdrvChild *bdrv_open_child(const char *filename,\n\n                           QDict *options, const char *bdref_key,\n\n                           BlockDriverState* parent,\n\n                           const BdrvChildRole *child_role,\n\n                           bool allow_none, Error **errp)\n\n{\n\n    BdrvChild *c = NULL;\n\n    BlockDriverState *bs;\n\n    QDict *image_options;\n\n    int ret;\n\n    char *bdref_key_dot;\n\n    const char *reference;\n\n\n\n    assert(child_role != NULL);\n\n\n\n    bdref_key_dot = g_strdup_printf(\"%s.\", bdref_key);\n\n    qdict_extract_subqdict(options, &image_options, bdref_key_dot);\n\n    g_free(bdref_key_dot);\n\n\n\n    reference = qdict_get_try_str(options, bdref_key);\n\n    if (!filename && !reference && !qdict_size(image_options)) {\n\n        if (!allow_none) {\n\n            error_setg(errp, \"A block device must be specified for \\\"%s\\\"\",\n\n                       bdref_key);\n\n        }\n\n        QDECREF(image_options);\n\n        goto done;\n\n    }\n\n\n\n    bs = NULL;\n\n    ret = bdrv_open_inherit(&bs, filename, reference, image_options, 0,\n\n                            parent, child_role, errp);\n\n    if (ret < 0) {\n\n        goto done;\n\n    }\n\n\n\n    c = bdrv_attach_child(parent, bs, child_role);\n\n\n\ndone:\n\n    qdict_del(options, bdref_key);\n\n    return c;\n\n}\n"},{"project":"qemu","commit_id":"2bfe11c8fac96db4f94abbe818fbc964a6744130","target":1,"func":"static void cpu_common_realizefn(DeviceState *dev, Error **errp)\n{\n    CPUState *cpu = CPU(dev);\n    if (dev->hotplugged) {\n        cpu_synchronize_post_init(cpu);\n        cpu_resume(cpu);\n    }\n}"},{"project":"qemu","commit_id":"544a3731591f5d53e15f22de00ce5ac758d490b3","target":1,"func":"void hmp_info_cpus(Monitor *mon, const QDict *qdict)\n\n{\n\n    CpuInfoList *cpu_list, *cpu;\n\n\n\n    cpu_list = qmp_query_cpus(NULL);\n\n\n\n    for (cpu = cpu_list; cpu; cpu = cpu->next) {\n\n        int active = ' ';\n\n\n\n        if (cpu->value->CPU == monitor_get_cpu_index()) {\n\n            active = '*';\n\n        }\n\n\n\n        monitor_printf(mon, \"%c CPU #%\" PRId64 \":\", active, cpu->value->CPU);\n\n\n\n        switch (cpu->value->arch) {\n\n        case CPU_INFO_ARCH_X86:\n\n            monitor_printf(mon, \" pc=0x%016\" PRIx64, cpu->value->u.x86->pc);\n\n            break;\n\n        case CPU_INFO_ARCH_PPC:\n\n            monitor_printf(mon, \" nip=0x%016\" PRIx64, cpu->value->u.ppc->nip);\n\n            break;\n\n        case CPU_INFO_ARCH_SPARC:\n\n            monitor_printf(mon, \" pc=0x%016\" PRIx64,\n\n                           cpu->value->u.q_sparc->pc);\n\n            monitor_printf(mon, \" npc=0x%016\" PRIx64,\n\n                           cpu->value->u.q_sparc->npc);\n\n            break;\n\n        case CPU_INFO_ARCH_MIPS:\n\n            monitor_printf(mon, \" PC=0x%016\" PRIx64, cpu->value->u.q_mips->PC);\n\n            break;\n\n        case CPU_INFO_ARCH_TRICORE:\n\n            monitor_printf(mon, \" PC=0x%016\" PRIx64, cpu->value->u.tricore->PC);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        if (cpu->value->halted) {\n\n            monitor_printf(mon, \" (halted)\");\n\n        }\n\n\n\n        monitor_printf(mon, \" thread_id=%\" PRId64 \"\\n\", cpu->value->thread_id);\n\n    }\n\n\n\n    qapi_free_CpuInfoList(cpu_list);\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void gt64120_isd_mapping(GT64120State *s)\n\n{\n\n    target_phys_addr_t start = s->regs[GT_ISD] << 21;\n\n    target_phys_addr_t length = 0x1000;\n\n\n\n    if (s->ISD_length) {\n\n        memory_region_del_subregion(get_system_memory(), &s->ISD_mem);\n\n    }\n\n    check_reserved_space(&start, &length);\n\n    length = 0x1000;\n\n    \/* Map new address *\/\n\n    DPRINTF(\"ISD: \"TARGET_FMT_plx\"@\"TARGET_FMT_plx\n\n        \" -> \"TARGET_FMT_plx\"@\"TARGET_FMT_plx\"\\n\",\n\n        s->ISD_length, s->ISD_start, length, start);\n\n    s->ISD_start = start;\n\n    s->ISD_length = length;\n\n    memory_region_add_subregion(get_system_memory(), s->ISD_start, &s->ISD_mem);\n\n}\n"},{"project":"qemu","commit_id":"079d0b7f1eedcc634c371fe05b617fdc55c8b762","target":0,"func":"static int do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n    int ret = 0;\n\n\n\n    assert(p->devep == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            ret = usb_device_handle_control(s, p, request, value, index,\n\n                                            s->setup_len, s->data_buf);\n\n            if (ret == USB_RET_ASYNC) {\n\n                return USB_RET_ASYNC;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            if (ret > 0)\n\n                return 0;\n\n            return ret;\n\n        }\n\n\n\n        \/* return 0 byte *\/\n\n        return 0;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len)\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            return len;\n\n        }\n\n\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        return USB_RET_STALL;\n\n\n\n    default:\n\n        return USB_RET_STALL;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"0c53d7342b4e8412f3b81eed67f053304813dc5d","target":1,"func":"static void gen_ove_ov(DisasContext *dc, TCGv ov)\n\n{\n\n    gen_helper_ove(cpu_env, ov);\n\n}\n"},{"project":"qemu","commit_id":"e8e880a72e63d0587f03aa670be3de683b881ca8","target":1,"func":"void slirp_input(const uint8_t *pkt, int pkt_len)\n\n{\n\n    struct mbuf *m;\n\n    int proto;\n\n\n\n    if (pkt_len < ETH_HLEN)\n\n        return;\n\n\n\n    proto = ntohs(*(uint16_t *)(pkt + 12));\n\n    switch(proto) {\n\n    case ETH_P_ARP:\n\n        arp_input(pkt, pkt_len);\n\n        break;\n\n    case ETH_P_IP:\n\n        m = m_get();\n\n        if (!m)\n\n            return;\n\n        \/* Note: we add to align the IP header *\/\n\n\n\n\n        m->m_len = pkt_len + 2;\n\n        memcpy(m->m_data + 2, pkt, pkt_len);\n\n\n\n        m->m_data += 2 + ETH_HLEN;\n\n        m->m_len -= 2 + ETH_HLEN;\n\n\n\n        ip_input(m);\n\n        break;\n\n    default:\n\n        break;\n\n"},{"project":"qemu","commit_id":"b4ba67d9a702507793c2724e56f98e9b0f7be02b","target":1,"func":"static uint16_t qvirtio_pci_get_queue_size(QVirtioDevice *d)\n\n{\n\n    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;\n\n    return qpci_io_readw(dev->pdev, dev->addr + VIRTIO_PCI_QUEUE_NUM);\n\n}\n"},{"project":"qemu","commit_id":"f090c9d4ad5812fb92843d6470a1111c15190c4c","target":0,"func":"INLINE flag extractFloat32Sign( float32 a )\n\n{\n\n\n\n    return a>>31;\n\n\n\n}\n"},{"project":"qemu","commit_id":"2362a28ea11c145e1a13ae79342d76dc118a72a6","target":1,"func":"static void *iothread_run(void *opaque)\n\n{\n\n    IOThread *iothread = opaque;\n\n\n\n    rcu_register_thread();\n\n\n\n    my_iothread = iothread;\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    iothread->thread_id = qemu_get_thread_id();\n\n    qemu_cond_signal(&iothread->init_done_cond);\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n\n\n    while (!atomic_read(&iothread->stopping)) {\n\n        aio_poll(iothread->ctx, true);\n\n\n\n        if (atomic_read(&iothread->worker_context)) {\n\n            GMainLoop *loop;\n\n\n\n            g_main_context_push_thread_default(iothread->worker_context);\n\n            iothread->main_loop =\n\n                g_main_loop_new(iothread->worker_context, TRUE);\n\n            loop = iothread->main_loop;\n\n\n\n            g_main_loop_run(iothread->main_loop);\n\n            iothread->main_loop = NULL;\n\n            g_main_loop_unref(loop);\n\n\n\n            g_main_context_pop_thread_default(iothread->worker_context);\n\n        }\n\n    }\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"b6dcbe086c77ec683f5ff0b693593cda1d61f3a1","target":0,"func":"CPUState *ppc405ep_init (target_phys_addr_t ram_bases[2],\n\n                         target_phys_addr_t ram_sizes[2],\n\n                         uint32_t sysclk, qemu_irq **picp,\n\n                         int do_init)\n\n{\n\n    clk_setup_t clk_setup[PPC405EP_CLK_NB], tlb_clk_setup;\n\n    qemu_irq dma_irqs[4], gpt_irqs[5], mal_irqs[4];\n\n    CPUState *env;\n\n    qemu_irq *pic, *irqs;\n\n\n\n    memset(clk_setup, 0, sizeof(clk_setup));\n\n    \/* init CPUs *\/\n\n    env = ppc4xx_init(\"405ep\", &clk_setup[PPC405EP_CPU_CLK],\n\n                      &tlb_clk_setup, sysclk);\n\n    clk_setup[PPC405EP_CPU_CLK].cb = tlb_clk_setup.cb;\n\n    clk_setup[PPC405EP_CPU_CLK].opaque = tlb_clk_setup.opaque;\n\n    \/* Internal devices init *\/\n\n    \/* Memory mapped devices registers *\/\n\n    \/* PLB arbitrer *\/\n\n    ppc4xx_plb_init(env);\n\n    \/* PLB to OPB bridge *\/\n\n    ppc4xx_pob_init(env);\n\n    \/* OBP arbitrer *\/\n\n    ppc4xx_opba_init(0xef600600);\n\n    \/* Universal interrupt controller *\/\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] =\n\n        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] =\n\n        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n    *picp = pic;\n\n    \/* SDRAM controller *\/\n\n\t\/* XXX 405EP has no ECC interrupt *\/\n\n    ppc4xx_sdram_init(env, pic[17], 2, ram_bases, ram_sizes, do_init);\n\n    \/* External bus controller *\/\n\n    ppc405_ebc_init(env);\n\n    \/* DMA controller *\/\n\n    dma_irqs[0] = pic[5];\n\n    dma_irqs[1] = pic[6];\n\n    dma_irqs[2] = pic[7];\n\n    dma_irqs[3] = pic[8];\n\n    ppc405_dma_init(env, dma_irqs);\n\n    \/* IIC controller *\/\n\n    ppc405_i2c_init(0xef600500, pic[2]);\n\n    \/* GPIO *\/\n\n    ppc405_gpio_init(0xef600700);\n\n    \/* Serial ports *\/\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(0xef600300, 0, pic[0], PPC_SERIAL_MM_BAUDBASE,\n\n                       serial_hds[0], 1, 1);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(0xef600400, 0, pic[1], PPC_SERIAL_MM_BAUDBASE,\n\n                       serial_hds[1], 1, 1);\n\n    }\n\n    \/* OCM *\/\n\n    ppc405_ocm_init(env);\n\n    \/* GPT *\/\n\n    gpt_irqs[0] = pic[19];\n\n    gpt_irqs[1] = pic[20];\n\n    gpt_irqs[2] = pic[21];\n\n    gpt_irqs[3] = pic[22];\n\n    gpt_irqs[4] = pic[23];\n\n    ppc4xx_gpt_init(0xef600000, gpt_irqs);\n\n    \/* PCI *\/\n\n    \/* Uses pic[3], pic[16], pic[18] *\/\n\n    \/* MAL *\/\n\n    mal_irqs[0] = pic[11];\n\n    mal_irqs[1] = pic[12];\n\n    mal_irqs[2] = pic[13];\n\n    mal_irqs[3] = pic[14];\n\n    ppc405_mal_init(env, mal_irqs);\n\n    \/* Ethernet *\/\n\n    \/* Uses pic[9], pic[15], pic[17] *\/\n\n    \/* CPU control *\/\n\n    ppc405ep_cpc_init(env, clk_setup, sysclk);\n\n\n\n    return env;\n\n}\n"},{"project":"qemu","commit_id":"6b728b31163bbd0788fe7d537931c4624cd24215","target":1,"func":"static int assign_intx(AssignedDevice *dev, Error **errp)\n\n{\n\n    AssignedIRQType new_type;\n\n    PCIINTxRoute intx_route;\n\n    bool intx_host_msi;\n\n    int r;\n\n    Error *local_err = NULL;\n\n\n\n    \/* Interrupt PIN 0 means don't use INTx *\/\n\n    if (assigned_dev_pci_read_byte(&dev->dev, PCI_INTERRUPT_PIN) == 0) {\n\n        pci_device_set_intx_routing_notifier(&dev->dev, NULL);\n\n        return 0;\n\n    }\n\n\n\n    verify_irqchip_in_kernel(&local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    pci_device_set_intx_routing_notifier(&dev->dev,\n\n                                         assigned_dev_update_irq_routing);\n\n\n\n    intx_route = pci_device_route_intx_to_irq(&dev->dev, dev->intpin);\n\n    assert(intx_route.mode != PCI_INTX_INVERTED);\n\n\n\n    if (!pci_intx_route_changed(&dev->intx_route, &intx_route)) {\n\n        return 0;\n\n    }\n\n\n\n    switch (dev->assigned_irq_type) {\n\n    case ASSIGNED_IRQ_INTX_HOST_INTX:\n\n    case ASSIGNED_IRQ_INTX_HOST_MSI:\n\n        intx_host_msi = dev->assigned_irq_type == ASSIGNED_IRQ_INTX_HOST_MSI;\n\n        r = kvm_device_intx_deassign(kvm_state, dev->dev_id, intx_host_msi);\n\n        break;\n\n    case ASSIGNED_IRQ_MSI:\n\n        r = kvm_device_msi_deassign(kvm_state, dev->dev_id);\n\n        break;\n\n    case ASSIGNED_IRQ_MSIX:\n\n        r = kvm_device_msix_deassign(kvm_state, dev->dev_id);\n\n        break;\n\n    default:\n\n        r = 0;\n\n        break;\n\n    }\n\n    if (r) {\n\n        perror(\"assign_intx: deassignment of previous interrupt failed\");\n\n    }\n\n    dev->assigned_irq_type = ASSIGNED_IRQ_NONE;\n\n\n\n    if (intx_route.mode == PCI_INTX_DISABLED) {\n\n        dev->intx_route = intx_route;\n\n        return 0;\n\n    }\n\n\n\nretry:\n\n    if (dev->features & ASSIGNED_DEVICE_PREFER_MSI_MASK &&\n\n        dev->cap.available & ASSIGNED_DEVICE_CAP_MSI) {\n\n        intx_host_msi = true;\n\n        new_type = ASSIGNED_IRQ_INTX_HOST_MSI;\n\n    } else {\n\n        intx_host_msi = false;\n\n        new_type = ASSIGNED_IRQ_INTX_HOST_INTX;\n\n    }\n\n\n\n    r = kvm_device_intx_assign(kvm_state, dev->dev_id, intx_host_msi,\n\n                               intx_route.irq);\n\n    if (r < 0) {\n\n        if (r == -EIO && !(dev->features & ASSIGNED_DEVICE_PREFER_MSI_MASK) &&\n\n            dev->cap.available & ASSIGNED_DEVICE_CAP_MSI) {\n\n            \/* Retry with host-side MSI. There might be an IRQ conflict and\n\n             * either the kernel or the device doesn't support sharing. *\/\n\n            error_report(\"Host-side INTx sharing not supported, \"\n\n                         \"using MSI instead\");\n\n            error_printf(\"Some devices do not work properly in this mode.\\n\");\n\n            dev->features |= ASSIGNED_DEVICE_PREFER_MSI_MASK;\n\n            goto retry;\n\n        }\n\n        error_setg_errno(errp, -r, \"Failed to assign irq for \\\"%s\\\"\",\n\n                         dev->dev.qdev.id);\n\n        error_append_hint(errp, \"Perhaps you are assigning a device \"\n\n                          \"that shares an IRQ with another device?\\n\");\n\n        return r;\n\n    }\n\n\n\n    dev->intx_route = intx_route;\n\n    dev->assigned_irq_type = new_type;\n\n    return r;\n\n}\n"},{"project":"qemu","commit_id":"7d1b0095bff7157e856d1d0e6c4295641ced2752","target":1,"func":"static void gen_exception_return(DisasContext *s, TCGv pc)\n\n{\n\n    TCGv tmp;\n\n    store_reg(s, 15, pc);\n\n    tmp = load_cpu_field(spsr);\n\n    gen_set_cpsr(tmp, 0xffffffff);\n\n    dead_tmp(tmp);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n"},{"project":"qemu","commit_id":"01ecaf438b1eb46abe23392c8ce5b7628b0c8cf5","target":0,"func":"MSA_ST_DF(DF_BYTE,   b, helper_ret_stb_mmu, oi, GETRA())\n\nMSA_ST_DF(DF_HALF,   h, helper_ret_stw_mmu, oi, GETRA())\n\nMSA_ST_DF(DF_WORD,   w, helper_ret_stl_mmu, oi, GETRA())\n\nMSA_ST_DF(DF_DOUBLE, d, helper_ret_stq_mmu, oi, GETRA())\n\n#else\n\nMSA_ST_DF(DF_BYTE,   b, cpu_stb_data)\n\nMSA_ST_DF(DF_HALF,   h, cpu_stw_data)\n\nMSA_ST_DF(DF_WORD,   w, cpu_stl_data)\n\nMSA_ST_DF(DF_DOUBLE, d, cpu_stq_data)\n\n#endif\n\n\n\nvoid helper_cache(CPUMIPSState *env, target_ulong addr, uint32_t op)\n\n{\n\n#ifndef CONFIG_USER_ONLY\n\n    target_ulong index = addr & 0x1fffffff;\n\n    if (op == 9) {\n\n        \/* Index Store Tag *\/\n\n        memory_region_dispatch_write(env->itc_tag, index, env->CP0_TagLo,\n\n                                     8, MEMTXATTRS_UNSPECIFIED);\n\n    } else if (op == 5) {\n\n        \/* Index Load Tag *\/\n\n        memory_region_dispatch_read(env->itc_tag, index, &env->CP0_TagLo,\n\n                                    8, MEMTXATTRS_UNSPECIFIED);\n\n    }\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void lm32_uclinux_init(QEMUMachineInitArgs *args)\n\n{\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq *cpu_irq, irq[32];\n\n    HWSetup *hw;\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    \/* memory map *\/\n\n    target_phys_addr_t flash_base   = 0x04000000;\n\n    size_t flash_sector_size        = 256 * 1024;\n\n    size_t flash_size               = 32 * 1024 * 1024;\n\n    target_phys_addr_t ram_base     = 0x08000000;\n\n    size_t ram_size                 = 64 * 1024 * 1024;\n\n    target_phys_addr_t uart0_base   = 0x80000000;\n\n    target_phys_addr_t timer0_base  = 0x80002000;\n\n    target_phys_addr_t timer1_base  = 0x80010000;\n\n    target_phys_addr_t timer2_base  = 0x80012000;\n\n    int uart0_irq                   = 0;\n\n    int timer0_irq                  = 1;\n\n    int timer1_irq                  = 20;\n\n    int timer2_irq                  = 21;\n\n    target_phys_addr_t hwsetup_base = 0x0bffe000;\n\n    target_phys_addr_t cmdline_base = 0x0bfff000;\n\n    target_phys_addr_t initrd_base  = 0x08400000;\n\n    size_t initrd_max               = 0x01000000;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = cpu_lm32_init(cpu_model);\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_init_ram(phys_ram, \"lm32_uclinux.sdram\", ram_size);\n\n    vmstate_register_ram_global(phys_ram);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    \/* Spansion S29NS128P *\/\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_uclinux.flash\", flash_size,\n\n                          dinfo ? dinfo->bdrv : NULL, flash_sector_size,\n\n                          flash_size \/ flash_sector_size, 1, 2,\n\n                          0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    \/* create irq lines *\/\n\n    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, env, 1);\n\n    env->pic_state = lm32_pic_init(*cpu_irq);\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    sysbus_create_simple(\"lm32-uart\", uart0_base, irq[uart0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer2_base, irq[timer2_irq]);\n\n\n\n    \/* make sure juart isn't the first chardev *\/\n\n    env->juart_state = lm32_juart_init();\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, ELF_MACHINE, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    \/* generate a rom with the hardware description *\/\n\n    hw = hwsetup_init();\n\n    hwsetup_add_cpu(hw, \"LM32\", 75000000);\n\n    hwsetup_add_flash(hw, \"flash\", flash_base, flash_size);\n\n    hwsetup_add_ddr_sdram(hw, \"ddr_sdram\", ram_base, ram_size);\n\n    hwsetup_add_timer(hw, \"timer0\", timer0_base, timer0_irq);\n\n    hwsetup_add_timer(hw, \"timer1_dev_only\", timer1_base, timer1_irq);\n\n    hwsetup_add_timer(hw, \"timer2_dev_only\", timer2_base, timer2_irq);\n\n    hwsetup_add_uart(hw, \"uart\", uart0_base, uart0_irq);\n\n    hwsetup_add_trailer(hw);\n\n    hwsetup_create_rom(hw, hwsetup_base);\n\n    hwsetup_free(hw);\n\n\n\n    reset_info->hwsetup_base = hwsetup_base;\n\n\n\n    if (kernel_cmdline && strlen(kernel_cmdline)) {\n\n        pstrcpy_targphys(\"cmdline\", cmdline_base, TARGET_PAGE_SIZE,\n\n                kernel_cmdline);\n\n        reset_info->cmdline_base = cmdline_base;\n\n    }\n\n\n\n    if (initrd_filename) {\n\n        size_t initrd_size;\n\n        initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                initrd_max);\n\n        reset_info->initrd_base = initrd_base;\n\n        reset_info->initrd_size = initrd_size;\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n"},{"project":"qemu","commit_id":"02a2cbc872df99205eeafd399f01c210e0b797c4","target":0,"func":"static bool vtd_process_inv_desc(IntelIOMMUState *s)\n\n{\n\n    VTDInvDesc inv_desc;\n\n    uint8_t desc_type;\n\n\n\n    VTD_DPRINTF(INV, \"iq head %\"PRIu16, s->iq_head);\n\n    if (!vtd_get_inv_desc(s->iq, s->iq_head, &inv_desc)) {\n\n        s->iq_last_desc_type = VTD_INV_DESC_NONE;\n\n        return false;\n\n    }\n\n    desc_type = inv_desc.lo & VTD_INV_DESC_TYPE;\n\n    \/* FIXME: should update at first or at last? *\/\n\n    s->iq_last_desc_type = desc_type;\n\n\n\n    switch (desc_type) {\n\n    case VTD_INV_DESC_CC:\n\n        VTD_DPRINTF(INV, \"Context-cache Invalidate Descriptor hi 0x%\"PRIx64\n\n                    \" lo 0x%\"PRIx64, inv_desc.hi, inv_desc.lo);\n\n        if (!vtd_process_context_cache_desc(s, &inv_desc)) {\n\n            return false;\n\n        }\n\n        break;\n\n\n\n    case VTD_INV_DESC_IOTLB:\n\n        VTD_DPRINTF(INV, \"IOTLB Invalidate Descriptor hi 0x%\"PRIx64\n\n                    \" lo 0x%\"PRIx64, inv_desc.hi, inv_desc.lo);\n\n        if (!vtd_process_iotlb_desc(s, &inv_desc)) {\n\n            return false;\n\n        }\n\n        break;\n\n\n\n    case VTD_INV_DESC_WAIT:\n\n        VTD_DPRINTF(INV, \"Invalidation Wait Descriptor hi 0x%\"PRIx64\n\n                    \" lo 0x%\"PRIx64, inv_desc.hi, inv_desc.lo);\n\n        if (!vtd_process_wait_desc(s, &inv_desc)) {\n\n            return false;\n\n        }\n\n        break;\n\n\n\n    case VTD_INV_DESC_IEC:\n\n        VTD_DPRINTF(INV, \"Interrupt Entry Cache Invalidation \"\n\n                    \"not implemented yet\");\n\n        \/*\n\n         * Since currently we do not cache interrupt entries, we can\n\n         * just mark this descriptor as \"good\" and move on.\n\n         *\/\n\n        break;\n\n\n\n    default:\n\n        VTD_DPRINTF(GENERAL, \"error: unkonw Invalidation Descriptor type \"\n\n                    \"hi 0x%\"PRIx64 \" lo 0x%\"PRIx64 \" type %\"PRIu8,\n\n                    inv_desc.hi, inv_desc.lo, desc_type);\n\n        return false;\n\n    }\n\n    s->iq_head++;\n\n    if (s->iq_head == s->iq_size) {\n\n        s->iq_head = 0;\n\n    }\n\n    return true;\n\n}\n"},{"project":"qemu","commit_id":"ddcd55316fb2851e144e719171621ad2816487dc","target":0,"func":"static int pc_boot_set(void *opaque, const char *boot_device)\n\n{\n\n    return set_boot_dev(opaque, boot_device);\n\n}\n"},{"project":"qemu","commit_id":"09aa3bf382243151e77682b2e89f997349b306d8","target":0,"func":"static uint64_t pl061_read(void *opaque, hwaddr offset,\n\n                           unsigned size)\n\n{\n\n    PL061State *s = (PL061State *)opaque;\n\n\n\n    if (offset >= 0xfd0 && offset < 0x1000) {\n\n        return s->id[(offset - 0xfd0) >> 2];\n\n    }\n\n    if (offset < 0x400) {\n\n        return s->data & (offset >> 2);\n\n    }\n\n    switch (offset) {\n\n    case 0x400: \/* Direction *\/\n\n        return s->dir;\n\n    case 0x404: \/* Interrupt sense *\/\n\n        return s->isense;\n\n    case 0x408: \/* Interrupt both edges *\/\n\n        return s->ibe;\n\n    case 0x40c: \/* Interrupt event *\/\n\n        return s->iev;\n\n    case 0x410: \/* Interrupt mask *\/\n\n        return s->im;\n\n    case 0x414: \/* Raw interrupt status *\/\n\n        return s->istate;\n\n    case 0x418: \/* Masked interrupt status *\/\n\n        return s->istate & s->im;\n\n    case 0x420: \/* Alternate function select *\/\n\n        return s->afsel;\n\n    case 0x500: \/* 2mA drive *\/\n\n        return s->dr2r;\n\n    case 0x504: \/* 4mA drive *\/\n\n        return s->dr4r;\n\n    case 0x508: \/* 8mA drive *\/\n\n        return s->dr8r;\n\n    case 0x50c: \/* Open drain *\/\n\n        return s->odr;\n\n    case 0x510: \/* Pull-up *\/\n\n        return s->pur;\n\n    case 0x514: \/* Pull-down *\/\n\n        return s->pdr;\n\n    case 0x518: \/* Slew rate control *\/\n\n        return s->slr;\n\n    case 0x51c: \/* Digital enable *\/\n\n        return s->den;\n\n    case 0x520: \/* Lock *\/\n\n        return s->locked;\n\n    case 0x524: \/* Commit *\/\n\n        return s->cr;\n\n    case 0x528: \/* Analog mode select *\/\n\n        return s->amsel;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pl061_read: Bad offset %x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"14a10fc39923b3af07c8c46d22cb20843bee3a72","target":1,"func":"static void s390_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    S390CPU *cpu = S390_CPU(dev);\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(dev);\n\n\n\n    cpu_reset(CPU(cpu));\n\n\n\n    scc->parent_realize(dev, errp);\n\n}\n"},{"project":"qemu","commit_id":"42a268c241183877192c376d03bd9b6d527407c7","target":0,"func":"static int decode_opc(MoxieCPU *cpu, DisasContext *ctx)\n\n{\n\n    CPUMoxieState *env = &cpu->env;\n\n\n\n    \/* Local cache for the instruction opcode.  *\/\n\n    int opcode;\n\n    \/* Set the default instruction length.  *\/\n\n    int length = 2;\n\n\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n        tcg_gen_debug_insn_start(ctx->pc);\n\n    }\n\n\n\n    \/* Examine the 16-bit opcode.  *\/\n\n    opcode = ctx->opcode;\n\n\n\n    \/* Decode instruction.  *\/\n\n    if (opcode & (1 << 15)) {\n\n        if (opcode & (1 << 14)) {\n\n            \/* This is a Form 3 instruction.  *\/\n\n            int inst = (opcode >> 10 & 0xf);\n\n\n\n#define BRANCH(cond)                                                         \\\n\n    do {                                                                     \\\n\n        int l1 = gen_new_label();                                            \\\n\n        tcg_gen_brcond_i32(cond, cc_a, cc_b, l1);                            \\\n\n        gen_goto_tb(env, ctx, 1, ctx->pc+2);                                 \\\n\n        gen_set_label(l1);                                                   \\\n\n        gen_goto_tb(env, ctx, 0, extract_branch_offset(opcode) + ctx->pc+2); \\\n\n        ctx->bstate = BS_BRANCH;                                             \\\n\n    } while (0)\n\n\n\n            switch (inst) {\n\n            case 0x00: \/* beq *\/\n\n                BRANCH(TCG_COND_EQ);\n\n                break;\n\n            case 0x01: \/* bne *\/\n\n                BRANCH(TCG_COND_NE);\n\n                break;\n\n            case 0x02: \/* blt *\/\n\n                BRANCH(TCG_COND_LT);\n\n                break;\n\n            case 0x03: \/* bgt *\/\n\n                BRANCH(TCG_COND_GT);\n\n                break;\n\n            case 0x04: \/* bltu *\/\n\n                BRANCH(TCG_COND_LTU);\n\n                break;\n\n            case 0x05: \/* bgtu *\/\n\n                BRANCH(TCG_COND_GTU);\n\n                break;\n\n            case 0x06: \/* bge *\/\n\n                BRANCH(TCG_COND_GE);\n\n                break;\n\n            case 0x07: \/* ble *\/\n\n                BRANCH(TCG_COND_LE);\n\n                break;\n\n            case 0x08: \/* bgeu *\/\n\n                BRANCH(TCG_COND_GEU);\n\n                break;\n\n            case 0x09: \/* bleu *\/\n\n                BRANCH(TCG_COND_LEU);\n\n                break;\n\n            default:\n\n                {\n\n                    TCGv temp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                    gen_helper_raise_exception(cpu_env, temp);\n\n                    tcg_temp_free_i32(temp);\n\n                }\n\n                break;\n\n            }\n\n        } else {\n\n            \/* This is a Form 2 instruction.  *\/\n\n            int inst = (opcode >> 12 & 0x3);\n\n            switch (inst) {\n\n            case 0x00: \/* inc *\/\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned int v = (opcode & 0xff);\n\n                    tcg_gen_addi_i32(REG(a), REG(a), v);\n\n                }\n\n                break;\n\n            case 0x01: \/* dec *\/\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned int v = (opcode & 0xff);\n\n                    tcg_gen_subi_i32(REG(a), REG(a), v);\n\n                }\n\n                break;\n\n            case 0x02: \/* gsr *\/\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned v = (opcode & 0xff);\n\n                    tcg_gen_ld_i32(REG(a), cpu_env,\n\n                                   offsetof(CPUMoxieState, sregs[v]));\n\n                }\n\n                break;\n\n            case 0x03: \/* ssr *\/\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned v = (opcode & 0xff);\n\n                    tcg_gen_st_i32(REG(a), cpu_env,\n\n                                   offsetof(CPUMoxieState, sregs[v]));\n\n                }\n\n                break;\n\n            default:\n\n                {\n\n                    TCGv temp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                    gen_helper_raise_exception(cpu_env, temp);\n\n                    tcg_temp_free_i32(temp);\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        \/* This is a Form 1 instruction.  *\/\n\n        int inst = opcode >> 8;\n\n        switch (inst) {\n\n        case 0x00: \/* nop *\/\n\n            break;\n\n        case 0x01: \/* ldi.l (immediate) *\/\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x02: \/* mov (register-to-register) *\/\n\n            {\n\n                int dest  = (opcode >> 4) & 0xf;\n\n                int src = opcode & 0xf;\n\n                tcg_gen_mov_i32(REG(dest), REG(src));\n\n            }\n\n            break;\n\n        case 0x03: \/* jsra *\/\n\n            {\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_movi_i32(t1, ctx->pc + 6);\n\n\n\n                \/* Make space for the static chain and return address.  *\/\n\n                tcg_gen_subi_i32(t2, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n\n\n\n                \/* Push the current frame pointer.  *\/\n\n                tcg_gen_subi_i32(t2, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n\n\n\n                \/* Set the pc and $fp.  *\/\n\n                tcg_gen_mov_i32(REG(0), REG(1));\n\n\n\n                gen_goto_tb(env, ctx, 0, cpu_ldl_code(env, ctx->pc+2));\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                ctx->bstate = BS_BRANCH;\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x04: \/* ret *\/\n\n            {\n\n                TCGv t1 = tcg_temp_new_i32();\n\n\n\n                \/* The new $sp is the old $fp.  *\/\n\n                tcg_gen_mov_i32(REG(1), REG(0));\n\n\n\n                \/* Pop the frame pointer.  *\/\n\n                tcg_gen_qemu_ld32u(REG(0), REG(1), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t1);\n\n\n\n\n\n                \/* Pop the return address and skip over the static chain\n\n                   slot.  *\/\n\n                tcg_gen_qemu_ld32u(cpu_pc, REG(1), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t1);\n\n\n\n                tcg_temp_free_i32(t1);\n\n\n\n                \/* Jump... *\/\n\n                tcg_gen_exit_tb(0);\n\n\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x05: \/* add.l *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_add_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x06: \/* push *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                tcg_gen_subi_i32(t1, REG(a), 4);\n\n                tcg_gen_mov_i32(REG(a), t1);\n\n                tcg_gen_qemu_st32(REG(b), REG(a), ctx->memidx);\n\n                tcg_temp_free_i32(t1);\n\n            }\n\n            break;\n\n        case 0x07: \/* pop *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                TCGv t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_qemu_ld32u(REG(b), REG(a), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(a), 4);\n\n                tcg_gen_mov_i32(REG(a), t1);\n\n                tcg_temp_free_i32(t1);\n\n            }\n\n            break;\n\n        case 0x08: \/* lda.l *\/\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld32u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x09: \/* sta.l *\/\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st32(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0a: \/* ld.l (register indirect) *\/\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld32u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x0b: \/* st.l *\/\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st32(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x0c: \/* ldo.l *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld32u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0d: \/* sto.l *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st32(REG(b), t1, ctx->memidx);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0e: \/* cmp *\/\n\n            {\n\n                int a  = (opcode >> 4) & 0xf;\n\n                int b  = opcode & 0xf;\n\n\n\n                tcg_gen_mov_i32(cc_a, REG(a));\n\n                tcg_gen_mov_i32(cc_b, REG(b));\n\n            }\n\n            break;\n\n        case 0x19: \/* jsr *\/\n\n            {\n\n                int fnreg = (opcode >> 4) & 0xf;\n\n\n\n                \/* Load the stack pointer into T0.  *\/\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_movi_i32(t1, ctx->pc+2);\n\n\n\n                \/* Make space for the static chain and return address.  *\/\n\n                tcg_gen_subi_i32(t2, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n\n\n\n                \/* Push the current frame pointer.  *\/\n\n                tcg_gen_subi_i32(t2, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n\n\n\n                \/* Set the pc and $fp.  *\/\n\n                tcg_gen_mov_i32(REG(0), REG(1));\n\n                tcg_gen_mov_i32(cpu_pc, REG(fnreg));\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x1a: \/* jmpa *\/\n\n            {\n\n                tcg_gen_movi_i32(cpu_pc, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1b: \/* ldi.b (immediate) *\/\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1c: \/* ld.b (register indirect) *\/\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld8u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x1d: \/* lda.b *\/\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld8u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1e: \/* st.b *\/\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st8(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x1f: \/* sta.b *\/\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st8(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x20: \/* ldi.s (immediate) *\/\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x21: \/* ld.s (register indirect) *\/\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld16u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x22: \/* lda.s *\/\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld16u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x23: \/* st.s *\/\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st16(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x24: \/* sta.s *\/\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st16(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x25: \/* jmp *\/\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                tcg_gen_mov_i32(cpu_pc, REG(reg));\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x26: \/* and *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_and_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x27: \/* lshr *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_shr_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x28: \/* ashl *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_shl_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x29: \/* sub.l *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_sub_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2a: \/* neg *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_neg_i32(REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2b: \/* or *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_or_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2c: \/* not *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_not_i32(REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2d: \/* ashr *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_sar_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x2e: \/* xor *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_xor_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2f: \/* mul.l *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_mul_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x30: \/* swi *\/\n\n            {\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(temp, val);\n\n                tcg_gen_st_i32(temp, cpu_env,\n\n                               offsetof(CPUMoxieState, sregs[3]));\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_SWI);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x31: \/* div.l *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                gen_helper_div(REG(a), cpu_env, REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x32: \/* udiv.l *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                gen_helper_udiv(REG(a), cpu_env, REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x33: \/* mod.l *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_rem_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x34: \/* umod.l *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_remu_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x35: \/* brk *\/\n\n            {\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_BREAK);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n            }\n\n            break;\n\n        case 0x36: \/* ldo.b *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld8u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x37: \/* sto.b *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st8(REG(b), t1, ctx->memidx);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x38: \/* ldo.s *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld16u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x39: \/* sto.s *\/\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st16(REG(b), t1, ctx->memidx);\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        default:\n\n            {\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n             }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return length;\n\n}\n"},{"project":"qemu","commit_id":"a89f364ae8740dfc31b321eed9ee454e996dc3c1","target":0,"func":"static uint64_t pxa2xx_cm_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    PXA2xxState *s = (PXA2xxState *) opaque;\n\n\n\n    switch (addr) {\n\n    case CCCR:\n\n    case CKEN:\n\n    case OSCC:\n\n        return s->cm_regs[addr >> 2];\n\n\n\n    case CCSR:\n\n        return s->cm_regs[CCCR >> 2] | (3 << 28);\n\n\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"517ff12c7d000fa1f5b1e989b22fb86a286f9cc2","target":0,"func":"static void virtio_ccw_save_config(DeviceState *d, QEMUFile *f)\n\n{\n\n    VirtioCcwDevice *dev = VIRTIO_CCW_DEVICE(d);\n\n    CcwDevice *ccw_dev = CCW_DEVICE(d);\n\n    SubchDev *s = ccw_dev->sch;\n\n    VirtIODevice *vdev = virtio_ccw_get_vdev(s);\n\n\n\n    subch_device_save(s, f);\n\n    if (dev->indicators != NULL) {\n\n        qemu_put_be32(f, dev->indicators->len);\n\n        qemu_put_be64(f, dev->indicators->addr);\n\n    } else {\n\n        qemu_put_be32(f, 0);\n\n        qemu_put_be64(f, 0UL);\n\n    }\n\n    if (dev->indicators2 != NULL) {\n\n        qemu_put_be32(f, dev->indicators2->len);\n\n        qemu_put_be64(f, dev->indicators2->addr);\n\n    } else {\n\n        qemu_put_be32(f, 0);\n\n        qemu_put_be64(f, 0UL);\n\n    }\n\n    if (dev->summary_indicator != NULL) {\n\n        qemu_put_be32(f, dev->summary_indicator->len);\n\n        qemu_put_be64(f, dev->summary_indicator->addr);\n\n    } else {\n\n        qemu_put_be32(f, 0);\n\n        qemu_put_be64(f, 0UL);\n\n    }\n\n    qemu_put_be16(f, vdev->config_vector);\n\n    qemu_put_be64(f, dev->routes.adapter.ind_offset);\n\n    qemu_put_byte(f, dev->thinint_isc);\n\n    qemu_put_be32(f, dev->revision);\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static int megasas_cache_flush(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    bdrv_drain_all();\n\n    return MFI_STAT_OK;\n\n}\n"},{"project":"qemu","commit_id":"8d06b149271cbd5b19bed5bde8da5ecef40ecbc6","target":1,"func":"static int smc91c111_can_receive(NetClientState *nc)\n\n{\n\n    smc91c111_state *s = qemu_get_nic_opaque(nc);\n\n\n\n    if ((s->rcr & RCR_RXEN) == 0 || (s->rcr & RCR_SOFT_RST))\n\n        return 1;\n\n    if (s->allocated == (1 << NUM_PACKETS) - 1)\n\n        return 0;\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"665f119fbad97c05c2603673ac6b2dcbf0d0e9e1","target":1,"func":"static int assign_intx(AssignedDevice *dev)\n\n{\n\n    AssignedIRQType new_type;\n\n    PCIINTxRoute intx_route;\n\n    bool intx_host_msi;\n\n    int r;\n\n\n\n    \/* Interrupt PIN 0 means don't use INTx *\/\n\n    if (assigned_dev_pci_read_byte(&dev->dev, PCI_INTERRUPT_PIN) == 0) {\n\n        pci_device_set_intx_routing_notifier(&dev->dev, NULL);\n\n        return 0;\n\n    }\n\n\n\n    if (!check_irqchip_in_kernel()) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    pci_device_set_intx_routing_notifier(&dev->dev,\n\n                                         assigned_dev_update_irq_routing);\n\n\n\n    intx_route = pci_device_route_intx_to_irq(&dev->dev, dev->intpin);\n\n    assert(intx_route.mode != PCI_INTX_INVERTED);\n\n\n\n    if (!pci_intx_route_changed(&dev->intx_route, &intx_route)) {\n\n        return 0;\n\n    }\n\n\n\n    switch (dev->assigned_irq_type) {\n\n    case ASSIGNED_IRQ_INTX_HOST_INTX:\n\n    case ASSIGNED_IRQ_INTX_HOST_MSI:\n\n        intx_host_msi = dev->assigned_irq_type == ASSIGNED_IRQ_INTX_HOST_MSI;\n\n        r = kvm_device_intx_deassign(kvm_state, dev->dev_id, intx_host_msi);\n\n        break;\n\n    case ASSIGNED_IRQ_MSI:\n\n        r = kvm_device_msi_deassign(kvm_state, dev->dev_id);\n\n        break;\n\n    case ASSIGNED_IRQ_MSIX:\n\n        r = kvm_device_msix_deassign(kvm_state, dev->dev_id);\n\n        break;\n\n    default:\n\n        r = 0;\n\n        break;\n\n    }\n\n    if (r) {\n\n        perror(\"assign_intx: deassignment of previous interrupt failed\");\n\n    }\n\n    dev->assigned_irq_type = ASSIGNED_IRQ_NONE;\n\n\n\n    if (intx_route.mode == PCI_INTX_DISABLED) {\n\n        dev->intx_route = intx_route;\n\n        return 0;\n\n    }\n\n\n\nretry:\n\n    if (dev->features & ASSIGNED_DEVICE_PREFER_MSI_MASK &&\n\n        dev->cap.available & ASSIGNED_DEVICE_CAP_MSI) {\n\n        intx_host_msi = true;\n\n        new_type = ASSIGNED_IRQ_INTX_HOST_MSI;\n\n    } else {\n\n        intx_host_msi = false;\n\n        new_type = ASSIGNED_IRQ_INTX_HOST_INTX;\n\n    }\n\n\n\n    r = kvm_device_intx_assign(kvm_state, dev->dev_id, intx_host_msi,\n\n                               intx_route.irq);\n\n    if (r < 0) {\n\n        if (r == -EIO && !(dev->features & ASSIGNED_DEVICE_PREFER_MSI_MASK) &&\n\n            dev->cap.available & ASSIGNED_DEVICE_CAP_MSI) {\n\n            \/* Retry with host-side MSI. There might be an IRQ conflict and\n\n             * either the kernel or the device doesn't support sharing. *\/\n\n            error_report(\"Host-side INTx sharing not supported, \"\n\n                         \"using MSI instead\");\n\n            error_printf(\"Some devices do not work properly in this mode.\\n\");\n\n            dev->features |= ASSIGNED_DEVICE_PREFER_MSI_MASK;\n\n            goto retry;\n\n        }\n\n        error_report(\"Failed to assign irq for \\\"%s\\\": %s\",\n\n                     dev->dev.qdev.id, strerror(-r));\n\n        error_report(\"Perhaps you are assigning a device \"\n\n                     \"that shares an IRQ with another device?\");\n\n        return r;\n\n    }\n\n\n\n    dev->intx_route = intx_route;\n\n    dev->assigned_irq_type = new_type;\n\n    return r;\n\n}\n"},{"project":"qemu","commit_id":"b9bec74bcb16519a876ec21cd5277c526a9b512d","target":0,"func":"static int get_para_features(CPUState *env)\n\n{\n\n        int i, features = 0;\n\n\n\n        for (i = 0; i < ARRAY_SIZE(para_features) - 1; i++) {\n\n                if (kvm_check_extension(env->kvm_state, para_features[i].cap))\n\n                        features |= (1 << para_features[i].feature);\n\n        }\n\n\n\n        return features;\n\n}\n"},{"project":"qemu","commit_id":"2119882c7eb7e2c612b24fc0c8d86f5887d6f1c3","target":0,"func":"static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node,\n\n                                                  const char *name,\n\n                                                  BlockDriverState **pbs,\n\n                                                  AioContext **paio,\n\n                                                  Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvDirtyBitmap *bitmap;\n\n    AioContext *aio_context;\n\n\n\n    if (!node) {\n\n        error_setg(errp, \"Node cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    if (!name) {\n\n        error_setg(errp, \"Bitmap name cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    bs = bdrv_lookup_bs(node, node, NULL);\n\n    if (!bs) {\n\n        error_setg(errp, \"Node '%s' not found\", node);\n\n        return NULL;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    bitmap = bdrv_find_dirty_bitmap(bs, name);\n\n    if (!bitmap) {\n\n        error_setg(errp, \"Dirty bitmap '%s' not found\", name);\n\n        goto fail;\n\n    }\n\n\n\n    if (pbs) {\n\n        *pbs = bs;\n\n    }\n\n    if (paio) {\n\n        *paio = aio_context;\n\n    } else {\n\n        aio_context_release(aio_context);\n\n    }\n\n\n\n    return bitmap;\n\n\n\n fail:\n\n    aio_context_release(aio_context);\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"848696bf353750899832c51005f1bd3540da5c29","target":1,"func":"static void i82374_isa_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ISAi82374State *isa = I82374(dev);\n\n    I82374State *s = &isa->state;\n\n    PortioList *port_list = g_new(PortioList, 1);\n\n\n\n    portio_list_init(port_list, OBJECT(isa), i82374_portio_list, s, \"i82374\");\n\n    portio_list_add(port_list, isa_address_space_io(&isa->parent_obj),\n\n                    isa->iobase);\n\n\n\n    i82374_realize(s, errp);\n\n\n\n    qdev_init_gpio_out(dev, &s->out, 1);\n\n}\n"},{"project":"qemu","commit_id":"ffe30937c89dd67a53bf3f35b962701cd9d8f70e","target":1,"func":"static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,\n\n                                    TCGv arg2, int add_ca, int compute_ca,\n\n                                    int compute_ov)\n\n{\n\n    TCGv t0, t1;\n\n\n\n    if ((!compute_ca && !compute_ov) ||\n\n        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = ret;\n\n    } else {\n\n        t0 = tcg_temp_local_new();\n\n    }\n\n\n\n    if (add_ca) {\n\n        t1 = tcg_temp_local_new();\n\n        tcg_gen_mov_tl(t1, cpu_ca);\n\n    } else {\n\n        TCGV_UNUSED(t1);\n\n    }\n\n\n\n    if (compute_ca) {\n\n        \/* Start with XER CA disabled, the most likely case *\/\n\n        tcg_gen_movi_tl(cpu_ca, 0);\n\n    }\n\n    if (compute_ov) {\n\n        \/* Start with XER OV disabled, the most likely case *\/\n\n        tcg_gen_movi_tl(cpu_ov, 0);\n\n    }\n\n\n\n    tcg_gen_add_tl(t0, arg1, arg2);\n\n\n\n    if (compute_ca) {\n\n        gen_op_arith_compute_ca(ctx, t0, arg1, 0);\n\n    }\n\n    if (add_ca) {\n\n        tcg_gen_add_tl(t0, t0, t1);\n\n        gen_op_arith_compute_ca(ctx, t0, t1, 0);\n\n        tcg_temp_free(t1);\n\n    }\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);\n\n    }\n\n\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, t0);\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"12d4536f7d911b6d87a766ad7300482ea663cea2","target":1,"func":"void pause_all_vcpus(void)\n\n{\n\n}\n"},{"project":"qemu","commit_id":"ffbb1705a33df8e2fb12b24d96663d63b22eaf8b","target":0,"func":"static void *spapr_build_fdt(sPAPRMachineState *spapr,\n\n                             hwaddr rtas_addr,\n\n                             hwaddr rtas_size)\n\n{\n\n    MachineState *machine = MACHINE(qdev_get_machine());\n\n    MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);\n\n    int ret;\n\n    void *fdt;\n\n    sPAPRPHBState *phb;\n\n    char *buf;\n\n\n\n    fdt = g_malloc0(FDT_MAX_SIZE);\n\n    _FDT((fdt_create_empty_tree(fdt, FDT_MAX_SIZE)));\n\n\n\n    \/* Root node *\/\n\n    _FDT(fdt_setprop_string(fdt, 0, \"device_type\", \"chrp\"));\n\n    _FDT(fdt_setprop_string(fdt, 0, \"model\", \"IBM pSeries (emulated by qemu)\"));\n\n    _FDT(fdt_setprop_string(fdt, 0, \"compatible\", \"qemu,pseries\"));\n\n\n\n    \/*\n\n     * Add info to guest to indentify which host is it being run on\n\n     * and what is the uuid of the guest\n\n     *\/\n\n    if (kvmppc_get_host_model(&buf)) {\n\n        _FDT(fdt_setprop_string(fdt, 0, \"host-model\", buf));\n\n        g_free(buf);\n\n    }\n\n    if (kvmppc_get_host_serial(&buf)) {\n\n        _FDT(fdt_setprop_string(fdt, 0, \"host-serial\", buf));\n\n        g_free(buf);\n\n    }\n\n\n\n    buf = qemu_uuid_unparse_strdup(&qemu_uuid);\n\n\n\n    _FDT(fdt_setprop_string(fdt, 0, \"vm,uuid\", buf));\n\n    if (qemu_uuid_set) {\n\n        _FDT(fdt_setprop_string(fdt, 0, \"system-id\", buf));\n\n    }\n\n    g_free(buf);\n\n\n\n    if (qemu_get_vm_name()) {\n\n        _FDT(fdt_setprop_string(fdt, 0, \"ibm,partition-name\",\n\n                                qemu_get_vm_name()));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, 0, \"#address-cells\", 2));\n\n    _FDT(fdt_setprop_cell(fdt, 0, \"#size-cells\", 2));\n\n\n\n    \/* \/interrupt controller *\/\n\n    spapr_dt_xics(spapr->xics, fdt, PHANDLE_XICP);\n\n\n\n    ret = spapr_populate_memory(spapr, fdt);\n\n    if (ret < 0) {\n\n        error_report(\"couldn't setup memory nodes in fdt\");\n\n        exit(1);\n\n    }\n\n\n\n    \/* \/vdevice *\/\n\n    spapr_dt_vdevice(spapr->vio_bus, fdt);\n\n\n\n    if (object_resolve_path_type(\"\", TYPE_SPAPR_RNG, NULL)) {\n\n        ret = spapr_rng_populate_dt(fdt);\n\n        if (ret < 0) {\n\n            error_report(\"could not set up rng device in the fdt\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    QLIST_FOREACH(phb, &spapr->phbs, list) {\n\n        ret = spapr_populate_pci_dt(phb, PHANDLE_XICP, fdt);\n\n        if (ret < 0) {\n\n            error_report(\"couldn't setup PCI devices in fdt\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    \/* cpus *\/\n\n    spapr_populate_cpus_dt_node(fdt, spapr);\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        _FDT(spapr_drc_populate_dt(fdt, 0, NULL, SPAPR_DR_CONNECTOR_TYPE_LMB));\n\n    }\n\n\n\n    if (mc->query_hotpluggable_cpus) {\n\n        int offset = fdt_path_offset(fdt, \"\/cpus\");\n\n        ret = spapr_drc_populate_dt(fdt, offset, NULL,\n\n                                    SPAPR_DR_CONNECTOR_TYPE_CPU);\n\n        if (ret < 0) {\n\n            error_report(\"Couldn't set up CPU DR device tree properties\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    \/* \/event-sources *\/\n\n    spapr_dt_events(fdt, spapr->check_exception_irq);\n\n\n\n    \/* \/rtas *\/\n\n    spapr_dt_rtas(spapr, fdt);\n\n\n\n    \/* \/chosen *\/\n\n    spapr_dt_chosen(spapr, fdt);\n\n\n\n    \/* \/hypervisor *\/\n\n    if (kvm_enabled()) {\n\n        spapr_dt_hypervisor(spapr, fdt);\n\n    }\n\n\n\n    \/* Build memory reserve map *\/\n\n    if (spapr->kernel_size) {\n\n        _FDT((fdt_add_mem_rsv(fdt, KERNEL_LOAD_ADDR, spapr->kernel_size)));\n\n    }\n\n    if (spapr->initrd_size) {\n\n        _FDT((fdt_add_mem_rsv(fdt, spapr->initrd_base, spapr->initrd_size)));\n\n    }\n\n\n\n    \/* ibm,client-architecture-support updates *\/\n\n    ret = spapr_dt_cas_updates(spapr, fdt, spapr->ov5_cas);\n\n    if (ret < 0) {\n\n        error_report(\"couldn't setup CAS properties fdt\");\n\n        exit(1);\n\n    }\n\n\n\n    return fdt;\n\n}\n"},{"project":"qemu","commit_id":"3efa9a672e4a5f7b2d35cf457ea277e997a0f8c6","target":1,"func":"static uint32_t get_elf_hwcap(void)\n\n{\n\n    CPUState *e = thread_env;\n\n    uint32_t features = 0;\n\n\n\n    \/* We don't have to be terribly complete here; the high points are\n\n       Altivec\/FP\/SPE support.  Anything else is just a bonus.  *\/\n\n#define GET_FEATURE(flag, feature)              \\\n\n    do {if (e->insns_flags & flag) features |= feature; } while(0)\n\n    GET_FEATURE(PPC_64B, PPC_FEATURE_64);\n\n    GET_FEATURE(PPC_FLOAT, PPC_FEATURE_HAS_FPU);\n\n    GET_FEATURE(PPC_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC);\n\n    GET_FEATURE(PPC_SPE, PPC_FEATURE_HAS_SPE);\n\n    GET_FEATURE(PPC_SPE_SINGLE, PPC_FEATURE_HAS_EFP_SINGLE);\n\n    GET_FEATURE(PPC_SPE_DOUBLE, PPC_FEATURE_HAS_EFP_DOUBLE);\n\n    GET_FEATURE(PPC_BOOKE, PPC_FEATURE_BOOKE);\n\n    GET_FEATURE(PPC_405_MAC, PPC_FEATURE_HAS_4xxMAC);\n\n#undef GET_FEATURE\n\n\n\n    return features;\n\n}\n"},{"project":"qemu","commit_id":"3e305e4a4752f70c0b5c3cf5b43ec957881714f7","target":1,"func":"static gnutls_anon_server_credentials_t vnc_tls_initialize_anon_cred(void)\n\n{\n\n    gnutls_anon_server_credentials_t anon_cred;\n\n    int ret;\n\n\n\n    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {\n\n        VNC_DEBUG(\"Cannot allocate credentials %s\\n\", gnutls_strerror(ret));\n\n        return NULL;\n\n    }\n\n\n\n    gnutls_anon_set_server_dh_params(anon_cred, dh_params);\n\n\n\n    return anon_cred;\n\n}\n"},{"project":"qemu","commit_id":"c99a55d38dd5b5131f3fcbbaf41828a09ee62544","target":1,"func":"static void arm_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    CPUState *cs = CPU(dev);\n\n    ARMCPU *cpu = ARM_CPU(dev);\n\n    ARMCPUClass *acc = ARM_CPU_GET_CLASS(dev);\n\n    CPUARMState *env = &cpu->env;\n\n    int pagebits;\n\n    Error *local_err = NULL;\n\n\n\n    cpu_exec_realizefn(cs, &local_err);\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    \/* Some features automatically imply others: *\/\n\n    if (arm_feature(env, ARM_FEATURE_V8)) {\n\n        set_feature(env, ARM_FEATURE_V7);\n\n        set_feature(env, ARM_FEATURE_ARM_DIV);\n\n        set_feature(env, ARM_FEATURE_LPAE);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V7)) {\n\n        set_feature(env, ARM_FEATURE_VAPA);\n\n        set_feature(env, ARM_FEATURE_THUMB2);\n\n        set_feature(env, ARM_FEATURE_MPIDR);\n\n        if (!arm_feature(env, ARM_FEATURE_M)) {\n\n            set_feature(env, ARM_FEATURE_V6K);\n\n        } else {\n\n            set_feature(env, ARM_FEATURE_V6);\n\n        }\n\n\n\n        \/* Always define VBAR for V7 CPUs even if it doesn't exist in\n\n         * non-EL3 configs. This is needed by some legacy boards.\n\n         *\/\n\n        set_feature(env, ARM_FEATURE_VBAR);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V6K)) {\n\n        set_feature(env, ARM_FEATURE_V6);\n\n        set_feature(env, ARM_FEATURE_MVFR);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V6)) {\n\n        set_feature(env, ARM_FEATURE_V5);\n\n\n        if (!arm_feature(env, ARM_FEATURE_M)) {\n\n            set_feature(env, ARM_FEATURE_AUXCR);\n\n        }\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V5)) {\n\n        set_feature(env, ARM_FEATURE_V4T);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        set_feature(env, ARM_FEATURE_THUMB_DIV);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_ARM_DIV)) {\n\n        set_feature(env, ARM_FEATURE_THUMB_DIV);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_VFP4)) {\n\n        set_feature(env, ARM_FEATURE_VFP3);\n\n        set_feature(env, ARM_FEATURE_VFP_FP16);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_VFP3)) {\n\n        set_feature(env, ARM_FEATURE_VFP);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_LPAE)) {\n\n        set_feature(env, ARM_FEATURE_V7MP);\n\n        set_feature(env, ARM_FEATURE_PXN);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_CBAR_RO)) {\n\n        set_feature(env, ARM_FEATURE_CBAR);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_THUMB2) &&\n\n        !arm_feature(env, ARM_FEATURE_M)) {\n\n        set_feature(env, ARM_FEATURE_THUMB_DSP);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_V7) &&\n\n        !arm_feature(env, ARM_FEATURE_M) &&\n\n        !arm_feature(env, ARM_FEATURE_PMSA)) {\n\n        \/* v7VMSA drops support for the old ARMv5 tiny pages, so we\n\n         * can use 4K pages.\n\n         *\/\n\n        pagebits = 12;\n\n    } else {\n\n        \/* For CPUs which might have tiny 1K pages, or which have an\n\n         * MPU and might have small region sizes, stick with 1K pages.\n\n         *\/\n\n        pagebits = 10;\n\n    }\n\n    if (!set_preferred_target_page_bits(pagebits)) {\n\n        \/* This can only ever happen for hotplugging a CPU, or if\n\n         * the board code incorrectly creates a CPU which it has\n\n         * promised via minimum_page_size that it will not.\n\n         *\/\n\n        error_setg(errp, \"This CPU requires a smaller page size than the \"\n\n                   \"system is using\");\n\n        return;\n\n    }\n\n\n\n    \/* This cpu-id-to-MPIDR affinity is used only for TCG; KVM will override it.\n\n     * We don't support setting cluster ID ([16..23]) (known as Aff2\n\n     * in later ARM ARM versions), or any of the higher affinity level fields,\n\n     * so these bits always RAZ.\n\n     *\/\n\n    if (cpu->mp_affinity == ARM64_AFFINITY_INVALID) {\n\n        cpu->mp_affinity = arm_cpu_mp_affinity(cs->cpu_index,\n\n                                               ARM_DEFAULT_CPUS_PER_CLUSTER);\n\n    }\n\n\n\n    if (cpu->reset_hivecs) {\n\n            cpu->reset_sctlr |= (1 << 13);\n\n    }\n\n\n\n    if (cpu->cfgend) {\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V7)) {\n\n            cpu->reset_sctlr |= SCTLR_EE;\n\n        } else {\n\n            cpu->reset_sctlr |= SCTLR_B;\n\n        }\n\n    }\n\n\n\n    if (!cpu->has_el3) {\n\n        \/* If the has_el3 CPU property is disabled then we need to disable the\n\n         * feature.\n\n         *\/\n\n        unset_feature(env, ARM_FEATURE_EL3);\n\n\n\n        \/* Disable the security extension feature bits in the processor feature\n\n         * registers as well. These are id_pfr1[7:4] and id_aa64pfr0[15:12].\n\n         *\/\n\n        cpu->id_pfr1 &= ~0xf0;\n\n        cpu->id_aa64pfr0 &= ~0xf000;\n\n    }\n\n\n\n    if (!cpu->has_el2) {\n\n        unset_feature(env, ARM_FEATURE_EL2);\n\n    }\n\n\n\n    if (!cpu->has_pmu) {\n\n        unset_feature(env, ARM_FEATURE_PMU);\n\n        cpu->id_aa64dfr0 &= ~0xf00;\n\n    }\n\n\n\n    if (!arm_feature(env, ARM_FEATURE_EL2)) {\n\n        \/* Disable the hypervisor feature bits in the processor feature\n\n         * registers if we don't have EL2. These are id_pfr1[15:12] and\n\n         * id_aa64pfr0_el1[11:8].\n\n         *\/\n\n        cpu->id_aa64pfr0 &= ~0xf00;\n\n        cpu->id_pfr1 &= ~0xf000;\n\n    }\n\n\n\n    \/* MPU can be configured out of a PMSA CPU either by setting has-mpu\n\n     * to false or by setting pmsav7-dregion to 0.\n\n     *\/\n\n    if (!cpu->has_mpu) {\n\n        cpu->pmsav7_dregion = 0;\n\n    }\n\n    if (cpu->pmsav7_dregion == 0) {\n\n        cpu->has_mpu = false;\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_PMSA) &&\n\n        arm_feature(env, ARM_FEATURE_V7)) {\n\n        uint32_t nr = cpu->pmsav7_dregion;\n\n\n\n        if (nr > 0xff) {\n\n            error_setg(errp, \"PMSAv7 MPU #regions invalid %\" PRIu32, nr);\n\n            return;\n\n        }\n\n\n\n        if (nr) {\n\n            if (arm_feature(env, ARM_FEATURE_V8)) {\n\n                \/* PMSAv8 *\/\n\n                env->pmsav8.rbar[M_REG_NS] = g_new0(uint32_t, nr);\n\n                env->pmsav8.rlar[M_REG_NS] = g_new0(uint32_t, nr);\n\n                if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {\n\n                    env->pmsav8.rbar[M_REG_S] = g_new0(uint32_t, nr);\n\n                    env->pmsav8.rlar[M_REG_S] = g_new0(uint32_t, nr);\n\n                }\n\n            } else {\n\n                env->pmsav7.drbar = g_new0(uint32_t, nr);\n\n                env->pmsav7.drsr = g_new0(uint32_t, nr);\n\n                env->pmsav7.dracr = g_new0(uint32_t, nr);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_EL3)) {\n\n        set_feature(env, ARM_FEATURE_VBAR);\n\n    }\n\n\n\n    register_cp_regs_for_features(cpu);\n\n    arm_cpu_register_gdb_regs_for_features(cpu);\n\n\n\n    init_cpreg_list(cpu);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if (cpu->has_el3 || arm_feature(env, ARM_FEATURE_M_SECURITY)) {\n\n        AddressSpace *as;\n\n\n\n        cs->num_ases = 2;\n\n\n\n        if (!cpu->secure_memory) {\n\n            cpu->secure_memory = cs->memory;\n\n        }\n\n        as = address_space_init_shareable(cpu->secure_memory,\n\n                                          \"cpu-secure-memory\");\n\n        cpu_address_space_init(cs, as, ARMASIdx_S);\n\n    } else {\n\n        cs->num_ases = 1;\n\n    }\n\n\n\n    cpu_address_space_init(cs,\n\n                           address_space_init_shareable(cs->memory,\n\n                                                        \"cpu-memory\"),\n\n                           ARMASIdx_NS);\n\n#endif\n\n\n\n    qemu_init_vcpu(cs);\n\n    cpu_reset(cs);\n\n\n\n    acc->parent_realize(dev, errp);\n\n}"},{"project":"qemu","commit_id":"c07a9008ac6985cd5a15909c2b9977d982defc12","target":0,"func":"static BlockDriverAIOCB *bdrv_aio_rw_vector(BlockDriverState *bs,\n\n                                            int64_t sector_num,\n\n                                            QEMUIOVector *iov,\n\n                                            int nb_sectors,\n\n                                            BlockDriverCompletionFunc *cb,\n\n                                            void *opaque,\n\n                                            int is_write)\n\n\n\n{\n\n    VectorTranslationState *s = qemu_mallocz(sizeof(*s));\n\n    BlockDriverAIOCB *aiocb = qemu_aio_get(bs, cb, opaque);\n\n\n\n    s->this_aiocb = aiocb;\n\n    s->iov = iov;\n\n    s->bounce = qemu_memalign(512, nb_sectors * 512);\n\n    s->is_write = is_write;\n\n    if (is_write) {\n\n        qemu_iovec_to_buffer(s->iov, s->bounce);\n\n        s->aiocb = bdrv_aio_write(bs, sector_num, s->bounce, nb_sectors,\n\n                                  bdrv_aio_rw_vector_cb, s);\n\n    } else {\n\n        s->aiocb = bdrv_aio_read(bs, sector_num, s->bounce, nb_sectors,\n\n                                 bdrv_aio_rw_vector_cb, s);\n\n    }\n\n    return aiocb;\n\n}\n"},{"project":"qemu","commit_id":"afff2b15e89ac81c113f2ebfd729aaa02b40edb6","target":1,"func":"QemuConsole *qemu_console_lookup_by_device(DeviceState *dev, uint32_t head)\n\n{\n\n    Error *local_err = NULL;\n\n    Object *obj;\n\n    uint32_t h;\n\n    int i;\n\n\n\n    for (i = 0; i < nb_consoles; i++) {\n\n        if (!consoles[i]) {\n\n            continue;\n\n        }\n\n        obj = object_property_get_link(OBJECT(consoles[i]),\n\n                                       \"device\", &local_err);\n\n        if (DEVICE(obj) != dev) {\n\n            continue;\n\n        }\n\n        h = object_property_get_int(OBJECT(consoles[i]),\n\n                                    \"head\", &local_err);\n\n        if (h != head) {\n\n            continue;\n\n        }\n\n        return consoles[i];\n\n    }\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"0479097859372a760843ad1b9c6ed3705c6423ca","target":1,"func":"static void pc_dimm_plug(HotplugHandler *hotplug_dev,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    HotplugHandlerClass *hhc;\n\n    Error *local_err = NULL;\n\n    PCMachineState *pcms = PC_MACHINE(hotplug_dev);\n\n    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);\n\n    MemoryRegion *mr = ddc->get_memory_region(dimm);\n\n    uint64_t align = TARGET_PAGE_SIZE;\n\n    bool is_nvdimm = object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM);\n\n\n\n    if (memory_region_get_alignment(mr) && pcmc->enforce_aligned_dimm) {\n\n        align = memory_region_get_alignment(mr);\n\n    }\n\n\n\n    if (!pcms->acpi_dev) {\n\n        error_setg(&local_err,\n\n                   \"memory hotplug is not enabled: missing acpi device\");\n\n        goto out;\n\n    }\n\n\n\n    if (is_nvdimm && !pcms->acpi_nvdimm_state.is_enabled) {\n\n        error_setg(&local_err,\n\n                   \"nvdimm is not enabled: missing 'nvdimm' in '-M'\");\n\n        goto out;\n\n    }\n\n\n\n    pc_dimm_memory_plug(dev, &pcms->hotplug_memory, mr, align, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    if (is_nvdimm) {\n\n        nvdimm_plug(&pcms->acpi_nvdimm_state);\n\n    }\n\n\n\n    hhc = HOTPLUG_HANDLER_GET_CLASS(pcms->acpi_dev);\n\n    hhc->plug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, &error_abort);\n\nout:\n\n    error_propagate(errp, local_err);\n\n}\n"},{"project":"qemu","commit_id":"4fc9af53d88c0a2a810704a06cb39a7182982e4e","target":0,"func":"static void load_linux(const char *kernel_filename,\n\n\t\t       const char *initrd_filename,\n\n\t\t       const char *kernel_cmdline)\n\n{\n\n    uint16_t protocol;\n\n    uint32_t gpr[8];\n\n    uint16_t seg[6];\n\n    uint16_t real_seg;\n\n    int setup_size, kernel_size, initrd_size, cmdline_size;\n\n    uint32_t initrd_max;\n\n    uint8_t header[1024];\n\n    target_phys_addr_t real_addr, prot_addr, cmdline_addr, initrd_addr;\n\n    FILE *f, *fi;\n\n\n\n    \/* Align to 16 bytes as a paranoia measure *\/\n\n    cmdline_size = (strlen(kernel_cmdline)+16) & ~15;\n\n\n\n    \/* load the kernel header *\/\n\n    f = fopen(kernel_filename, \"rb\");\n\n    if (!f || !(kernel_size = get_file_size(f)) ||\n\n\tfread(header, 1, 1024, f) != 1024) {\n\n\tfprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n\t\tkernel_filename);\n\n\texit(1);\n\n    }\n\n\n\n    \/* kernel protocol version *\/\n\n#if 0\n\n    fprintf(stderr, \"header magic: %#x\\n\", ldl_p(header+0x202));\n\n#endif\n\n    if (ldl_p(header+0x202) == 0x53726448)\n\n\tprotocol = lduw_p(header+0x206);\n\n    else\n\n\tprotocol = 0;\n\n\n\n    if (protocol < 0x200 || !(header[0x211] & 0x01)) {\n\n\t\/* Low kernel *\/\n\n\treal_addr    = 0x90000;\n\n\tcmdline_addr = 0x9a000 - cmdline_size;\n\n\tprot_addr    = 0x10000;\n\n    } else if (protocol < 0x202) {\n\n\t\/* High but ancient kernel *\/\n\n\treal_addr    = 0x90000;\n\n\tcmdline_addr = 0x9a000 - cmdline_size;\n\n\tprot_addr    = 0x100000;\n\n    } else {\n\n\t\/* High and recent kernel *\/\n\n\treal_addr    = 0x10000;\n\n\tcmdline_addr = 0x20000;\n\n\tprot_addr    = 0x100000;\n\n    }\n\n\n\n#if 0\n\n    fprintf(stderr,\n\n\t    \"qemu: real_addr     = 0x\" TARGET_FMT_plx \"\\n\"\n\n\t    \"qemu: cmdline_addr  = 0x\" TARGET_FMT_plx \"\\n\"\n\n\t    \"qemu: prot_addr     = 0x\" TARGET_FMT_plx \"\\n\",\n\n\t    real_addr,\n\n\t    cmdline_addr,\n\n\t    prot_addr);\n\n#endif\n\n\n\n    \/* highest address for loading the initrd *\/\n\n    if (protocol >= 0x203)\n\n\tinitrd_max = ldl_p(header+0x22c);\n\n    else\n\n\tinitrd_max = 0x37ffffff;\n\n\n\n    if (initrd_max >= ram_size-ACPI_DATA_SIZE)\n\n\tinitrd_max = ram_size-ACPI_DATA_SIZE-1;\n\n\n\n    \/* kernel command line *\/\n\n    pstrcpy_targphys(cmdline_addr, 4096, kernel_cmdline);\n\n\n\n    if (protocol >= 0x202) {\n\n\tstl_p(header+0x228, cmdline_addr);\n\n    } else {\n\n\tstw_p(header+0x20, 0xA33F);\n\n\tstw_p(header+0x22, cmdline_addr-real_addr);\n\n    }\n\n\n\n    \/* loader type *\/\n\n    \/* High nybble = B reserved for Qemu; low nybble is revision number.\n\n       If this code is substantially changed, you may want to consider\n\n       incrementing the revision. *\/\n\n    if (protocol >= 0x200)\n\n\theader[0x210] = 0xB0;\n\n\n\n    \/* heap *\/\n\n    if (protocol >= 0x201) {\n\n\theader[0x211] |= 0x80;\t\/* CAN_USE_HEAP *\/\n\n\tstw_p(header+0x224, cmdline_addr-real_addr-0x200);\n\n    }\n\n\n\n    \/* load initrd *\/\n\n    if (initrd_filename) {\n\n\tif (protocol < 0x200) {\n\n\t    fprintf(stderr, \"qemu: linux kernel too old to load a ram disk\\n\");\n\n\t    exit(1);\n\n\t}\n\n\n\n\tfi = fopen(initrd_filename, \"rb\");\n\n\tif (!fi) {\n\n\t    fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n\t\t    initrd_filename);\n\n\t    exit(1);\n\n\t}\n\n\n\n\tinitrd_size = get_file_size(fi);\n\n\tinitrd_addr = (initrd_max-initrd_size) & ~4095;\n\n\n\n        fprintf(stderr, \"qemu: loading initrd (%#x bytes) at 0x\" TARGET_FMT_plx\n\n                \"\\n\", initrd_size, initrd_addr);\n\n\n\n\tif (!fread_targphys_ok(initrd_addr, initrd_size, fi)) {\n\n\t    fprintf(stderr, \"qemu: read error on initial ram disk '%s'\\n\",\n\n\t\t    initrd_filename);\n\n\t    exit(1);\n\n\t}\n\n\tfclose(fi);\n\n\n\n\tstl_p(header+0x218, initrd_addr);\n\n\tstl_p(header+0x21c, initrd_size);\n\n    }\n\n\n\n    \/* store the finalized header and load the rest of the kernel *\/\n\n    cpu_physical_memory_write(real_addr, header, 1024);\n\n\n\n    setup_size = header[0x1f1];\n\n    if (setup_size == 0)\n\n\tsetup_size = 4;\n\n\n\n    setup_size = (setup_size+1)*512;\n\n    kernel_size -= setup_size;\t\/* Size of protected-mode code *\/\n\n\n\n    if (!fread_targphys_ok(real_addr+1024, setup_size-1024, f) ||\n\n\t!fread_targphys_ok(prot_addr, kernel_size, f)) {\n\n\tfprintf(stderr, \"qemu: read error on kernel '%s'\\n\",\n\n\t\tkernel_filename);\n\n\texit(1);\n\n    }\n\n    fclose(f);\n\n\n\n    \/* generate bootsector to set up the initial register state *\/\n\n    real_seg = real_addr >> 4;\n\n    seg[0] = seg[2] = seg[3] = seg[4] = seg[4] = real_seg;\n\n    seg[1] = real_seg+0x20;\t\/* CS *\/\n\n    memset(gpr, 0, sizeof gpr);\n\n    gpr[4] = cmdline_addr-real_addr-16;\t\/* SP (-16 is paranoia) *\/\n\n\n\n    generate_bootsect(gpr, seg, 0);\n\n}\n"},{"project":"qemu","commit_id":"13412c9d2fce7c402e93a08177abdbc593208140","target":1,"func":"void do_info_vnc(void)\n\n{\n\n    if (vnc_state == NULL)\n\n\tterm_printf(\"VNC server disabled\\n\");\n\n    else {\n\n\tterm_printf(\"VNC server active on: \");\n\n\tterm_print_filename(vnc_state->display);\n\n\tterm_printf(\"\\n\");\n\n\n\n\tif (vnc_state->csock == -1)\n\n\t    term_printf(\"No client connected\\n\");\n\n\telse\n\n\t    term_printf(\"Client connected\\n\");\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"48bb9f53f4944771bc5d7bf89bbaa61094ad4382","target":0,"func":"static const char *scsi_command_name(uint8_t cmd)\n\n{\n\n    static const char *names[] = {\n\n        [ TEST_UNIT_READY          ] = \"TEST_UNIT_READY\",\n\n        [ REWIND                   ] = \"REWIND\",\n\n        [ REQUEST_SENSE            ] = \"REQUEST_SENSE\",\n\n        [ FORMAT_UNIT              ] = \"FORMAT_UNIT\",\n\n        [ READ_BLOCK_LIMITS        ] = \"READ_BLOCK_LIMITS\",\n\n        [ REASSIGN_BLOCKS          ] = \"REASSIGN_BLOCKS\",\n\n        [ READ_6                   ] = \"READ_6\",\n\n        [ WRITE_6                  ] = \"WRITE_6\",\n\n        [ SEEK_6                   ] = \"SEEK_6\",\n\n        [ READ_REVERSE             ] = \"READ_REVERSE\",\n\n        [ WRITE_FILEMARKS          ] = \"WRITE_FILEMARKS\",\n\n        [ SPACE                    ] = \"SPACE\",\n\n        [ INQUIRY                  ] = \"INQUIRY\",\n\n        [ RECOVER_BUFFERED_DATA    ] = \"RECOVER_BUFFERED_DATA\",\n\n        [ MAINTENANCE_IN           ] = \"MAINTENANCE_IN\",\n\n        [ MAINTENANCE_OUT          ] = \"MAINTENANCE_OUT\",\n\n        [ MODE_SELECT              ] = \"MODE_SELECT\",\n\n        [ RESERVE                  ] = \"RESERVE\",\n\n        [ RELEASE                  ] = \"RELEASE\",\n\n        [ COPY                     ] = \"COPY\",\n\n        [ ERASE                    ] = \"ERASE\",\n\n        [ MODE_SENSE               ] = \"MODE_SENSE\",\n\n        [ START_STOP               ] = \"START_STOP\",\n\n        [ RECEIVE_DIAGNOSTIC       ] = \"RECEIVE_DIAGNOSTIC\",\n\n        [ SEND_DIAGNOSTIC          ] = \"SEND_DIAGNOSTIC\",\n\n        [ ALLOW_MEDIUM_REMOVAL     ] = \"ALLOW_MEDIUM_REMOVAL\",\n\n        [ READ_CAPACITY_10         ] = \"READ_CAPACITY_10\",\n\n        [ READ_10                  ] = \"READ_10\",\n\n        [ WRITE_10                 ] = \"WRITE_10\",\n\n        [ SEEK_10                  ] = \"SEEK_10\",\n\n        [ WRITE_VERIFY_10          ] = \"WRITE_VERIFY_10\",\n\n        [ VERIFY_10                ] = \"VERIFY_10\",\n\n        [ SEARCH_HIGH              ] = \"SEARCH_HIGH\",\n\n        [ SEARCH_EQUAL             ] = \"SEARCH_EQUAL\",\n\n        [ SEARCH_LOW               ] = \"SEARCH_LOW\",\n\n        [ SET_LIMITS               ] = \"SET_LIMITS\",\n\n        [ PRE_FETCH                ] = \"PRE_FETCH\",\n\n        \/* READ_POSITION and PRE_FETCH use the same operation code *\/\n\n        [ SYNCHRONIZE_CACHE        ] = \"SYNCHRONIZE_CACHE\",\n\n        [ LOCK_UNLOCK_CACHE        ] = \"LOCK_UNLOCK_CACHE\",\n\n        [ READ_DEFECT_DATA         ] = \"READ_DEFECT_DATA\",\n\n        [ MEDIUM_SCAN              ] = \"MEDIUM_SCAN\",\n\n        [ COMPARE                  ] = \"COMPARE\",\n\n        [ COPY_VERIFY              ] = \"COPY_VERIFY\",\n\n        [ WRITE_BUFFER             ] = \"WRITE_BUFFER\",\n\n        [ READ_BUFFER              ] = \"READ_BUFFER\",\n\n        [ UPDATE_BLOCK             ] = \"UPDATE_BLOCK\",\n\n        [ READ_LONG_10             ] = \"READ_LONG_10\",\n\n        [ WRITE_LONG_10            ] = \"WRITE_LONG_10\",\n\n        [ CHANGE_DEFINITION        ] = \"CHANGE_DEFINITION\",\n\n        [ WRITE_SAME_10            ] = \"WRITE_SAME_10\",\n\n        [ UNMAP                    ] = \"UNMAP\",\n\n        [ READ_TOC                 ] = \"READ_TOC\",\n\n        [ REPORT_DENSITY_SUPPORT   ] = \"REPORT_DENSITY_SUPPORT\",\n\n        [ GET_CONFIGURATION        ] = \"GET_CONFIGURATION\",\n\n        [ LOG_SELECT               ] = \"LOG_SELECT\",\n\n        [ LOG_SENSE                ] = \"LOG_SENSE\",\n\n        [ MODE_SELECT_10           ] = \"MODE_SELECT_10\",\n\n        [ RESERVE_10               ] = \"RESERVE_10\",\n\n        [ RELEASE_10               ] = \"RELEASE_10\",\n\n        [ MODE_SENSE_10            ] = \"MODE_SENSE_10\",\n\n        [ PERSISTENT_RESERVE_IN    ] = \"PERSISTENT_RESERVE_IN\",\n\n        [ PERSISTENT_RESERVE_OUT   ] = \"PERSISTENT_RESERVE_OUT\",\n\n        [ WRITE_FILEMARKS_16       ] = \"WRITE_FILEMARKS_16\",\n\n        [ EXTENDED_COPY            ] = \"EXTENDED_COPY\",\n\n        [ ATA_PASSTHROUGH          ] = \"ATA_PASSTHROUGH\",\n\n        [ ACCESS_CONTROL_IN        ] = \"ACCESS_CONTROL_IN\",\n\n        [ ACCESS_CONTROL_OUT       ] = \"ACCESS_CONTROL_OUT\",\n\n        [ READ_16                  ] = \"READ_16\",\n\n        [ COMPARE_AND_WRITE        ] = \"COMPARE_AND_WRITE\",\n\n        [ WRITE_16                 ] = \"WRITE_16\",\n\n        [ WRITE_VERIFY_16          ] = \"WRITE_VERIFY_16\",\n\n        [ VERIFY_16                ] = \"VERIFY_16\",\n\n        [ SYNCHRONIZE_CACHE_16     ] = \"SYNCHRONIZE_CACHE_16\",\n\n        [ LOCATE_16                ] = \"LOCATE_16\",\n\n        [ WRITE_SAME_16            ] = \"WRITE_SAME_16\",\n\n        [ ERASE_16                 ] = \"ERASE_16\",\n\n        [ SERVICE_ACTION_IN_16     ] = \"SERVICE_ACTION_IN_16\",\n\n        [ WRITE_LONG_16            ] = \"WRITE_LONG_16\",\n\n        [ REPORT_LUNS              ] = \"REPORT_LUNS\",\n\n        [ BLANK                    ] = \"BLANK\",\n\n        [ MAINTENANCE_IN           ] = \"MAINTENANCE_IN\",\n\n        [ MAINTENANCE_OUT          ] = \"MAINTENANCE_OUT\",\n\n        [ MOVE_MEDIUM              ] = \"MOVE_MEDIUM\",\n\n        [ LOAD_UNLOAD              ] = \"LOAD_UNLOAD\",\n\n        [ READ_12                  ] = \"READ_12\",\n\n        [ WRITE_12                 ] = \"WRITE_12\",\n\n        [ SERVICE_ACTION_IN_12     ] = \"SERVICE_ACTION_IN_12\",\n\n        [ WRITE_VERIFY_12          ] = \"WRITE_VERIFY_12\",\n\n        [ VERIFY_12                ] = \"VERIFY_12\",\n\n        [ SEARCH_HIGH_12           ] = \"SEARCH_HIGH_12\",\n\n        [ SEARCH_EQUAL_12          ] = \"SEARCH_EQUAL_12\",\n\n        [ SEARCH_LOW_12            ] = \"SEARCH_LOW_12\",\n\n        [ READ_ELEMENT_STATUS      ] = \"READ_ELEMENT_STATUS\",\n\n        [ SEND_VOLUME_TAG          ] = \"SEND_VOLUME_TAG\",\n\n        [ READ_DEFECT_DATA_12      ] = \"READ_DEFECT_DATA_12\",\n\n        [ SET_CD_SPEED             ] = \"SET_CD_SPEED\",\n\n    };\n\n\n\n    if (cmd >= ARRAY_SIZE(names) || names[cmd] == NULL)\n\n        return \"*UNKNOWN*\";\n\n    return names[cmd];\n\n}\n"},{"project":"qemu","commit_id":"6baebed7698a37a0ac5168faf26023426b0ac940","target":1,"func":"static void send_framebuffer_update_raw(VncState *vs, int x, int y, int w, int h)\n\n{\n\n    int i;\n\n    uint8_t *row;\n\n\n\n    row = ds_get_data(vs->ds) + y * ds_get_linesize(vs->ds) + x * ds_get_bytes_per_pixel(vs->ds);\n\n    for (i = 0; i < h; i++) {\n\n        vs->write_pixels(vs, row, w * ds_get_bytes_per_pixel(vs->ds));\n\n        row += ds_get_linesize(vs->ds);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"8653c0158c23ec592f0041ab48b83d6cc6d152fe","target":0,"func":"static int spawn_thread(void)\n\n{\n\n    pthread_attr_t attr;\n\n    int ret;\n\n\n\n    cur_threads++;\n\n    idle_threads++;\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"375092332eeaa6e47561ce47fd36144cdaf964d0","target":0,"func":"static ssize_t test_block_read_func(QCryptoBlock *block,\n\n                                    size_t offset,\n\n                                    uint8_t *buf,\n\n                                    size_t buflen,\n\n                                    Error **errp,\n\n                                    void *opaque)\n\n{\n\n    Buffer *header = opaque;\n\n\n\n    g_assert_cmpint(offset + buflen, <=, header->capacity);\n\n\n\n    memcpy(buf, header->buffer + offset, buflen);\n\n\n\n    return buflen;\n\n}\n"},{"project":"qemu","commit_id":"732b530c1bd064bdcc29975c0b78fc6de8c47e7f","target":0,"func":"static void nvdimm_build_common_dsm(Aml *dev)\n\n{\n\n    Aml *method, *ifctx, *function, *dsm_mem, *unpatched, *result_size;\n\n    uint8_t byte_list[1];\n\n\n\n    method = aml_method(NVDIMM_COMMON_DSM, 4, AML_SERIALIZED);\n\n    function = aml_arg(2);\n\n    dsm_mem = aml_name(NVDIMM_ACPI_MEM_ADDR);\n\n\n\n    \/*\n\n     * do not support any method if DSM memory address has not been\n\n     * patched.\n\n     *\/\n\n    unpatched = aml_if(aml_equal(dsm_mem, aml_int(0x0)));\n\n\n\n    \/*\n\n     * function 0 is called to inquire what functions are supported by\n\n     * OSPM\n\n     *\/\n\n    ifctx = aml_if(aml_equal(function, aml_int(0)));\n\n    byte_list[0] = 0 \/* No function Supported *\/;\n\n    aml_append(ifctx, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(unpatched, ifctx);\n\n\n\n    \/* No function is supported yet. *\/\n\n    byte_list[0] = 1 \/* Not Supported *\/;\n\n    aml_append(unpatched, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(method, unpatched);\n\n\n\n    \/*\n\n     * The HDLE indicates the DSM function is issued from which device,\n\n     * it is not used at this time as no function is supported yet.\n\n     * Currently we make it always be 0 for all the devices and will set\n\n     * the appropriate value once real function is implemented.\n\n     *\/\n\n    aml_append(method, aml_store(aml_int(0x0), aml_name(\"HDLE\")));\n\n    aml_append(method, aml_store(aml_arg(1), aml_name(\"REVS\")));\n\n    aml_append(method, aml_store(aml_arg(2), aml_name(\"FUNC\")));\n\n\n\n    \/*\n\n     * tell QEMU about the real address of DSM memory, then QEMU\n\n     * gets the control and fills the result in DSM memory.\n\n     *\/\n\n    aml_append(method, aml_store(dsm_mem, aml_name(\"NTFI\")));\n\n\n\n    result_size = aml_local(1);\n\n    aml_append(method, aml_store(aml_name(\"RLEN\"), result_size));\n\n    aml_append(method, aml_store(aml_shiftleft(result_size, aml_int(3)),\n\n                                 result_size));\n\n    aml_append(method, aml_create_field(aml_name(\"ODAT\"), aml_int(0),\n\n                                        result_size, \"OBUF\"));\n\n    aml_append(method, aml_concatenate(aml_buffer(0, NULL), aml_name(\"OBUF\"),\n\n                                       aml_arg(6)));\n\n    aml_append(method, aml_return(aml_arg(6)));\n\n    aml_append(dev, method);\n\n}\n"},{"project":"qemu","commit_id":"6ef228fc0de1d5fb43ebfef039563d39a3a37067","target":0,"func":"static void ratelimit_set_speed(RateLimit *limit, uint64_t speed)\n\n{\n\n    limit->slice_quota = speed \/ (1000000000ULL \/ SLICE_TIME);\n\n}\n"},{"project":"qemu","commit_id":"f4658285f99473367dbbc34ce6970ec4637c2388","target":1,"func":"static void tracked_request_end(BdrvTrackedRequest *req)\n\n{\n\n    QLIST_REMOVE(req, list);\n\n\n}"},{"project":"qemu","commit_id":"2bcf018340cbf233f7145e643fc1bb367f23fd90","target":0,"func":"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,\n\n                       target_ulong *addr, int *flags)\n\n{\n\n    \/* TODO: low address protection once we flush the tlb on cr changes *\/\n\n    *flags = PAGE_READ | PAGE_WRITE;\n\n    *addr = mmu_real2abs(env, raddr);\n\n\n\n    \/* TODO: storage key handling *\/\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"8dfba2797761d8a43744e4e6571c8175e448a478","target":0,"func":"static void commit_complete(BlockJob *job, void *opaque)\n\n{\n\n    CommitBlockJob *s = container_of(job, CommitBlockJob, common);\n\n    CommitCompleteData *data = opaque;\n\n    BlockDriverState *active = s->active;\n\n    BlockDriverState *top = blk_bs(s->top);\n\n    BlockDriverState *base = blk_bs(s->base);\n\n    BlockDriverState *overlay_bs = bdrv_find_overlay(active, top);\n\n    int ret = data->ret;\n\n\n\n    if (!block_job_is_cancelled(&s->common) && ret == 0) {\n\n        \/* success *\/\n\n        ret = bdrv_drop_intermediate(active, top, base, s->backing_file_str);\n\n    }\n\n\n\n    \/* restore base open flags here if appropriate (e.g., change the base back\n\n     * to r\/o). These reopens do not need to be atomic, since we won't abort\n\n     * even on failure here *\/\n\n    if (s->base_flags != bdrv_get_flags(base)) {\n\n        bdrv_reopen(base, s->base_flags, NULL);\n\n    }\n\n    if (overlay_bs && s->orig_overlay_flags != bdrv_get_flags(overlay_bs)) {\n\n        bdrv_reopen(overlay_bs, s->orig_overlay_flags, NULL);\n\n    }\n\n    g_free(s->backing_file_str);\n\n    blk_unref(s->top);\n\n    blk_unref(s->base);\n\n    block_job_completed(&s->common, ret);\n\n    g_free(data);\n\n}\n"},{"project":"qemu","commit_id":"187337f8b0ec0813dd3876d1efe37d415fb81c2e","target":1,"func":"void *pl110_init(DisplayState *ds, uint32_t base, qemu_irq irq,\n\n                 int versatile)\n\n{\n\n    pl110_state *s;\n\n    int iomemtype;\n\n\n\n    s = (pl110_state *)qemu_mallocz(sizeof(pl110_state));\n\n    iomemtype = cpu_register_io_memory(0, pl110_readfn,\n\n                                       pl110_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->ds = ds;\n\n    s->versatile = versatile;\n\n    s->irq = irq;\n\n    graphic_console_init(ds, pl110_update_display, pl110_invalidate_display,\n\n                         NULL, s);\n\n    \/* ??? Save\/restore.  *\/\n\n    return s;\n\n}\n"},{"project":"qemu","commit_id":"c2b38b277a7882a592f4f2ec955084b2b756daaa","target":0,"func":"static void thread_pool_co_cb(void *opaque, int ret)\n\n{\n\n    ThreadPoolCo *co = opaque;\n\n\n\n    co->ret = ret;\n\n    qemu_coroutine_enter(co->co);\n\n}\n"},{"project":"qemu","commit_id":"82cbbdc6a0958b49c77639a60906e30d02e6bb7b","target":0,"func":"void qemu_aio_set_fd_handler(int fd,\n\n                             IOHandler *io_read,\n\n                             IOHandler *io_write,\n\n                             AioFlushHandler *io_flush,\n\n                             void *opaque)\n\n{\n\n    aio_set_fd_handler(qemu_aio_context, fd, io_read, io_write, io_flush,\n\n                       opaque);\n\n\n\n    qemu_set_fd_handler2(fd, NULL, io_read, io_write, opaque);\n\n}\n"},{"project":"qemu","commit_id":"e2a32ebbfe899a32a6b063f0f9e7c2593267ea88","target":0,"func":"int x86_cpu_handle_mmu_fault(CPUState *cs, vaddr addr,\n\n                             int is_write1, int mmu_idx)\n\n{\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n    uint64_t ptep, pte;\n\n    target_ulong pde_addr, pte_addr;\n\n    int error_code = 0;\n\n    int is_dirty, prot, page_size, is_write, is_user;\n\n    hwaddr paddr;\n\n    uint64_t rsvd_mask = PG_HI_RSVD_MASK;\n\n    uint32_t page_offset;\n\n    target_ulong vaddr;\n\n\n\n    is_user = mmu_idx == MMU_USER_IDX;\n\n#if defined(DEBUG_MMU)\n\n    printf(\"MMU fault: addr=%\" VADDR_PRIx \" w=%d u=%d eip=\" TARGET_FMT_lx \"\\n\",\n\n           addr, is_write1, is_user, env->eip);\n\n#endif\n\n    is_write = is_write1 & 1;\n\n\n\n    if (!(env->cr[0] & CR0_PG_MASK)) {\n\n        pte = addr;\n\n#ifdef TARGET_X86_64\n\n        if (!(env->hflags & HF_LMA_MASK)) {\n\n            \/* Without long mode we can only address 32bits in real mode *\/\n\n            pte = (uint32_t)pte;\n\n        }\n\n#endif\n\n        prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n        page_size = 4096;\n\n        goto do_mapping;\n\n    }\n\n\n\n    if (env->cr[4] & CR4_PAE_MASK) {\n\n        uint64_t pde, pdpe;\n\n        target_ulong pdpe_addr;\n\n\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_LMA_MASK) {\n\n            uint64_t pml4e_addr, pml4e;\n\n            int32_t sext;\n\n\n\n            \/* test virtual address sign extension *\/\n\n            sext = (int64_t)addr >> 47;\n\n            if (sext != 0 && sext != -1) {\n\n                env->error_code = 0;\n\n                cs->exception_index = EXCP0D_GPF;\n\n                return 1;\n\n            }\n\n\n\n            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pml4e = ldq_phys(cs->as, pml4e_addr);\n\n            if (!(pml4e & PG_PRESENT_MASK)) {\n\n                goto do_fault;\n\n            }\n\n            if (pml4e & (rsvd_mask | PG_PSE_MASK)) {\n\n                goto do_fault_rsvd;\n\n            }\n\n            if (!(env->efer & MSR_EFER_NXE) && (pml4e & PG_NX_MASK)) {\n\n                goto do_fault_rsvd;\n\n            }\n\n            if (!(pml4e & PG_ACCESSED_MASK)) {\n\n                pml4e |= PG_ACCESSED_MASK;\n\n                stl_phys_notdirty(cs->as, pml4e_addr, pml4e);\n\n            }\n\n            ptep = pml4e ^ PG_NX_MASK;\n\n            pdpe_addr = ((pml4e & PG_ADDRESS_MASK) + (((addr >> 30) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(cs->as, pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK)) {\n\n                goto do_fault;\n\n            }\n\n            if (pdpe & rsvd_mask) {\n\n                goto do_fault_rsvd;\n\n            }\n\n            if (!(env->efer & MSR_EFER_NXE) && (pdpe & PG_NX_MASK)) {\n\n                goto do_fault_rsvd;\n\n            }\n\n            ptep &= pdpe ^ PG_NX_MASK;\n\n            if (!(pdpe & PG_ACCESSED_MASK)) {\n\n                pdpe |= PG_ACCESSED_MASK;\n\n                stl_phys_notdirty(cs->as, pdpe_addr, pdpe);\n\n            }\n\n            if (pdpe & PG_PSE_MASK) {\n\n                \/* 1 GB page *\/\n\n                page_size = 1024 * 1024 * 1024;\n\n                pte_addr = pdpe_addr;\n\n                pte = pdpe;\n\n                goto do_check_protect;\n\n            }\n\n        } else\n\n#endif\n\n        {\n\n            \/* XXX: load them when cr3 is loaded ? *\/\n\n            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(cs->as, pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK)) {\n\n                goto do_fault;\n\n            }\n\n            rsvd_mask |= PG_HI_USER_MASK | PG_NX_MASK;\n\n            if (pdpe & rsvd_mask) {\n\n                goto do_fault_rsvd;\n\n            }\n\n            ptep = PG_NX_MASK | PG_USER_MASK | PG_RW_MASK;\n\n        }\n\n\n\n        pde_addr = ((pdpe & PG_ADDRESS_MASK) + (((addr >> 21) & 0x1ff) << 3)) &\n\n            env->a20_mask;\n\n        pde = ldq_phys(cs->as, pde_addr);\n\n        if (!(pde & PG_PRESENT_MASK)) {\n\n            goto do_fault;\n\n        }\n\n        if (pde & rsvd_mask) {\n\n            goto do_fault_rsvd;\n\n        }\n\n        if (!(env->efer & MSR_EFER_NXE) && (pde & PG_NX_MASK)) {\n\n            goto do_fault_rsvd;\n\n        }\n\n        ptep &= pde ^ PG_NX_MASK;\n\n        if (pde & PG_PSE_MASK) {\n\n            \/* 2 MB page *\/\n\n            page_size = 2048 * 1024;\n\n            pte_addr = pde_addr;\n\n            pte = pde;\n\n            goto do_check_protect;\n\n        }\n\n        \/* 4 KB page *\/\n\n        if (!(pde & PG_ACCESSED_MASK)) {\n\n            pde |= PG_ACCESSED_MASK;\n\n            stl_phys_notdirty(cs->as, pde_addr, pde);\n\n        }\n\n        pte_addr = ((pde & PG_ADDRESS_MASK) + (((addr >> 12) & 0x1ff) << 3)) &\n\n            env->a20_mask;\n\n        pte = ldq_phys(cs->as, pte_addr);\n\n        if (!(pte & PG_PRESENT_MASK)) {\n\n            goto do_fault;\n\n        }\n\n        if (pte & rsvd_mask) {\n\n            goto do_fault_rsvd;\n\n        }\n\n        if (!(env->efer & MSR_EFER_NXE) && (pte & PG_NX_MASK)) {\n\n            goto do_fault_rsvd;\n\n        }\n\n        \/* combine pde and pte nx, user and rw protections *\/\n\n        ptep &= pte ^ PG_NX_MASK;\n\n        page_size = 4096;\n\n    } else {\n\n        uint32_t pde;\n\n\n\n        \/* page directory entry *\/\n\n        pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) &\n\n            env->a20_mask;\n\n        pde = ldl_phys(cs->as, pde_addr);\n\n        if (!(pde & PG_PRESENT_MASK)) {\n\n            goto do_fault;\n\n        }\n\n        ptep = pde | PG_NX_MASK;\n\n\n\n        \/* if PSE bit is set, then we use a 4MB page *\/\n\n        if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n            page_size = 4096 * 1024;\n\n            pte_addr = pde_addr;\n\n            pte = pde;\n\n            goto do_check_protect;\n\n        }\n\n\n\n        if (!(pde & PG_ACCESSED_MASK)) {\n\n            pde |= PG_ACCESSED_MASK;\n\n            stl_phys_notdirty(cs->as, pde_addr, pde);\n\n        }\n\n\n\n        \/* page directory entry *\/\n\n        pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) &\n\n            env->a20_mask;\n\n        pte = ldl_phys(cs->as, pte_addr);\n\n        if (!(pte & PG_PRESENT_MASK)) {\n\n            goto do_fault;\n\n        }\n\n        \/* combine pde and pte user and rw protections *\/\n\n        ptep &= pte | PG_NX_MASK;\n\n        page_size = 4096;\n\n        rsvd_mask = 0;\n\n    }\n\n\n\ndo_check_protect:\n\n    if (pte & rsvd_mask) {\n\n        goto do_fault_rsvd;\n\n    }\n\n    ptep ^= PG_NX_MASK;\n\n    if ((ptep & PG_NX_MASK) && is_write1 == 2) {\n\n        goto do_fault_protect;\n\n    }\n\n    switch (mmu_idx) {\n\n    case MMU_USER_IDX:\n\n        if (!(ptep & PG_USER_MASK)) {\n\n            goto do_fault_protect;\n\n        }\n\n        if (is_write && !(ptep & PG_RW_MASK)) {\n\n            goto do_fault_protect;\n\n        }\n\n        break;\n\n\n\n    case MMU_KSMAP_IDX:\n\n        if (is_write1 != 2 && (ptep & PG_USER_MASK)) {\n\n            goto do_fault_protect;\n\n        }\n\n        \/* fall through *\/\n\n    case MMU_KNOSMAP_IDX:\n\n        if (is_write1 == 2 && (env->cr[4] & CR4_SMEP_MASK) &&\n\n            (ptep & PG_USER_MASK)) {\n\n            goto do_fault_protect;\n\n        }\n\n        if ((env->cr[0] & CR0_WP_MASK) &&\n\n            is_write && !(ptep & PG_RW_MASK)) {\n\n            goto do_fault_protect;\n\n        }\n\n        break;\n\n\n\n    default: \/* cannot happen *\/\n\n        break;\n\n    }\n\n    is_dirty = is_write && !(pte & PG_DIRTY_MASK);\n\n    if (!(pte & PG_ACCESSED_MASK) || is_dirty) {\n\n        pte |= PG_ACCESSED_MASK;\n\n        if (is_dirty) {\n\n            pte |= PG_DIRTY_MASK;\n\n        }\n\n        stl_phys_notdirty(cs->as, pte_addr, pte);\n\n    }\n\n\n\n    \/* the page can be put in the TLB *\/\n\n    prot = PAGE_READ;\n\n    if (!(ptep & PG_NX_MASK))\n\n        prot |= PAGE_EXEC;\n\n    if (pte & PG_DIRTY_MASK) {\n\n        \/* only set write access if already dirty... otherwise wait\n\n           for dirty access *\/\n\n        if (is_user) {\n\n            if (ptep & PG_RW_MASK)\n\n                prot |= PAGE_WRITE;\n\n        } else {\n\n            if (!(env->cr[0] & CR0_WP_MASK) ||\n\n                (ptep & PG_RW_MASK))\n\n                prot |= PAGE_WRITE;\n\n        }\n\n    }\n\n do_mapping:\n\n    pte = pte & env->a20_mask;\n\n\n\n    \/* align to page_size *\/\n\n    pte &= PG_ADDRESS_MASK & ~(page_size - 1);\n\n\n\n    \/* Even if 4MB pages, we map only one 4KB page in the cache to\n\n       avoid filling it too fast *\/\n\n    vaddr = addr & TARGET_PAGE_MASK;\n\n    page_offset = vaddr & (page_size - 1);\n\n    paddr = pte + page_offset;\n\n\n\n    tlb_set_page(cs, vaddr, paddr, prot, mmu_idx, page_size);\n\n    return 0;\n\n do_fault_rsvd:\n\n    error_code |= PG_ERROR_RSVD_MASK;\n\n do_fault_protect:\n\n    error_code |= PG_ERROR_P_MASK;\n\n do_fault:\n\n    error_code |= (is_write << PG_ERROR_W_BIT);\n\n    if (is_user)\n\n        error_code |= PG_ERROR_U_MASK;\n\n    if (is_write1 == 2 &&\n\n        (((env->efer & MSR_EFER_NXE) &&\n\n          (env->cr[4] & CR4_PAE_MASK)) ||\n\n         (env->cr[4] & CR4_SMEP_MASK)))\n\n        error_code |= PG_ERROR_I_D_MASK;\n\n    if (env->intercept_exceptions & (1 << EXCP0E_PAGE)) {\n\n        \/* cr2 is not modified in case of exceptions *\/\n\n        stq_phys(cs->as,\n\n                 env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2),\n\n                 addr);\n\n    } else {\n\n        env->cr[2] = addr;\n\n    }\n\n    env->error_code = error_code;\n\n    cs->exception_index = EXCP0E_PAGE;\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"8786db7cb96f8ce5c75c6e1e074319c9dca8d356","target":1,"func":"void memory_global_sync_dirty_bitmap(MemoryRegion *address_space)\n\n{\n\n    AddressSpace *as = memory_region_to_address_space(address_space);\n\n    FlatRange *fr;\n\n\n\n    FOR_EACH_FLAT_RANGE(fr, &as->current_map) {\n\n        MEMORY_LISTENER_UPDATE_REGION(fr, as, Forward, log_sync);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"81017645e45bcb0b4d985e900c501f92f2c6fb60","target":0,"func":"void net_check_clients(void)\n\n{\n\n    VLANState *vlan;\n\n    VLANClientState *vc;\n\n    int i;\n\n\n\n    \/* Don't warn about the default network setup that you get if\n\n     * no command line -net or -netdev options are specified. There\n\n     * are two cases that we would otherwise complain about:\n\n     * (1) board doesn't support a NIC but the implicit \"-net nic\"\n\n     * requested one\n\n     * (2) CONFIG_SLIRP not set, in which case the implicit \"-net nic\"\n\n     * sets up a nic that isn't connected to anything.\n\n     *\/\n\n    if (default_net) {\n\n        return;\n\n    }\n\n\n\n    QTAILQ_FOREACH(vlan, &vlans, next) {\n\n        int has_nic = 0, has_host_dev = 0;\n\n\n\n        QTAILQ_FOREACH(vc, &vlan->clients, next) {\n\n            switch (vc->info->type) {\n\n            case NET_CLIENT_OPTIONS_KIND_NIC:\n\n                has_nic = 1;\n\n                break;\n\n            case NET_CLIENT_OPTIONS_KIND_USER:\n\n            case NET_CLIENT_OPTIONS_KIND_TAP:\n\n            case NET_CLIENT_OPTIONS_KIND_SOCKET:\n\n            case NET_CLIENT_OPTIONS_KIND_VDE:\n\n                has_host_dev = 1;\n\n                break;\n\n            default: ;\n\n            }\n\n        }\n\n        if (has_host_dev && !has_nic)\n\n            fprintf(stderr, \"Warning: vlan %d with no nics\\n\", vlan->id);\n\n        if (has_nic && !has_host_dev)\n\n            fprintf(stderr,\n\n                    \"Warning: vlan %d is not connected to host network\\n\",\n\n                    vlan->id);\n\n    }\n\n    QTAILQ_FOREACH(vc, &non_vlan_clients, next) {\n\n        if (!vc->peer) {\n\n            fprintf(stderr, \"Warning: %s %s has no peer\\n\",\n\n                    vc->info->type == NET_CLIENT_OPTIONS_KIND_NIC ? \"nic\" : \"netdev\",\n\n                    vc->name);\n\n        }\n\n    }\n\n\n\n    \/* Check that all NICs requested via -net nic actually got created.\n\n     * NICs created via -device don't need to be checked here because\n\n     * they are always instantiated.\n\n     *\/\n\n    for (i = 0; i < MAX_NICS; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n        if (nd->used && !nd->instantiated) {\n\n            fprintf(stderr, \"Warning: requested NIC (%s, model %s) \"\n\n                    \"was not created (not supported by this machine?)\\n\",\n\n                    nd->name ? nd->name : \"anonymous\",\n\n                    nd->model ? nd->model : \"unspecified\");\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"548f52ea06951c20f0b91cae6cde0512ec073c83","target":1,"func":"static void qemu_fill_buffer(QEMUFile *f)\n\n{\n\n    int len;\n\n    int pending;\n\n\n\n    assert(!qemu_file_is_writable(f));\n\n\n\n    pending = f->buf_size - f->buf_index;\n\n    if (pending > 0) {\n\n        memmove(f->buf, f->buf + f->buf_index, pending);\n\n    }\n\n    f->buf_index = 0;\n\n    f->buf_size = pending;\n\n\n\n    len = f->ops->get_buffer(f->opaque, f->buf + pending, f->pos,\n\n                        IO_BUF_SIZE - pending);\n\n    if (len > 0) {\n\n        f->buf_size += len;\n\n        f->pos += len;\n\n    } else if (len == 0) {\n\n        qemu_file_set_error(f, -EIO);\n\n    } else if (len != -EAGAIN) {\n\n        qemu_file_set_error(f, len);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"79853e18d904b0a4bcef62701d48559688007c93","target":0,"func":"static void spapr_hotplug_req_event(sPAPRDRConnector *drc, uint8_t hp_action)\n\n{\n\n    struct hp_log_full *new_hp;\n\n    struct rtas_error_log *hdr;\n\n    struct rtas_event_log_v6 *v6hdr;\n\n    struct rtas_event_log_v6_maina *maina;\n\n    struct rtas_event_log_v6_mainb *mainb;\n\n    struct rtas_event_log_v6_hp *hp;\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    sPAPRDRConnectorType drc_type = drck->get_type(drc);\n\n\n\n    new_hp = g_malloc0(sizeof(struct hp_log_full));\n\n    hdr = &new_hp->hdr;\n\n    v6hdr = &new_hp->v6hdr;\n\n    maina = &new_hp->maina;\n\n    mainb = &new_hp->mainb;\n\n    hp = &new_hp->hp;\n\n\n\n    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6\n\n                               | RTAS_LOG_SEVERITY_EVENT\n\n                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED\n\n                               | RTAS_LOG_OPTIONAL_PART_PRESENT\n\n                               | RTAS_LOG_INITIATOR_HOTPLUG\n\n                               | RTAS_LOG_TYPE_HOTPLUG);\n\n    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)\n\n                                       - sizeof(new_hp->hdr));\n\n\n\n    spapr_init_v6hdr(v6hdr);\n\n    spapr_init_maina(maina, 3 \/* Main-A, Main-B, HP *\/);\n\n\n\n    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);\n\n    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));\n\n    mainb->subsystem_id = 0x80; \/* External environment *\/\n\n    mainb->event_severity = 0x00; \/* Informational \/ non-error *\/\n\n    mainb->event_subtype = 0x00; \/* Normal shutdown *\/\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; \/* includes extended modifier *\/\n\n    hp->hotplug_action = hp_action;\n\n\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->drc.index = cpu_to_be32(drck->get_index(drc));\n\n        hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX;\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        break;\n\n    default:\n\n        \/* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         *\/\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq));\n\n}\n"},{"project":"qemu","commit_id":"df3a429ae82c0f45becdfab105617701d75e0f05","target":0,"func":"static inline int qemu_gluster_zerofill(struct glfs_fd *fd, int64_t offset,\n\n                                        int64_t size)\n\n{\n\n    return glfs_zerofill(fd, offset, size);\n\n}\n"},{"project":"qemu","commit_id":"1195fed9e6790bd8fd86b0dc33e2442d70355ac6","target":0,"func":"set_mdic(E1000State *s, int index, uint32_t val)\n\n{\n\n    uint32_t data = val & E1000_MDIC_DATA_MASK;\n\n    uint32_t addr = ((val & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);\n\n\n\n    if ((val & E1000_MDIC_PHY_MASK) >> E1000_MDIC_PHY_SHIFT != 1) \/\/ phy #\n\n        val = s->mac_reg[MDIC] | E1000_MDIC_ERROR;\n\n    else if (val & E1000_MDIC_OP_READ) {\n\n        DBGOUT(MDIC, \"MDIC read reg 0x%x\\n\", addr);\n\n        if (!(phy_regcap[addr] & PHY_R)) {\n\n            DBGOUT(MDIC, \"MDIC read reg %x unhandled\\n\", addr);\n\n            val |= E1000_MDIC_ERROR;\n\n        } else\n\n            val = (val ^ data) | s->phy_reg[addr];\n\n    } else if (val & E1000_MDIC_OP_WRITE) {\n\n        DBGOUT(MDIC, \"MDIC write reg 0x%x, value 0x%x\\n\", addr, data);\n\n        if (!(phy_regcap[addr] & PHY_W)) {\n\n            DBGOUT(MDIC, \"MDIC write reg %x unhandled\\n\", addr);\n\n            val |= E1000_MDIC_ERROR;\n\n        } else {\n\n            if (addr < NPHYWRITEOPS && phyreg_writeops[addr]) {\n\n                phyreg_writeops[addr](s, index, data);\n\n            }\n\n            s->phy_reg[addr] = data;\n\n        }\n\n    }\n\n    s->mac_reg[MDIC] = val | E1000_MDIC_READY;\n\n\n\n    if (val & E1000_MDIC_INT_EN) {\n\n        set_ics(s, 0, E1000_ICR_MDAC);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"61007b316cd71ee7333ff7a0a749a8949527575f","target":0,"func":"int bdrv_write(BlockDriverState *bs, int64_t sector_num,\n\n               const uint8_t *buf, int nb_sectors)\n\n{\n\n    return bdrv_rw_co(bs, sector_num, (uint8_t *)buf, nb_sectors, true, 0);\n\n}\n"},{"project":"qemu","commit_id":"4c315c27661502a0813b129e41c0bf640c34a8d6","target":1,"func":"static void pci_vpb_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = pci_vpb_realize;\n\n    dc->reset = pci_vpb_reset;\n\n    dc->vmsd = &pci_vpb_vmstate;\n\n    dc->props = pci_vpb_properties;\n\n\n\n}"},{"project":"qemu","commit_id":"4fa4ce7107c6ec432f185307158c5df91ce54308","target":0,"func":"static int local_statfs(FsContext *s, V9fsPath *fs_path, struct statfs *stbuf)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    return statfs(rpath(s, path, buffer), stbuf);\n\n}\n"},{"project":"qemu","commit_id":"b1b27b64262fdace45e5ab134c4438338076cb98","target":1,"func":"static int nbd_co_writev_1(NbdClientSession *client, int64_t sector_num,\n\n                           int nb_sectors, QEMUIOVector *qiov,\n\n                           int offset)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    request.type = NBD_CMD_WRITE;\n\n    if (!bdrv_enable_write_cache(client->bs) &&\n\n        (client->nbdflags & NBD_FLAG_SEND_FUA)) {\n\n        request.type |= NBD_CMD_FLAG_FUA;\n\n    }\n\n\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, qiov, offset);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL, 0);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n}\n"},{"project":"qemu","commit_id":"9307c4c1d93939db9b04117b654253af5113dc21","target":0,"func":"static void do_screen_dump(int argc, const char **argv)\n\n{\n\n    if (argc != 2) {\n\n        help_cmd(argv[0]);\n\n        return;\n\n    }\n\n    vga_screen_dump(argv[1]);\n\n}\n"},{"project":"qemu","commit_id":"a7812ae412311d7d47f8aa85656faadac9d64b56","target":0,"func":"static always_inline void gen_qemu_stg (TCGv t0, TCGv t1, int flags)\n\n{\n\n    TCGv tmp = tcg_temp_new(TCG_TYPE_I64);\n\n    tcg_gen_helper_1_1(helper_g_to_memory, tmp, t0);\n\n    tcg_gen_qemu_st64(tmp, t1, flags);\n\n    tcg_temp_free(tmp);\n\n}\n"},{"project":"qemu","commit_id":"3b098d56979d2f7fd707c5be85555d114353a28d","target":0,"func":"static void qmp_cleanup(void *datap)\n\n{\n\n    QmpSerializeData *d = datap;\n\n    visit_free(qmp_output_get_visitor(d->qov));\n\n    visit_free(d->qiv);\n\n\n\n    g_free(d);\n\n}\n"},{"project":"qemu","commit_id":"890241ab6942a0186eaf485dabf266a5a7aac428","target":1,"func":"static void migrate_check_parameter(QTestState *who, const char *parameter,\n\n                                    const char *value)\n\n{\n\n    QDict *rsp, *rsp_return;\n\n    const char *result;\n\n\n\n    rsp = wait_command(who, \"{ 'execute': 'query-migrate-parameters' }\");\n\n    rsp_return = qdict_get_qdict(rsp, \"return\");\n\n    result = g_strdup_printf(\"%\" PRId64,\n\n                             qdict_get_try_int(rsp_return,  parameter, -1));\n\n    g_assert_cmpstr(result, ==, value);\n\n    QDECREF(rsp);\n\n}\n"},{"project":"qemu","commit_id":"9b990ee5a3cc6aa38f81266fb0c6ef37a36c45b9","target":0,"func":"static void check_watchpoint(int offset, int len, MemTxAttrs attrs, int flags)\n\n{\n\n    CPUState *cpu = current_cpu;\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    CPUArchState *env = cpu->env_ptr;\n\n    target_ulong pc, cs_base;\n\n    target_ulong vaddr;\n\n    CPUWatchpoint *wp;\n\n    uint32_t cpu_flags;\n\n\n\n    assert(tcg_enabled());\n\n    if (cpu->watchpoint_hit) {\n\n        \/* We re-entered the check after replacing the TB. Now raise\n\n         * the debug interrupt so that is will trigger after the\n\n         * current instruction. *\/\n\n        cpu_interrupt(cpu, CPU_INTERRUPT_DEBUG);\n\n        return;\n\n    }\n\n    vaddr = (cpu->mem_io_vaddr & TARGET_PAGE_MASK) + offset;\n\n    vaddr = cc->adjust_watchpoint_address(cpu, vaddr, len);\n\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n\n        if (cpu_watchpoint_address_matches(wp, vaddr, len)\n\n            && (wp->flags & flags)) {\n\n            if (flags == BP_MEM_READ) {\n\n                wp->flags |= BP_WATCHPOINT_HIT_READ;\n\n            } else {\n\n                wp->flags |= BP_WATCHPOINT_HIT_WRITE;\n\n            }\n\n            wp->hitaddr = vaddr;\n\n            wp->hitattrs = attrs;\n\n            if (!cpu->watchpoint_hit) {\n\n                if (wp->flags & BP_CPU &&\n\n                    !cc->debug_check_watchpoint(cpu, wp)) {\n\n                    wp->flags &= ~BP_WATCHPOINT_HIT;\n\n                    continue;\n\n                }\n\n                cpu->watchpoint_hit = wp;\n\n\n\n                \/* Both tb_lock and iothread_mutex will be reset when\n\n                 * cpu_loop_exit or cpu_loop_exit_noexc longjmp\n\n                 * back into the cpu_exec main loop.\n\n                 *\/\n\n                tb_lock();\n\n                tb_check_watchpoint(cpu);\n\n                if (wp->flags & BP_STOP_BEFORE_ACCESS) {\n\n                    cpu->exception_index = EXCP_DEBUG;\n\n                    cpu_loop_exit(cpu);\n\n                } else {\n\n                    cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);\n\n                    tb_gen_code(cpu, pc, cs_base, cpu_flags, 1 | curr_cflags());\n\n                    cpu_loop_exit_noexc(cpu);\n\n                }\n\n            }\n\n        } else {\n\n            wp->flags &= ~BP_WATCHPOINT_HIT;\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"b3db211f3c80bb996a704d665fe275619f728bd4","target":0,"func":"Visitor *visitor_input_test_init(TestInputVisitorData *data,\n\n                                 const char *json_string, ...)\n\n{\n\n    Visitor *v;\n\n    va_list ap;\n\n\n\n    va_start(ap, json_string);\n\n    v = visitor_input_test_init_internal(data, json_string, &ap);\n\n    va_end(ap);\n\n    return v;\n\n}\n"},{"project":"qemu","commit_id":"a7812ae412311d7d47f8aa85656faadac9d64b56","target":0,"func":"static inline void gen_neon_mull(TCGv dest, TCGv a, TCGv b, int size, int u)\n\n{\n\n    TCGv tmp;\n\n\n\n    switch ((size << 1) | u) {\n\n    case 0: gen_helper_neon_mull_s8(dest, a, b); break;\n\n    case 1: gen_helper_neon_mull_u8(dest, a, b); break;\n\n    case 2: gen_helper_neon_mull_s16(dest, a, b); break;\n\n    case 3: gen_helper_neon_mull_u16(dest, a, b); break;\n\n    case 4:\n\n        tmp = gen_muls_i64_i32(a, b);\n\n        tcg_gen_mov_i64(dest, tmp);\n\n        break;\n\n    case 5:\n\n        tmp = gen_mulu_i64_i32(a, b);\n\n        tcg_gen_mov_i64(dest, tmp);\n\n        break;\n\n    default: abort();\n\n    }\n\n    if (size < 2) {\n\n        dead_tmp(b);\n\n        dead_tmp(a);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"57407ea44cc0a3d630b9b89a2be011f1955ce5c1","target":0,"func":"static void spapr_vlan_cleanup(NetClientState *nc)\n\n{\n\n    VIOsPAPRVLANDevice *dev = qemu_get_nic_opaque(nc);\n\n\n\n    dev->nic = NULL;\n\n}\n"},{"project":"qemu","commit_id":"9807caccd605d09a72495637959568d690e10175","target":0,"func":"static uint64_t virtio_pci_config_read(void *opaque, hwaddr addr,\n\n                                       unsigned size)\n\n{\n\n    VirtIOPCIProxy *proxy = opaque;\n\n    uint32_t config = VIRTIO_PCI_CONFIG(&proxy->pci_dev);\n\n    uint64_t val = 0;\n\n    if (addr < config) {\n\n        return virtio_ioport_read(proxy, addr);\n\n    }\n\n    addr -= config;\n\n\n\n    switch (size) {\n\n    case 1:\n\n        val = virtio_config_readb(proxy->vdev, addr);\n\n        break;\n\n    case 2:\n\n        val = virtio_config_readw(proxy->vdev, addr);\n\n        if (virtio_is_big_endian()) {\n\n            val = bswap16(val);\n\n        }\n\n        break;\n\n    case 4:\n\n        val = virtio_config_readl(proxy->vdev, addr);\n\n        if (virtio_is_big_endian()) {\n\n            val = bswap32(val);\n\n        }\n\n        break;\n\n    }\n\n    return val;\n\n}\n"},{"project":"qemu","commit_id":"7d48a0f7217474899c5f5920b21f4cfdf4efa8d1","target":0,"func":"int load_image_gzipped(const char *filename, hwaddr addr, uint64_t max_sz)\n\n{\n\n    uint8_t *compressed_data = NULL;\n\n    uint8_t *data = NULL;\n\n    gsize len;\n\n    ssize_t bytes;\n\n    int ret = -1;\n\n\n\n    if (!g_file_get_contents(filename, (char **) &compressed_data, &len,\n\n                             NULL)) {\n\n        goto out;\n\n    }\n\n\n\n    \/* Is it a gzip-compressed file? *\/\n\n    if (len < 2 ||\n\n        compressed_data[0] != 0x1f ||\n\n        compressed_data[1] != 0x8b) {\n\n        goto out;\n\n    }\n\n\n\n    if (max_sz > LOAD_IMAGE_MAX_GUNZIP_BYTES) {\n\n        max_sz = LOAD_IMAGE_MAX_GUNZIP_BYTES;\n\n    }\n\n\n\n    data = g_malloc(max_sz);\n\n    bytes = gunzip(data, max_sz, compressed_data, len);\n\n    if (bytes < 0) {\n\n        fprintf(stderr, \"%s: unable to decompress gzipped kernel file\\n\",\n\n                filename);\n\n        goto out;\n\n    }\n\n\n\n    rom_add_blob_fixed(filename, data, bytes, addr);\n\n    ret = bytes;\n\n\n\n out:\n\n    g_free(compressed_data);\n\n    g_free(data);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"430eb509d2d05bd568c1394213fd12cb447467a7","target":0,"func":"void bdrv_info(void)\n\n{\n\n    BlockDriverState *bs;\n\n\n\n    for (bs = bdrv_first; bs != NULL; bs = bs->next) {\n\n        term_printf(\"%s:\", bs->device_name);\n\n        term_printf(\" type=\");\n\n        switch(bs->type) {\n\n        case BDRV_TYPE_HD:\n\n            term_printf(\"hd\");\n\n            break;\n\n        case BDRV_TYPE_CDROM:\n\n            term_printf(\"cdrom\");\n\n            break;\n\n        case BDRV_TYPE_FLOPPY:\n\n            term_printf(\"floppy\");\n\n            break;\n\n        }\n\n        term_printf(\" removable=%d\", bs->removable);\n\n        if (bs->removable) {\n\n            term_printf(\" locked=%d\", bs->locked);\n\n        }\n\n        if (bs->drv) {\n\n            term_printf(\" file=\");\n\n\t    term_print_filename(bs->filename);\n\n            if (bs->backing_file[0] != '\\0') {\n\n                term_printf(\" backing_file=\");\n\n\t\tterm_print_filename(bs->backing_file);\n\n\t    }\n\n            term_printf(\" ro=%d\", bs->read_only);\n\n            term_printf(\" drv=%s\", bs->drv->format_name);\n\n            if (bs->encrypted)\n\n                term_printf(\" encrypted\");\n\n        } else {\n\n            term_printf(\" [not inserted]\");\n\n        }\n\n        term_printf(\"\\n\");\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"b40acf99bef69fa8ab0f9092ff162fde945eec12","target":0,"func":"uint32_t cpu_inl(pio_addr_t addr)\n\n{\n\n    uint32_t val;\n\n    val = ioport_read(2, addr);\n\n    trace_cpu_in(addr, val);\n\n    LOG_IOPORT(\"inl : %04\"FMT_pioaddr\" %08\"PRIx32\"\\n\", addr, val);\n\n    return val;\n\n}\n"},{"project":"qemu","commit_id":"d0855f1235ed203700a3a24fc7e138490c272117","target":0,"func":"kern_return_t FindEjectableCDMedia( io_iterator_t *mediaIterator )\n\n{\n\n    kern_return_t       kernResult;\n\n    mach_port_t     masterPort;\n\n    CFMutableDictionaryRef  classesToMatch;\n\n\n\n    kernResult = IOMasterPort( MACH_PORT_NULL, &masterPort );\n\n    if ( KERN_SUCCESS != kernResult ) {\n\n        printf( \"IOMasterPort returned %d\\n\", kernResult );\n\n    }\n\n\n\n    classesToMatch = IOServiceMatching( kIOCDMediaClass );\n\n    if ( classesToMatch == NULL ) {\n\n        printf( \"IOServiceMatching returned a NULL dictionary.\\n\" );\n\n    } else {\n\n    CFDictionarySetValue( classesToMatch, CFSTR( kIOMediaEjectableKey ), kCFBooleanTrue );\n\n    }\n\n    kernResult = IOServiceGetMatchingServices( masterPort, classesToMatch, mediaIterator );\n\n    if ( KERN_SUCCESS != kernResult )\n\n    {\n\n        printf( \"IOServiceGetMatchingServices returned %d\\n\", kernResult );\n\n    }\n\n\n\n    return kernResult;\n\n}\n"},{"project":"qemu","commit_id":"7ea2d269cb84ca7a2f4b7c3735634176f7c1dc35","target":1,"func":"NBDExport *nbd_export_new(BlockDriverState *bs, off_t dev_offset,\n\n                          off_t size, uint32_t nbdflags,\n\n                          void (*close)(NBDExport *))\n\n{\n\n    NBDExport *exp = g_malloc0(sizeof(NBDExport));\n\n    exp->refcount = 1;\n\n    QTAILQ_INIT(&exp->clients);\n\n    exp->bs = bs;\n\n    exp->dev_offset = dev_offset;\n\n    exp->nbdflags = nbdflags;\n\n    exp->size = size == -1 ? bdrv_getlength(bs) : size;\n\n    exp->close = close;\n\n    exp->ctx = bdrv_get_aio_context(bs);\n\n    bdrv_ref(bs);\n\n    bdrv_add_aio_context_notifier(bs, bs_aio_attached, bs_aio_detach, exp);\n\n\n\n\n\n\n\n    return exp;\n\n}"},{"project":"qemu","commit_id":"e4a3507e86a1ef1453d603031bca27d5ac4cff3c","target":0,"func":"static ssize_t test_block_read_func(QCryptoBlock *block,\n\n                                    void *opaque,\n\n                                    size_t offset,\n\n                                    uint8_t *buf,\n\n                                    size_t buflen,\n\n                                    Error **errp)\n\n{\n\n    Buffer *header = opaque;\n\n\n\n    g_assert_cmpint(offset + buflen, <=, header->capacity);\n\n\n\n    memcpy(buf, header->buffer + offset, buflen);\n\n\n\n    return buflen;\n\n}\n"},{"project":"qemu","commit_id":"13f59ae8157e8ec238fa8aefe5309909a1eeb7e2","target":0,"func":"void error_set(Error **errp, const char *fmt, ...)\n\n{\n\n    Error *err;\n\n    va_list ap;\n\n\n\n    if (errp == NULL) {\n\n        return;\n\n    }\n\n    assert(*errp == NULL);\n\n\n\n    err = g_malloc0(sizeof(*err));\n\n\n\n    va_start(ap, fmt);\n\n    err->obj = qobject_to_qdict(qobject_from_jsonv(fmt, &ap));\n\n    va_end(ap);\n\n    err->msg = qerror_format(fmt, err->obj);\n\n\n\n    *errp = err;\n\n}\n"},{"project":"qemu","commit_id":"6f2d8978728c48ca46f5c01835438508aace5c64","target":1,"func":"int mmubooke_get_physical_address (CPUState *env, mmu_ctx_t *ctx,\n\n                                   target_ulong address, int rw,\n\n                                   int access_type)\n\n{\n\n    ppcemb_tlb_t *tlb;\n\n    target_phys_addr_t raddr;\n\n    int i, prot, ret;\n\n\n\n    ret = -1;\n\n    raddr = -1;\n\n    for (i = 0; i < env->nb_tlb; i++) {\n\n        tlb = &env->tlb[i].tlbe;\n\n        if (ppcemb_tlb_check(env, tlb, &raddr, address,\n\n                             env->spr[SPR_BOOKE_PID], 1, i) < 0)\n\n            continue;\n\n        if (msr_pr != 0)\n\n            prot = tlb->prot & 0xF;\n\n        else\n\n            prot = (tlb->prot >> 4) & 0xF;\n\n        \/* Check the address space *\/\n\n        if (access_type == ACCESS_CODE) {\n\n            if (msr_ir != (tlb->attr & 1))\n\n                continue;\n\n            ctx->prot = prot;\n\n            if (prot & PAGE_EXEC) {\n\n                ret = 0;\n\n                break;\n\n            }\n\n            ret = -3;\n\n        } else {\n\n            if (msr_dr != (tlb->attr & 1))\n\n                continue;\n\n            ctx->prot = prot;\n\n            if ((!rw && prot & PAGE_READ) || (rw && (prot & PAGE_WRITE))) {\n\n                ret = 0;\n\n                break;\n\n            }\n\n            ret = -2;\n\n        }\n\n    }\n\n    if (ret >= 0)\n\n        ctx->raddr = raddr;\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"c5633d998a27502ad8cc10c2d46f91b02555ae7a","target":1,"func":"static void xen_read_physmap(XenIOState *state)\n\n{\n\n    XenPhysmap *physmap = NULL;\n\n    unsigned int len, num, i;\n\n    char path[80], *value = NULL;\n\n    char **entries = NULL;\n\n\n\n    snprintf(path, sizeof(path),\n\n            \"\/local\/domain\/0\/device-model\/%d\/physmap\", xen_domid);\n\n    entries = xs_directory(state->xenstore, 0, path, &num);\n\n    if (entries == NULL)\n\n        return;\n\n\n\n    for (i = 0; i < num; i++) {\n\n        physmap = g_malloc(sizeof (XenPhysmap));\n\n        physmap->phys_offset = strtoull(entries[i], NULL, 16);\n\n        snprintf(path, sizeof(path),\n\n                \"\/local\/domain\/0\/device-model\/%d\/physmap\/%s\/start_addr\",\n\n                xen_domid, entries[i]);\n\n        value = xs_read(state->xenstore, 0, path, &len);\n\n        if (value == NULL) {\n\n            free(physmap);\n\n            continue;\n\n        }\n\n        physmap->start_addr = strtoull(value, NULL, 16);\n\n        free(value);\n\n\n\n        snprintf(path, sizeof(path),\n\n                \"\/local\/domain\/0\/device-model\/%d\/physmap\/%s\/size\",\n\n                xen_domid, entries[i]);\n\n        value = xs_read(state->xenstore, 0, path, &len);\n\n        if (value == NULL) {\n\n            free(physmap);\n\n            continue;\n\n        }\n\n        physmap->size = strtoull(value, NULL, 16);\n\n        free(value);\n\n\n\n        snprintf(path, sizeof(path),\n\n                \"\/local\/domain\/0\/device-model\/%d\/physmap\/%s\/name\",\n\n                xen_domid, entries[i]);\n\n        physmap->name = xs_read(state->xenstore, 0, path, &len);\n\n\n\n        QLIST_INSERT_HEAD(&state->physmap, physmap, list);\n\n    }\n\n    free(entries);\n\n}\n"},{"project":"qemu","commit_id":"fd56e0612b6454a282fa6a953fdb09281a98c589","target":0,"func":"AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)\n\n{\n\n    PCIBus *bus = PCI_BUS(dev->bus);\n\n    PCIBus *iommu_bus = bus;\n\n\n\n    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {\n\n        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);\n\n    }\n\n    if (iommu_bus && iommu_bus->iommu_fn) {\n\n        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);\n\n    }\n\n    return &address_space_memory;\n\n}\n"},{"project":"qemu","commit_id":"5839e53bbc0fec56021d758aab7610df421ed8c8","target":1,"func":"void bdrv_op_block(BlockDriverState *bs, BlockOpType op, Error *reason)\n\n{\n\n    BdrvOpBlocker *blocker;\n\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n\n\n\n    blocker = g_malloc0(sizeof(BdrvOpBlocker));\n\n    blocker->reason = reason;\n\n    QLIST_INSERT_HEAD(&bs->op_blockers[op], blocker, list);\n\n}\n"},{"project":"qemu","commit_id":"0a12f6f80eeebeebd492db7d8c4237fe5c712f68","target":1,"func":"static ImageInfoSpecific *qcow2_get_specific_info(BlockDriverState *bs)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    ImageInfoSpecific *spec_info = g_new(ImageInfoSpecific, 1);\n\n\n\n    *spec_info = (ImageInfoSpecific){\n\n        .type  = IMAGE_INFO_SPECIFIC_KIND_QCOW2,\n\n        .u.qcow2.data = g_new(ImageInfoSpecificQCow2, 1),\n\n    };\n\n    if (s->qcow_version == 2) {\n\n        *spec_info->u.qcow2.data = (ImageInfoSpecificQCow2){\n\n            .compat             = g_strdup(\"0.10\"),\n\n            .refcount_bits      = s->refcount_bits,\n\n        };\n\n    } else if (s->qcow_version == 3) {\n\n        *spec_info->u.qcow2.data = (ImageInfoSpecificQCow2){\n\n            .compat             = g_strdup(\"1.1\"),\n\n            .lazy_refcounts     = s->compatible_features &\n\n                                  QCOW2_COMPAT_LAZY_REFCOUNTS,\n\n            .has_lazy_refcounts = true,\n\n            .corrupt            = s->incompatible_features &\n\n                                  QCOW2_INCOMPAT_CORRUPT,\n\n            .has_corrupt        = true,\n\n            .refcount_bits      = s->refcount_bits,\n\n        };\n\n    } else {\n\n        \/* if this assertion fails, this probably means a new version was\n\n         * added without having it covered here *\/\n\n        assert(false);\n\n    }\n\n\n\n    return spec_info;\n\n}\n"},{"project":"qemu","commit_id":"69d34a360dfe773e17e72c76d15931c9b9d190f6","target":1,"func":"static int dmg_open(BlockDriverState *bs, int flags)\n\n{\n\n    BDRVDMGState *s = bs->opaque;\n\n    off_t info_begin,info_end,last_in_offset,last_out_offset;\n\n    uint32_t count;\n\n    uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i;\n\n    int64_t offset;\n\n\n\n    bs->read_only = 1;\n\n    s->n_chunks = 0;\n\n    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;\n\n\n\n    \/* read offset of info blocks *\/\n\n    offset = bdrv_getlength(bs->file);\n\n    if (offset < 0) {\n\n        goto fail;\n\n    }\n\n    offset -= 0x1d8;\n\n\n\n    info_begin = read_off(bs, offset);\n\n    if (info_begin == 0) {\n\n\tgoto fail;\n\n    }\n\n\n\n    if (read_uint32(bs, info_begin) != 0x100) {\n\n        goto fail;\n\n    }\n\n\n\n    count = read_uint32(bs, info_begin + 4);\n\n    if (count == 0) {\n\n        goto fail;\n\n    }\n\n    info_end = info_begin + count;\n\n\n\n    offset = info_begin + 0x100;\n\n\n\n    \/* read offsets *\/\n\n    last_in_offset = last_out_offset = 0;\n\n    while (offset < info_end) {\n\n        uint32_t type;\n\n\n\n\tcount = read_uint32(bs, offset);\n\n\tif(count==0)\n\n\t    goto fail;\n\n        offset += 4;\n\n\n\n\ttype = read_uint32(bs, offset);\n\n\tif (type == 0x6d697368 && count >= 244) {\n\n\t    int new_size, chunk_count;\n\n\n\n            offset += 4;\n\n            offset += 200;\n\n\n\n\t    chunk_count = (count-204)\/40;\n\n\t    new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\n\n\t    s->types = g_realloc(s->types, new_size\/2);\n\n\t    s->offsets = g_realloc(s->offsets, new_size);\n\n\t    s->lengths = g_realloc(s->lengths, new_size);\n\n\t    s->sectors = g_realloc(s->sectors, new_size);\n\n\t    s->sectorcounts = g_realloc(s->sectorcounts, new_size);\n\n\n\n\t    for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) {\n\n\t\ts->types[i] = read_uint32(bs, offset);\n\n\t\toffset += 4;\n\n\t\tif(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) {\n\n\t\t    if(s->types[i]==0xffffffff) {\n\n\t\t\tlast_in_offset = s->offsets[i-1]+s->lengths[i-1];\n\n\t\t\tlast_out_offset = s->sectors[i-1]+s->sectorcounts[i-1];\n\n\t\t    }\n\n\t\t    chunk_count--;\n\n\t\t    i--;\n\n\t\t    offset += 36;\n\n\t\t    continue;\n\n\t\t}\n\n\t\toffset += 4;\n\n\n\n\t\ts->sectors[i] = last_out_offset+read_off(bs, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->sectorcounts[i] = read_off(bs, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->offsets[i] = last_in_offset+read_off(bs, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->lengths[i] = read_off(bs, offset);\n\n\t\toffset += 8;\n\n\n\n\t\tif(s->lengths[i]>max_compressed_size)\n\n\t\t    max_compressed_size = s->lengths[i];\n\n\t\tif(s->sectorcounts[i]>max_sectors_per_chunk)\n\n\t\t    max_sectors_per_chunk = s->sectorcounts[i];\n\n\t    }\n\n\t    s->n_chunks+=chunk_count;\n\n\t}\n\n    }\n\n\n\n    \/* initialize zlib engine *\/\n\n    s->compressed_chunk = g_malloc(max_compressed_size+1);\n\n    s->uncompressed_chunk = g_malloc(512*max_sectors_per_chunk);\n\n    if(inflateInit(&s->zstream) != Z_OK)\n\n\tgoto fail;\n\n\n\n    s->current_chunk = s->n_chunks;\n\n\n\n    qemu_co_mutex_init(&s->lock);\n\n    return 0;\n\nfail:\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"f22d85e9e67262db34504f4079745f9843da6a92","target":0,"func":"static void disable_logging(void)\n\n{\n\n    ga_disable_logging(ga_state);\n\n}\n"},{"project":"qemu","commit_id":"ab2b9f174db088633922eaa82c2bcffd84e6bb94","target":1,"func":"int print_insn_lm32(bfd_vma memaddr, struct disassemble_info *info)\n\n{\n\n    fprintf_function fprintf_fn = info->fprintf_func;\n\n    void *stream = info->stream;\n\n    int rc;\n\n    uint8_t insn[4];\n\n    const Lm32OpcodeInfo *opc_info;\n\n    uint32_t op;\n\n    const char *args_fmt;\n\n\n\n    rc = info->read_memory_func(memaddr, insn, 4, info);\n\n    if (rc != 0) {\n\n        info->memory_error_func(rc, memaddr, info);\n\n        return -1;\n\n    }\n\n\n\n    fprintf_fn(stream, \"%02x %02x %02x %02x    \",\n\n            insn[0], insn[1], insn[2], insn[3]);\n\n\n\n    op = bfd_getb32(insn);\n\n    opc_info = find_opcode_info(op);\n\n    if (opc_info) {\n\n        fprintf_fn(stream, \"%-8s \", opc_info->name);\n\n        args_fmt = opc_info->args_fmt;\n\n        while (args_fmt && *args_fmt) {\n\n            if (*args_fmt == '%') {\n\n                switch (*(++args_fmt)) {\n\n                case '0': {\n\n                    uint8_t r0;\n\n                    const char *r0_name;\n\n                    r0 = (op >> 21) & 0x1f;\n\n                    r0_name = find_reg_info(r0)->name;\n\n                    fprintf_fn(stream, \"%s\", r0_name);\n\n                    break;\n\n                }\n\n                case '1': {\n\n                    uint8_t r1;\n\n                    const char *r1_name;\n\n                    r1 = (op >> 16) & 0x1f;\n\n                    r1_name = find_reg_info(r1)->name;\n\n                    fprintf_fn(stream, \"%s\", r1_name);\n\n                    break;\n\n                }\n\n                case '2': {\n\n                    uint8_t r2;\n\n                    const char *r2_name;\n\n                    r2 = (op >> 11) & 0x1f;\n\n                    r2_name = find_reg_info(r2)->name;\n\n                    fprintf_fn(stream, \"%s\", r2_name);\n\n                    break;\n\n                }\n\n                case 'c': {\n\n                    uint8_t csr;\n\n                    const char *csr_name;\n\n                    csr = (op >> 21) & 0x1f;\n\n                    csr_name = find_csr_info(csr)->name;\n\n                    if (csr_name) {\n\n                        fprintf_fn(stream, \"%s\", csr_name);\n\n                    } else {\n\n                        fprintf_fn(stream, \"0x%x\", csr);\n\n                    }\n\n                    break;\n\n                }\n\n                case 'u': {\n\n                    uint16_t u16;\n\n                    u16 = op & 0xffff;\n\n                    fprintf_fn(stream, \"0x%x\", u16);\n\n                    break;\n\n                }\n\n                case 's': {\n\n                    int16_t s16;\n\n                    s16 = (int16_t)(op & 0xffff);\n\n                    fprintf_fn(stream, \"%d\", s16);\n\n                    break;\n\n                }\n\n                case 'r': {\n\n                    uint32_t rela;\n\n                    rela = memaddr + (((int16_t)(op & 0xffff)) << 2);\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'R': {\n\n                    uint32_t rela;\n\n                    int32_t imm26;\n\n                    imm26 = (int32_t)((op & 0x3ffffff) << 6) >> 4;\n\n                    rela = memaddr + imm26;\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'h': {\n\n                    uint8_t u5;\n\n                    u5 = (op & 0x1f);\n\n                    fprintf_fn(stream, \"%d\", u5);\n\n                    break;\n\n                }\n\n                default:\n\n                    break;\n\n                }\n\n            } else {\n\n                fprintf_fn(stream, \"%c\", *args_fmt);\n\n            }\n\n            args_fmt++;\n\n        }\n\n    } else {\n\n        fprintf_fn(stream, \".word 0x%x\", op);\n\n    }\n\n\n\n    return 4;\n\n}\n"},{"project":"qemu","commit_id":"c4237dfa635900e4d1cdc6038d5efe3507f45f0c","target":1,"func":"static void mirror_write_complete(void *opaque, int ret)\n\n{\n\n    MirrorOp *op = opaque;\n\n    MirrorBlockJob *s = op->s;\n\n    if (ret < 0) {\n\n        BlockDriverState *source = s->common.bs;\n\n        BlockErrorAction action;\n\n\n\n        bdrv_set_dirty(source, op->sector_num, op->nb_sectors);\n\n        action = mirror_error_action(s, false, -ret);\n\n        if (action == BLOCK_ERROR_ACTION_REPORT && s->ret >= 0) {\n\n            s->ret = ret;\n\n        }\n\n    }\n\n    mirror_iteration_done(op, ret);\n\n}\n"},{"project":"qemu","commit_id":"d7a4155265416a1c8f3067b59e68bf5fda1d6215","target":0,"func":"static int e1000_post_load(void *opaque, int version_id)\n\n{\n\n    E1000State *s = opaque;\n\n    NetClientState *nc = qemu_get_queue(s->nic);\n\n\n\n    if (!(s->compat_flags & E1000_FLAG_MIT)) {\n\n        s->mac_reg[ITR] = s->mac_reg[RDTR] = s->mac_reg[RADV] =\n\n            s->mac_reg[TADV] = 0;\n\n        s->mit_irq_level = false;\n\n    }\n\n    s->mit_ide = 0;\n\n    s->mit_timer_on = false;\n\n\n\n    \/* nc.link_down can't be migrated, so infer link_down according\n\n     * to link status bit in mac_reg[STATUS].\n\n     * Alternatively, restart link negotiation if it was in progress. *\/\n\n    nc->link_down = (s->mac_reg[STATUS] & E1000_STATUS_LU) == 0;\n\n\n\n    if (s->compat_flags & E1000_FLAG_AUTONEG &&\n\n        s->phy_reg[PHY_CTRL] & MII_CR_AUTO_NEG_EN &&\n\n        s->phy_reg[PHY_CTRL] & MII_CR_RESTART_AUTO_NEG &&\n\n        !(s->phy_reg[PHY_STATUS] & MII_SR_AUTONEG_COMPLETE)) {\n\n        nc->link_down = false;\n\n        timer_mod(s->autoneg_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + 500);\n\n    }\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"eabb7b91b36b202b4dac2df2d59d698e3aff197a","target":0,"func":"static inline void tcg_out_rld(TCGContext *s, int op, TCGReg ra, TCGReg rs,\n\n                               int sh, int mb)\n\n{\n\n    assert(TCG_TARGET_REG_BITS == 64);\n\n    sh = SH(sh & 0x1f) | (((sh >> 5) & 1) << 1);\n\n    mb = MB64((mb >> 5) | ((mb << 1) & 0x3f));\n\n    tcg_out32(s, op | RA(ra) | RS(rs) | sh | mb);\n\n}\n"},{"project":"qemu","commit_id":"91a9ecefb6d7f066c6eecc09f7231ce7969d1817","target":1,"func":"int setenv(const char *name, const char *value, int overwrite)\n{\n    int result = 0;\n    if (overwrite || !getenv(name)) {\n        size_t length = strlen(name) + strlen(value) + 2;\n        char *string = g_malloc(length);\n        snprintf(string, length, \"%s=%s\", name, value);\n        result = putenv(string);\n    }\n    return result;\n}"},{"project":"qemu","commit_id":"0b8b8753e4d94901627b3e86431230f2319215c4","target":1,"func":"static void coroutine_fn nest(void *opaque)\n\n{\n\n    NestData *nd = opaque;\n\n\n\n    nd->n_enter++;\n\n\n\n    if (nd->n_enter < nd->max) {\n\n        Coroutine *child;\n\n\n\n        child = qemu_coroutine_create(nest);\n\n        qemu_coroutine_enter(child, nd);\n\n    }\n\n\n\n    nd->n_return++;\n\n}\n"},{"project":"qemu","commit_id":"3468b59e18b179bc63c7ce934de912dfa9596122","target":0,"func":"size_t tcg_code_size(void)\n\n{\n\n    unsigned int i;\n\n    size_t total;\n\n\n\n    qemu_mutex_lock(&region.lock);\n\n    total = region.agg_size_full;\n\n    for (i = 0; i < n_tcg_ctxs; i++) {\n\n        const TCGContext *s = tcg_ctxs[i];\n\n        size_t size;\n\n\n\n        size = atomic_read(&s->code_gen_ptr) - s->code_gen_buffer;\n\n        g_assert(size <= s->code_gen_buffer_size);\n\n        total += size;\n\n    }\n\n    qemu_mutex_unlock(&region.lock);\n\n    return total;\n\n}\n"},{"project":"qemu","commit_id":"0c9390d978cbf61e8f16c9f580fa96b305c43568","target":1,"func":"static coroutine_fn void nbd_co_client_start(void *opaque)\n\n{\n\n    NBDClientNewData *data = opaque;\n\n    NBDClient *client = data->client;\n\n    NBDExport *exp = client->exp;\n\n\n\n    if (exp) {\n\n        nbd_export_get(exp);\n\n        QTAILQ_INSERT_TAIL(&exp->clients, client, next);\n\n    }\n\n    qemu_co_mutex_init(&client->send_lock);\n\n\n\n    if (nbd_negotiate(data)) {\n\n        client_close(client);\n\n        goto out;\n\n    }\n\n\n\n    nbd_client_receive_next_request(client);\n\n\n\nout:\n\n    g_free(data);\n\n}\n"},{"project":"qemu","commit_id":"74b4c74d5efb0a489bdf0acc5b5d0197167e7649","target":0,"func":"static void sigp_initial_cpu_reset(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);\n\n    SigpInfo *si = arg.host_ptr;\n\n\n\n    cpu_synchronize_state(cs);\n\n    scc->initial_cpu_reset(cs);\n\n    cpu_synchronize_post_reset(cs);\n\n    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n}\n"},{"project":"qemu","commit_id":"fbfecf43e9d354cfae04496563f7bb87d2ccde46","target":0,"func":"static uint64_t pl050_read(void *opaque, hwaddr offset,\n\n                           unsigned size)\n\n{\n\n    pl050_state *s = (pl050_state *)opaque;\n\n    if (offset >= 0xfe0 && offset < 0x1000)\n\n        return pl050_id[(offset - 0xfe0) >> 2];\n\n\n\n    switch (offset >> 2) {\n\n    case 0: \/* KMICR *\/\n\n        return s->cr;\n\n    case 1: \/* KMISTAT *\/\n\n        {\n\n            uint8_t val;\n\n            uint32_t stat;\n\n\n\n            val = s->last;\n\n            val = val ^ (val >> 4);\n\n            val = val ^ (val >> 2);\n\n            val = (val ^ (val >> 1)) & 1;\n\n\n\n            stat = PL050_TXEMPTY;\n\n            if (val)\n\n                stat |= PL050_RXPARITY;\n\n            if (s->pending)\n\n                stat |= PL050_RXFULL;\n\n\n\n            return stat;\n\n        }\n\n    case 2: \/* KMIDATA *\/\n\n        if (s->pending)\n\n            s->last = ps2_read_data(s->dev);\n\n        return s->last;\n\n    case 3: \/* KMICLKDIV *\/\n\n        return s->clk;\n\n    case 4: \/* KMIIR *\/\n\n        return s->pending | 2;\n\n    default:\n\n        hw_error(\"pl050_read: Bad offset %x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"91b0a8f33419573c1d741e49559bfb666fd8b1f0","target":0,"func":"void css_conditional_io_interrupt(SubchDev *sch)\n\n{\n\n    \/*\n\n     * If the subchannel is not currently status pending, make it pending\n\n     * with alert status.\n\n     *\/\n\n    if (!(sch->curr_status.scsw.ctrl & SCSW_STCTL_STATUS_PEND)) {\n\n        S390CPU *cpu = s390_cpu_addr2state(0);\n\n        uint8_t isc = (sch->curr_status.pmcw.flags & PMCW_FLAGS_MASK_ISC) >> 11;\n\n\n\n        trace_css_io_interrupt(sch->cssid, sch->ssid, sch->schid,\n\n                               sch->curr_status.pmcw.intparm, isc,\n\n                               \"(unsolicited)\");\n\n        sch->curr_status.scsw.ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n        sch->curr_status.scsw.ctrl |=\n\n            SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n        \/* Inject an I\/O interrupt. *\/\n\n        s390_io_interrupt(cpu,\n\n                          css_build_subchannel_id(sch),\n\n                          sch->schid,\n\n                          sch->curr_status.pmcw.intparm,\n\n                          (0x80 >> isc) << 24);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"560f19f162529d691619ac69ed032321c7f5f1fb","target":1,"func":"char *object_property_get_str(Object *obj, const char *name,\n\n                              Error **errp)\n\n{\n\n    QObject *ret = object_property_get_qobject(obj, name, errp);\n\n    QString *qstring;\n\n    char *retval;\n\n\n\n    if (!ret) {\n\n        return NULL;\n\n    }\n\n    qstring = qobject_to_qstring(ret);\n\n    if (!qstring) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name, \"string\");\n\n        retval = NULL;\n\n    } else {\n\n        retval = g_strdup(qstring_get_str(qstring));\n\n    }\n\n\n\n    QDECREF(qstring);\n\n    return retval;\n\n}\n"},{"project":"qemu","commit_id":"3ba235a02284c39b34a68a2a588508ffb52a7b55","target":0,"func":"void aio_set_fd_handler(AioContext *ctx,\n\n                        int fd,\n\n                        IOHandler *io_read,\n\n                        IOHandler *io_write,\n\n                        void *opaque)\n\n{\n\n    \/* fd is a SOCKET in our case *\/\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.fd == fd && !node->deleted) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    \/* Are we deleting the fd handler? *\/\n\n    if (!io_read && !io_write) {\n\n        if (node) {\n\n            \/* If the lock is held, just mark the node as deleted *\/\n\n            if (ctx->walking_handlers) {\n\n                node->deleted = 1;\n\n                node->pfd.revents = 0;\n\n            } else {\n\n                \/* Otherwise, delete it for real.  We can't just mark it as\n\n                 * deleted because deleted nodes are only cleaned up after\n\n                 * releasing the walking_handlers lock.\n\n                 *\/\n\n                QLIST_REMOVE(node, node);\n\n                g_free(node);\n\n            }\n\n        }\n\n    } else {\n\n        HANDLE event;\n\n\n\n        if (node == NULL) {\n\n            \/* Alloc and insert if it's not already there *\/\n\n            node = g_malloc0(sizeof(AioHandler));\n\n            node->pfd.fd = fd;\n\n            QLIST_INSERT_HEAD(&ctx->aio_handlers, node, node);\n\n        }\n\n\n\n        node->pfd.events = 0;\n\n        if (node->io_read) {\n\n            node->pfd.events |= G_IO_IN;\n\n        }\n\n        if (node->io_write) {\n\n            node->pfd.events |= G_IO_OUT;\n\n        }\n\n\n\n        node->e = &ctx->notifier;\n\n\n\n        \/* Update handler with latest information *\/\n\n        node->opaque = opaque;\n\n        node->io_read = io_read;\n\n        node->io_write = io_write;\n\n\n\n        event = event_notifier_get_handle(&ctx->notifier);\n\n        WSAEventSelect(node->pfd.fd, event,\n\n                       FD_READ | FD_ACCEPT | FD_CLOSE |\n\n                       FD_CONNECT | FD_WRITE | FD_OOB);\n\n    }\n\n\n\n    aio_notify(ctx);\n\n}\n"},{"project":"qemu","commit_id":"166dbda7e131f7b6540f56c3234bb2f8b23d84c0","target":1,"func":"static bool scsi_block_is_passthrough(SCSIDiskState *s, uint8_t *buf)\n\n{\n\n    switch (buf[0]) {\n\n    case VERIFY_10:\n\n    case VERIFY_12:\n\n    case VERIFY_16:\n\n        \/* Check if BYTCHK == 0x01 (data-out buffer contains data\n\n         * for the number of logical blocks specified in the length\n\n         * field).  For other modes, do not use scatter\/gather operation.\n\n         *\/\n\n        if ((buf[1] & 6) != 2) {\n\n            return false;\n\n        }\n\n        break;\n\n\n\n    case READ_6:\n\n    case READ_10:\n\n    case READ_12:\n\n    case READ_16:\n\n    case WRITE_6:\n\n    case WRITE_10:\n\n    case WRITE_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_VERIFY_16:\n\n        \/* MMC writing cannot be done via DMA helpers, because it sometimes\n\n         * involves writing beyond the maximum LBA or to negative LBA (lead-in).\n\n         * We might use scsi_disk_dma_reqops as long as no writing commands are\n\n         * seen, but performance usually isn't paramount on optical media.  So,\n\n         * just make scsi-block operate the same as scsi-generic for them.\n\n         *\/\n\n        if (s->qdev.type != TYPE_ROM) {\n\n            return false;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    return true;\n\n}\n"},{"project":"qemu","commit_id":"f090c9d4ad5812fb92843d6470a1111c15190c4c","target":0,"func":"int float32_eq( float32 a, float32 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat32Exp( a ) == 0xFF ) && extractFloat32Frac( a ) )\n\n         || ( ( extractFloat32Exp( b ) == 0xFF ) && extractFloat32Frac( b ) )\n\n       ) {\n\n        if ( float32_is_signaling_nan( a ) || float32_is_signaling_nan( b ) ) {\n\n            float_raise( float_flag_invalid STATUS_VAR);\n\n        }\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits32) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n"},{"project":"qemu","commit_id":"b3db211f3c80bb996a704d665fe275619f728bd4","target":0,"func":"static void test_visitor_out_enum_errors(TestOutputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    EnumOne i, bad_values[] = { ENUM_ONE__MAX, -1 };\n\n    Error *err;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(bad_values) ; i++) {\n\n        err = NULL;\n\n        visit_type_EnumOne(data->ov, \"unused\", &bad_values[i], &err);\n\n        g_assert(err);\n\n        error_free(err);\n\n        visitor_reset(data);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a5b8dd2ce83208cd7d6eb4562339ecf5aae13574","target":0,"func":"static int bdrv_open_common(BlockDriverState *bs, BdrvChild *file,\n\n                            QDict *options, Error **errp)\n\n{\n\n    int ret, open_flags;\n\n    const char *filename;\n\n    const char *driver_name = NULL;\n\n    const char *node_name = NULL;\n\n    QemuOpts *opts;\n\n    BlockDriver *drv;\n\n    Error *local_err = NULL;\n\n\n\n    assert(bs->file == NULL);\n\n    assert(options != NULL && bs->options != options);\n\n\n\n    opts = qemu_opts_create(&bdrv_runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail_opts;\n\n    }\n\n\n\n    driver_name = qemu_opt_get(opts, \"driver\");\n\n    drv = bdrv_find_format(driver_name);\n\n    assert(drv != NULL);\n\n\n\n    if (file != NULL) {\n\n        filename = file->bs->filename;\n\n    } else {\n\n        filename = qdict_get_try_str(options, \"filename\");\n\n    }\n\n\n\n    if (drv->bdrv_needs_filename && !filename) {\n\n        error_setg(errp, \"The '%s' block driver requires a file name\",\n\n                   drv->format_name);\n\n        ret = -EINVAL;\n\n        goto fail_opts;\n\n    }\n\n\n\n    trace_bdrv_open_common(bs, filename ?: \"\", bs->open_flags,\n\n                           drv->format_name);\n\n\n\n    node_name = qemu_opt_get(opts, \"node-name\");\n\n    bdrv_assign_node_name(bs, node_name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail_opts;\n\n    }\n\n\n\n    bs->read_only = !(bs->open_flags & BDRV_O_RDWR);\n\n\n\n    if (use_bdrv_whitelist && !bdrv_is_whitelisted(drv, bs->read_only)) {\n\n        error_setg(errp,\n\n                   !bs->read_only && bdrv_is_whitelisted(drv, true)\n\n                        ? \"Driver '%s' can only be used for read-only devices\"\n\n                        : \"Driver '%s' is not whitelisted\",\n\n                   drv->format_name);\n\n        ret = -ENOTSUP;\n\n        goto fail_opts;\n\n    }\n\n\n\n    assert(bs->copy_on_read == 0); \/* bdrv_new() and bdrv_close() make it so *\/\n\n    if (bs->open_flags & BDRV_O_COPY_ON_READ) {\n\n        if (!bs->read_only) {\n\n            bdrv_enable_copy_on_read(bs);\n\n        } else {\n\n            error_setg(errp, \"Can't use copy-on-read on read-only device\");\n\n            ret = -EINVAL;\n\n            goto fail_opts;\n\n        }\n\n    }\n\n\n\n    if (filename != NULL) {\n\n        pstrcpy(bs->filename, sizeof(bs->filename), filename);\n\n    } else {\n\n        bs->filename[0] = '\\0';\n\n    }\n\n    pstrcpy(bs->exact_filename, sizeof(bs->exact_filename), bs->filename);\n\n\n\n    bs->drv = drv;\n\n    bs->opaque = g_malloc0(drv->instance_size);\n\n\n\n    \/* Apply cache mode options *\/\n\n    update_flags_from_options(&bs->open_flags, opts);\n\n\n\n    \/* Open the image, either directly or using a protocol *\/\n\n    open_flags = bdrv_open_flags(bs, bs->open_flags);\n\n    if (drv->bdrv_file_open) {\n\n        assert(file == NULL);\n\n        assert(!drv->bdrv_needs_filename || filename != NULL);\n\n        ret = drv->bdrv_file_open(bs, options, open_flags, &local_err);\n\n    } else {\n\n        if (file == NULL) {\n\n            error_setg(errp, \"Can't use '%s' as a block driver for the \"\n\n                       \"protocol level\", drv->format_name);\n\n            ret = -EINVAL;\n\n            goto free_and_fail;\n\n        }\n\n        bs->file = file;\n\n        ret = drv->bdrv_open(bs, options, open_flags, &local_err);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n        } else if (bs->filename[0]) {\n\n            error_setg_errno(errp, -ret, \"Could not open '%s'\", bs->filename);\n\n        } else {\n\n            error_setg_errno(errp, -ret, \"Could not open image\");\n\n        }\n\n        goto free_and_fail;\n\n    }\n\n\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n\n        goto free_and_fail;\n\n    }\n\n\n\n    bdrv_refresh_limits(bs, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto free_and_fail;\n\n    }\n\n\n\n    assert(bdrv_opt_mem_align(bs) != 0);\n\n    assert(bdrv_min_mem_align(bs) != 0);\n\n    assert(is_power_of_2(bs->request_alignment) || bdrv_is_sg(bs));\n\n\n\n    qemu_opts_del(opts);\n\n    return 0;\n\n\n\nfree_and_fail:\n\n    bs->file = NULL;\n\n    g_free(bs->opaque);\n\n    bs->opaque = NULL;\n\n    bs->drv = NULL;\n\nfail_opts:\n\n    qemu_opts_del(opts);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"1ac157da77c863b62b1d2f467626a440d57cf17d","target":0,"func":"void cpu_x86_update_cr3(CPUX86State *env)\n\n{\n\n    if (env->cr[0] & CR0_PG_MASK) {\n\n#if defined(DEBUG_MMU)\n\n        printf(\"CR3 update: CR3=%08x\\n\", env->cr[3]);\n\n#endif\n\n        tlb_flush(env);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"3ad9fd5a257794d516db515c217c78a5806112fe","target":1,"func":"static int64_t load_kernel (void)\n\n{\n\n    int64_t kernel_entry, kernel_high;\n\n    long initrd_size;\n\n    ram_addr_t initrd_offset;\n\n    int big_endian;\n\n    uint32_t *prom_buf;\n\n    long prom_size;\n\n    int prom_index = 0;\n\n    uint64_t (*xlate_to_kseg0) (void *opaque, uint64_t addr);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    big_endian = 1;\n\n#else\n\n    big_endian = 0;\n\n#endif\n\n\n\n    if (load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys, NULL,\n\n                 (uint64_t *)&kernel_entry, NULL, (uint64_t *)&kernel_high,\n\n                 big_endian, ELF_MACHINE, 1) < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                loaderparams.kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    \/* Sanity check where the kernel has been linked *\/\n\n    if (kvm_enabled()) {\n\n        if (kernel_entry & 0x80000000ll) {\n\n            error_report(\"KVM guest kernels must be linked in useg. \"\n\n                         \"Did you forget to enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_kvm_um_phys_to_kseg0;\n\n    } else {\n\n        if (!(kernel_entry & 0x80000000ll)) {\n\n            error_report(\"KVM guest kernels aren't supported with TCG. \"\n\n                         \"Did you unintentionally enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_phys_to_kseg0;\n\n    }\n\n\n\n    \/* load initrd *\/\n\n    initrd_size = 0;\n\n    initrd_offset = 0;\n\n    if (loaderparams.initrd_filename) {\n\n        initrd_size = get_image_size (loaderparams.initrd_filename);\n\n        if (initrd_size > 0) {\n\n            initrd_offset = (kernel_high + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;\n\n            if (initrd_offset + initrd_size > ram_size) {\n\n                fprintf(stderr,\n\n                        \"qemu: memory too small for initial ram disk '%s'\\n\",\n\n                        loaderparams.initrd_filename);\n\n                exit(1);\n\n            }\n\n            initrd_size = load_image_targphys(loaderparams.initrd_filename,\n\n                                              initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n        }\n\n        if (initrd_size == (target_ulong) -1) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    loaderparams.initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    \/* Setup prom parameters. *\/\n\n    prom_size = ENVP_NB_ENTRIES * (sizeof(int32_t) + ENVP_ENTRY_SIZE);\n\n    prom_buf = g_malloc(prom_size);\n\n\n\n    prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_filename);\n\n    if (initrd_size > 0) {\n\n        prom_set(prom_buf, prom_index++, \"rd_start=0x%\" PRIx64 \" rd_size=%li %s\",\n\n                 xlate_to_kseg0(NULL, initrd_offset), initrd_size,\n\n                 loaderparams.kernel_cmdline);\n\n    } else {\n\n        prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_cmdline);\n\n    }\n\n\n\n    prom_set(prom_buf, prom_index++, \"memsize\");\n\n    prom_set(prom_buf, prom_index++, \"%i\",\n\n             MIN(loaderparams.ram_size, 256 << 20));\n\n\n\n    prom_set(prom_buf, prom_index++, \"modetty0\");\n\n    prom_set(prom_buf, prom_index++, \"38400n8r\");\n\n    prom_set(prom_buf, prom_index++, NULL);\n\n\n\n    rom_add_blob_fixed(\"prom\", prom_buf, prom_size,\n\n                       cpu_mips_kseg0_to_phys(NULL, ENVP_ADDR));\n\n\n\n\n    return kernel_entry;\n\n}"},{"project":"qemu","commit_id":"9586fefefe383a9aa25ad99bde9a6b240309ca33","target":1,"func":"static int cirrus_vga_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    CirrusVGAState *s = opaque;\n\n    int ret;\n\n\n\n    if (version_id > 2)\n\n        return -EINVAL;\n\n\n\n    if (s->pci_dev && version_id >= 2) {\n\n        ret = pci_device_load(s->pci_dev, f);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    qemu_get_be32s(f, &s->latch);\n\n    qemu_get_8s(f, &s->sr_index);\n\n    qemu_get_buffer(f, s->sr, 256);\n\n    qemu_get_8s(f, &s->gr_index);\n\n    qemu_get_8s(f, &s->cirrus_shadow_gr0);\n\n    qemu_get_8s(f, &s->cirrus_shadow_gr1);\n\n    s->gr[0x00] = s->cirrus_shadow_gr0 & 0x0f;\n\n    s->gr[0x01] = s->cirrus_shadow_gr1 & 0x0f;\n\n    qemu_get_buffer(f, s->gr + 2, 254);\n\n    qemu_get_8s(f, &s->ar_index);\n\n    qemu_get_buffer(f, s->ar, 21);\n\n    s->ar_flip_flop=qemu_get_be32(f);\n\n    qemu_get_8s(f, &s->cr_index);\n\n    qemu_get_buffer(f, s->cr, 256);\n\n    qemu_get_8s(f, &s->msr);\n\n    qemu_get_8s(f, &s->fcr);\n\n    qemu_get_8s(f, &s->st00);\n\n    qemu_get_8s(f, &s->st01);\n\n\n\n    qemu_get_8s(f, &s->dac_state);\n\n    qemu_get_8s(f, &s->dac_sub_index);\n\n    qemu_get_8s(f, &s->dac_read_index);\n\n    qemu_get_8s(f, &s->dac_write_index);\n\n    qemu_get_buffer(f, s->dac_cache, 3);\n\n    qemu_get_buffer(f, s->palette, 768);\n\n\n\n    s->bank_offset=qemu_get_be32(f);\n\n\n\n    qemu_get_8s(f, &s->cirrus_hidden_dac_lockindex);\n\n    qemu_get_8s(f, &s->cirrus_hidden_dac_data);\n\n\n\n    qemu_get_be32s(f, &s->hw_cursor_x);\n\n    qemu_get_be32s(f, &s->hw_cursor_y);\n\n\n\n    cirrus_update_memory_access(s);\n\n    \/* force refresh *\/\n\n    s->graphic_mode = -1;\n\n    cirrus_update_bank_ptr(s, 0);\n\n    cirrus_update_bank_ptr(s, 1);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"75f19f8c3006970632303b49043b075dc4fe922e","target":0,"func":"static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    PCIDevice *p = PCI_DEVICE(s);\n\n\n\n    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);\n\n    cmd->frame = NULL;\n\n    cmd->pa = 0;\n\n    clear_bit(cmd->index, s->frame_map);\n\n}\n"},{"project":"qemu","commit_id":"fa5912a17b51b807c4ec78a4aa914891c7770781","target":1,"func":"vreader_xfr_bytes(VReader *reader,\n\n                  unsigned char *send_buf, int send_buf_len,\n\n                  unsigned char *receive_buf, int *receive_buf_len)\n\n{\n\n    VCardAPDU *apdu;\n\n    VCardResponse *response = NULL;\n\n    VCardStatus card_status;\n\n    unsigned short status;\n\n    VCard *card = vreader_get_card(reader);\n\n\n\n    if (card == NULL) {\n\n        return VREADER_NO_CARD;\n\n    }\n\n\n\n    apdu = vcard_apdu_new(send_buf, send_buf_len, &status);\n\n    if (apdu == NULL) {\n\n        response = vcard_make_response(status);\n\n        card_status = VCARD_DONE;\n\n    } else {\n\n        g_debug(\"%s: CLS=0x%x,INS=0x%x,P1=0x%x,P2=0x%x,Lc=%d,Le=%d %s\",\n\n              __func__, apdu->a_cla, apdu->a_ins, apdu->a_p1, apdu->a_p2,\n\n              apdu->a_Lc, apdu->a_Le, apdu_ins_to_string(apdu->a_ins));\n\n        card_status = vcard_process_apdu(card, apdu, &response);\n\n        if (response) {\n\n            g_debug(\"%s: status=%d sw1=0x%x sw2=0x%x len=%d (total=%d)\",\n\n                  __func__, response->b_status, response->b_sw1,\n\n                  response->b_sw2, response->b_len, response->b_total_len);\n\n        }\n\n    }\n\n    assert(card_status == VCARD_DONE);\n\n    if (card_status == VCARD_DONE) {\n\n        int size = MIN(*receive_buf_len, response->b_total_len);\n\n        memcpy(receive_buf, response->b_data, size);\n\n        *receive_buf_len = size;\n\n    }\n\n    vcard_response_delete(response);\n\n    vcard_apdu_delete(apdu);\n\n    vcard_free(card); \/* free our reference *\/\n\n    return VREADER_OK;\n\n}\n"},{"project":"qemu","commit_id":"4a1418e07bdcfaa3177739e04707ecaec75d89e1","target":0,"func":"void helper_lret_protected(int shift, int addend)\n\n{\n\n    helper_ret_protected(shift, 0, addend);\n\n#ifdef CONFIG_KQEMU\n\n    if (kqemu_is_ok(env)) {\n\n        env->exception_index = -1;\n\n        cpu_loop_exit();\n\n    }\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"a369da5f31ddbdeb32a7f76622e480d3995fbb00","target":0,"func":"void mips_malta_init (ram_addr_t ram_size,\n\n                      const char *boot_device,\n\n                      const char *kernel_filename, const char *kernel_cmdline,\n\n                      const char *initrd_filename, const char *cpu_model)\n\n{\n\n    char *filename;\n\n    pflash_t *fl;\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *bios, *bios_alias = g_new(MemoryRegion, 1);\n\n    target_long bios_size;\n\n    int64_t kernel_entry;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    CPUState *env;\n\n    qemu_irq *isa_irq;\n\n    qemu_irq *cpu_exit_irq;\n\n    int piix4_devfn;\n\n    i2c_bus *smbus;\n\n    int i;\n\n    DriveInfo *dinfo;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n    int fl_idx = 0;\n\n    int fl_sectors = 0;\n\n    int be;\n\n\n\n    DeviceState *dev = qdev_create(NULL, \"mips-malta\");\n\n    MaltaState *s = DO_UPCAST(MaltaState, busdev.qdev, dev);\n\n\n\n    qdev_init_nofail(dev);\n\n\n\n    \/* Make sure the first 3 serial ports are associated with a device. *\/\n\n    for(i = 0; i < 3; i++) {\n\n        if (!serial_hds[i]) {\n\n            char label[32];\n\n            snprintf(label, sizeof(label), \"serial%d\", i);\n\n            serial_hds[i] = qemu_chr_new(label, \"null\", NULL);\n\n        }\n\n    }\n\n\n\n    \/* init CPUs *\/\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_MIPS64\n\n        cpu_model = \"20Kc\";\n\n#else\n\n        cpu_model = \"24Kf\";\n\n#endif\n\n    }\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        \/* Init internal devices *\/\n\n        cpu_mips_irq_init_cpu(env);\n\n        cpu_mips_clock_init(env);\n\n        qemu_register_reset(main_cpu_reset, env);\n\n    }\n\n    env = first_cpu;\n\n\n\n    \/* allocate RAM *\/\n\n    if (ram_size > (256 << 20)) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d MB, maximum 256 MB\\n\",\n\n                ((unsigned int)ram_size \/ (1 << 20)));\n\n        exit(1);\n\n    }\n\n    memory_region_init_ram(ram, \"mips_malta.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_add_subregion(system_memory, 0, ram);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    \/* FPGA *\/\n\n    malta_fpga_init(system_memory, 0x1f000000LL, env->irq[2], serial_hds[2]);\n\n\n\n    \/* Load firmware in flash \/ BIOS unless we boot directly into a kernel. *\/\n\n    if (kernel_filename) {\n\n        \/* Write a small bootloader to the flash location. *\/\n\n        bios = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram(bios, \"mips_malta.bios\", BIOS_SIZE);\n\n        vmstate_register_ram_global(bios);\n\n        memory_region_set_readonly(bios, true);\n\n        memory_region_init_alias(bios_alias, \"bios.1fc\", bios, 0, BIOS_SIZE);\n\n        \/* Map the bios at two physical locations, as on the real board. *\/\n\n        memory_region_add_subregion(system_memory, 0x1e000000LL, bios);\n\n        memory_region_add_subregion(system_memory, 0x1fc00000LL, bios_alias);\n\n        loaderparams.ram_size = ram_size;\n\n        loaderparams.kernel_filename = kernel_filename;\n\n        loaderparams.kernel_cmdline = kernel_cmdline;\n\n        loaderparams.initrd_filename = initrd_filename;\n\n        kernel_entry = load_kernel();\n\n        write_bootloader(env, memory_region_get_ram_ptr(bios), kernel_entry);\n\n    } else {\n\n        dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n        if (dinfo) {\n\n            \/* Load firmware from flash. *\/\n\n            bios_size = 0x400000;\n\n            fl_sectors = bios_size >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n            printf(\"Register parallel flash %d size \" TARGET_FMT_lx \" at \"\n\n                   \"addr %08llx '%s' %x\\n\",\n\n                   fl_idx, bios_size, 0x1e000000LL,\n\n                   bdrv_get_device_name(dinfo->bdrv), fl_sectors);\n\n#endif\n\n            fl = pflash_cfi01_register(0x1e000000LL,\n\n                                       NULL, \"mips_malta.bios\", BIOS_SIZE,\n\n                                       dinfo->bdrv, 65536, fl_sectors,\n\n                                       4, 0x0000, 0x0000, 0x0000, 0x0000, be);\n\n            bios = pflash_cfi01_get_memory(fl);\n\n            \/* Map the bios at two physical locations, as on the real board. *\/\n\n            memory_region_init_alias(bios_alias, \"bios.1fc\",\n\n                                     bios, 0, BIOS_SIZE);\n\n            memory_region_add_subregion(system_memory, 0x1fc00000LL,\n\n                                        bios_alias);\n\n           fl_idx++;\n\n        } else {\n\n            bios = g_new(MemoryRegion, 1);\n\n            memory_region_init_ram(bios, \"mips_malta.bios\", BIOS_SIZE);\n\n            vmstate_register_ram_global(bios);\n\n            memory_region_set_readonly(bios, true);\n\n            memory_region_init_alias(bios_alias, \"bios.1fc\",\n\n                                     bios, 0, BIOS_SIZE);\n\n            \/* Map the bios at two physical locations, as on the real board. *\/\n\n            memory_region_add_subregion(system_memory, 0x1e000000LL, bios);\n\n            memory_region_add_subregion(system_memory, 0x1fc00000LL,\n\n                                        bios_alias);\n\n            \/* Load a BIOS image. *\/\n\n            if (bios_name == NULL)\n\n                bios_name = BIOS_FILENAME;\n\n            filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n            if (filename) {\n\n                bios_size = load_image_targphys(filename, 0x1fc00000LL,\n\n                                                BIOS_SIZE);\n\n                g_free(filename);\n\n            } else {\n\n                bios_size = -1;\n\n            }\n\n            if ((bios_size < 0 || bios_size > BIOS_SIZE) && !kernel_filename) {\n\n                fprintf(stderr,\n\n                        \"qemu: Could not load MIPS bios '%s', and no -kernel argument was specified\\n\",\n\n                        bios_name);\n\n                exit(1);\n\n            }\n\n        }\n\n        \/* In little endian mode the 32bit words in the bios are swapped,\n\n           a neat trick which allows bi-endian firmware. *\/\n\n#ifndef TARGET_WORDS_BIGENDIAN\n\n        {\n\n            uint32_t *addr = memory_region_get_ram_ptr(bios);\n\n            uint32_t *end = addr + bios_size;\n\n            while (addr < end) {\n\n                bswap32s(addr);\n\n                addr++;\n\n            }\n\n        }\n\n#endif\n\n    }\n\n\n\n    \/* Board ID = 0x420 (Malta Board with CoreLV)\n\n       XXX: theoretically 0x1e000010 should map to flash and 0x1fc00010 should\n\n       map to the board ID. *\/\n\n    stl_p(memory_region_get_ram_ptr(bios) + 0x10, 0x00000420);\n\n\n\n    \/* Init internal devices *\/\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    \/*\n\n     * We have a circular dependency problem: pci_bus depends on isa_irq,\n\n     * isa_irq is provided by i8259, i8259 depends on ISA, ISA depends\n\n     * on piix4, and piix4 depends on pci_bus.  To stop the cycle we have\n\n     * qemu_irq_proxy() adds an extra bit of indirection, allowing us\n\n     * to resolve the isa_irq -> i8259 dependency after i8259 is initialized.\n\n     *\/\n\n    isa_irq = qemu_irq_proxy(&s->i8259, 16);\n\n\n\n    \/* Northbridge *\/\n\n    pci_bus = gt64120_register(isa_irq);\n\n\n\n    \/* Southbridge *\/\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n\n\n    piix4_devfn = piix4_init(pci_bus, &isa_bus, 80);\n\n\n\n    \/* Interrupt controller *\/\n\n    \/* The 8259 is attached to the MIPS CPU INT0 pin, ie interrupt 2 *\/\n\n    s->i8259 = i8259_init(isa_bus, env->irq[2]);\n\n\n\n    isa_bus_irqs(isa_bus, s->i8259);\n\n    pci_piix4_ide_init(pci_bus, hd, piix4_devfn + 1);\n\n    usb_uhci_piix4_init(pci_bus, piix4_devfn + 2);\n\n    smbus = piix4_pm_init(pci_bus, piix4_devfn + 3, 0x1100,\n\n                          isa_get_irq(NULL, 9), NULL, NULL, 0);\n\n    \/* TODO: Populate SPD eeprom data.  *\/\n\n    smbus_eeprom_init(smbus, 8, NULL, 0);\n\n    pit = pit_init(isa_bus, 0x40, 0);\n\n    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);\n\n    DMA_init(0, cpu_exit_irq);\n\n\n\n    \/* Super I\/O *\/\n\n    isa_create_simple(isa_bus, \"i8042\");\n\n\n\n    rtc_init(isa_bus, 2000, NULL);\n\n    serial_isa_init(isa_bus, 0, serial_hds[0]);\n\n    serial_isa_init(isa_bus, 1, serial_hds[1]);\n\n    if (parallel_hds[0])\n\n        parallel_init(isa_bus, 0, parallel_hds[0]);\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    fdctrl_init_isa(isa_bus, fd);\n\n\n\n    \/* Sound card *\/\n\n    audio_init(isa_bus, pci_bus);\n\n\n\n    \/* Network card *\/\n\n    network_init();\n\n\n\n    \/* Optional PCI video card *\/\n\n    if (cirrus_vga_enabled) {\n\n        pci_cirrus_vga_init(pci_bus);\n\n    } else if (vmsvga_enabled) {\n\n        if (!pci_vmsvga_init(pci_bus)) {\n\n            fprintf(stderr, \"Warning: vmware_vga not available,\"\n\n                    \" using standard VGA instead\\n\");\n\n            pci_vga_init(pci_bus);\n\n        }\n\n    } else if (std_vga_enabled) {\n\n        pci_vga_init(pci_bus);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"086abc1ccd0fa5103345adda819e6c6436949579","target":0,"func":"static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    int queues = n->multiqueue ? n->max_queues : 1;\n\n\n\n    if (!get_vhost_net(nc->peer)) {\n\n        return;\n\n    }\n\n\n\n    if (!!n->vhost_started ==\n\n        (virtio_net_started(n, status) && !nc->peer->link_down)) {\n\n        return;\n\n    }\n\n    if (!n->vhost_started) {\n\n        int r;\n\n        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {\n\n            return;\n\n        }\n\n        n->vhost_started = 1;\n\n        r = vhost_net_start(vdev, n->nic->ncs, queues);\n\n        if (r < 0) {\n\n            error_report(\"unable to start vhost net: %d: \"\n\n                         \"falling back on userspace virtio\", -r);\n\n            n->vhost_started = 0;\n\n        }\n\n    } else {\n\n        vhost_net_stop(vdev, n->nic->ncs, queues);\n\n        n->vhost_started = 0;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"35deebb2327227d8c5f4816476befb06f6329de6","target":1,"func":"static void pc87312_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = pc87312_realize;\n\n    dc->reset = pc87312_reset;\n\n    dc->vmsd = &vmstate_pc87312;\n\n    dc->props = pc87312_properties;\n\n\n\n}"},{"project":"qemu","commit_id":"f06ee3d4aa547df8d7d2317b2b6db7a88c1f3744","target":1,"func":"static void qed_copy_from_backing_file(BDRVQEDState *s, uint64_t pos,\n\n                                       uint64_t len, uint64_t offset,\n\n                                       BlockDriverCompletionFunc *cb,\n\n                                       void *opaque)\n\n{\n\n    CopyFromBackingFileCB *copy_cb;\n\n\n\n    \/* Skip copy entirely if there is no work to do *\/\n\n    if (len == 0) {\n\n        cb(opaque, 0);\n\n        return;\n\n    }\n\n\n\n    copy_cb = gencb_alloc(sizeof(*copy_cb), cb, opaque);\n\n    copy_cb->s = s;\n\n    copy_cb->offset = offset;\n\n    copy_cb->iov.iov_base = qemu_blockalign(s->bs, len);\n\n    copy_cb->iov.iov_len = len;\n\n    qemu_iovec_init_external(&copy_cb->qiov, &copy_cb->iov, 1);\n\n\n\n    qed_read_backing_file(s, pos, &copy_cb->qiov,\n\n                          qed_copy_from_backing_file_write, copy_cb);\n\n}\n"},{"project":"qemu","commit_id":"ddca7f86ac022289840e0200fd4050b2b58e9176","target":0,"func":"static void v9fs_renameat(void *opaque)\n\n{\n\n    ssize_t err = 0;\n\n    size_t offset = 7;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n    int32_t olddirfid, newdirfid;\n\n    V9fsString old_name, new_name;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dsds\", &olddirfid,\n\n                  &old_name, &newdirfid, &new_name);\n\n\n\n    v9fs_path_write_lock(s);\n\n    err = v9fs_complete_renameat(pdu, olddirfid,\n\n                                 &old_name, newdirfid, &new_name);\n\n    v9fs_path_unlock(s);\n\n    if (!err) {\n\n        err = offset;\n\n    }\n\n    complete_pdu(s, pdu, err);\n\n    v9fs_string_free(&old_name);\n\n    v9fs_string_free(&new_name);\n\n}\n"},{"project":"qemu","commit_id":"9b2fadda3e0196ffd485adde4fe9cdd6fae35300","target":1,"func":"static void gen_tlbwe_40x(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    switch (rB(ctx->opcode)) {\n\n    case 0:\n\n        gen_helper_4xx_tlbwe_hi(cpu_env, cpu_gpr[rA(ctx->opcode)],\n\n                                cpu_gpr[rS(ctx->opcode)]);\n\n        break;\n\n    case 1:\n\n        gen_helper_4xx_tlbwe_lo(cpu_env, cpu_gpr[rA(ctx->opcode)],\n\n                                cpu_gpr[rS(ctx->opcode)]);\n\n        break;\n\n    default:\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n        break;\n\n    }\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"b3db211f3c80bb996a704d665fe275619f728bd4","target":0,"func":"static void validate_test_add(const char *testpath,\n\n                               TestInputVisitorData *data,\n\n                               void (*test_func)(TestInputVisitorData *data, const void *user_data))\n\n{\n\n    g_test_add(testpath, TestInputVisitorData, data, NULL, test_func,\n\n               validate_teardown);\n\n}\n"},{"project":"qemu","commit_id":"6ab3fc32ea640026726bc5f9f4db622d0954fb8a","target":1,"func":"static void grlib_apbuart_write(void *opaque, hwaddr addr,\n\n                                uint64_t value, unsigned size)\n\n{\n\n    UART          *uart = opaque;\n\n    unsigned char  c    = 0;\n\n\n\n    addr &= 0xff;\n\n\n\n    \/* Unit registers *\/\n\n    switch (addr) {\n\n    case DATA_OFFSET:\n\n    case DATA_OFFSET + 3:       \/* When only one byte write *\/\n\n        \/* Transmit when character device available and transmitter enabled *\/\n\n        if ((uart->chr) && (uart->control & UART_TRANSMIT_ENABLE)) {\n\n            c = value & 0xFF;\n\n            qemu_chr_fe_write(uart->chr, &c, 1);\n\n            \/* Generate interrupt *\/\n\n            if (uart->control & UART_TRANSMIT_INTERRUPT) {\n\n                qemu_irq_pulse(uart->irq);\n\n            }\n\n        }\n\n        return;\n\n\n\n    case STATUS_OFFSET:\n\n        \/* Read Only *\/\n\n        return;\n\n\n\n    case CONTROL_OFFSET:\n\n        uart->control = value;\n\n        return;\n\n\n\n    case SCALER_OFFSET:\n\n        \/* Not supported *\/\n\n        return;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    trace_grlib_apbuart_writel_unknown(addr, value);\n\n}\n"},{"project":"qemu","commit_id":"28c5af54c661e73e5596918fa67a22b5e87c2022","target":0,"func":"static void ppc_core99_init (int ram_size, int vga_ram_size,\n\n                             const char *boot_device, DisplayState *ds,\n\n                             const char **fd_filename, int snapshot,\n\n                             const char *kernel_filename,\n\n                             const char *kernel_cmdline,\n\n                             const char *initrd_filename,\n\n                             const char *cpu_model)\n\n{\n\n    CPUState *env = NULL, *envs[MAX_CPUS];\n\n    char buf[1024];\n\n    qemu_irq *pic, **openpic_irqs;\n\n    int unin_memory;\n\n    int linux_boot, i;\n\n    unsigned long bios_offset, vga_bios_offset;\n\n    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;\n\n    PCIBus *pci_bus;\n\n    nvram_t nvram;\n\n#if 0\n\n    MacIONVRAMState *nvr;\n\n    int nvram_mem_index;\n\n#endif\n\n    m48t59_t *m48t59;\n\n    int vga_bios_size, bios_size;\n\n    qemu_irq *dummy_irq;\n\n    int pic_mem_index, dbdma_mem_index, cuda_mem_index;\n\n    int ide_mem_index[2];\n\n    int ppc_boot_device = boot_device[0];\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    \/* init CPUs *\/\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"default\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        \/* Set time-base frequency to 100 Mhz *\/\n\n        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n#if 0\n\n        env->osi_call = vga_osi_call;\n\n#endif\n\n        qemu_register_reset(&cpu_ppc_reset, env);\n\n        register_savevm(\"cpu\", 0, 3, cpu_save, cpu_load, env);\n\n        envs[i] = env;\n\n    }\n\n    if (env->nip < 0xFFF80000) {\n\n        \/* Special test for PowerPC 601:\n\n         * the boot vector is at 0xFFF00100, then we need a 1MB BIOS.\n\n         * But the NVRAM is located at 0xFFF04000...\n\n         *\/\n\n        cpu_abort(env, \"Mac99 hardware can not handle 1 MB BIOS\\n\");\n\n    }\n\n\n\n    \/* allocate RAM *\/\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    \/* allocate and load BIOS *\/\n\n    bios_offset = ram_size + vga_ram_size;\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s\/%s\", bios_dir, bios_name);\n\n    bios_size = load_image(buf, phys_ram_base + bios_offset);\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        cpu_abort(env, \"qemu: could not load PowerPC bios '%s'\\n\", buf);\n\n        exit(1);\n\n    }\n\n    bios_size = (bios_size + 0xfff) & ~0xfff;\n\n    if (bios_size > 0x00080000) {\n\n        \/* As the NVRAM is located at 0xFFF04000, we cannot use 1 MB BIOSes *\/\n\n        cpu_abort(env, \"Mac99 hardware can not handle 1 MB BIOS\\n\");\n\n    }\n\n    cpu_register_physical_memory((uint32_t)(-bios_size),\n\n                                 bios_size, bios_offset | IO_MEM_ROM);\n\n\n\n    \/* allocate and load VGA BIOS *\/\n\n    vga_bios_offset = bios_offset + bios_size;\n\n    snprintf(buf, sizeof(buf), \"%s\/%s\", bios_dir, VGABIOS_FILENAME);\n\n    vga_bios_size = load_image(buf, phys_ram_base + vga_bios_offset + 8);\n\n    if (vga_bios_size < 0) {\n\n        \/* if no bios is present, we can still work *\/\n\n        fprintf(stderr, \"qemu: warning: could not load VGA bios '%s'\\n\", buf);\n\n        vga_bios_size = 0;\n\n    } else {\n\n        \/* set a specific header (XXX: find real Apple format for NDRV\n\n           drivers) *\/\n\n        phys_ram_base[vga_bios_offset] = 'N';\n\n        phys_ram_base[vga_bios_offset + 1] = 'D';\n\n        phys_ram_base[vga_bios_offset + 2] = 'R';\n\n        phys_ram_base[vga_bios_offset + 3] = 'V';\n\n        cpu_to_be32w((uint32_t *)(phys_ram_base + vga_bios_offset + 4),\n\n                     vga_bios_size);\n\n        vga_bios_size += 8;\n\n    }\n\n    vga_bios_size = (vga_bios_size + 0xfff) & ~0xfff;\n\n\n\n    if (linux_boot) {\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        \/* now we can load the kernel *\/\n\n        kernel_size = load_image(kernel_filename, phys_ram_base + kernel_base);\n\n        if (kernel_size < 0) {\n\n            cpu_abort(env, \"qemu: could not load kernel '%s'\\n\",\n\n                      kernel_filename);\n\n            exit(1);\n\n        }\n\n        \/* load initrd *\/\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image(initrd_filename,\n\n                                     phys_ram_base + initrd_base);\n\n            if (initrd_size < 0) {\n\n                cpu_abort(env, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                          initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n    }\n\n\n\n    isa_mem_base = 0x80000000;\n\n\n\n    \/* Register 8 MB of ISA IO space *\/\n\n    isa_mmio_init(0xf2000000, 0x00800000);\n\n\n\n    \/* UniN init *\/\n\n    unin_memory = cpu_register_io_memory(0, unin_read, unin_write, NULL);\n\n    cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory);\n\n\n\n    openpic_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));\n\n    openpic_irqs[0] =\n\n        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        \/* Mac99 IRQ connection between OpenPIC outputs pins\n\n         * and PowerPC input pins\n\n         *\/\n\n        switch (PPC_INPUT(env)) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];\n\n            \/* Not connected ? *\/\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            \/* Check this *\/\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];\n\n            break;\n\n#if defined(TARGET_PPC64)\n\n        case PPC_FLAGS_INPUT_970:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];\n\n            \/* Not connected ? *\/\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            \/* Check this *\/\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];\n\n            break;\n\n#endif \/* defined(TARGET_PPC64) *\/\n\n        default:\n\n            cpu_abort(env, \"Bus model not supported on mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n    pic = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irqs, NULL);\n\n    pci_bus = pci_pmac_init(pic);\n\n    \/* init basic PC hardware *\/\n\n    pci_vga_init(pci_bus, ds, phys_ram_base + ram_size,\n\n                 ram_size, vga_ram_size,\n\n                 vga_bios_offset, vga_bios_size);\n\n    \n\n    \/* XXX: suppress that *\/\n\n    dummy_irq = i8259_init(NULL);\n\n\n\n    \/* XXX: use Mac Serial port *\/\n\n    serial_init(0x3f8, dummy_irq[4], serial_hds[0]);\n\n    for(i = 0; i < nb_nics; i++) {\n\n        if (!nd_table[i].model)\n\n            nd_table[i].model = \"ne2k_pci\";\n\n        pci_nic_init(pci_bus, &nd_table[i], -1);\n\n    }\n\n#if 1\n\n    ide_mem_index[0] = pmac_ide_init(&bs_table[0], pic[0x13]);\n\n    ide_mem_index[1] = pmac_ide_init(&bs_table[2], pic[0x14]);\n\n#else\n\n    pci_cmd646_ide_init(pci_bus, &bs_table[0], 0);\n\n#endif\n\n    \/* cuda also initialize ADB *\/\n\n    cuda_init(&cuda_mem_index, pic[0x19]);\n\n    \n\n    adb_kbd_init(&adb_bus);\n\n    adb_mouse_init(&adb_bus);\n\n\n\n    dbdma_init(&dbdma_mem_index);\n\n\n\n    macio_init(pci_bus, 0x0022, 0, pic_mem_index, dbdma_mem_index,\n\n               cuda_mem_index, NULL, 2, ide_mem_index);\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, 3, -1);\n\n    }\n\n\n\n    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)\n\n        graphic_depth = 15;\n\n#if 0 \/* XXX: this is ugly but needed for now, or OHW won't boot *\/\n\n    \/* The NewWorld NVRAM is not located in the MacIO device *\/\n\n    nvr = macio_nvram_init(&nvram_mem_index, 0x2000);\n\n    pmac_format_nvram_partition(nvr, 0x2000);\n\n    macio_nvram_map(nvr, 0xFFF04000);\n\n    nvram.opaque = nvr;\n\n    nvram.read_fn = &macio_nvram_read;\n\n    nvram.write_fn = &macio_nvram_write;\n\n#else\n\n    m48t59 = m48t59_init(dummy_irq[8], 0xFFF04000, 0x0074, NVRAM_SIZE, 59);\n\n    nvram.opaque = m48t59;\n\n    nvram.read_fn = &m48t59_read;\n\n    nvram.write_fn = &m48t59_write;\n\n#endif\n\n    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, \"MAC99\", ram_size,\n\n                         ppc_boot_device, kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         \/* XXX: need an option to load a NVRAM image *\/\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n    \/* No PCI init: the BIOS will do it *\/\n\n\n\n    \/* Special port to get debug messages from Open-Firmware *\/\n\n    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);\n\n }\n"},{"project":"qemu","commit_id":"fd56e0612b6454a282fa6a953fdb09281a98c589","target":0,"func":"static void s390_pcihost_hot_unplug(HotplugHandler *hotplug_dev,\n\n                                    DeviceState *dev, Error **errp)\n\n{\n\n    PCIDevice *pci_dev = NULL;\n\n    PCIBus *bus;\n\n    int32_t devfn;\n\n    S390PCIBusDevice *pbdev = NULL;\n\n    S390pciState *s = s390_get_phb();\n\n\n\n    if (object_dynamic_cast(OBJECT(dev), TYPE_PCI_BRIDGE)) {\n\n        error_setg(errp, \"PCI bridge hot unplug currently not supported\");\n\n        return;\n\n    } else if (object_dynamic_cast(OBJECT(dev), TYPE_PCI_DEVICE)) {\n\n        pci_dev = PCI_DEVICE(dev);\n\n\n\n        QTAILQ_FOREACH(pbdev, &s->zpci_devs, link) {\n\n            if (pbdev->pdev == pci_dev) {\n\n                break;\n\n            }\n\n        }\n\n        assert(pbdev != NULL);\n\n    } else if (object_dynamic_cast(OBJECT(dev), TYPE_S390_PCI_DEVICE)) {\n\n        pbdev = S390_PCI_DEVICE(dev);\n\n        pci_dev = pbdev->pdev;\n\n    }\n\n\n\n    switch (pbdev->state) {\n\n    case ZPCI_FS_RESERVED:\n\n        goto out;\n\n    case ZPCI_FS_STANDBY:\n\n        break;\n\n    default:\n\n        s390_pci_generate_plug_event(HP_EVENT_DECONFIGURE_REQUEST,\n\n                                     pbdev->fh, pbdev->fid);\n\n        pbdev->release_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                                            s390_pcihost_timer_cb,\n\n                                            pbdev);\n\n        timer_mod(pbdev->release_timer,\n\n                  qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + HOT_UNPLUG_TIMEOUT);\n\n        return;\n\n    }\n\n\n\n    if (pbdev->release_timer && timer_pending(pbdev->release_timer)) {\n\n        timer_del(pbdev->release_timer);\n\n        timer_free(pbdev->release_timer);\n\n        pbdev->release_timer = NULL;\n\n    }\n\n\n\n    s390_pci_generate_plug_event(HP_EVENT_STANDBY_TO_RESERVED,\n\n                                 pbdev->fh, pbdev->fid);\n\n    bus = pci_dev->bus;\n\n    devfn = pci_dev->devfn;\n\n    object_unparent(OBJECT(pci_dev));\n\n    s390_pci_msix_free(pbdev);\n\n    s390_pci_iommu_free(s, bus, devfn);\n\n    pbdev->pdev = NULL;\n\n    pbdev->state = ZPCI_FS_RESERVED;\n\nout:\n\n    pbdev->fid = 0;\n\n    QTAILQ_REMOVE(&s->zpci_devs, pbdev, link);\n\n    g_hash_table_remove(s->zpci_table, &pbdev->idx);\n\n    object_unparent(OBJECT(pbdev));\n\n}\n"},{"project":"qemu","commit_id":"5bb95e41868b461f37159efb48908828ebd7ab36","target":0,"func":"void do_smbios_option(const char *optarg)\n\n{\n\n#ifdef TARGET_I386\n\n    if (smbios_entry_add(optarg) < 0) {\n\n        fprintf(stderr, \"Wrong smbios provided\\n\");\n\n        exit(1);\n\n    }\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"d9f62dde1303286b24ac8ce88be27e2b9b9c5f46","target":0,"func":"GenericList *visit_next_list(Visitor *v, GenericList **list, size_t size)\n\n{\n\n    assert(list && size >= sizeof(GenericList));\n\n    return v->next_list(v, list, size);\n\n}\n"},{"project":"qemu","commit_id":"0ccb9c1d8128a020720d5c6abf99a470742a1b94","target":1,"func":"DISAS_INSN(divl)\n\n{\n\n    TCGv num;\n\n    TCGv den;\n\n    TCGv reg;\n\n    uint16_t ext;\n\n\n\n    ext = read_im16(env, s);\n\n    if (ext & 0x87f8) {\n\n        gen_exception(s, s->pc - 4, EXCP_UNSUPPORTED);\n\n        return;\n\n    }\n\n    num = DREG(ext, 12);\n\n    reg = DREG(ext, 0);\n\n    tcg_gen_mov_i32(QREG_DIV1, num);\n\n    SRC_EA(env, den, OS_LONG, 0, NULL);\n\n    tcg_gen_mov_i32(QREG_DIV2, den);\n\n    if (ext & 0x0800) {\n\n        gen_helper_divs(cpu_env, tcg_const_i32(0));\n\n    } else {\n\n        gen_helper_divu(cpu_env, tcg_const_i32(0));\n\n    }\n\n    if ((ext & 7) == ((ext >> 12) & 7)) {\n\n        \/* div *\/\n\n        tcg_gen_mov_i32 (reg, QREG_DIV1);\n\n    } else {\n\n        \/* rem *\/\n\n        tcg_gen_mov_i32 (reg, QREG_DIV2);\n\n    }\n\n    set_cc_op(s, CC_OP_FLAGS);\n\n}\n"},{"project":"qemu","commit_id":"260fecf13b0d30621dc88da03dc1b502b7358c6b","target":0,"func":"static bool append_open_options(QDict *d, BlockDriverState *bs)\n\n{\n\n    const QDictEntry *entry;\n\n    QemuOptDesc *desc;\n\n    bool found_any = false;\n\n\n\n    for (entry = qdict_first(bs->options); entry;\n\n         entry = qdict_next(bs->options, entry))\n\n    {\n\n        \/* Only take options for this level *\/\n\n        if (strchr(qdict_entry_key(entry), '.')) {\n\n            continue;\n\n        }\n\n\n\n        \/* And exclude all non-driver-specific options *\/\n\n        for (desc = bdrv_runtime_opts.desc; desc->name; desc++) {\n\n            if (!strcmp(qdict_entry_key(entry), desc->name)) {\n\n                break;\n\n            }\n\n        }\n\n        if (desc->name) {\n\n            continue;\n\n        }\n\n\n\n        qobject_incref(qdict_entry_value(entry));\n\n        qdict_put_obj(d, qdict_entry_key(entry), qdict_entry_value(entry));\n\n        found_any = true;\n\n    }\n\n\n\n    return found_any;\n\n}\n"},{"project":"qemu","commit_id":"b6d36def6d9e9fd187327182d0abafc9b7085d8f","target":0,"func":"static int realloc_refcount_array(BDRVQcow2State *s, void **array,\n\n                                  int64_t *size, int64_t new_size)\n\n{\n\n    size_t old_byte_size, new_byte_size;\n\n    void *new_ptr;\n\n\n\n    \/* Round to clusters so the array can be directly written to disk *\/\n\n    old_byte_size = size_to_clusters(s, refcount_array_byte_size(s, *size))\n\n                    * s->cluster_size;\n\n    new_byte_size = size_to_clusters(s, refcount_array_byte_size(s, new_size))\n\n                    * s->cluster_size;\n\n\n\n    if (new_byte_size == old_byte_size) {\n\n        *size = new_size;\n\n        return 0;\n\n    }\n\n\n\n    assert(new_byte_size > 0);\n\n\n\n    new_ptr = g_try_realloc(*array, new_byte_size);\n\n    if (!new_ptr) {\n\n        return -ENOMEM;\n\n    }\n\n\n\n    if (new_byte_size > old_byte_size) {\n\n        memset((void *)((uintptr_t)new_ptr + old_byte_size), 0,\n\n               new_byte_size - old_byte_size);\n\n    }\n\n\n\n    *array = new_ptr;\n\n    *size  = new_size;\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"f5ed36635d8fa73feb66fe12b3b9c2ed90a1adbe","target":1,"func":"void virtqueue_fill(VirtQueue *vq, const VirtQueueElement *elem,\n                    unsigned int len, unsigned int idx)\n{\n    VRingUsedElem uelem;\n    trace_virtqueue_fill(vq, elem, len, idx);\n    virtqueue_unmap_sg(vq, elem, len);\n    idx = (idx + vq->used_idx) % vq->vring.num;\n    uelem.id = elem->index;\n    uelem.len = len;\n    vring_used_write(vq, &uelem, idx);"},{"project":"qemu","commit_id":"72cf2d4f0e181d0d3a3122e04129c58a95da713e","target":0,"func":"int qemu_acl_party_is_allowed(qemu_acl *acl,\n\n                              const char *party)\n\n{\n\n    qemu_acl_entry *entry;\n\n\n\n    TAILQ_FOREACH(entry, &acl->entries, next) {\n\n#ifdef CONFIG_FNMATCH\n\n        if (fnmatch(entry->match, party, 0) == 0)\n\n            return entry->deny ? 0 : 1;\n\n#else\n\n        \/* No fnmatch, so fallback to exact string matching\n\n         * instead of allowing wildcards *\/\n\n        if (strcmp(entry->match, party) == 0)\n\n            return entry->deny ? 0 : 1;\n\n#endif\n\n    }\n\n\n\n    return acl->defaultDeny ? 0 : 1;\n\n}\n"},{"project":"qemu","commit_id":"b7394c8394d38cb38b6db14eb431cac7a91e7140","target":0,"func":"int hvf_vcpu_exec(CPUState *cpu)\n\n{\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n    CPUX86State *env = &x86_cpu->env;\n\n    int ret = 0;\n\n    uint64_t rip = 0;\n\n\n\n    cpu->halted = 0;\n\n\n\n    if (hvf_process_events(cpu)) {\n\n        return EXCP_HLT;\n\n    }\n\n\n\n    do {\n\n        if (cpu->vcpu_dirty) {\n\n            hvf_put_registers(cpu);\n\n            cpu->vcpu_dirty = false;\n\n        }\n\n\n\n        env->hvf_emul->interruptable =\n\n            !(rvmcs(cpu->hvf_fd, VMCS_GUEST_INTERRUPTIBILITY) &\n\n             (VMCS_INTERRUPTIBILITY_STI_BLOCKING |\n\n             VMCS_INTERRUPTIBILITY_MOVSS_BLOCKING));\n\n\n\n        hvf_inject_interrupts(cpu);\n\n        vmx_update_tpr(cpu);\n\n\n\n        qemu_mutex_unlock_iothread();\n\n        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {\n\n            qemu_mutex_lock_iothread();\n\n            return EXCP_HLT;\n\n        }\n\n\n\n        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);\n\n        assert_hvf_ok(r);\n\n\n\n        \/* handle VMEXIT *\/\n\n        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);\n\n        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);\n\n        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,\n\n                                           VMCS_EXIT_INSTRUCTION_LENGTH);\n\n        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n        rip = rreg(cpu->hvf_fd, HV_X86_RIP);\n\n        RFLAGS(env) = rreg(cpu->hvf_fd, HV_X86_RFLAGS);\n\n        env->eflags = RFLAGS(env);\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        update_apic_tpr(cpu);\n\n        current_cpu = cpu;\n\n\n\n        ret = 0;\n\n        switch (exit_reason) {\n\n        case EXIT_REASON_HLT: {\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            if (!((cpu->interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                (EFLAGS(env) & IF_MASK))\n\n                && !(cpu->interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                !(idtvec_info & VMCS_IDT_VEC_VALID)) {\n\n                cpu->halted = 1;\n\n                ret = EXCP_HLT;\n\n            }\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_MWAIT: {\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n            \/* Need to check if MMIO or unmmaped fault *\/\n\n        case EXIT_REASON_EPT_FAULT:\n\n        {\n\n            hvf_slot *slot;\n\n            addr_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);\n\n\n\n            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&\n\n                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {\n\n                vmx_set_nmi_blocking(cpu);\n\n            }\n\n\n\n            slot = hvf_find_overlap_slot(gpa, gpa);\n\n            \/* mmio *\/\n\n            if (ept_emulation_fault(slot, gpa, exit_qual)) {\n\n                struct x86_decode decode;\n\n\n\n                load_regs(cpu);\n\n                env->hvf_emul->fetch_rip = rip;\n\n\n\n                decode_instruction(env, &decode);\n\n                exec_instruction(env, &decode);\n\n                store_regs(cpu);\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        case EXIT_REASON_INOUT:\n\n        {\n\n            uint32_t in = (exit_qual & 8) != 0;\n\n            uint32_t size =  (exit_qual & 7) + 1;\n\n            uint32_t string =  (exit_qual & 16) != 0;\n\n            uint32_t port =  exit_qual >> 16;\n\n            \/*uint32_t rep = (exit_qual & 0x20) != 0;*\/\n\n\n\n#if 1\n\n            if (!string && in) {\n\n                uint64_t val = 0;\n\n                load_regs(cpu);\n\n                hvf_handle_io(env, port, &val, 0, size, 1);\n\n                if (size == 1) {\n\n                    AL(env) = val;\n\n                } else if (size == 2) {\n\n                    AX(env) = val;\n\n                } else if (size == 4) {\n\n                    RAX(env) = (uint32_t)val;\n\n                } else {\n\n                    VM_PANIC(\"size\");\n\n                }\n\n                RIP(env) += ins_len;\n\n                store_regs(cpu);\n\n                break;\n\n            } else if (!string && !in) {\n\n                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);\n\n                hvf_handle_io(env, port, &RAX(env), 1, size, 1);\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n#endif\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            VM_PANIC_ON(ins_len != decode.len);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n\n\n            break;\n\n        }\n\n        case EXIT_REASON_CPUID: {\n\n            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);\n\n            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);\n\n\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, rax);\n\n            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);\n\n            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);\n\n\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_XSETBV: {\n\n            X86CPU *x86_cpu = X86_CPU(cpu);\n\n            CPUX86State *env = &x86_cpu->env;\n\n            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            if (ecx) {\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n            env->xcr0 = ((uint64_t)edx << 32) | eax;\n\n            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_INTR_WINDOW:\n\n            vmx_clear_int_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_NMI_WINDOW:\n\n            vmx_clear_nmi_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_EXT_INTR:\n\n            \/* force exit and allow io handling *\/\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_RDMSR:\n\n        case EXIT_REASON_WRMSR:\n\n        {\n\n            load_regs(cpu);\n\n            if (exit_reason == EXIT_REASON_RDMSR) {\n\n                simulate_rdmsr(cpu);\n\n            } else {\n\n                simulate_wrmsr(cpu);\n\n            }\n\n            RIP(env) += rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_CR_ACCESS: {\n\n            int cr;\n\n            int reg;\n\n\n\n            load_regs(cpu);\n\n            cr = exit_qual & 15;\n\n            reg = (exit_qual >> 8) & 15;\n\n\n\n            switch (cr) {\n\n            case 0x0: {\n\n                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 4: {\n\n                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 8: {\n\n                X86CPU *x86_cpu = X86_CPU(cpu);\n\n                if (exit_qual & 0x10) {\n\n                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);\n\n                } else {\n\n                    int tpr = RRX(env, reg);\n\n                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);\n\n                    ret = EXCP_INTERRUPT;\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                error_report(\"Unrecognized CR %d\\n\", cr);\n\n                abort();\n\n            }\n\n            RIP(env) += ins_len;\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_APIC_ACCESS: { \/* TODO *\/\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TPR: {\n\n            ret = 1;\n\n            break;\n\n        }\n\n        case EXIT_REASON_TASK_SWITCH: {\n\n            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n            x68_segment_selector sel = {.sel = exit_qual & 0xffff};\n\n            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,\n\n             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo\n\n             & VMCS_INTR_T_MASK);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TRIPLE_FAULT: {\n\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_RDPMC:\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, 0);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, 0);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        case VMX_REASON_VMCALL:\n\n            \/* TODO: inject #GP fault *\/\n\n            break;\n\n        default:\n\n            error_report(\"%llx: unhandled exit %llx\\n\", rip, exit_reason);\n\n        }\n\n    } while (ret == 0);\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"b9ce1454e14ec918acb90d899ce7724f69682f45","target":0,"func":"int qemu_get_byte(QEMUFile *f)\n\n{\n\n    if (f->is_write)\n\n        abort();\n\n\n\n    if (f->buf_index >= f->buf_size) {\n\n        qemu_fill_buffer(f);\n\n        if (f->buf_index >= f->buf_size)\n\n            return 0;\n\n    }\n\n    return f->buf[f->buf_index++];\n\n}\n"},{"project":"qemu","commit_id":"dfd100f242370886bb6732f70f1f7cbd8eb9fedc","target":0,"func":"static void test_io_channel_setup_sync(SocketAddress *listen_addr,\n\n                                       SocketAddress *connect_addr,\n\n                                       QIOChannel **src,\n\n                                       QIOChannel **dst)\n\n{\n\n    QIOChannelSocket *lioc;\n\n\n\n    lioc = qio_channel_socket_new();\n\n    qio_channel_socket_listen_sync(lioc, listen_addr, &error_abort);\n\n\n\n    if (listen_addr->type == SOCKET_ADDRESS_KIND_INET) {\n\n        SocketAddress *laddr = qio_channel_socket_get_local_address(\n\n            lioc, &error_abort);\n\n\n\n        g_free(connect_addr->u.inet.data->port);\n\n        connect_addr->u.inet.data->port = g_strdup(laddr->u.inet.data->port);\n\n\n\n        qapi_free_SocketAddress(laddr);\n\n    }\n\n\n\n    *src = QIO_CHANNEL(qio_channel_socket_new());\n\n    qio_channel_socket_connect_sync(\n\n        QIO_CHANNEL_SOCKET(*src), connect_addr, &error_abort);\n\n    qio_channel_set_delay(*src, false);\n\n\n\n    qio_channel_wait(QIO_CHANNEL(lioc), G_IO_IN);\n\n    *dst = QIO_CHANNEL(qio_channel_socket_accept(lioc, &error_abort));\n\n    g_assert(*dst);\n\n\n\n    test_io_channel_set_socket_bufs(*src, *dst);\n\n\n\n    object_unref(OBJECT(lioc));\n\n}\n"},{"project":"qemu","commit_id":"1e9981465f05a0f103d7e09afd975c9c0ff6d132","target":1,"func":"void qmp_cont(Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        error_set(errp, QERR_MIGRATION_EXPECTED);\n\n        return;\n\n    } else if (runstate_check(RUN_STATE_INTERNAL_ERROR) ||\n\n               runstate_check(RUN_STATE_SHUTDOWN)) {\n\n        error_set(errp, QERR_RESET_REQUIRED);\n\n        return;\n\n    } else if (runstate_check(RUN_STATE_SUSPENDED)) {\n\n        return;\n\n    }\n\n\n\n    bdrv_iterate(iostatus_bdrv_it, NULL);\n\n    bdrv_iterate(encrypted_bdrv_it, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    vm_start();\n\n}\n"},{"project":"qemu","commit_id":"f8b6cc0070aab8b75bd082582c829be1353f395f","target":0,"func":"static int parse_drive(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    DriveInfo **ptr = qdev_get_prop_ptr(dev, prop);\n\n\n\n    *ptr = drive_get_by_id(str);\n\n    if (*ptr == NULL)\n\n        return -ENOENT;\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"e23a1b33b53d25510320b26d9f154e19c6c99725","target":1,"func":"void mips_malta_init (ram_addr_t ram_size,\n\n                      const char *boot_device,\n\n                      const char *kernel_filename, const char *kernel_cmdline,\n\n                      const char *initrd_filename, const char *cpu_model)\n\n{\n\n    char *filename;\n\n    ram_addr_t ram_offset;\n\n    ram_addr_t bios_offset;\n\n    target_long bios_size;\n\n    int64_t kernel_entry;\n\n    PCIBus *pci_bus;\n\n    ISADevice *isa_dev;\n\n    CPUState *env;\n\n    RTCState *rtc_state;\n\n    fdctrl_t *floppy_controller;\n\n    MaltaFPGAState *malta_fpga;\n\n    qemu_irq *i8259;\n\n    int piix4_devfn;\n\n    uint8_t *eeprom_buf;\n\n    i2c_bus *smbus;\n\n    int i;\n\n    DriveInfo *dinfo;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n    int fl_idx = 0;\n\n    int fl_sectors = 0;\n\n\n\n    \/* Make sure the first 3 serial ports are associated with a device. *\/\n\n    for(i = 0; i < 3; i++) {\n\n        if (!serial_hds[i]) {\n\n            char label[32];\n\n            snprintf(label, sizeof(label), \"serial%d\", i);\n\n            serial_hds[i] = qemu_chr_open(label, \"null\", NULL);\n\n        }\n\n    }\n\n\n\n    \/* init CPUs *\/\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_MIPS64\n\n        cpu_model = \"20Kc\";\n\n#else\n\n        cpu_model = \"24Kf\";\n\n#endif\n\n    }\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    qemu_register_reset(main_cpu_reset, env);\n\n\n\n    \/* allocate RAM *\/\n\n    if (ram_size > (256 << 20)) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d MB, maximum 256 MB\\n\",\n\n                ((unsigned int)ram_size \/ (1 << 20)));\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(ram_size);\n\n    bios_offset = qemu_ram_alloc(BIOS_SIZE);\n\n\n\n\n\n    cpu_register_physical_memory(0, ram_size, ram_offset | IO_MEM_RAM);\n\n\n\n    \/* Map the bios at two physical locations, as on the real board. *\/\n\n    cpu_register_physical_memory(0x1e000000LL,\n\n                                 BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n    cpu_register_physical_memory(0x1fc00000LL,\n\n                                 BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n\n\n    \/* FPGA *\/\n\n    malta_fpga = malta_fpga_init(0x1f000000LL, env->irq[2], serial_hds[2]);\n\n\n\n    \/* Load firmware in flash \/ BIOS unless we boot directly into a kernel. *\/\n\n    if (kernel_filename) {\n\n        \/* Write a small bootloader to the flash location. *\/\n\n        loaderparams.ram_size = ram_size;\n\n        loaderparams.kernel_filename = kernel_filename;\n\n        loaderparams.kernel_cmdline = kernel_cmdline;\n\n        loaderparams.initrd_filename = initrd_filename;\n\n        kernel_entry = load_kernel(env);\n\n        env->CP0_Status &= ~((1 << CP0St_BEV) | (1 << CP0St_ERL));\n\n        write_bootloader(env, qemu_get_ram_ptr(bios_offset), kernel_entry);\n\n    } else {\n\n        dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n        if (dinfo) {\n\n            \/* Load firmware from flash. *\/\n\n            bios_size = 0x400000;\n\n            fl_sectors = bios_size >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n            printf(\"Register parallel flash %d size \" TARGET_FMT_lx \" at \"\n\n                   \"offset %08lx addr %08llx '%s' %x\\n\",\n\n                   fl_idx, bios_size, bios_offset, 0x1e000000LL,\n\n                   bdrv_get_device_name(dinfo->bdrv), fl_sectors);\n\n#endif\n\n            pflash_cfi01_register(0x1e000000LL, bios_offset,\n\n                                  dinfo->bdrv, 65536, fl_sectors,\n\n                                  4, 0x0000, 0x0000, 0x0000, 0x0000);\n\n            fl_idx++;\n\n        } else {\n\n            \/* Load a BIOS image. *\/\n\n            if (bios_name == NULL)\n\n                bios_name = BIOS_FILENAME;\n\n            filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n            if (filename) {\n\n                bios_size = load_image_targphys(filename, 0x1fc00000LL,\n\n                                                BIOS_SIZE);\n\n                qemu_free(filename);\n\n            } else {\n\n                bios_size = -1;\n\n            }\n\n            if ((bios_size < 0 || bios_size > BIOS_SIZE) && !kernel_filename) {\n\n                fprintf(stderr,\n\n                        \"qemu: Could not load MIPS bios '%s', and no -kernel argument was specified\\n\",\n\n                        bios_name);\n\n                exit(1);\n\n            }\n\n        }\n\n        \/* In little endian mode the 32bit words in the bios are swapped,\n\n           a neat trick which allows bi-endian firmware. *\/\n\n#ifndef TARGET_WORDS_BIGENDIAN\n\n        {\n\n            uint32_t *addr = qemu_get_ram_ptr(bios_offset);;\n\n            uint32_t *end = addr + bios_size;\n\n            while (addr < end) {\n\n                bswap32s(addr);\n\n            }\n\n        }\n\n#endif\n\n    }\n\n\n\n    \/* Board ID = 0x420 (Malta Board with CoreLV)\n\n       XXX: theoretically 0x1e000010 should map to flash and 0x1fc00010 should\n\n       map to the board ID. *\/\n\n    stl_phys(0x1fc00010LL, 0x00000420);\n\n\n\n    \/* Init internal devices *\/\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    \/* Interrupt controller *\/\n\n    \/* The 8259 is attached to the MIPS CPU INT0 pin, ie interrupt 2 *\/\n\n    i8259 = i8259_init(env->irq[2]);\n\n\n\n    \/* Northbridge *\/\n\n    pci_bus = pci_gt64120_init(i8259);\n\n\n\n    \/* Southbridge *\/\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i \/ MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    piix4_devfn = piix4_init(pci_bus, 80);\n\n    isa_bus_irqs(i8259);\n\n    pci_piix4_ide_init(pci_bus, hd, piix4_devfn + 1);\n\n    usb_uhci_piix4_init(pci_bus, piix4_devfn + 2);\n\n    smbus = piix4_pm_init(pci_bus, piix4_devfn + 3, 0x1100, isa_reserve_irq(9));\n\n    eeprom_buf = qemu_mallocz(8 * 256); \/* XXX: make this persistent *\/\n\n    for (i = 0; i < 8; i++) {\n\n        \/* TODO: Populate SPD eeprom data.  *\/\n\n        DeviceState *eeprom;\n\n        eeprom = qdev_create((BusState *)smbus, \"smbus-eeprom\");\n\n        qdev_prop_set_uint8(eeprom, \"address\", 0x50 + i);\n\n        qdev_prop_set_ptr(eeprom, \"data\", eeprom_buf + (i * 256));\n\n        qdev_init(eeprom);\n\n    }\n\n    pit = pit_init(0x40, isa_reserve_irq(0));\n\n    DMA_init(0);\n\n\n\n    \/* Super I\/O *\/\n\n    isa_dev = isa_create_simple(\"i8042\");\n\n \n\n    rtc_state = rtc_init(2000);\n\n    serial_isa_init(0, serial_hds[0]);\n\n    serial_isa_init(1, serial_hds[1]);\n\n    if (parallel_hds[0])\n\n        parallel_init(0, parallel_hds[0]);\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    floppy_controller = fdctrl_init_isa(fd);\n\n\n\n    \/* Sound card *\/\n\n#ifdef HAS_AUDIO\n\n    audio_init(pci_bus);\n\n#endif\n\n\n\n    \/* Network card *\/\n\n    network_init();\n\n\n\n    \/* Optional PCI video card *\/\n\n    if (cirrus_vga_enabled) {\n\n        pci_cirrus_vga_init(pci_bus);\n\n    } else if (vmsvga_enabled) {\n\n        pci_vmsvga_init(pci_bus);\n\n    } else if (std_vga_enabled) {\n\n        pci_vga_init(pci_bus, 0, 0);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"14a10fc39923b3af07c8c46d22cb20843bee3a72","target":1,"func":"static void uc32_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    UniCore32CPUClass *ucc = UNICORE32_CPU_GET_CLASS(dev);\n    ucc->parent_realize(dev, errp);\n}"},{"project":"qemu","commit_id":"90e56fb46d0a7add88ed463efa4e723a6238f692","target":0,"func":"static void *do_data_compress(void *opaque)\n\n{\n\n    CompressParam *param = opaque;\n\n\n\n    while (!quit_comp_thread) {\n\n        qemu_mutex_lock(&param->mutex);\n\n        \/* Re-check the quit_comp_thread in case of\n\n         * terminate_compression_threads is called just before\n\n         * qemu_mutex_lock(&param->mutex) and after\n\n         * while(!quit_comp_thread), re-check it here can make\n\n         * sure the compression thread terminate as expected.\n\n         *\/\n\n        while (!param->start && !quit_comp_thread) {\n\n            qemu_cond_wait(&param->cond, &param->mutex);\n\n        }\n\n        if (!quit_comp_thread) {\n\n            do_compress_ram_page(param);\n\n        }\n\n        param->start = false;\n\n        qemu_mutex_unlock(&param->mutex);\n\n\n\n        qemu_mutex_lock(comp_done_lock);\n\n        param->done = true;\n\n        qemu_cond_signal(comp_done_cond);\n\n        qemu_mutex_unlock(comp_done_lock);\n\n    }\n\n\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"456d60692310e7ac25cf822cc1e98192ad636ece","target":1,"func":"static int mon_init_func(QemuOpts *opts, void *opaque)\n\n{\n\n    CharDriverState *chr;\n\n    const char *chardev;\n\n    const char *mode;\n\n    int flags;\n\n\n\n    mode = qemu_opt_get(opts, \"mode\");\n\n    if (mode == NULL) {\n\n        mode = \"readline\";\n\n    }\n\n    if (strcmp(mode, \"readline\") == 0) {\n\n        flags = MONITOR_USE_READLINE;\n\n    } else if (strcmp(mode, \"control\") == 0) {\n\n        flags = MONITOR_USE_CONTROL;\n\n    } else {\n\n        fprintf(stderr, \"unknown monitor mode \\\"%s\\\"\\n\", mode);\n\n        exit(1);\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"pretty\", 0))\n\n        flags |= MONITOR_USE_PRETTY;\n\n\n\n    if (qemu_opt_get_bool(opts, \"default\", 0))\n\n        flags |= MONITOR_IS_DEFAULT;\n\n\n\n    chardev = qemu_opt_get(opts, \"chardev\");\n\n    chr = qemu_chr_find(chardev);\n\n    if (chr == NULL) {\n\n        fprintf(stderr, \"chardev \\\"%s\\\" not found\\n\", chardev);\n\n        exit(1);\n\n    }\n\n\n\n\n    monitor_init(chr, flags);\n\n    return 0;\n\n}"},{"project":"qemu","commit_id":"dc520a7dee0a9307e844eb6c5d4b21482bf52fcd","target":1,"func":"void mips_malta_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    ram_addr_t ram_low_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    char *filename;\n\n    pflash_t *fl;\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *ram_high = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_low_preio = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_low_postio;\n\n    MemoryRegion *bios, *bios_copy = g_new(MemoryRegion, 1);\n\n    target_long bios_size = FLASH_SIZE;\n\n    const size_t smbus_eeprom_size = 8 * 256;\n\n    uint8_t *smbus_eeprom_buf = g_malloc0(smbus_eeprom_size);\n\n    int64_t kernel_entry, bootloader_run_addr;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    MIPSCPU *cpu;\n\n    CPUMIPSState *env;\n\n    qemu_irq *isa_irq;\n\n    int piix4_devfn;\n\n    I2CBus *smbus;\n\n    int i;\n\n    DriveInfo *dinfo;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n    int fl_idx = 0;\n\n    int fl_sectors = bios_size >> 16;\n\n    int be;\n\n\n\n    DeviceState *dev = qdev_create(NULL, TYPE_MIPS_MALTA);\n\n    MaltaState *s = MIPS_MALTA(dev);\n\n\n\n    \/* The whole address space decoded by the GT-64120A doesn't generate\n\n       exception when accessing invalid memory. Create an empty slot to\n\n       emulate this feature. *\/\n\n    empty_slot_init(0, 0x20000000);\n\n\n\n    qdev_init_nofail(dev);\n\n\n\n    \/* Make sure the first 3 serial ports are associated with a device. *\/\n\n    for(i = 0; i < 3; i++) {\n\n        if (!serial_hds[i]) {\n\n            char label[32];\n\n            snprintf(label, sizeof(label), \"serial%d\", i);\n\n            serial_hds[i] = qemu_chr_new(label, \"null\", NULL);\n\n        }\n\n    }\n\n\n\n    \/* init CPUs *\/\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_MIPS64\n\n        cpu_model = \"20Kc\";\n\n#else\n\n        cpu_model = \"24Kf\";\n\n#endif\n\n    }\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_mips_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        \/* Init internal devices *\/\n\n        cpu_mips_irq_init_cpu(env);\n\n        cpu_mips_clock_init(env);\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n    }\n\n    cpu = MIPS_CPU(first_cpu);\n\n    env = &cpu->env;\n\n\n\n    \/* allocate RAM *\/\n\n    if (ram_size > (2048u << 20)) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d MB, maximum 2048 MB\\n\",\n\n                ((unsigned int)ram_size \/ (1 << 20)));\n\n        exit(1);\n\n    }\n\n\n\n    \/* register RAM at high address where it is undisturbed by IO *\/\n\n    memory_region_allocate_system_memory(ram_high, NULL, \"mips_malta.ram\",\n\n                                         ram_size);\n\n    memory_region_add_subregion(system_memory, 0x80000000, ram_high);\n\n\n\n    \/* alias for pre IO hole access *\/\n\n    memory_region_init_alias(ram_low_preio, NULL, \"mips_malta_low_preio.ram\",\n\n                             ram_high, 0, MIN(ram_size, (256 << 20)));\n\n    memory_region_add_subregion(system_memory, 0, ram_low_preio);\n\n\n\n    \/* alias for post IO hole access, if there is enough RAM *\/\n\n    if (ram_size > (512 << 20)) {\n\n        ram_low_postio = g_new(MemoryRegion, 1);\n\n        memory_region_init_alias(ram_low_postio, NULL,\n\n                                 \"mips_malta_low_postio.ram\",\n\n                                 ram_high, 512 << 20,\n\n                                 ram_size - (512 << 20));\n\n        memory_region_add_subregion(system_memory, 512 << 20, ram_low_postio);\n\n    }\n\n\n\n    \/* generate SPD EEPROM data *\/\n\n    generate_eeprom_spd(&smbus_eeprom_buf[0 * 256], ram_size);\n\n    generate_eeprom_serial(&smbus_eeprom_buf[6 * 256]);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    \/* FPGA *\/\n\n    \/* The CBUS UART is attached to the MIPS CPU INT2 pin, ie interrupt 4 *\/\n\n    malta_fpga_init(system_memory, FPGA_ADDRESS, env->irq[4], serial_hds[2]);\n\n\n\n    \/* Load firmware in flash \/ BIOS. *\/\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n#ifdef DEBUG_BOARD_INIT\n\n    if (dinfo) {\n\n        printf(\"Register parallel flash %d size \" TARGET_FMT_lx \" at \"\n\n               \"addr %08llx '%s' %x\\n\",\n\n               fl_idx, bios_size, FLASH_ADDRESS,\n\n               blk_name(dinfo->bdrv), fl_sectors);\n\n    }\n\n#endif\n\n    fl = pflash_cfi01_register(FLASH_ADDRESS, NULL, \"mips_malta.bios\",\n\n                               BIOS_SIZE,\n\n                               dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                               65536, fl_sectors,\n\n                               4, 0x0000, 0x0000, 0x0000, 0x0000, be);\n\n    bios = pflash_cfi01_get_memory(fl);\n\n    fl_idx++;\n\n    if (kernel_filename) {\n\n        ram_low_size = MIN(ram_size, 256 << 20);\n\n        \/* For KVM we reserve 1MB of RAM for running bootloader *\/\n\n        if (kvm_enabled()) {\n\n            ram_low_size -= 0x100000;\n\n            bootloader_run_addr = 0x40000000 + ram_low_size;\n\n        } else {\n\n            bootloader_run_addr = 0xbfc00000;\n\n        }\n\n\n\n        \/* Write a small bootloader to the flash location. *\/\n\n        loaderparams.ram_size = ram_size;\n\n        loaderparams.ram_low_size = ram_low_size;\n\n        loaderparams.kernel_filename = kernel_filename;\n\n        loaderparams.kernel_cmdline = kernel_cmdline;\n\n        loaderparams.initrd_filename = initrd_filename;\n\n        kernel_entry = load_kernel();\n\n\n\n        write_bootloader(memory_region_get_ram_ptr(bios),\n\n                         bootloader_run_addr, kernel_entry);\n\n        if (kvm_enabled()) {\n\n            \/* Write the bootloader code @ the end of RAM, 1MB reserved *\/\n\n            write_bootloader(memory_region_get_ram_ptr(ram_low_preio) +\n\n                                    ram_low_size,\n\n                             bootloader_run_addr, kernel_entry);\n\n        }\n\n    } else {\n\n        \/* The flash region isn't executable from a KVM guest *\/\n\n        if (kvm_enabled()) {\n\n            error_report(\"KVM enabled but no -kernel argument was specified. \"\n\n                         \"Booting from flash is not supported with KVM.\");\n\n            exit(1);\n\n        }\n\n        \/* Load firmware from flash. *\/\n\n        if (!dinfo) {\n\n            \/* Load a BIOS image. *\/\n\n            if (bios_name == NULL) {\n\n                bios_name = BIOS_FILENAME;\n\n            }\n\n            filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n            if (filename) {\n\n                bios_size = load_image_targphys(filename, FLASH_ADDRESS,\n\n                                                BIOS_SIZE);\n\n                g_free(filename);\n\n            } else {\n\n                bios_size = -1;\n\n            }\n\n            if ((bios_size < 0 || bios_size > BIOS_SIZE) &&\n\n                !kernel_filename && !qtest_enabled()) {\n\n                error_report(\"Could not load MIPS bios '%s', and no \"\n\n                             \"-kernel argument was specified\", bios_name);\n\n                exit(1);\n\n            }\n\n        }\n\n        \/* In little endian mode the 32bit words in the bios are swapped,\n\n           a neat trick which allows bi-endian firmware. *\/\n\n#ifndef TARGET_WORDS_BIGENDIAN\n\n        {\n\n            uint32_t *end, *addr = rom_ptr(FLASH_ADDRESS);\n\n            if (!addr) {\n\n                addr = memory_region_get_ram_ptr(bios);\n\n            }\n\n            end = (void *)addr + MIN(bios_size, 0x3e0000);\n\n            while (addr < end) {\n\n                bswap32s(addr);\n\n                addr++;\n\n            }\n\n        }\n\n#endif\n\n    }\n\n\n\n    \/*\n\n     * Map the BIOS at a 2nd physical location, as on the real board.\n\n     * Copy it so that we can patch in the MIPS revision, which cannot be\n\n     * handled by an overlapping region as the resulting ROM code subpage\n\n     * regions are not executable.\n\n     *\/\n\n    memory_region_init_ram(bios_copy, NULL, \"bios.1fc\", BIOS_SIZE,\n\n                           &error_fatal);\n\n    if (!rom_copy(memory_region_get_ram_ptr(bios_copy),\n\n                  FLASH_ADDRESS, BIOS_SIZE)) {\n\n        memcpy(memory_region_get_ram_ptr(bios_copy),\n\n               memory_region_get_ram_ptr(bios), BIOS_SIZE);\n\n    }\n\n    memory_region_set_readonly(bios_copy, true);\n\n    memory_region_add_subregion(system_memory, RESET_ADDRESS, bios_copy);\n\n\n\n    \/* Board ID = 0x420 (Malta Board with CoreLV) *\/\n\n    stl_p(memory_region_get_ram_ptr(bios_copy) + 0x10, 0x00000420);\n\n\n\n    \/* Init internal devices *\/\n\n    cpu_mips_irq_init_cpu(env);\n\n    cpu_mips_clock_init(env);\n\n\n\n    \/*\n\n     * We have a circular dependency problem: pci_bus depends on isa_irq,\n\n     * isa_irq is provided by i8259, i8259 depends on ISA, ISA depends\n\n     * on piix4, and piix4 depends on pci_bus.  To stop the cycle we have\n\n     * qemu_irq_proxy() adds an extra bit of indirection, allowing us\n\n     * to resolve the isa_irq -> i8259 dependency after i8259 is initialized.\n\n     *\/\n\n    isa_irq = qemu_irq_proxy(&s->i8259, 16);\n\n\n\n    \/* Northbridge *\/\n\n    pci_bus = gt64120_register(isa_irq);\n\n\n\n    \/* Southbridge *\/\n\n    ide_drive_get(hd, ARRAY_SIZE(hd));\n\n\n\n    piix4_devfn = piix4_init(pci_bus, &isa_bus, 80);\n\n\n\n    \/* Interrupt controller *\/\n\n    \/* The 8259 is attached to the MIPS CPU INT0 pin, ie interrupt 2 *\/\n\n    s->i8259 = i8259_init(isa_bus, env->irq[2]);\n\n\n\n    isa_bus_irqs(isa_bus, s->i8259);\n\n    pci_piix4_ide_init(pci_bus, hd, piix4_devfn + 1);\n\n    pci_create_simple(pci_bus, piix4_devfn + 2, \"piix4-usb-uhci\");\n\n    smbus = piix4_pm_init(pci_bus, piix4_devfn + 3, 0x1100,\n\n                          isa_get_irq(NULL, 9), NULL, 0, NULL);\n\n    smbus_eeprom_init(smbus, 8, smbus_eeprom_buf, smbus_eeprom_size);\n\n    g_free(smbus_eeprom_buf);\n\n    pit = pit_init(isa_bus, 0x40, 0, NULL);\n\n    DMA_init(isa_bus, 0);\n\n\n\n    \/* Super I\/O *\/\n\n    isa_create_simple(isa_bus, \"i8042\");\n\n\n\n    rtc_init(isa_bus, 2000, NULL);\n\n    serial_hds_isa_init(isa_bus, 2);\n\n    parallel_hds_isa_init(isa_bus, 1);\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    fdctrl_init_isa(isa_bus, fd);\n\n\n\n    \/* Network card *\/\n\n    network_init(pci_bus);\n\n\n\n    \/* Optional PCI video card *\/\n\n    pci_vga_init(pci_bus);\n\n}\n"},{"project":"qemu","commit_id":"f4658285f99473367dbbc34ce6970ec4637c2388","target":1,"func":"static void tracked_request_begin(BdrvTrackedRequest *req,\n                                  BlockDriverState *bs,\n                                  int64_t sector_num,\n                                  int nb_sectors, bool is_write)\n    *req = (BdrvTrackedRequest){\n        .bs = bs,\n        .sector_num = sector_num,\n        .nb_sectors = nb_sectors,\n        .is_write = is_write,\n    };\n    QLIST_INSERT_HEAD(&bs->tracked_requests, req, list);"},{"project":"qemu","commit_id":"df58713396f8b2deb923e39c00b10744c5c63909","target":1,"func":"static void spapr_memory_plug(HotplugHandler *hotplug_dev, DeviceState *dev,\n                              uint32_t node, Error **errp)\n{\n    Error *local_err = NULL;\n    sPAPRMachineState *ms = SPAPR_MACHINE(hotplug_dev);\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);\n    MemoryRegion *mr = ddc->get_memory_region(dimm);\n    uint64_t align = memory_region_get_alignment(mr);\n    uint64_t size = memory_region_size(mr);\n    uint64_t addr;\n    char *mem_dev;\n    if (size % SPAPR_MEMORY_BLOCK_SIZE) {\n        error_setg(&local_err, \"Hotplugged memory size must be a multiple of \"\n                      \"%lld MB\", SPAPR_MEMORY_BLOCK_SIZE\/M_BYTE);\n    pc_dimm_memory_plug(dev, &ms->hotplug_memory, mr, align, &local_err);\n    if (local_err) {\n    addr = object_property_get_int(OBJECT(dimm), PC_DIMM_ADDR_PROP, &local_err);\n    if (local_err) {\n        pc_dimm_memory_unplug(dev, &ms->hotplug_memory, mr);\n    spapr_add_lmbs(dev, addr, size, node,\n                   spapr_ovec_test(ms->ov5_cas, OV5_HP_EVT),\n                   &error_abort);\nout:\n    error_propagate(errp, local_err);"},{"project":"qemu","commit_id":"7848c8d19f8556666df25044bbd5d8b29439c368","target":0,"func":"void helper_syscall(CPUX86State *env, int next_eip_addend)\n\n{\n\n    int selector;\n\n\n\n    if (!(env->efer & MSR_EFER_SCE)) {\n\n        raise_exception_err(env, EXCP06_ILLOP, 0);\n\n    }\n\n    selector = (env->star >> 32) & 0xffff;\n\n    if (env->hflags & HF_LMA_MASK) {\n\n        int code64;\n\n\n\n        env->regs[R_ECX] = env->eip + next_eip_addend;\n\n        env->regs[11] = cpu_compute_eflags(env);\n\n\n\n        code64 = env->hflags & HF_CS64_MASK;\n\n\n\n        env->eflags &= ~env->fmask;\n\n        cpu_load_eflags(env, env->eflags, 0);\n\n        cpu_x86_set_cpl(env, 0);\n\n        cpu_x86_load_seg_cache(env, R_CS, selector & 0xfffc,\n\n                           0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK |\n\n                               DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK |\n\n                               DESC_L_MASK);\n\n        cpu_x86_load_seg_cache(env, R_SS, (selector + 8) & 0xfffc,\n\n                               0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK |\n\n                               DESC_W_MASK | DESC_A_MASK);\n\n        if (code64) {\n\n            env->eip = env->lstar;\n\n        } else {\n\n            env->eip = env->cstar;\n\n        }\n\n    } else {\n\n        env->regs[R_ECX] = (uint32_t)(env->eip + next_eip_addend);\n\n\n\n        env->eflags &= ~(IF_MASK | RF_MASK | VM_MASK);\n\n        cpu_x86_set_cpl(env, 0);\n\n        cpu_x86_load_seg_cache(env, R_CS, selector & 0xfffc,\n\n                           0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK |\n\n                               DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK);\n\n        cpu_x86_load_seg_cache(env, R_SS, (selector + 8) & 0xfffc,\n\n                               0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK |\n\n                               DESC_W_MASK | DESC_A_MASK);\n\n        env->eip = (uint32_t)env->star;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"4482e05cbbb7e50e476f6a9500cf0b38913bd939","target":1,"func":"const char *cpu_parse_cpu_model(const char *typename, const char *cpu_model)\n\n{\n\n    ObjectClass *oc;\n\n    CPUClass *cc;\n\n    Error *err = NULL;\n\n    gchar **model_pieces;\n\n    const char *cpu_type;\n\n\n\n    model_pieces = g_strsplit(cpu_model, \",\", 2);\n\n\n\n    oc = cpu_class_by_name(typename, model_pieces[0]);\n\n    if (oc == NULL) {\n\n        g_strfreev(model_pieces);\n\n        return NULL;\n\n    }\n\n\n\n    cpu_type = object_class_get_name(oc);\n\n    cc = CPU_CLASS(oc);\n\n    cc->parse_features(cpu_type, model_pieces[1], &err);\n\n    g_strfreev(model_pieces);\n\n    if (err != NULL) {\n\n        error_report_err(err);\n\n        return NULL;\n\n    }\n\n    return cpu_type;\n\n}\n"},{"project":"qemu","commit_id":"231bb267644ee3a9ebfd9c7f42d5d41610194b45","target":1,"func":"int qcow2_check_metadata_overlap(BlockDriverState *bs, int chk, int64_t offset,\n\n                                 int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int i, j;\n\n\n\n    if (!size) {\n\n        return 0;\n\n    }\n\n\n\n    if (chk & QCOW2_OL_MAIN_HEADER) {\n\n        if (offset < s->cluster_size) {\n\n            return QCOW2_OL_MAIN_HEADER;\n\n        }\n\n    }\n\n\n\n    \/* align range to test to cluster boundaries *\/\n\n    size = align_offset(offset_into_cluster(s, offset) + size, s->cluster_size);\n\n    offset = start_of_cluster(s, offset);\n\n\n\n    if ((chk & QCOW2_OL_ACTIVE_L1) && s->l1_size) {\n\n        if (overlaps_with(s->l1_table_offset, s->l1_size * sizeof(uint64_t))) {\n\n            return QCOW2_OL_ACTIVE_L1;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_REFCOUNT_TABLE) && s->refcount_table_size) {\n\n        if (overlaps_with(s->refcount_table_offset,\n\n            s->refcount_table_size * sizeof(uint64_t))) {\n\n            return QCOW2_OL_REFCOUNT_TABLE;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_SNAPSHOT_TABLE) && s->snapshots_size) {\n\n        if (overlaps_with(s->snapshots_offset, s->snapshots_size)) {\n\n            return QCOW2_OL_SNAPSHOT_TABLE;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_INACTIVE_L1) && s->snapshots) {\n\n        for (i = 0; i < s->nb_snapshots; i++) {\n\n            if (s->snapshots[i].l1_size &&\n\n                overlaps_with(s->snapshots[i].l1_table_offset,\n\n                s->snapshots[i].l1_size * sizeof(uint64_t))) {\n\n                return QCOW2_OL_INACTIVE_L1;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_ACTIVE_L2) && s->l1_table) {\n\n        for (i = 0; i < s->l1_size; i++) {\n\n            if ((s->l1_table[i] & L1E_OFFSET_MASK) &&\n\n                overlaps_with(s->l1_table[i] & L1E_OFFSET_MASK,\n\n                s->cluster_size)) {\n\n                return QCOW2_OL_ACTIVE_L2;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_REFCOUNT_BLOCK) && s->refcount_table) {\n\n        for (i = 0; i < s->refcount_table_size; i++) {\n\n            if ((s->refcount_table[i] & REFT_OFFSET_MASK) &&\n\n                overlaps_with(s->refcount_table[i] & REFT_OFFSET_MASK,\n\n                s->cluster_size)) {\n\n                return QCOW2_OL_REFCOUNT_BLOCK;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_INACTIVE_L2) && s->snapshots) {\n\n        for (i = 0; i < s->nb_snapshots; i++) {\n\n            uint64_t l1_ofs = s->snapshots[i].l1_table_offset;\n\n            uint32_t l1_sz  = s->snapshots[i].l1_size;\n\n            uint64_t l1_sz2 = l1_sz * sizeof(uint64_t);\n\n            uint64_t *l1 = g_malloc(l1_sz2);\n\n            int ret;\n\n\n\n            ret = bdrv_pread(bs->file, l1_ofs, l1, l1_sz2);\n\n            if (ret < 0) {\n\n                g_free(l1);\n\n                return ret;\n\n            }\n\n\n\n            for (j = 0; j < l1_sz; j++) {\n\n                uint64_t l2_ofs = be64_to_cpu(l1[j]) & L1E_OFFSET_MASK;\n\n                if (l2_ofs && overlaps_with(l2_ofs, s->cluster_size)) {\n\n                    g_free(l1);\n\n                    return QCOW2_OL_INACTIVE_L2;\n\n                }\n\n            }\n\n\n\n            g_free(l1);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"82d07945652f16078b172d2bd46659e8f5f30d8e","target":1,"func":"static void assign_failed_examine(AssignedDevice *dev)\n\n{\n\n    char name[PATH_MAX], dir[PATH_MAX], driver[PATH_MAX] = {}, *ns;\n\n    uint16_t vendor_id, device_id;\n\n    int r;\n\n\n\n    snprintf(dir, sizeof(dir), \"\/sys\/bus\/pci\/devices\/%04x:%02x:%02x.%01x\/\",\n\n            dev->host.domain, dev->host.bus, dev->host.slot,\n\n            dev->host.function);\n\n\n\n    snprintf(name, sizeof(name), \"%sdriver\", dir);\n\n\n\n    r = readlink(name, driver, sizeof(driver));\n\n    if ((r <= 0) || r >= sizeof(driver)) {\n\n        goto fail;\n\n    }\n\n\n\n\n    ns = strrchr(driver, '\/');\n\n    if (!ns) {\n\n        goto fail;\n\n    }\n\n\n\n    ns++;\n\n\n\n    if (get_real_vendor_id(dir, &vendor_id) ||\n\n        get_real_device_id(dir, &device_id)) {\n\n        goto fail;\n\n    }\n\n\n\n    error_printf(\"*** The driver '%s' is occupying your device \"\n\n        \"%04x:%02x:%02x.%x.\\n\"\n\n        \"***\\n\"\n\n        \"*** You can try the following commands to free it:\\n\"\n\n        \"***\\n\"\n\n        \"*** $ echo \\\"%04x %04x\\\" > \/sys\/bus\/pci\/drivers\/pci-stub\/new_id\\n\"\n\n        \"*** $ echo \\\"%04x:%02x:%02x.%x\\\" > \/sys\/bus\/pci\/drivers\/%s\/unbind\\n\"\n\n        \"*** $ echo \\\"%04x:%02x:%02x.%x\\\" > \/sys\/bus\/pci\/drivers\/\"\n\n        \"pci-stub\/bind\\n\"\n\n        \"*** $ echo \\\"%04x %04x\\\" > \/sys\/bus\/pci\/drivers\/pci-stub\/remove_id\\n\"\n\n        \"***\",\n\n        ns, dev->host.domain, dev->host.bus, dev->host.slot,\n\n        dev->host.function, vendor_id, device_id,\n\n        dev->host.domain, dev->host.bus, dev->host.slot, dev->host.function,\n\n        ns, dev->host.domain, dev->host.bus, dev->host.slot,\n\n        dev->host.function, vendor_id, device_id);\n\n\n\n    return;\n\n\n\nfail:\n\n    error_report(\"Couldn't find out why.\");\n\n}"},{"project":"qemu","commit_id":"b4d02820d95e025e57d82144f7b2ccd677ac2418","target":0,"func":"void bdrv_close(BlockDriverState *bs)\n\n{\n\n    BdrvAioNotifier *ban, *ban_next;\n\n\n\n    if (bs->job) {\n\n        block_job_cancel_sync(bs->job);\n\n    }\n\n\n\n    \/* Disable I\/O limits and drain all pending throttled requests *\/\n\n    if (bs->io_limits_enabled) {\n\n        bdrv_io_limits_disable(bs);\n\n    }\n\n\n\n    bdrv_drain(bs); \/* complete I\/O *\/\n\n    bdrv_flush(bs);\n\n    bdrv_drain(bs); \/* in case flush left pending I\/O *\/\n\n    notifier_list_notify(&bs->close_notifiers, bs);\n\n\n\n    if (bs->drv) {\n\n        BdrvChild *child, *next;\n\n\n\n        bs->drv->bdrv_close(bs);\n\n        bs->drv = NULL;\n\n\n\n        bdrv_set_backing_hd(bs, NULL);\n\n\n\n        if (bs->file != NULL) {\n\n            bdrv_unref_child(bs, bs->file);\n\n            bs->file = NULL;\n\n        }\n\n\n\n        QLIST_FOREACH_SAFE(child, &bs->children, next, next) {\n\n            \/* TODO Remove bdrv_unref() from drivers' close function and use\n\n             * bdrv_unref_child() here *\/\n\n            if (child->bs->inherits_from == bs) {\n\n                child->bs->inherits_from = NULL;\n\n            }\n\n            bdrv_detach_child(child);\n\n        }\n\n\n\n        g_free(bs->opaque);\n\n        bs->opaque = NULL;\n\n        bs->copy_on_read = 0;\n\n        bs->backing_file[0] = '\\0';\n\n        bs->backing_format[0] = '\\0';\n\n        bs->total_sectors = 0;\n\n        bs->encrypted = 0;\n\n        bs->valid_key = 0;\n\n        bs->sg = 0;\n\n        bs->zero_beyond_eof = false;\n\n        QDECREF(bs->options);\n\n        bs->options = NULL;\n\n        QDECREF(bs->full_open_options);\n\n        bs->full_open_options = NULL;\n\n    }\n\n\n\n    if (bs->blk) {\n\n        blk_dev_change_media_cb(bs->blk, false);\n\n    }\n\n\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n\n        g_free(ban);\n\n    }\n\n    QLIST_INIT(&bs->aio_notifiers);\n\n}\n"},{"project":"qemu","commit_id":"7b0309490cb108d881a0c66d6b350b4db7b3b4ac","target":1,"func":"DeviceState *qdev_device_add(QemuOpts *opts)\n\n{\n\n    ObjectClass *oc;\n\n    DeviceClass *dc;\n\n    const char *driver, *path, *id;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        qerror_report(QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    \/* find driver *\/\n\n    oc = object_class_by_name(driver);\n\n    if (!oc) {\n\n        const char *typename = find_typename_by_alias(driver);\n\n\n\n        if (typename) {\n\n            driver = typename;\n\n            oc = object_class_by_name(driver);\n\n        }\n\n    }\n\n\n\n    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"'%s' is not a valid device model name\", driver);\n\n        return NULL;\n\n    }\n\n\n\n    if (object_class_is_abstract(oc)) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"non-abstract device type\");\n\n        return NULL;\n\n    }\n\n\n\n    dc = DEVICE_CLASS(oc);\n\n    if (dc->cannot_instantiate_with_device_add_yet) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"pluggable device type\");\n\n        return NULL;\n\n    }\n\n\n\n    \/* find bus *\/\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            qerror_report(QERR_BAD_BUS_FOR_DEVICE,\n\n                          driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus) {\n\n            qerror_report(QERR_NO_BUS_FOR_DEVICE,\n\n                          dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !bus->allow_hotplug) {\n\n        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    \/* create device, set properties *\/\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n    }\n\n\n\n    id = qemu_opts_id(opts);\n\n    if (id) {\n\n        dev->id = id;\n\n    }\n\n    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        return NULL;\n\n    }\n\n    if (dev->id) {\n\n        object_property_add_child(qdev_get_peripheral(), dev->id,\n\n                                  OBJECT(dev), NULL);\n\n    } else {\n\n        static int anon_count;\n\n        gchar *name = g_strdup_printf(\"device[%d]\", anon_count++);\n\n        object_property_add_child(qdev_get_peripheral_anon(), name,\n\n                                  OBJECT(dev), NULL);\n\n        g_free(name);\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        qerror_report_err(err);\n\n        error_free(err);\n\n        dev->opts = NULL;\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        qerror_report(QERR_DEVICE_INIT_FAILED, driver);\n\n        return NULL;\n\n    }\n\n    return dev;\n\n}\n"},{"project":"qemu","commit_id":"240ce26a0533a6e5ee472789fbfbd9f7f939197e","target":1,"func":"static int decode_micromips_opc (CPUMIPSState *env, DisasContext *ctx, int *is_branch)\n\n{\n\n    uint32_t op;\n\n\n\n    \/* make sure instructions are on a halfword boundary *\/\n\n    if (ctx->pc & 0x1) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception(ctx, EXCP_AdEL);\n\n        ctx->bstate = BS_STOP;\n\n        return 2;\n\n    }\n\n\n\n    op = (ctx->opcode >> 10) & 0x3f;\n\n    \/* Enforce properly-sized instructions in a delay slot *\/\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int bits = ctx->hflags & MIPS_HFLAG_BMASK_EXT;\n\n\n\n        switch (op) {\n\n        case POOL32A:\n\n        case POOL32B:\n\n        case POOL32I:\n\n        case POOL32C:\n\n        case ADDI32:\n\n        case ADDIU32:\n\n        case ORI32:\n\n        case XORI32:\n\n        case SLTI32:\n\n        case SLTIU32:\n\n        case ANDI32:\n\n        case JALX32:\n\n        case LBU32:\n\n        case LHU32:\n\n        case POOL32F:\n\n        case JALS32:\n\n        case BEQ32:\n\n        case BNE32:\n\n        case J32:\n\n        case JAL32:\n\n        case SB32:\n\n        case SH32:\n\n        case POOL32S:\n\n        case ADDIUPC:\n\n        case SWC132:\n\n        case SDC132:\n\n        case SD32:\n\n        case SW32:\n\n        case LB32:\n\n        case LH32:\n\n        case DADDIU32:\n\n        case LWC132:\n\n        case LDC132:\n\n        case LD32:\n\n        case LW32:\n\n            if (bits & MIPS_HFLAG_BDS16) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                \/* Just stop translation; the user is confused.  *\/\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        case POOL16A:\n\n        case POOL16B:\n\n        case POOL16C:\n\n        case LWGP16:\n\n        case POOL16F:\n\n        case LBU16:\n\n        case LHU16:\n\n        case LWSP16:\n\n        case LW16:\n\n        case SB16:\n\n        case SH16:\n\n        case SWSP16:\n\n        case SW16:\n\n        case MOVE16:\n\n        case ANDI16:\n\n        case POOL16D:\n\n        case POOL16E:\n\n        case BEQZ16:\n\n        case BNEZ16:\n\n        case B16:\n\n        case LI16:\n\n            if (bits & MIPS_HFLAG_BDS32) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                \/* Just stop translation; the user is confused.  *\/\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    switch (op) {\n\n    case POOL16A:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs1 = mmreg(uMIPS_RS1(ctx->opcode));\n\n            int rs2 = mmreg(uMIPS_RS2(ctx->opcode));\n\n            uint32_t opc = 0;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case ADDU16:\n\n                opc = OPC_ADDU;\n\n                break;\n\n            case SUBU16:\n\n                opc = OPC_SUBU;\n\n                break;\n\n            }\n\n\n\n            gen_arith(ctx, opc, rd, rs1, rs2);\n\n        }\n\n        break;\n\n    case POOL16B:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs = mmreg(uMIPS_RS(ctx->opcode));\n\n            int amount = (ctx->opcode >> 1) & 0x7;\n\n            uint32_t opc = 0;\n\n            amount = amount == 0 ? 8 : amount;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case SLL16:\n\n                opc = OPC_SLL;\n\n                break;\n\n            case SRL16:\n\n                opc = OPC_SRL;\n\n                break;\n\n            }\n\n\n\n            gen_shift_imm(ctx, opc, rd, rs, amount);\n\n        }\n\n        break;\n\n    case POOL16C:\n\n        gen_pool16c_insn(ctx, is_branch);\n\n        break;\n\n    case LWGP16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = 28;            \/* GP *\/\n\n            int16_t offset = SIMM(ctx->opcode, 0, 7) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case POOL16F:\n\n        if (ctx->opcode & 1) {\n\n            generate_exception(ctx, EXCP_RI);\n\n        } else {\n\n            \/* MOVEP *\/\n\n            int enc_dest = uMIPS_RD(ctx->opcode);\n\n            int enc_rt = uMIPS_RS2(ctx->opcode);\n\n            int enc_rs = uMIPS_RS1(ctx->opcode);\n\n            int rd, rs, re, rt;\n\n            static const int rd_enc[] = { 5, 5, 6, 4, 4, 4, 4, 4 };\n\n            static const int re_enc[] = { 6, 7, 7, 21, 22, 5, 6, 7 };\n\n            static const int rs_rt_enc[] = { 0, 17, 2, 3, 16, 18, 19, 20 };\n\n\n\n            rd = rd_enc[enc_dest];\n\n            re = re_enc[enc_dest];\n\n            rs = rs_rt_enc[enc_rs];\n\n            rt = rs_rt_enc[enc_rt];\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, re, rt, 0);\n\n        }\n\n        break;\n\n    case LBU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n            offset = (offset == 0xf ? -1 : offset);\n\n\n\n            gen_ld(ctx, OPC_LBU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LHU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_ld(ctx, OPC_LHU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            \/* SP *\/\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LW16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SB16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_st(ctx, OPC_SB, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SH16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_st(ctx, OPC_SH, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            \/* SP *\/\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SW16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case MOVE16:\n\n        {\n\n            int rd = uMIPS_RD5(ctx->opcode);\n\n            int rs = uMIPS_RS5(ctx->opcode);\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n        }\n\n        break;\n\n    case ANDI16:\n\n        gen_andi16(ctx);\n\n        break;\n\n    case POOL16D:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUS5:\n\n            gen_addius5(ctx);\n\n            break;\n\n        case ADDIUSP:\n\n            gen_addiusp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case POOL16E:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUR2:\n\n            gen_addiur2(ctx);\n\n            break;\n\n        case ADDIUR1SP:\n\n            gen_addiur1sp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case B16:\n\n        gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0,\n\n                           SIMM(ctx->opcode, 0, 10) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case BNEZ16:\n\n    case BEQZ16:\n\n        gen_compute_branch(ctx, op == BNEZ16 ? OPC_BNE : OPC_BEQ, 2,\n\n                           mmreg(uMIPS_RD(ctx->opcode)),\n\n                           0, SIMM(ctx->opcode, 0, 7) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case LI16:\n\n        {\n\n            int reg = mmreg(uMIPS_RD(ctx->opcode));\n\n            int imm = ZIMM(ctx->opcode, 0, 7);\n\n\n\n            imm = (imm == 0x7f ? -1 : imm);\n\n            tcg_gen_movi_tl(cpu_gpr[reg], imm);\n\n        }\n\n        break;\n\n    case RES_20:\n\n    case RES_28:\n\n    case RES_29:\n\n    case RES_30:\n\n    case RES_31:\n\n    case RES_38:\n\n    case RES_39:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    default:\n\n        decode_micromips32_opc (env, ctx, op, is_branch);\n\n        return 4;\n\n    }\n\n\n\n    return 2;\n\n}\n"},{"project":"qemu","commit_id":"4f5e19e6c570459cd524b29b24374f03860f5149","target":0,"func":"static int pci_pbm_init_device(SysBusDevice *dev)\n\n{\n\n\n\n    APBState *s;\n\n    int pci_mem_config, pci_mem_data, apb_config, pci_ioport;\n\n\n\n    s = FROM_SYSBUS(APBState, dev);\n\n    \/* apb_config *\/\n\n    apb_config = cpu_register_io_memory(apb_config_read,\n\n                                        apb_config_write, s);\n\n    sysbus_init_mmio(dev, 0x40ULL, apb_config);\n\n    \/* pci_ioport *\/\n\n    pci_ioport = cpu_register_io_memory(pci_apb_ioread,\n\n                                          pci_apb_iowrite, s);\n\n    sysbus_init_mmio(dev, 0x10000ULL, pci_ioport);\n\n    \/* mem_config  *\/\n\n    pci_mem_config = cpu_register_io_memory(pci_apb_config_read,\n\n                                            pci_apb_config_write, s);\n\n    sysbus_init_mmio(dev, 0x10ULL, pci_mem_config);\n\n    \/* mem_data *\/\n\n    pci_mem_data = cpu_register_io_memory(pci_apb_read,\n\n                                          pci_apb_write, &s->host_state);\n\n    sysbus_init_mmio(dev, 0x10000000ULL, pci_mem_data);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"timer_write(void *opaque, target_phys_addr_t addr,\n\n            uint64_t val64, unsigned int size)\n\n{\n\n    struct etrax_timer *t = opaque;\n\n    uint32_t value = val64;\n\n\n\n    switch (addr)\n\n    {\n\n        case RW_TMR0_DIV:\n\n            t->rw_tmr0_div = value;\n\n            break;\n\n        case RW_TMR0_CTRL:\n\n            D(printf (\"RW_TMR0_CTRL=%x\\n\", value));\n\n            t->rw_tmr0_ctrl = value;\n\n            update_ctrl(t, 0);\n\n            break;\n\n        case RW_TMR1_DIV:\n\n            t->rw_tmr1_div = value;\n\n            break;\n\n        case RW_TMR1_CTRL:\n\n            D(printf (\"RW_TMR1_CTRL=%x\\n\", value));\n\n            t->rw_tmr1_ctrl = value;\n\n            update_ctrl(t, 1);\n\n            break;\n\n        case RW_INTR_MASK:\n\n            D(printf (\"RW_INTR_MASK=%x\\n\", value));\n\n            t->rw_intr_mask = value;\n\n            timer_update_irq(t);\n\n            break;\n\n        case RW_WD_CTRL:\n\n            timer_watchdog_update(t, value);\n\n            break;\n\n        case RW_ACK_INTR:\n\n            t->rw_ack_intr = value;\n\n            timer_update_irq(t);\n\n            t->rw_ack_intr = 0;\n\n            break;\n\n        default:\n\n            printf (\"%s \" TARGET_FMT_plx \" %x\\n\",\n\n                __func__, addr, value);\n\n            break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"7385ac0ba2456159a52b9b2cbb5f6c71921d0c23","target":0,"func":"static void gen_mtc0 (CPUState *env, DisasContext *ctx, int reg, int sel)\n\n{\n\n    const char *rn = \"invalid\";\n\n\n\n    if (sel != 0)\n\n        check_insn(env, ctx, ISA_MIPS32);\n\n\n\n    switch (reg) {\n\n    case 0:\n\n        switch (sel) {\n\n        case 0:\n\n           gen_op_mtc0_index();\n\n            rn = \"Index\";\n\n            break;\n\n        case 1:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_mvpcontrol();\n\n            rn = \"MVPControl\";\n\n            break;\n\n        case 2:\n\n            check_mips_mt(env, ctx);\n\n            \/* ignored *\/\n\n            rn = \"MVPConf0\";\n\n            break;\n\n        case 3:\n\n            check_mips_mt(env, ctx);\n\n            \/* ignored *\/\n\n            rn = \"MVPConf1\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 1:\n\n        switch (sel) {\n\n        case 0:\n\n            \/* ignored *\/\n\n            rn = \"Random\";\n\n            break;\n\n        case 1:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_vpecontrol();\n\n            rn = \"VPEControl\";\n\n            break;\n\n        case 2:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_vpeconf0();\n\n            rn = \"VPEConf0\";\n\n            break;\n\n        case 3:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_vpeconf1();\n\n            rn = \"VPEConf1\";\n\n            break;\n\n        case 4:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_yqmask();\n\n            rn = \"YQMask\";\n\n            break;\n\n        case 5:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_vpeschedule();\n\n            rn = \"VPESchedule\";\n\n            break;\n\n        case 6:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_vpeschefback();\n\n            rn = \"VPEScheFBack\";\n\n            break;\n\n        case 7:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_vpeopt();\n\n            rn = \"VPEOpt\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 2:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_entrylo0();\n\n            rn = \"EntryLo0\";\n\n            break;\n\n        case 1:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tcstatus();\n\n            rn = \"TCStatus\";\n\n            break;\n\n        case 2:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tcbind();\n\n            rn = \"TCBind\";\n\n            break;\n\n        case 3:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tcrestart();\n\n            rn = \"TCRestart\";\n\n            break;\n\n        case 4:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tchalt();\n\n            rn = \"TCHalt\";\n\n            break;\n\n        case 5:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tccontext();\n\n            rn = \"TCContext\";\n\n            break;\n\n        case 6:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tcschedule();\n\n            rn = \"TCSchedule\";\n\n            break;\n\n        case 7:\n\n            check_mips_mt(env, ctx);\n\n            gen_op_mtc0_tcschefback();\n\n            rn = \"TCScheFBack\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 3:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_entrylo1();\n\n            rn = \"EntryLo1\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 4:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_context();\n\n            rn = \"Context\";\n\n            break;\n\n        case 1:\n\n\/\/            gen_op_mtc0_contextconfig(); \/* SmartMIPS ASE *\/\n\n            rn = \"ContextConfig\";\n\n\/\/            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 5:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_pagemask();\n\n            rn = \"PageMask\";\n\n            break;\n\n        case 1:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_pagegrain();\n\n            rn = \"PageGrain\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 6:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_wired();\n\n            rn = \"Wired\";\n\n            break;\n\n        case 1:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsconf0();\n\n            rn = \"SRSConf0\";\n\n            break;\n\n        case 2:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsconf1();\n\n            rn = \"SRSConf1\";\n\n            break;\n\n        case 3:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsconf2();\n\n            rn = \"SRSConf2\";\n\n            break;\n\n        case 4:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsconf3();\n\n            rn = \"SRSConf3\";\n\n            break;\n\n        case 5:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsconf4();\n\n            rn = \"SRSConf4\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 7:\n\n        switch (sel) {\n\n        case 0:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_hwrena();\n\n            rn = \"HWREna\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 8:\n\n        \/* ignored *\/\n\n        rn = \"BadVaddr\";\n\n        break;\n\n    case 9:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_count();\n\n            rn = \"Count\";\n\n            break;\n\n        \/* 6,7 are implementation dependent *\/\n\n        default:\n\n            goto die;\n\n        }\n\n        \/* Stop translation as we may have switched the execution mode *\/\n\n        ctx->bstate = BS_STOP;\n\n        break;\n\n    case 10:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_entryhi();\n\n            rn = \"EntryHi\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 11:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_compare();\n\n            rn = \"Compare\";\n\n            break;\n\n        \/* 6,7 are implementation dependent *\/\n\n        default:\n\n            goto die;\n\n        }\n\n        \/* Stop translation as we may have switched the execution mode *\/\n\n        ctx->bstate = BS_STOP;\n\n        break;\n\n    case 12:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_status();\n\n            \/* BS_STOP isn't good enough here, hflags may have changed. *\/\n\n            gen_save_pc(ctx->pc + 4);\n\n            ctx->bstate = BS_EXCP;\n\n            rn = \"Status\";\n\n            break;\n\n        case 1:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_intctl();\n\n            \/* Stop translation as we may have switched the execution mode *\/\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"IntCtl\";\n\n            break;\n\n        case 2:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsctl();\n\n            \/* Stop translation as we may have switched the execution mode *\/\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"SRSCtl\";\n\n            break;\n\n        case 3:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_srsmap();\n\n            \/* Stop translation as we may have switched the execution mode *\/\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"SRSMap\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 13:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_cause();\n\n            rn = \"Cause\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        \/* Stop translation as we may have switched the execution mode *\/\n\n        ctx->bstate = BS_STOP;\n\n        break;\n\n    case 14:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_epc();\n\n            rn = \"EPC\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 15:\n\n        switch (sel) {\n\n        case 0:\n\n            \/* ignored *\/\n\n            rn = \"PRid\";\n\n            break;\n\n        case 1:\n\n            check_insn(env, ctx, ISA_MIPS32R2);\n\n            gen_op_mtc0_ebase();\n\n            rn = \"EBase\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 16:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_config0();\n\n            rn = \"Config\";\n\n            \/* Stop translation as we may have switched the execution mode *\/\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        case 1:\n\n            \/* ignored, read only *\/\n\n            rn = \"Config1\";\n\n            break;\n\n        case 2:\n\n            gen_op_mtc0_config2();\n\n            rn = \"Config2\";\n\n            \/* Stop translation as we may have switched the execution mode *\/\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        case 3:\n\n            \/* ignored, read only *\/\n\n            rn = \"Config3\";\n\n            break;\n\n        \/* 4,5 are reserved *\/\n\n        \/* 6,7 are implementation dependent *\/\n\n        case 6:\n\n            \/* ignored *\/\n\n            rn = \"Config6\";\n\n            break;\n\n        case 7:\n\n            \/* ignored *\/\n\n            rn = \"Config7\";\n\n            break;\n\n        default:\n\n            rn = \"Invalid config selector\";\n\n            goto die;\n\n        }\n\n        break;\n\n    case 17:\n\n        switch (sel) {\n\n        case 0:\n\n            \/* ignored *\/\n\n            rn = \"LLAddr\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 18:\n\n        switch (sel) {\n\n        case 0 ... 7:\n\n            gen_op_mtc0_watchlo(sel);\n\n            rn = \"WatchLo\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 19:\n\n        switch (sel) {\n\n        case 0 ... 7:\n\n            gen_op_mtc0_watchhi(sel);\n\n            rn = \"WatchHi\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 20:\n\n        switch (sel) {\n\n        case 0:\n\n#if defined(TARGET_MIPSN32) || defined(TARGET_MIPS64)\n\n            check_insn(env, ctx, ISA_MIPS3);\n\n            gen_op_mtc0_xcontext();\n\n            rn = \"XContext\";\n\n            break;\n\n#endif\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 21:\n\n       \/* Officially reserved, but sel 0 is used for R1x000 framemask *\/\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_framemask();\n\n            rn = \"Framemask\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 22:\n\n        \/* ignored *\/\n\n        rn = \"Diagnostic\"; \/* implementation dependent *\/\n\n        break;\n\n    case 23:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_debug(); \/* EJTAG support *\/\n\n            \/* BS_STOP isn't good enough here, hflags may have changed. *\/\n\n            gen_save_pc(ctx->pc + 4);\n\n            ctx->bstate = BS_EXCP;\n\n            rn = \"Debug\";\n\n            break;\n\n        case 1:\n\n\/\/            gen_op_mtc0_tracecontrol(); \/* PDtrace support *\/\n\n            rn = \"TraceControl\";\n\n            \/* Stop translation as we may have switched the execution mode *\/\n\n            ctx->bstate = BS_STOP;\n\n\/\/            break;\n\n        case 2:\n\n\/\/            gen_op_mtc0_tracecontrol2(); \/* PDtrace support *\/\n\n            rn = \"TraceControl2\";\n\n            \/* Stop translation as we may have switched the execution mode *\/\n\n            ctx->bstate = BS_STOP;\n\n\/\/            break;\n\n        case 3:\n\n            \/* Stop translation as we may have switched the execution mode *\/\n\n            ctx->bstate = BS_STOP;\n\n\/\/            gen_op_mtc0_usertracedata(); \/* PDtrace support *\/\n\n            rn = \"UserTraceData\";\n\n            \/* Stop translation as we may have switched the execution mode *\/\n\n            ctx->bstate = BS_STOP;\n\n\/\/            break;\n\n        case 4:\n\n\/\/            gen_op_mtc0_debug(); \/* PDtrace support *\/\n\n            \/* Stop translation as we may have switched the execution mode *\/\n\n            ctx->bstate = BS_STOP;\n\n            rn = \"TraceBPC\";\n\n\/\/            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 24:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_depc(); \/* EJTAG support *\/\n\n            rn = \"DEPC\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 25:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_performance0();\n\n            rn = \"Performance0\";\n\n            break;\n\n        case 1:\n\n\/\/            gen_op_mtc0_performance1();\n\n            rn = \"Performance1\";\n\n\/\/            break;\n\n        case 2:\n\n\/\/            gen_op_mtc0_performance2();\n\n            rn = \"Performance2\";\n\n\/\/            break;\n\n        case 3:\n\n\/\/            gen_op_mtc0_performance3();\n\n            rn = \"Performance3\";\n\n\/\/            break;\n\n        case 4:\n\n\/\/            gen_op_mtc0_performance4();\n\n            rn = \"Performance4\";\n\n\/\/            break;\n\n        case 5:\n\n\/\/            gen_op_mtc0_performance5();\n\n            rn = \"Performance5\";\n\n\/\/            break;\n\n        case 6:\n\n\/\/            gen_op_mtc0_performance6();\n\n            rn = \"Performance6\";\n\n\/\/            break;\n\n        case 7:\n\n\/\/            gen_op_mtc0_performance7();\n\n            rn = \"Performance7\";\n\n\/\/            break;\n\n        default:\n\n            goto die;\n\n        }\n\n       break;\n\n    case 26:\n\n        \/* ignored *\/\n\n        rn = \"ECC\";\n\n        break;\n\n    case 27:\n\n        switch (sel) {\n\n        case 0 ... 3:\n\n            \/* ignored *\/\n\n            rn = \"CacheErr\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n       break;\n\n    case 28:\n\n        switch (sel) {\n\n        case 0:\n\n        case 2:\n\n        case 4:\n\n        case 6:\n\n            gen_op_mtc0_taglo();\n\n            rn = \"TagLo\";\n\n            break;\n\n        case 1:\n\n        case 3:\n\n        case 5:\n\n        case 7:\n\n            gen_op_mtc0_datalo();\n\n            rn = \"DataLo\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 29:\n\n        switch (sel) {\n\n        case 0:\n\n        case 2:\n\n        case 4:\n\n        case 6:\n\n            gen_op_mtc0_taghi();\n\n            rn = \"TagHi\";\n\n            break;\n\n        case 1:\n\n        case 3:\n\n        case 5:\n\n        case 7:\n\n            gen_op_mtc0_datahi();\n\n            rn = \"DataHi\";\n\n            break;\n\n        default:\n\n            rn = \"invalid sel\";\n\n            goto die;\n\n        }\n\n       break;\n\n    case 30:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_errorepc();\n\n            rn = \"ErrorEPC\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        break;\n\n    case 31:\n\n        switch (sel) {\n\n        case 0:\n\n            gen_op_mtc0_desave(); \/* EJTAG support *\/\n\n            rn = \"DESAVE\";\n\n            break;\n\n        default:\n\n            goto die;\n\n        }\n\n        \/* Stop translation as we may have switched the execution mode *\/\n\n        ctx->bstate = BS_STOP;\n\n        break;\n\n    default:\n\n       goto die;\n\n    }\n\n#if defined MIPS_DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        fprintf(logfile, \"mtc0 %s (reg %d sel %d)\\n\",\n\n                rn, reg, sel);\n\n    }\n\n#endif\n\n    return;\n\n\n\ndie:\n\n#if defined MIPS_DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        fprintf(logfile, \"mtc0 %s (reg %d sel %d)\\n\",\n\n                rn, reg, sel);\n\n    }\n\n#endif\n\n    generate_exception(ctx, EXCP_RI);\n\n}\n"},{"project":"qemu","commit_id":"80308d33ec70834a80351a79eba106049b44a366","target":1,"func":"static int coroutine_fn sd_co_rw_vector(void *p)\n\n{\n\n    SheepdogAIOCB *acb = p;\n\n    int ret = 0;\n\n    unsigned long len, done = 0, total = acb->nb_sectors * BDRV_SECTOR_SIZE;\n\n    unsigned long idx = acb->sector_num * BDRV_SECTOR_SIZE \/ SD_DATA_OBJ_SIZE;\n\n    uint64_t oid;\n\n    uint64_t offset = (acb->sector_num * BDRV_SECTOR_SIZE) % SD_DATA_OBJ_SIZE;\n\n    BDRVSheepdogState *s = acb->common.bs->opaque;\n\n    SheepdogInode *inode = &s->inode;\n\n    AIOReq *aio_req;\n\n\n\n    if (acb->aiocb_type == AIOCB_WRITE_UDATA && s->is_snapshot) {\n\n        \/*\n\n         * In the case we open the snapshot VDI, Sheepdog creates the\n\n         * writable VDI when we do a write operation first.\n\n         *\/\n\n        ret = sd_create_branch(s);\n\n        if (ret) {\n\n            acb->ret = -EIO;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    \/*\n\n     * Make sure we don't free the aiocb before we are done with all requests.\n\n     * This additional reference is dropped at the end of this function.\n\n     *\/\n\n    acb->nr_pending++;\n\n\n\n    while (done != total) {\n\n        uint8_t flags = 0;\n\n        uint64_t old_oid = 0;\n\n        bool create = false;\n\n\n\n        oid = vid_to_data_oid(inode->data_vdi_id[idx], idx);\n\n\n\n        len = MIN(total - done, SD_DATA_OBJ_SIZE - offset);\n\n\n\n        switch (acb->aiocb_type) {\n\n        case AIOCB_READ_UDATA:\n\n            if (!inode->data_vdi_id[idx]) {\n\n                qemu_iovec_memset(acb->qiov, done, 0, len);\n\n                goto done;\n\n            }\n\n            break;\n\n        case AIOCB_WRITE_UDATA:\n\n            if (!inode->data_vdi_id[idx]) {\n\n                create = true;\n\n            } else if (!is_data_obj_writable(inode, idx)) {\n\n                \/* Copy-On-Write *\/\n\n                create = true;\n\n                old_oid = oid;\n\n                flags = SD_FLAG_CMD_COW;\n\n            }\n\n            break;\n\n        case AIOCB_DISCARD_OBJ:\n\n            \/*\n\n             * We discard the object only when the whole object is\n\n             * 1) allocated 2) trimmed. Otherwise, simply skip it.\n\n             *\/\n\n            if (len != SD_DATA_OBJ_SIZE || inode->data_vdi_id[idx] == 0) {\n\n                goto done;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        if (create) {\n\n            DPRINTF(\"update ino (%\" PRIu32 \") %\" PRIu64 \" %\" PRIu64 \" %ld\\n\",\n\n                    inode->vdi_id, oid,\n\n                    vid_to_data_oid(inode->data_vdi_id[idx], idx), idx);\n\n            oid = vid_to_data_oid(inode->vdi_id, idx);\n\n            DPRINTF(\"new oid %\" PRIx64 \"\\n\", oid);\n\n        }\n\n\n\n        aio_req = alloc_aio_req(s, acb, oid, len, offset, flags, old_oid, done);\n\n\n\n        if (create) {\n\n            AIOReq *areq;\n\n            QLIST_FOREACH(areq, &s->inflight_aio_head, aio_siblings) {\n\n                if (areq->oid == oid) {\n\n                    \/*\n\n                     * Sheepdog cannot handle simultaneous create\n\n                     * requests to the same object.  So we cannot send\n\n                     * the request until the previous request\n\n                     * finishes.\n\n                     *\/\n\n                    aio_req->flags = 0;\n\n                    aio_req->base_oid = 0;\n\n                    QLIST_INSERT_HEAD(&s->pending_aio_head, aio_req,\n\n                                      aio_siblings);\n\n                    goto done;\n\n                }\n\n            }\n\n        }\n\n\n\n        QLIST_INSERT_HEAD(&s->inflight_aio_head, aio_req, aio_siblings);\n\n        add_aio_request(s, aio_req, acb->qiov->iov, acb->qiov->niov, create,\n\n                        acb->aiocb_type);\n\n    done:\n\n        offset = 0;\n\n        idx++;\n\n        done += len;\n\n    }\n\nout:\n\n    if (!--acb->nr_pending) {\n\n        return acb->ret;\n\n    }\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"80ac2390358c906215a849670ca5b7a3d1d112a3","target":0,"func":"void armv7m_nvic_set_pending(void *opaque, int irq, bool secure)\n\n{\n\n    NVICState *s = (NVICState *)opaque;\n\n    bool banked = exc_is_banked(irq);\n\n    VecInfo *vec;\n\n\n\n    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);\n\n    assert(!secure || banked);\n\n\n\n    vec = (banked && secure) ? &s->sec_vectors[irq] : &s->vectors[irq];\n\n\n\n    trace_nvic_set_pending(irq, secure, vec->enabled, vec->prio);\n\n\n\n    if (irq >= ARMV7M_EXCP_HARD && irq < ARMV7M_EXCP_PENDSV) {\n\n        \/* If a synchronous exception is pending then it may be\n\n         * escalated to HardFault if:\n\n         *  * it is equal or lower priority to current execution\n\n         *  * it is disabled\n\n         * (ie we need to take it immediately but we can't do so).\n\n         * Asynchronous exceptions (and interrupts) simply remain pending.\n\n         *\n\n         * For QEMU, we don't have any imprecise (asynchronous) faults,\n\n         * so we can assume that PREFETCH_ABORT and DATA_ABORT are always\n\n         * synchronous.\n\n         * Debug exceptions are awkward because only Debug exceptions\n\n         * resulting from the BKPT instruction should be escalated,\n\n         * but we don't currently implement any Debug exceptions other\n\n         * than those that result from BKPT, so we treat all debug exceptions\n\n         * as needing escalation.\n\n         *\n\n         * This all means we can identify whether to escalate based only on\n\n         * the exception number and don't (yet) need the caller to explicitly\n\n         * tell us whether this exception is synchronous or not.\n\n         *\/\n\n        int running = nvic_exec_prio(s);\n\n        bool escalate = false;\n\n\n\n        if (vec->prio >= running) {\n\n            trace_nvic_escalate_prio(irq, vec->prio, running);\n\n            escalate = true;\n\n        } else if (!vec->enabled) {\n\n            trace_nvic_escalate_disabled(irq);\n\n            escalate = true;\n\n        }\n\n\n\n        if (escalate) {\n\n            if (running < 0) {\n\n                \/* We want to escalate to HardFault but we can't take a\n\n                 * synchronous HardFault at this point either. This is a\n\n                 * Lockup condition due to a guest bug. We don't model\n\n                 * Lockup, so report via cpu_abort() instead.\n\n                 *\/\n\n                cpu_abort(&s->cpu->parent_obj,\n\n                          \"Lockup: can't escalate %d to HardFault \"\n\n                          \"(current priority %d)\\n\", irq, running);\n\n            }\n\n\n\n            \/* We can do the escalation, so we take HardFault instead.\n\n             * If BFHFNMINS is set then we escalate to the banked HF for\n\n             * the target security state of the original exception; otherwise\n\n             * we take a Secure HardFault.\n\n             *\/\n\n            irq = ARMV7M_EXCP_HARD;\n\n            if (arm_feature(&s->cpu->env, ARM_FEATURE_M_SECURITY) &&\n\n                (secure ||\n\n                 !(s->cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK))) {\n\n                vec = &s->sec_vectors[irq];\n\n            } else {\n\n                vec = &s->vectors[irq];\n\n            }\n\n            \/* HF may be banked but there is only one shared HFSR *\/\n\n            s->cpu->env.v7m.hfsr |= R_V7M_HFSR_FORCED_MASK;\n\n        }\n\n    }\n\n\n\n    if (!vec->pending) {\n\n        vec->pending = 1;\n\n        nvic_irq_update(s);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"f3172a0e2e7bd983cada19f11d9bb59400e0dd3d","target":0,"func":"static void sysctl_write(void *opaque, target_phys_addr_t addr, uint32_t value)\n\n{\n\n    MilkymistSysctlState *s = opaque;\n\n\n\n    trace_milkymist_sysctl_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_GPIO_OUT:\n\n    case R_GPIO_INTEN:\n\n    case R_TIMER0_COUNTER:\n\n        if (value > s->regs[R_TIMER0_COUNTER]) {\n\n            value = s->regs[R_TIMER0_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer0: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        \/* milkymist timer counts up *\/\n\n        value = s->regs[R_TIMER0_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer0, value);\n\n        break;\n\n    case R_TIMER1_COUNTER:\n\n        if (value > s->regs[R_TIMER1_COUNTER]) {\n\n            value = s->regs[R_TIMER1_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer1: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        \/* milkymist timer counts up *\/\n\n        value = s->regs[R_TIMER1_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer1, value);\n\n        break;\n\n    case R_TIMER0_COMPARE:\n\n        ptimer_set_limit(s->ptimer0, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER1_COMPARE:\n\n        ptimer_set_limit(s->ptimer1, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER0_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER0_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer0, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer0);\n\n        }\n\n        break;\n\n    case R_TIMER1_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER1_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer1, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer1);\n\n        }\n\n        break;\n\n    case R_ICAP:\n\n        sysctl_icap_write(s, value);\n\n        break;\n\n    case R_SYSTEM_ID:\n\n        qemu_system_reset_request();\n\n        break;\n\n\n\n    case R_GPIO_IN:\n\n    case R_CAPABILITIES:\n\n        error_report(\"milkymist_sysctl: write to read-only register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_sysctl: write access to unkown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"0d7937974cd0504f30ad483c3368b21da426ddf9","target":0,"func":"static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)\n\n{\n\n    struct vmsvga_state_s *s = opaque;\n\n    switch (s->index) {\n\n    case SVGA_REG_ID:\n\n        if (value == SVGA_ID_2 || value == SVGA_ID_1 || value == SVGA_ID_0)\n\n            s->svgaid = value;\n\n        break;\n\n\n\n    case SVGA_REG_ENABLE:\n\n        s->enable = value;\n\n        s->config &= !!value;\n\n        s->width = -1;\n\n        s->height = -1;\n\n        s->invalidated = 1;\n\n        s->vga.invalidate(&s->vga);\n\n        if (s->enable) {\n\n            s->fb_size = ((s->depth + 7) >> 3) * s->new_width * s->new_height;\n\n            vga_dirty_log_stop(&s->vga);\n\n        } else {\n\n            vga_dirty_log_start(&s->vga);\n\n        }\n\n        break;\n\n\n\n    case SVGA_REG_WIDTH:\n\n        s->new_width = value;\n\n        s->invalidated = 1;\n\n        break;\n\n\n\n    case SVGA_REG_HEIGHT:\n\n        s->new_height = value;\n\n        s->invalidated = 1;\n\n        break;\n\n\n\n    case SVGA_REG_DEPTH:\n\n    case SVGA_REG_BITS_PER_PIXEL:\n\n        if (value != s->depth) {\n\n            printf(\"%s: Bad colour depth: %i bits\\n\", __FUNCTION__, value);\n\n            s->config = 0;\n\n        }\n\n        break;\n\n\n\n    case SVGA_REG_CONFIG_DONE:\n\n        if (value) {\n\n            s->fifo = (uint32_t *) s->fifo_ptr;\n\n            \/* Check range and alignment.  *\/\n\n            if ((CMD(min) | CMD(max) |\n\n                        CMD(next_cmd) | CMD(stop)) & 3)\n\n                break;\n\n            if (CMD(min) < (uint8_t *) s->cmd->fifo - (uint8_t *) s->fifo)\n\n                break;\n\n            if (CMD(max) > SVGA_FIFO_SIZE)\n\n                break;\n\n            if (CMD(max) < CMD(min) + 10 * 1024)\n\n                break;\n\n        }\n\n        s->config = !!value;\n\n        break;\n\n\n\n    case SVGA_REG_SYNC:\n\n        s->syncing = 1;\n\n        vmsvga_fifo_run(s); \/* Or should we just wait for update_display? *\/\n\n        break;\n\n\n\n    case SVGA_REG_GUEST_ID:\n\n        s->guest = value;\n\n#ifdef VERBOSE\n\n        if (value >= GUEST_OS_BASE && value < GUEST_OS_BASE +\n\n                ARRAY_SIZE(vmsvga_guest_id))\n\n            printf(\"%s: guest runs %s.\\n\", __FUNCTION__,\n\n                            vmsvga_guest_id[value - GUEST_OS_BASE]);\n\n#endif\n\n        break;\n\n\n\n    case SVGA_REG_CURSOR_ID:\n\n        s->cursor.id = value;\n\n        break;\n\n\n\n    case SVGA_REG_CURSOR_X:\n\n        s->cursor.x = value;\n\n        break;\n\n\n\n    case SVGA_REG_CURSOR_Y:\n\n        s->cursor.y = value;\n\n        break;\n\n\n\n    case SVGA_REG_CURSOR_ON:\n\n        s->cursor.on |= (value == SVGA_CURSOR_ON_SHOW);\n\n        s->cursor.on &= (value != SVGA_CURSOR_ON_HIDE);\n\n#ifdef HW_MOUSE_ACCEL\n\n        if (value <= SVGA_CURSOR_ON_SHOW) {\n\n            dpy_mouse_set(s->vga.ds, s->cursor.x, s->cursor.y, s->cursor.on);\n\n        }\n\n#endif\n\n        break;\n\n\n\n    case SVGA_REG_MEM_REGS:\n\n    case SVGA_REG_NUM_DISPLAYS:\n\n    case SVGA_REG_PITCHLOCK:\n\n    case SVGA_PALETTE_BASE ... SVGA_PALETTE_END:\n\n        break;\n\n\n\n    default:\n\n        if (s->index >= SVGA_SCRATCH_BASE &&\n\n                s->index < SVGA_SCRATCH_BASE + s->scratch_size) {\n\n            s->scratch[s->index - SVGA_SCRATCH_BASE] = value;\n\n            break;\n\n        }\n\n        printf(\"%s: Bad register %02x\\n\", __FUNCTION__, s->index);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"60fe637bf0e4d7989e21e50f52526444765c63b4","target":1,"func":"static int qemu_rdma_accept(RDMAContext *rdma)\n\n{\n\n    RDMACapabilities cap;\n\n    struct rdma_conn_param conn_param = {\n\n                                            .responder_resources = 2,\n\n                                            .private_data = &cap,\n\n                                            .private_data_len = sizeof(cap),\n\n                                         };\n\n    struct rdma_cm_event *cm_event;\n\n    struct ibv_context *verbs;\n\n    int ret = -EINVAL;\n\n    int idx;\n\n\n\n    ret = rdma_get_cm_event(rdma->channel, &cm_event);\n\n    if (ret) {\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    if (cm_event->event != RDMA_CM_EVENT_CONNECT_REQUEST) {\n\n        rdma_ack_cm_event(cm_event);\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    memcpy(&cap, cm_event->param.conn.private_data, sizeof(cap));\n\n\n\n    network_to_caps(&cap);\n\n\n\n    if (cap.version < 1 || cap.version > RDMA_CONTROL_VERSION_CURRENT) {\n\n            fprintf(stderr, \"Unknown source RDMA version: %d, bailing...\\n\",\n\n                            cap.version);\n\n            rdma_ack_cm_event(cm_event);\n\n            goto err_rdma_dest_wait;\n\n    }\n\n\n\n    \/*\n\n     * Respond with only the capabilities this version of QEMU knows about.\n\n     *\/\n\n    cap.flags &= known_capabilities;\n\n\n\n    \/*\n\n     * Enable the ones that we do know about.\n\n     * Add other checks here as new ones are introduced.\n\n     *\/\n\n    if (cap.flags & RDMA_CAPABILITY_PIN_ALL) {\n\n        rdma->pin_all = true;\n\n    }\n\n\n\n    rdma->cm_id = cm_event->id;\n\n    verbs = cm_event->id->verbs;\n\n\n\n    rdma_ack_cm_event(cm_event);\n\n\n\n    DPRINTF(\"Memory pin all: %s\\n\", rdma->pin_all ? \"enabled\" : \"disabled\");\n\n\n\n    caps_to_network(&cap);\n\n\n\n    DPRINTF(\"verbs context after listen: %p\\n\", verbs);\n\n\n\n    if (!rdma->verbs) {\n\n        rdma->verbs = verbs;\n\n    } else if (rdma->verbs != verbs) {\n\n            fprintf(stderr, \"ibv context not matching %p, %p!\\n\",\n\n                    rdma->verbs, verbs);\n\n            goto err_rdma_dest_wait;\n\n    }\n\n\n\n    qemu_rdma_dump_id(\"dest_init\", verbs);\n\n\n\n    ret = qemu_rdma_alloc_pd_cq(rdma);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma migration: error allocating pd and cq!\\n\");\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    ret = qemu_rdma_alloc_qp(rdma);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma migration: error allocating qp!\\n\");\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    ret = qemu_rdma_init_ram_blocks(rdma);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma migration: error initializing ram blocks!\\n\");\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    for (idx = 0; idx < RDMA_WRID_MAX; idx++) {\n\n        ret = qemu_rdma_reg_control(rdma, idx);\n\n        if (ret) {\n\n            fprintf(stderr, \"rdma: error registering %d control!\\n\", idx);\n\n            goto err_rdma_dest_wait;\n\n        }\n\n    }\n\n\n\n    qemu_set_fd_handler2(rdma->channel->fd, NULL, NULL, NULL, NULL);\n\n\n\n    ret = rdma_accept(rdma->cm_id, &conn_param);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma_accept returns %d!\\n\", ret);\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    ret = rdma_get_cm_event(rdma->channel, &cm_event);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma_accept get_cm_event failed %d!\\n\", ret);\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    if (cm_event->event != RDMA_CM_EVENT_ESTABLISHED) {\n\n        fprintf(stderr, \"rdma_accept not event established!\\n\");\n\n        rdma_ack_cm_event(cm_event);\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    rdma_ack_cm_event(cm_event);\n\n    rdma->connected = true;\n\n\n\n    ret = qemu_rdma_post_recv_control(rdma, RDMA_WRID_READY);\n\n    if (ret) {\n\n        fprintf(stderr, \"rdma migration: error posting second control recv!\\n\");\n\n        goto err_rdma_dest_wait;\n\n    }\n\n\n\n    qemu_rdma_dump_gid(\"dest_connect\", rdma->cm_id);\n\n\n\n    return 0;\n\n\n\nerr_rdma_dest_wait:\n\n    rdma->error_state = ret;\n\n    qemu_rdma_cleanup(rdma);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"b3db211f3c80bb996a704d665fe275619f728bd4","target":0,"func":"static void test_visitor_out_native_list_int(TestOutputVisitorData *data,\n\n                                             const void *unused)\n\n{\n\n    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_INTEGER);\n\n}\n"},{"project":"qemu","commit_id":"4083733db5e4120939acee57019ff52db1f45b9d","target":0,"func":"static DisplaySurface *qemu_create_message_surface(int w, int h,\n\n                                                   const char *msg)\n\n{\n\n    DisplaySurface *surface = qemu_create_displaysurface(w, h);\n\n    pixman_color_t bg = color_table_rgb[0][COLOR_BLACK];\n\n    pixman_color_t fg = color_table_rgb[0][COLOR_WHITE];\n\n    pixman_image_t *glyph;\n\n    int len, x, y, i;\n\n\n\n    len = strlen(msg);\n\n    x = (w \/ FONT_WIDTH  - len) \/ 2;\n\n    y = (h \/ FONT_HEIGHT - 1)   \/ 2;\n\n    for (i = 0; i < len; i++) {\n\n        glyph = qemu_pixman_glyph_from_vgafont(FONT_HEIGHT, vgafont16, msg[i]);\n\n        qemu_pixman_glyph_render(glyph, surface->image, &fg, &bg,\n\n                                 x+i, y, FONT_WIDTH, FONT_HEIGHT);\n\n        qemu_pixman_image_unref(glyph);\n\n    }\n\n    return surface;\n\n}\n"},{"project":"qemu","commit_id":"fac7d7b1cdb21f921d7ac396365f5e920ef03096","target":1,"func":"int net_init_tap(const Netdev *netdev, const char *name,\n\n                 NetClientState *peer, Error **errp)\n\n{\n\n    const NetdevTapOptions *tap;\n\n    int fd, vnet_hdr = 0, i = 0, queues;\n\n    \/* for the no-fd, no-helper case *\/\n\n    const char *script = NULL; \/* suppress wrong \"uninit'd use\" gcc warning *\/\n\n    const char *downscript = NULL;\n\n    Error *err = NULL;\n\n    const char *vhostfdname;\n\n    char ifname[128];\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_TAP);\n\n    tap = &netdev->u.tap;\n\n    queues = tap->has_queues ? tap->queues : 1;\n\n    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;\n\n\n\n    \/* QEMU vlans does not support multiqueue tap, in this case peer is set.\n\n     * For -netdev, peer is always NULL. *\/\n\n    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) {\n\n        error_setg(errp, \"Multiqueue tap cannot be used with QEMU vlans\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_fds || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, fds=, and vhostfds= \"\n\n                       \"are invalid with fd=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = monitor_fd_param(cur_mon, tap->fd, &err);\n\n        if (fd == -1) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"tap\", name, NULL,\n\n                         script, downscript,\n\n                         vhostfdname, vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n    } else if (tap->has_fds) {\n\n        char **fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        int nfds, nvhosts;\n\n\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_vhostfd) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, and vhostfd= \"\n\n                       \"are invalid with fds=\");\n\n            return -1;\n\n        }\n\n\n\n        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);\n\n        if (tap->has_vhostfds) {\n\n            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);\n\n            if (nfds != nvhosts) {\n\n                error_setg(errp, \"The number of fds passed does not match \"\n\n                           \"the number of vhostfds passed\");\n\n                goto free_fail;\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < nfds; i++) {\n\n            fd = monitor_fd_param(cur_mon, fds[i], &err);\n\n            if (fd == -1) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n\n\n            fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n            if (i == 0) {\n\n                vnet_hdr = tap_probe_vnet_hdr(fd);\n\n            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {\n\n                error_setg(errp,\n\n                           \"vnet_hdr not consistent across given tap fds\");\n\n                goto free_fail;\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             script, downscript,\n\n                             tap->has_vhostfds ? vhost_fds[i] : NULL,\n\n                             vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return 0;\n\n\n\nfree_fail:\n\n        for (i = 0; i < nfds; i++) {\n\n            g_free(fds[i]);\n\n            g_free(vhost_fds[i]);\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return -1;\n\n    } else if (tap->has_helper) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"queues=, and vhostfds= are invalid with helper=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_bridge_run_helper(tap->helper,\n\n                                   tap->has_br ?\n\n                                   tap->br : DEFAULT_BRIDGE_INTERFACE,\n\n                                   errp);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"bridge\", name, ifname,\n\n                         script, downscript, vhostfdname,\n\n                         vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (tap->has_vhostfds) {\n\n            error_setg(errp, \"vhostfds= is invalid if fds= wasn't specified\");\n\n            return -1;\n\n        }\n\n        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;\n\n        downscript = tap->has_downscript ? tap->downscript :\n\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n\n\n\n        if (tap->has_ifname) {\n\n            pstrcpy(ifname, sizeof ifname, tap->ifname);\n\n        } else {\n\n            ifname[0] = '\\0';\n\n        }\n\n\n\n        for (i = 0; i < queues; i++) {\n\n            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? \"no\" : script,\n\n                              ifname, sizeof ifname, queues > 1, errp);\n\n            if (fd == -1) {\n\n                return -1;\n\n            }\n\n\n\n            if (queues > 1 && i == 0 && !tap->has_ifname) {\n\n                if (tap_fd_get_ifname(fd, ifname)) {\n\n                    error_setg(errp, \"Fail to get ifname\");\n\n                    close(fd);\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             i >= 1 ? \"no\" : script,\n\n                             i >= 1 ? \"no\" : downscript,\n\n                             vhostfdname, vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                close(fd);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"44701ab71ad854e6be567a6294f4665f36651076","target":0,"func":"void msix_unuse_all_vectors(PCIDevice *dev)\n\n{\n\n    if (!(dev->cap_present & QEMU_PCI_CAP_MSIX))\n\n        return;\n\n    msix_free_irq_entries(dev);\n\n}\n"},{"project":"qemu","commit_id":"09e68369a88d7de0f988972bf28eec1b80cc47f9","target":0,"func":"void object_property_set_qobject(Object *obj, QObject *value,\n\n                                 const char *name, Error **errp)\n\n{\n\n    Visitor *v;\n\n    \/* TODO: Should we reject, rather than ignore, excess input? *\/\n\n    v = qmp_input_visitor_new(value, false);\n\n    object_property_set(obj, v, name, errp);\n\n    visit_free(v);\n\n}\n"},{"project":"qemu","commit_id":"8bcbf37caa87ba89bc391bad70039f942a98c7e3","target":1,"func":"void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n    switch (ri->accessfn(env, ri)) {\n\n    case CP_ACCESS_OK:\n\n        return;\n\n    case CP_ACCESS_TRAP:\n\n    case CP_ACCESS_TRAP_UNCATEGORIZED:\n\n        \/* These cases will eventually need to generate different\n\n         * syndrome information.\n\n         *\/\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n    raise_exception(env, EXCP_UDEF);\n\n}\n"},{"project":"qemu","commit_id":"0919ac787641db11024912651f3bc5764d4f1286","target":0,"func":"static void omap2_inth_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t value, unsigned size)\n\n{\n\n    struct omap_intr_handler_s *s = (struct omap_intr_handler_s *) opaque;\n\n    int offset = addr;\n\n    int bank_no, line_no;\n\n    struct omap_intr_handler_bank_s *bank = NULL;\n\n\n\n    if ((offset & 0xf80) == 0x80) {\n\n        bank_no = (offset & 0x60) >> 5;\n\n        if (bank_no < s->nbanks) {\n\n            offset &= ~0x60;\n\n            bank = &s->bank[bank_no];\n\n        }\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x10:\t\/* INTC_SYSCONFIG *\/\n\n        s->autoidle &= 4;\n\n        s->autoidle |= (value & 1) << 2;\n\n        if (value & 2)\t\t\t\t\t\t\/* SOFTRESET *\/\n\n            omap_inth_reset(s);\n\n        return;\n\n\n\n    case 0x48:\t\/* INTC_CONTROL *\/\n\n        s->mask = (value & 4) ? 0 : ~0;\t\t\t\t\/* GLOBALMASK *\/\n\n        if (value & 2) {\t\t\t\t\t\/* NEWFIQAGR *\/\n\n            qemu_set_irq(s->parent_intr[1], 0);\n\n            s->new_agr[1] = ~0;\n\n            omap_inth_update(s, 1);\n\n        }\n\n        if (value & 1) {\t\t\t\t\t\/* NEWIRQAGR *\/\n\n            qemu_set_irq(s->parent_intr[0], 0);\n\n            s->new_agr[0] = ~0;\n\n            omap_inth_update(s, 0);\n\n        }\n\n        return;\n\n\n\n    case 0x4c:\t\/* INTC_PROTECTION *\/\n\n        \/* TODO: Make a bitmap (or sizeof(char)map) of access privileges\n\n         * for every register, see Chapter 3 and 4 for privileged mode.  *\/\n\n        if (value & 1)\n\n            fprintf(stderr, \"%s: protection mode enable attempt\\n\",\n\n                            __FUNCTION__);\n\n        return;\n\n\n\n    case 0x50:\t\/* INTC_IDLE *\/\n\n        s->autoidle &= ~3;\n\n        s->autoidle |= value & 3;\n\n        return;\n\n\n\n    \/* Per-bank registers *\/\n\n    case 0x84:\t\/* INTC_MIR *\/\n\n        bank->mask = value;\n\n        omap_inth_update(s, 0);\n\n        omap_inth_update(s, 1);\n\n        return;\n\n\n\n    case 0x88:\t\/* INTC_MIR_CLEAR *\/\n\n        bank->mask &= ~value;\n\n        omap_inth_update(s, 0);\n\n        omap_inth_update(s, 1);\n\n        return;\n\n\n\n    case 0x8c:\t\/* INTC_MIR_SET *\/\n\n        bank->mask |= value;\n\n        return;\n\n\n\n    case 0x90:\t\/* INTC_ISR_SET *\/\n\n        bank->irqs |= bank->swi |= value;\n\n        omap_inth_update(s, 0);\n\n        omap_inth_update(s, 1);\n\n        return;\n\n\n\n    case 0x94:\t\/* INTC_ISR_CLEAR *\/\n\n        bank->swi &= ~value;\n\n        bank->irqs = bank->swi & bank->inputs;\n\n        return;\n\n\n\n    \/* Per-line registers *\/\n\n    case 0x100 ... 0x300:\t\/* INTC_ILR *\/\n\n        bank_no = (offset - 0x100) >> 7;\n\n        if (bank_no > s->nbanks)\n\n            break;\n\n        bank = &s->bank[bank_no];\n\n        line_no = (offset & 0x7f) >> 2;\n\n        bank->priority[line_no] = (value >> 2) & 0x3f;\n\n        bank->fiq &= ~(1 << line_no);\n\n        bank->fiq |= (value & 1) << line_no;\n\n        return;\n\n\n\n    case 0x00:\t\/* INTC_REVISION *\/\n\n    case 0x14:\t\/* INTC_SYSSTATUS *\/\n\n    case 0x40:\t\/* INTC_SIR_IRQ *\/\n\n    case 0x44:\t\/* INTC_SIR_FIQ *\/\n\n    case 0x80:\t\/* INTC_ITR *\/\n\n    case 0x98:\t\/* INTC_PENDING_IRQ *\/\n\n    case 0x9c:\t\/* INTC_PENDING_FIQ *\/\n\n        OMAP_RO_REG(addr);\n\n        return;\n\n    }\n\n    OMAP_BAD_REG(addr);\n\n}\n"},{"project":"qemu","commit_id":"64e69e80920d82df3fa679bc41b13770d2f99360","target":1,"func":"iscsi_aio_cancel(BlockDriverAIOCB *blockacb)\n\n{\n\n    IscsiAIOCB *acb = (IscsiAIOCB *)blockacb;\n\n    IscsiLun *iscsilun = acb->iscsilun;\n\n\n\n    acb->common.cb(acb->common.opaque, -ECANCELED);\n\n    acb->canceled = 1;\n\n\n\n    \/* send a task mgmt call to the target to cancel the task on the target *\/\n\n    iscsi_task_mgmt_abort_task_async(iscsilun->iscsi, acb->task,\n\n                                     iscsi_abort_task_cb, NULL);\n\n\n\n    \/* then also cancel the task locally in libiscsi *\/\n\n    iscsi_scsi_task_cancel(iscsilun->iscsi, acb->task);\n\n}\n"},{"project":"qemu","commit_id":"1945dbc15f0f1ffdc9a10526448e9eba7c599d98","target":0,"func":"static uint32_t openpic_cpu_read_internal(void *opaque, hwaddr addr,\n\n                                          int idx)\n\n{\n\n    openpic_t *opp = opaque;\n\n    IRQ_src_t *src;\n\n    IRQ_dst_t *dst;\n\n    uint32_t retval;\n\n    int n_IRQ;\n\n\n\n    DPRINTF(\"%s: cpu %d addr \" TARGET_FMT_plx \"\\n\", __func__, idx, addr);\n\n    retval = 0xFFFFFFFF;\n\n    if (addr & 0xF)\n\n        return retval;\n\n    dst = &opp->dst[idx];\n\n    addr &= 0xFF0;\n\n    switch (addr) {\n\n    case 0x00: \/* Block Revision Register1 (BRR1) *\/\n\n        retval = FSL_BRR1_IPID | FSL_BRR1_IPMJ | FSL_BRR1_IPMN;\n\n        break;\n\n    case 0x80: \/* PCTP *\/\n\n        retval = dst->pctp;\n\n        break;\n\n    case 0x90: \/* WHOAMI *\/\n\n        retval = idx;\n\n        break;\n\n    case 0xA0: \/* PIAC *\/\n\n        DPRINTF(\"Lower OpenPIC INT output\\n\");\n\n        qemu_irq_lower(dst->irqs[OPENPIC_OUTPUT_INT]);\n\n        n_IRQ = IRQ_get_next(opp, &dst->raised);\n\n        DPRINTF(\"PIAC: irq=%d\\n\", n_IRQ);\n\n        if (n_IRQ == -1) {\n\n            \/* No more interrupt pending *\/\n\n            retval = IPVP_VECTOR(opp->spve);\n\n        } else {\n\n            src = &opp->src[n_IRQ];\n\n            if (!test_bit(&src->ipvp, IPVP_ACTIVITY) ||\n\n                !(IPVP_PRIORITY(src->ipvp) > dst->pctp)) {\n\n                \/* - Spurious level-sensitive IRQ\n\n                 * - Priorities has been changed\n\n                 *   and the pending IRQ isn't allowed anymore\n\n                 *\/\n\n                reset_bit(&src->ipvp, IPVP_ACTIVITY);\n\n                retval = IPVP_VECTOR(opp->spve);\n\n            } else {\n\n                \/* IRQ enter servicing state *\/\n\n                IRQ_setbit(&dst->servicing, n_IRQ);\n\n                retval = IPVP_VECTOR(src->ipvp);\n\n            }\n\n            IRQ_resetbit(&dst->raised, n_IRQ);\n\n            dst->raised.next = -1;\n\n            if (!test_bit(&src->ipvp, IPVP_SENSE)) {\n\n                \/* edge-sensitive IRQ *\/\n\n                reset_bit(&src->ipvp, IPVP_ACTIVITY);\n\n                src->pending = 0;\n\n            }\n\n\n\n            if ((n_IRQ >= opp->irq_ipi0) &&  (n_IRQ < (opp->irq_ipi0 + MAX_IPI))) {\n\n                src->ide &= ~(1 << idx);\n\n                if (src->ide && !test_bit(&src->ipvp, IPVP_SENSE)) {\n\n                    \/* trigger on CPUs that didn't know about it yet *\/\n\n                    openpic_set_irq(opp, n_IRQ, 1);\n\n                    openpic_set_irq(opp, n_IRQ, 0);\n\n                    \/* if all CPUs knew about it, set active bit again *\/\n\n                    set_bit(&src->ipvp, IPVP_ACTIVITY);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case 0xB0: \/* PEOI *\/\n\n        retval = 0;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    DPRINTF(\"%s: => %08x\\n\", __func__, retval);\n\n\n\n    return retval;\n\n}\n"},{"project":"qemu","commit_id":"fb0e8e79a9d77ee240dbca036fa8698ce654e5d1","target":1,"func":"void HELPER(cpsr_write_eret)(CPUARMState *env, uint32_t val)\n{\n    cpsr_write(env, val, CPSR_ERET_MASK, CPSRWriteExceptionReturn);\n    arm_call_el_change_hook(arm_env_get_cpu(env));\n}"},{"project":"qemu","commit_id":"8417cebfda193c7f9ca70be5e308eaa92cf84b94","target":1,"func":"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)\n\n{\n\n    uint64_t start = MAX(r1.start, r2.start);\n\n    \/* off-by-one arithmetic to prevent overflow *\/\n\n    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);\n\n    return addrrange_make(start, end - start + 1);\n\n}\n"},{"project":"qemu","commit_id":"ddca7f86ac022289840e0200fd4050b2b58e9176","target":0,"func":"static int v9fs_xattr_write(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n\n                            uint64_t off, uint32_t count,\n\n                            struct iovec *sg, int cnt)\n\n{\n\n    int i, to_copy;\n\n    ssize_t err = 0;\n\n    int write_count;\n\n    int64_t xattr_len;\n\n    size_t offset = 7;\n\n\n\n\n\n    xattr_len = fidp->fs.xattr.len;\n\n    write_count = xattr_len - off;\n\n    if (write_count > count) {\n\n        write_count = count;\n\n    } else if (write_count < 0) {\n\n        \/*\n\n         * write beyond XATTR value len specified in\n\n         * xattrcreate\n\n         *\/\n\n        err = -ENOSPC;\n\n        goto out;\n\n    }\n\n    offset += pdu_marshal(pdu, offset, \"d\", write_count);\n\n    err = offset;\n\n    fidp->fs.xattr.copied_len += write_count;\n\n    \/*\n\n     * Now copy the content from sg list\n\n     *\/\n\n    for (i = 0; i < cnt; i++) {\n\n        if (write_count > sg[i].iov_len) {\n\n            to_copy = sg[i].iov_len;\n\n        } else {\n\n            to_copy = write_count;\n\n        }\n\n        memcpy((char *)fidp->fs.xattr.value + off, sg[i].iov_base, to_copy);\n\n        \/* updating vs->off since we are not using below *\/\n\n        off += to_copy;\n\n        write_count -= to_copy;\n\n    }\n\nout:\n\n    return err;\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static void rtas_nvram_store(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                             uint32_t token, uint32_t nargs,\n\n                             target_ulong args,\n\n                             uint32_t nret, target_ulong rets)\n\n{\n\n    sPAPRNVRAM *nvram = spapr->nvram;\n\n    hwaddr offset, buffer, len;\n\n    int alen;\n\n    void *membuf;\n\n\n\n    if ((nargs != 3) || (nret != 2)) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    if (!nvram) {\n\n        rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n        return;\n\n    }\n\n\n\n    offset = rtas_ld(args, 0);\n\n    buffer = rtas_ld(args, 1);\n\n    len = rtas_ld(args, 2);\n\n\n\n    if (((offset + len) < offset)\n\n        || ((offset + len) > nvram->size)) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    membuf = cpu_physical_memory_map(buffer, &len, 0);\n\n    if (nvram->drive) {\n\n        alen = bdrv_pwrite(nvram->drive, offset, membuf, len);\n\n    } else {\n\n        assert(nvram->buf);\n\n\n\n        memcpy(nvram->buf + offset, membuf, len);\n\n        alen = len;\n\n    }\n\n    cpu_physical_memory_unmap(membuf, len, 0, len);\n\n\n\n    rtas_st(rets, 0, (alen < len) ? RTAS_OUT_HW_ERROR : RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, (alen < 0) ? 0 : alen);\n\n}\n"},{"project":"qemu","commit_id":"d59ce6f34434bf47a9b26138c908650bf9a24be1","target":1,"func":"void hmp_info_migrate(Monitor *mon, const QDict *qdict)\n\n{\n\n    MigrationInfo *info;\n\n    MigrationCapabilityStatusList *caps, *cap;\n\n\n\n    info = qmp_query_migrate(NULL);\n\n    caps = qmp_query_migrate_capabilities(NULL);\n\n\n\n    \/* do not display parameters during setup *\/\n\n    if (info->has_status && caps) {\n\n        monitor_printf(mon, \"capabilities: \");\n\n        for (cap = caps; cap; cap = cap->next) {\n\n            monitor_printf(mon, \"%s: %s \",\n\n                           MigrationCapability_lookup[cap->value->capability],\n\n                           cap->value->state ? \"on\" : \"off\");\n\n        }\n\n        monitor_printf(mon, \"\\n\");\n\n    }\n\n\n\n    if (info->has_status) {\n\n        monitor_printf(mon, \"Migration status: %s\\n\",\n\n                       MigrationStatus_lookup[info->status]);\n\n        monitor_printf(mon, \"total time: %\" PRIu64 \" milliseconds\\n\",\n\n                       info->total_time);\n\n        if (info->has_expected_downtime) {\n\n            monitor_printf(mon, \"expected downtime: %\" PRIu64 \" milliseconds\\n\",\n\n                           info->expected_downtime);\n\n        }\n\n        if (info->has_downtime) {\n\n            monitor_printf(mon, \"downtime: %\" PRIu64 \" milliseconds\\n\",\n\n                           info->downtime);\n\n        }\n\n        if (info->has_setup_time) {\n\n            monitor_printf(mon, \"setup: %\" PRIu64 \" milliseconds\\n\",\n\n                           info->setup_time);\n\n        }\n\n    }\n\n\n\n    if (info->has_ram) {\n\n        monitor_printf(mon, \"transferred ram: %\" PRIu64 \" kbytes\\n\",\n\n                       info->ram->transferred >> 10);\n\n        monitor_printf(mon, \"throughput: %0.2f mbps\\n\",\n\n                       info->ram->mbps);\n\n        monitor_printf(mon, \"remaining ram: %\" PRIu64 \" kbytes\\n\",\n\n                       info->ram->remaining >> 10);\n\n        monitor_printf(mon, \"total ram: %\" PRIu64 \" kbytes\\n\",\n\n                       info->ram->total >> 10);\n\n        monitor_printf(mon, \"duplicate: %\" PRIu64 \" pages\\n\",\n\n                       info->ram->duplicate);\n\n        monitor_printf(mon, \"skipped: %\" PRIu64 \" pages\\n\",\n\n                       info->ram->skipped);\n\n        monitor_printf(mon, \"normal: %\" PRIu64 \" pages\\n\",\n\n                       info->ram->normal);\n\n        monitor_printf(mon, \"normal bytes: %\" PRIu64 \" kbytes\\n\",\n\n                       info->ram->normal_bytes >> 10);\n\n        monitor_printf(mon, \"dirty sync count: %\" PRIu64 \"\\n\",\n\n                       info->ram->dirty_sync_count);\n\n        if (info->ram->dirty_pages_rate) {\n\n            monitor_printf(mon, \"dirty pages rate: %\" PRIu64 \" pages\\n\",\n\n                           info->ram->dirty_pages_rate);\n\n        }\n\n    }\n\n\n\n    if (info->has_disk) {\n\n        monitor_printf(mon, \"transferred disk: %\" PRIu64 \" kbytes\\n\",\n\n                       info->disk->transferred >> 10);\n\n        monitor_printf(mon, \"remaining disk: %\" PRIu64 \" kbytes\\n\",\n\n                       info->disk->remaining >> 10);\n\n        monitor_printf(mon, \"total disk: %\" PRIu64 \" kbytes\\n\",\n\n                       info->disk->total >> 10);\n\n    }\n\n\n\n    if (info->has_xbzrle_cache) {\n\n        monitor_printf(mon, \"cache size: %\" PRIu64 \" bytes\\n\",\n\n                       info->xbzrle_cache->cache_size);\n\n        monitor_printf(mon, \"xbzrle transferred: %\" PRIu64 \" kbytes\\n\",\n\n                       info->xbzrle_cache->bytes >> 10);\n\n        monitor_printf(mon, \"xbzrle pages: %\" PRIu64 \" pages\\n\",\n\n                       info->xbzrle_cache->pages);\n\n        monitor_printf(mon, \"xbzrle cache miss: %\" PRIu64 \"\\n\",\n\n                       info->xbzrle_cache->cache_miss);\n\n        monitor_printf(mon, \"xbzrle cache miss rate: %0.2f\\n\",\n\n                       info->xbzrle_cache->cache_miss_rate);\n\n        monitor_printf(mon, \"xbzrle overflow : %\" PRIu64 \"\\n\",\n\n                       info->xbzrle_cache->overflow);\n\n    }\n\n\n\n    if (info->has_cpu_throttle_percentage) {\n\n        monitor_printf(mon, \"cpu throttle percentage: %\" PRIu64 \"\\n\",\n\n                       info->cpu_throttle_percentage);\n\n    }\n\n\n\n    qapi_free_MigrationInfo(info);\n\n    qapi_free_MigrationCapabilityStatusList(caps);\n\n}\n"},{"project":"qemu","commit_id":"3c529d935923a70519557d420db1d5a09a65086a","target":0,"func":"static BlockDriverAIOCB *raw_aio_write(BlockDriverState *bs,\n\n        int64_t sector_num, const uint8_t *buf, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    \/*\n\n     * If O_DIRECT is used and the buffer is not aligned fall back\n\n     * to synchronous IO.\n\n     *\/\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {\n\n        QEMUBH *bh;\n\n        acb = qemu_aio_get(bs, cb, opaque);\n\n        acb->ret = raw_pwrite(bs, 512 * sector_num, buf, 512 * nb_sectors);\n\n        bh = qemu_bh_new(raw_aio_em_cb, acb);\n\n        qemu_bh_schedule(bh);\n\n        return &acb->common;\n\n    }\n\n\n\n    acb = raw_aio_setup(bs, sector_num, (uint8_t*)buf, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (aio_write(&acb->aiocb) < 0) {\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n"},{"project":"qemu","commit_id":"7d6e771f49c36f4388798ce25bde1dede40cda74","target":0,"func":"static int pci_vpb_init(SysBusDevice *dev)\n\n{\n\n    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);\n\n    PCIBus *bus;\n\n    int i;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        sysbus_init_irq(dev, &s->irq[i]);\n\n    }\n\n    bus = pci_register_bus(&dev->qdev, \"pci\",\n\n                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,\n\n                           get_system_memory(), get_system_io(),\n\n                           PCI_DEVFN(11, 0), 4);\n\n\n\n    \/* ??? Register memory space.  *\/\n\n\n\n    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-selfconfig\", 0x1000000);\n\n    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-config\", 0x1000000);\n\n    if (s->realview) {\n\n        isa_mmio_setup(&s->isa, 0x0100000);\n\n    }\n\n\n\n    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);\n\n\n\n    pci_create_simple(bus, -1, \"versatile_pci_host\");\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"0266f2c733911ca3f70e009e3230c790c800e524","target":0,"func":"static void set_lcd_pixel(musicpal_lcd_state *s, int x, int y, int col)\n\n{\n\n    int dx, dy;\n\n\n\n    for (dy = 0; dy < 3; dy++)\n\n        for (dx = 0; dx < 3; dx++) {\n\n            s->ds->data[(x*3 + dx + (y*3 + dy) * 128*3) * 4 + 0] =\n\n                scale_lcd_color(col);\n\n            s->ds->data[(x*3 + dx + (y*3 + dy) * 128*3) * 4 + 1] =\n\n                scale_lcd_color(col >> 8);\n\n            s->ds->data[(x*3 + dx + (y*3 + dy) * 128*3) * 4 + 2] =\n\n                scale_lcd_color(col >> 16);\n\n        }\n\n}\n"},{"project":"qemu","commit_id":"f61eddcb2bb5cbbdd1d911b7e937db9affc29028","target":0,"func":"static void qemu_kill_report(void)\n\n{\n\n    if (!qtest_driver() && shutdown_signal != -1) {\n\n        fprintf(stderr, \"qemu: terminating on signal %d\", shutdown_signal);\n\n        if (shutdown_pid == 0) {\n\n            \/* This happens for eg ^C at the terminal, so it's worth\n\n             * avoiding printing an odd message in that case.\n\n             *\/\n\n            fputc('\\n', stderr);\n\n        } else {\n\n            fprintf(stderr, \" from pid \" FMT_pid \"\\n\", shutdown_pid);\n\n        }\n\n        shutdown_signal = -1;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"63ffb564dca94f8bda01ed6d209784104630a4d2","target":0,"func":"static void pc_init1(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename,\n\n                     const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     const char *cpu_model,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *isa_irq;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cmos_s3;\n\n    qemu_irq *smi_irq;\n\n    IsaIrqState *isa_irq_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    FDCtrl *floppy_controller;\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n\n\n    pc_cpus_init(cpu_model);\n\n\n\n    if (kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    \/* allocate ram and load rom\/bios *\/\n\n    pc_memory_init(ram_size, kernel_filename, kernel_cmdline, initrd_filename,\n\n                   &below_4g_mem_size, &above_4g_mem_size);\n\n\n\n    cpu_irq = pc_allocate_cpu_irq();\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    isa_irq_state = qemu_mallocz(sizeof(*isa_irq_state));\n\n    isa_irq_state->i8259 = i8259;\n\n    if (pci_enabled) {\n\n        ioapic_init(isa_irq_state);\n\n    }\n\n    isa_irq = qemu_allocate_irqs(isa_irq_handler, isa_irq_state, 24);\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, isa_irq, ram_size);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus_new(NULL);\n\n    }\n\n    isa_bus_irqs(isa_irq);\n\n\n\n    pc_register_ferr_irq(isa_reserve_irq(13));\n\n\n\n    pc_vga_init(pci_enabled? pci_bus: NULL);\n\n\n\n    \/* init basic PC hardware *\/\n\n    pc_basic_device_init(isa_irq, &floppy_controller, &rtc_state);\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd);\n\n        else\n\n            pci_nic_init_nofail(nd, \"e1000\", NULL);\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i \/ MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            dev = isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            idebus[i] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        }\n\n    }\n\n\n\n    audio_init(isa_irq, pci_enabled ? pci_bus : NULL);\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device,\n\n                 idebus[0], idebus[1], floppy_controller, rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); \/* XXX: make this persistent *\/\n\n        i2c_bus *smbus;\n\n\n\n        cmos_s3 = qemu_allocate_irqs(pc_cmos_set_s3_resume, rtc_state, 1);\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        \/* TODO: Populate SPD eeprom data.  *\/\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              isa_reserve_irq(9), *cmos_s3, *smi_irq,\n\n                              kvm_enabled());\n\n        for (i = 0; i < 8; i++) {\n\n            DeviceState *eeprom;\n\n            eeprom = qdev_create((BusState *)smbus, \"smbus-eeprom\");\n\n            qdev_prop_set_uint8(eeprom, \"address\", 0x50 + i);\n\n            qdev_prop_set_ptr(eeprom, \"data\", eeprom_buf + (i * 256));\n\n            qdev_init_nofail(eeprom);\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"40f8f0c31b6009e802175463c97f3b9e6f7c5d0f","target":0,"func":"static void pcie_aer_msg(PCIDevice *dev, const PCIEAERMsg *msg)\n\n{\n\n    uint8_t type;\n\n\n\n    while (dev) {\n\n        if (!pci_is_express(dev)) {\n\n            \/* just ignore it *\/\n\n            \/* TODO: Shouldn't we set PCI_STATUS_SIG_SYSTEM_ERROR?\n\n             * Consider e.g. a PCI bridge above a PCI Express device. *\/\n\n            return;\n\n        }\n\n\n\n        type = pcie_cap_get_type(dev);\n\n        if ((type == PCI_EXP_TYPE_ROOT_PORT ||\n\n            type == PCI_EXP_TYPE_UPSTREAM ||\n\n            type == PCI_EXP_TYPE_DOWNSTREAM) &&\n\n            !pcie_aer_msg_vbridge(dev, msg)) {\n\n                return;\n\n        }\n\n        if (!pcie_aer_msg_alldev(dev, msg)) {\n\n            return;\n\n        }\n\n        if (type == PCI_EXP_TYPE_ROOT_PORT) {\n\n            pcie_aer_msg_root_port(dev, msg);\n\n            \/* Root port can notify system itself,\n\n               or send the error message to root complex event collector. *\/\n\n            \/*\n\n             * if root port is associated with an event collector,\n\n             * return the root complex event collector here.\n\n             * For now root complex event collector isn't supported.\n\n             *\/\n\n            return;\n\n        }\n\n        dev = pci_bridge_get_device(dev->bus);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"e23a1b33b53d25510320b26d9f154e19c6c99725","target":1,"func":"qemu_irq *armv7m_init(int flash_size, int sram_size,\n\n                      const char *kernel_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    DeviceState *nvic;\n\n    \/* FIXME: make this local state.  *\/\n\n    static qemu_irq pic[64];\n\n    qemu_irq *cpu_pic;\n\n    uint32_t pc;\n\n    int image_size;\n\n    uint64_t entry;\n\n    uint64_t lowaddr;\n\n    int i;\n\n    int big_endian;\n\n\n\n    flash_size *= 1024;\n\n    sram_size *= 1024;\n\n\n\n    if (!cpu_model)\n\n\tcpu_model = \"cortex-m3\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#if 0\n\n    \/* > 32Mb SRAM gets complicated because it overlaps the bitband area.\n\n       We don't have proper commandline options, so allocate half of memory\n\n       as SRAM, up to a maximum of 32Mb, and the rest as code.  *\/\n\n    if (ram_size > (512 + 32) * 1024 * 1024)\n\n        ram_size = (512 + 32) * 1024 * 1024;\n\n    sram_size = (ram_size \/ 2) & TARGET_PAGE_MASK;\n\n    if (sram_size > 32 * 1024 * 1024)\n\n        sram_size = 32 * 1024 * 1024;\n\n    code_size = ram_size - sram_size;\n\n#endif\n\n\n\n    \/* Flash programming is done via the SCU, so pretend it is ROM.  *\/\n\n    cpu_register_physical_memory(0, flash_size,\n\n                                 qemu_ram_alloc(flash_size) | IO_MEM_ROM);\n\n    cpu_register_physical_memory(0x20000000, sram_size,\n\n                                 qemu_ram_alloc(sram_size) | IO_MEM_RAM);\n\n    armv7m_bitband_init();\n\n\n\n    nvic = qdev_create(NULL, \"armv7m_nvic\");\n\n    env->v7m.nvic = nvic;\n\n    qdev_init(nvic);\n\n    cpu_pic = arm_pic_init_cpu(env);\n\n    sysbus_connect_irq(sysbus_from_qdev(nvic), 0, cpu_pic[ARM_PIC_CPU_IRQ]);\n\n    for (i = 0; i < 64; i++) {\n\n        pic[i] = qdev_get_gpio_in(nvic, i);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    big_endian = 1;\n\n#else\n\n    big_endian = 0;\n\n#endif\n\n\n\n    image_size = load_elf(kernel_filename, 0, &entry, &lowaddr, NULL,\n\n                          big_endian, ELF_MACHINE, 1);\n\n    if (image_size < 0) {\n\n        image_size = load_image_targphys(kernel_filename, 0, flash_size);\n\n\tlowaddr = 0;\n\n    }\n\n    if (image_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    \/* If the image was loaded at address zero then assume it is a\n\n       regular ROM image and perform the normal CPU reset sequence.\n\n       Otherwise jump directly to the entry point.  *\/\n\n    if (lowaddr == 0) {\n\n\tenv->regs[13] = ldl_phys(0);\n\n\tpc = ldl_phys(4);\n\n    } else {\n\n\tpc = entry;\n\n    }\n\n    env->thumb = pc & 1;\n\n    env->regs[15] = pc & ~1;\n\n\n\n    \/* Hack to map an additional page of ram at the top of the address\n\n       space.  This stops qemu complaining about executing code outside RAM\n\n       when returning from an exception.  *\/\n\n    cpu_register_physical_memory(0xfffff000, 0x1000,\n\n                                 qemu_ram_alloc(0x1000) | IO_MEM_RAM);\n\n\n\n    return pic;\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void uart_write(void *opaque, target_phys_addr_t offset,\n\n                          uint64_t value, unsigned size)\n\n{\n\n    UartState *s = (UartState *)opaque;\n\n\n\n    DB_PRINT(\" offset:%x data:%08x\\n\", offset, (unsigned)value);\n\n    offset >>= 2;\n\n    switch (offset) {\n\n    case R_IER: \/* ier (wts imr) *\/\n\n        s->r[R_IMR] |= value;\n\n        break;\n\n    case R_IDR: \/* idr (wtc imr) *\/\n\n        s->r[R_IMR] &= ~value;\n\n        break;\n\n    case R_IMR: \/* imr (read only) *\/\n\n        break;\n\n    case R_CISR: \/* cisr (wtc) *\/\n\n        s->r[R_CISR] &= ~value;\n\n        break;\n\n    case R_TX_RX: \/* UARTDR *\/\n\n        switch (s->r[R_MR] & UART_MR_CHMODE) {\n\n        case NORMAL_MODE:\n\n            uart_write_tx_fifo(s, (uint8_t *) &value, 1);\n\n            break;\n\n        case LOCAL_LOOPBACK:\n\n            uart_write_rx_fifo(opaque, (uint8_t *) &value, 1);\n\n            break;\n\n        }\n\n        break;\n\n    default:\n\n        s->r[offset] = value;\n\n    }\n\n\n\n    switch (offset) {\n\n    case R_CR:\n\n        uart_ctrl_update(s);\n\n        break;\n\n    case R_MR:\n\n        uart_parameters_setup(s);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"f53a829bb9ef14be800556cbc02d8b20fc1050a7","target":0,"func":"static int nbd_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n                         int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    return nbd_client_session_co_writev(&s->client, sector_num,\n\n                                        nb_sectors, qiov);\n\n}\n"},{"project":"qemu","commit_id":"e95205e1f9cd2c4262b7a7b1c992a94512c86d0e","target":1,"func":"static void cpu_notify_map_clients_locked(void)\n\n{\n\n    MapClient *client;\n\n\n\n    while (!QLIST_EMPTY(&map_client_list)) {\n\n        client = QLIST_FIRST(&map_client_list);\n\n        client->callback(client->opaque);\n\n        cpu_unregister_map_client(client);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"8417cebfda193c7f9ca70be5e308eaa92cf84b94","target":1,"func":"static void memory_map_init(void)\n\n{\n\n    system_memory = qemu_malloc(sizeof(*system_memory));\n\n    memory_region_init(system_memory, \"system\", UINT64_MAX);\n\n    set_system_memory_map(system_memory);\n\n}\n"},{"project":"qemu","commit_id":"a367467995d0528fe591d87ca2e437c7b7d7951b","target":0,"func":"static int do_write_compressed(BlockBackend *blk, char *buf, int64_t offset,\n\n                               int64_t count, int64_t *total)\n\n{\n\n    int ret;\n\n\n\n    if (count >> 9 > INT_MAX) {\n\n        return -ERANGE;\n\n    }\n\n\n\n    ret = blk_write_compressed(blk, offset >> 9, (uint8_t *)buf, count >> 9);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    *total = count;\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"4a41a2d68a684241aca96dba066e0699941b730d","target":1,"func":"static void nbd_teardown_connection(NbdClientSession *client)\n\n{\n\n    struct nbd_request request = {\n\n        .type = NBD_CMD_DISC,\n\n        .from = 0,\n\n        .len = 0\n\n    };\n\n\n\n    nbd_send_request(client->sock, &request);\n\n\n\n    \/* finish any pending coroutines *\/\n\n    shutdown(client->sock, 2);\n\n    nbd_recv_coroutines_enter_all(client);\n\n\n\n    qemu_aio_set_fd_handler(client->sock, NULL, NULL, NULL);\n\n    closesocket(client->sock);\n\n    client->sock = -1;\n\n}\n"},{"project":"qemu","commit_id":"6cec5487990bf3f1f22b3fcb871978255e92ae0d","target":1,"func":"static void set_pixel_format(VncState *vs,\n\n\t\t\t     int bits_per_pixel, int depth,\n\n\t\t\t     int big_endian_flag, int true_color_flag,\n\n\t\t\t     int red_max, int green_max, int blue_max,\n\n\t\t\t     int red_shift, int green_shift, int blue_shift)\n\n{\n\n    int host_big_endian_flag;\n\n\n\n#ifdef WORDS_BIGENDIAN\n\n    host_big_endian_flag = 1;\n\n#else\n\n    host_big_endian_flag = 0;\n\n#endif\n\n    if (!true_color_flag) {\n\n    fail:\n\n\tvnc_client_error(vs);\n\n        return;\n\n    }\n\n    if (bits_per_pixel == 32 &&\n\n        bits_per_pixel == vs->depth * 8 &&\n\n        host_big_endian_flag == big_endian_flag &&\n\n        red_max == 0xff && green_max == 0xff && blue_max == 0xff &&\n\n        red_shift == 16 && green_shift == 8 && blue_shift == 0) {\n\n        vs->depth = 4;\n\n        vs->write_pixels = vnc_write_pixels_copy;\n\n        vs->send_hextile_tile = send_hextile_tile_32;\n\n    } else\n\n    if (bits_per_pixel == 16 &&\n\n        bits_per_pixel == vs->depth * 8 && \n\n        host_big_endian_flag == big_endian_flag &&\n\n        red_max == 31 && green_max == 63 && blue_max == 31 &&\n\n        red_shift == 11 && green_shift == 5 && blue_shift == 0) {\n\n        vs->depth = 2;\n\n        vs->write_pixels = vnc_write_pixels_copy;\n\n        vs->send_hextile_tile = send_hextile_tile_16;\n\n    } else\n\n    if (bits_per_pixel == 8 &&\n\n        bits_per_pixel == vs->depth * 8 &&\n\n        red_max == 7 && green_max == 7 && blue_max == 3 &&\n\n        red_shift == 5 && green_shift == 2 && blue_shift == 0) {\n\n        vs->depth = 1;\n\n        vs->write_pixels = vnc_write_pixels_copy;\n\n        vs->send_hextile_tile = send_hextile_tile_8;\n\n    } else\n\n    {\n\n        \/* generic and slower case *\/\n\n        if (bits_per_pixel != 8 &&\n\n            bits_per_pixel != 16 &&\n\n            bits_per_pixel != 32)\n\n            goto fail;\n\n        if (vs->depth == 4) {\n\n            vs->send_hextile_tile = send_hextile_tile_generic_32;\n\n        } else if (vs->depth == 2) {\n\n           vs->send_hextile_tile = send_hextile_tile_generic_16;\n\n        } else {\n\n            vs->send_hextile_tile = send_hextile_tile_generic_8;\n\n        }\n\n\n\n        vs->pix_big_endian = big_endian_flag;\n\n        vs->write_pixels = vnc_write_pixels_generic;\n\n    }\n\n\n\n    vs->client_red_shift = red_shift;\n\n    vs->client_red_max = red_max;\n\n    vs->client_green_shift = green_shift;\n\n    vs->client_green_max = green_max;\n\n    vs->client_blue_shift = blue_shift;\n\n    vs->client_blue_max = blue_max;\n\n    vs->pix_bpp = bits_per_pixel \/ 8;\n\n\n\n    vga_hw_invalidate();\n\n    vga_hw_update();\n\n}\n"},{"project":"qemu","commit_id":"efec3dd631d94160288392721a5f9c39e50fb2bc","target":1,"func":"static void vapic_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->no_user = 1;\n\n    dc->reset   = vapic_reset;\n\n    dc->vmsd    = &vmstate_vapic;\n\n    dc->realize = vapic_realize;\n\n}\n"},{"project":"qemu","commit_id":"aec4b054ea36c53c8b887da99f20010133b84378","target":1,"func":"static void simple_dict(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \"{\\\"foo\\\": 42, \\\"bar\\\": \\\"hello world\\\"}\",\n\n            .decoded = QLIT_QDICT(((LiteralQDictEntry[]){\n\n                        { \"foo\", QLIT_QINT(42) },\n\n                        { \"bar\", QLIT_QSTR(\"hello world\") },\n\n                        { }\n\n                    })),\n\n        }, {\n\n            .encoded = \"{}\",\n\n            .decoded = QLIT_QDICT(((LiteralQDictEntry[]){\n\n                        { }\n\n                    })),\n\n        }, {\n\n            .encoded = \"{\\\"foo\\\": 43}\",\n\n            .decoded = QLIT_QDICT(((LiteralQDictEntry[]){\n\n                        { \"foo\", QLIT_QINT(43) },\n\n                        { }\n\n                    })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"846424350b292f16b732b573273a5c1f195cd7a3","target":1,"func":"static int32_t scsi_target_send_command(SCSIRequest *req, uint8_t *buf)\n\n{\n\n    SCSITargetReq *r = DO_UPCAST(SCSITargetReq, req, req);\n\n\n\n    switch (buf[0]) {\n\n    case REPORT_LUNS:\n\n        if (!scsi_target_emulate_report_luns(r)) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case INQUIRY:\n\n        if (!scsi_target_emulate_inquiry(r)) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case REQUEST_SENSE:\n\n        r->len = scsi_device_get_sense(r->req.dev, r->buf,\n\n                                       MIN(req->cmd.xfer, sizeof r->buf),\n\n                                       (req->cmd.buf[1] & 1) == 0);\n\n        if (r->req.dev->sense_is_ua) {\n\n            scsi_device_unit_attention_reported(req->dev);\n\n            r->req.dev->sense_len = 0;\n\n            r->req.dev->sense_is_ua = false;\n\n        }\n\n        break;\n\n    default:\n\n        scsi_req_build_sense(req, SENSE_CODE(LUN_NOT_SUPPORTED));\n\n        scsi_req_complete(req, CHECK_CONDITION);\n\n        return 0;\n\n    illegal_request:\n\n        scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));\n\n        scsi_req_complete(req, CHECK_CONDITION);\n\n        return 0;\n\n    }\n\n\n\n    if (!r->len) {\n\n        scsi_req_complete(req, GOOD);\n\n    }\n\n    return r->len;\n\n}\n"},{"project":"qemu","commit_id":"fcf73f66a67f5e58c18216f8c8651e38cf4d90af","target":1,"func":"static void qmp_input_type_int(Visitor *v, int64_t *obj, const char *name,\n\n                               Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qmp_input_get_object(qiv, name, true);\n\n\n\n    if (!qobj || qobject_type(qobj) != QTYPE_QINT) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"integer\");\n\n        return;\n\n    }\n\n\n\n    *obj = qint_get_int(qobject_to_qint(qobj));\n\n}\n"},{"project":"qemu","commit_id":"9b2fadda3e0196ffd485adde4fe9cdd6fae35300","target":1,"func":"static void gen_dcbi(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv EA, val;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    EA = tcg_temp_new();\n\n    gen_set_access_type(ctx, ACCESS_CACHE);\n\n    gen_addr_reg_index(ctx, EA);\n\n    val = tcg_temp_new();\n\n    \/* XXX: specification says this should be treated as a store by the MMU *\/\n\n    gen_qemu_ld8u(ctx, val, EA);\n\n    gen_qemu_st8(ctx, val, EA);\n\n    tcg_temp_free(val);\n\n    tcg_temp_free(EA);\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"2725aec70114cf1bee00443aeb47a305f9b0c665","target":1,"func":"static void update_pam(PCII440FXState *d, uint32_t start, uint32_t end, int r,\n\n                       PAMMemoryRegion *mem)\n\n{\n\n    if (mem->initialized) {\n\n        memory_region_del_subregion(d->system_memory, &mem->mem);\n\n        memory_region_destroy(&mem->mem);\n\n    }\n\n\n\n    \/\/    printf(\"ISA mapping %08x-0x%08x: %d\\n\", start, end, r);\n\n    switch(r) {\n\n    case 3:\n\n        \/* RAM *\/\n\n        memory_region_init_alias(&mem->mem, \"pam-ram\", d->ram_memory,\n\n                                 start, end - start);\n\n        break;\n\n    case 1:\n\n        \/* ROM (XXX: not quite correct) *\/\n\n        memory_region_init_alias(&mem->mem, \"pam-rom\", d->ram_memory,\n\n                                 start, end - start);\n\n        memory_region_set_readonly(&mem->mem, true);\n\n        break;\n\n    case 2:\n\n    case 0:\n\n        \/* XXX: should distinguish read\/write cases *\/\n\n        memory_region_init_alias(&mem->mem, \"pam-pci\", d->pci_address_space,\n\n                                 start, end - start);\n\n        break;\n\n    }\n\n    memory_region_add_subregion_overlap(d->system_memory,\n\n                                        start, &mem->mem, 1);\n\n    mem->initialized = true;\n\n}\n"},{"project":"qemu","commit_id":"751ebd76e654bd1e65da08ecf694325282b4cfcc","target":0,"func":"BlockJobInfo *block_job_query(BlockJob *job)\n\n{\n\n    BlockJobInfo *info = g_new0(BlockJobInfo, 1);\n\n    info->type      = g_strdup(BlockJobType_lookup[job->driver->job_type]);\n\n    info->device    = g_strdup(bdrv_get_device_name(job->bs));\n\n    info->len       = job->len;\n\n    info->busy      = job->busy;\n\n    info->paused    = job->paused;\n\n    info->offset    = job->offset;\n\n    info->speed     = job->speed;\n\n    info->io_status = job->iostatus;\n\n    info->ready     = job->ready;\n\n    return info;\n\n}\n"},{"project":"qemu","commit_id":"6da528d14de29138ca5ac43d6d059889dd24f464","target":0,"func":"void HELPER(mvpg)(CPUS390XState *env, uint64_t r0, uint64_t r1, uint64_t r2)\n\n{\n\n    \/* XXX missing r0 handling *\/\n\n    env->cc_op = 0;\n\n#ifdef CONFIG_USER_ONLY\n\n    memmove(g2h(r1), g2h(r2), TARGET_PAGE_SIZE);\n\n#else\n\n    mvc_fast_memmove(env, TARGET_PAGE_SIZE, r1, r2);\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"de5dca1b792ada25c29a95c8f84e01f4300aef9c","target":1,"func":"e1000e_io_write(void *opaque, hwaddr addr,\n\n                uint64_t val, unsigned size)\n\n{\n\n    E1000EState *s = opaque;\n\n    uint32_t idx;\n\n\n\n    switch (addr) {\n\n    case E1000_IOADDR:\n\n        trace_e1000e_io_write_addr(val);\n\n        s->ioaddr = (uint32_t) val;\n\n        return;\n\n    case E1000_IODATA:\n\n        if (e1000e_io_get_reg_index(s, &idx)) {\n\n            trace_e1000e_io_write_data(idx, val);\n\n            e1000e_core_write(&s->core, idx, val, sizeof(val));\n\n        }\n\n        return;\n\n    default:\n\n        trace_e1000e_wrn_io_write_unknown(addr);\n\n        return;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b","target":0,"func":"static uint16_t read_u16(uint8_t *data, size_t offset)\n\n{\n\n    return ((data[offset] & 0xFF) << 8) | (data[offset + 1] & 0xFF);\n\n}\n"},{"project":"qemu","commit_id":"61007b316cd71ee7333ff7a0a749a8949527575f","target":0,"func":"BlockDriverState *bdrv_find_node(const char *node_name)\n\n{\n\n    BlockDriverState *bs;\n\n\n\n    assert(node_name);\n\n\n\n    QTAILQ_FOREACH(bs, &graph_bdrv_states, node_list) {\n\n        if (!strcmp(node_name, bs->node_name)) {\n\n            return bs;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"81f3053b77f7d3a4d9100c425cd8cec99ee7a3d4","target":0,"func":"void helper_mwait(CPUX86State *env, int next_eip_addend)\n\n{\n\n    CPUState *cs;\n\n    X86CPU *cpu;\n\n\n\n    if ((uint32_t)env->regs[R_ECX] != 0) {\n\n        raise_exception(env, EXCP0D_GPF);\n\n    }\n\n    cpu_svm_check_intercept_param(env, SVM_EXIT_MWAIT, 0);\n\n    env->eip += next_eip_addend;\n\n\n\n    cpu = x86_env_get_cpu(env);\n\n    cs = CPU(cpu);\n\n    \/* XXX: not complete but not completely erroneous *\/\n\n    if (cs->cpu_index != 0 || CPU_NEXT(cs) != NULL) {\n\n        \/* more than one CPU: do not sleep because another CPU may\n\n           wake this one *\/\n\n    } else {\n\n        do_hlt(cpu);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static void lm32_uclinux_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq *cpu_irq, irq[32];\n\n    HWSetup *hw;\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    \/* memory map *\/\n\n    hwaddr flash_base   = 0x04000000;\n\n    size_t flash_sector_size        = 256 * 1024;\n\n    size_t flash_size               = 32 * 1024 * 1024;\n\n    hwaddr ram_base     = 0x08000000;\n\n    size_t ram_size                 = 64 * 1024 * 1024;\n\n    hwaddr uart0_base   = 0x80000000;\n\n    hwaddr timer0_base  = 0x80002000;\n\n    hwaddr timer1_base  = 0x80010000;\n\n    hwaddr timer2_base  = 0x80012000;\n\n    int uart0_irq                   = 0;\n\n    int timer0_irq                  = 1;\n\n    int timer1_irq                  = 20;\n\n    int timer2_irq                  = 21;\n\n    hwaddr hwsetup_base = 0x0bffe000;\n\n    hwaddr cmdline_base = 0x0bfff000;\n\n    hwaddr initrd_base  = 0x08400000;\n\n    size_t initrd_max               = 0x01000000;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = cpu_lm32_init(cpu_model);\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: unable to find CPU '%s'\\n\", cpu_model);\n\n        exit(1);\n\n    }\n\n\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_init_ram(phys_ram, NULL, \"lm32_uclinux.sdram\", ram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(phys_ram);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    \/* Spansion S29NS128P *\/\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_uclinux.flash\", flash_size,\n\n                          dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                          flash_sector_size, flash_size \/ flash_sector_size,\n\n                          1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    \/* create irq lines *\/\n\n    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, env, 1);\n\n    env->pic_state = lm32_pic_init(*cpu_irq);\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    sysbus_create_simple(\"lm32-uart\", uart0_base, irq[uart0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer2_base, irq[timer2_irq]);\n\n\n\n    \/* make sure juart isn't the first chardev *\/\n\n    env->juart_state = lm32_juart_init();\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, ELF_MACHINE, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    \/* generate a rom with the hardware description *\/\n\n    hw = hwsetup_init();\n\n    hwsetup_add_cpu(hw, \"LM32\", 75000000);\n\n    hwsetup_add_flash(hw, \"flash\", flash_base, flash_size);\n\n    hwsetup_add_ddr_sdram(hw, \"ddr_sdram\", ram_base, ram_size);\n\n    hwsetup_add_timer(hw, \"timer0\", timer0_base, timer0_irq);\n\n    hwsetup_add_timer(hw, \"timer1_dev_only\", timer1_base, timer1_irq);\n\n    hwsetup_add_timer(hw, \"timer2_dev_only\", timer2_base, timer2_irq);\n\n    hwsetup_add_uart(hw, \"uart\", uart0_base, uart0_irq);\n\n    hwsetup_add_trailer(hw);\n\n    hwsetup_create_rom(hw, hwsetup_base);\n\n    hwsetup_free(hw);\n\n\n\n    reset_info->hwsetup_base = hwsetup_base;\n\n\n\n    if (kernel_cmdline && strlen(kernel_cmdline)) {\n\n        pstrcpy_targphys(\"cmdline\", cmdline_base, TARGET_PAGE_SIZE,\n\n                kernel_cmdline);\n\n        reset_info->cmdline_base = cmdline_base;\n\n    }\n\n\n\n    if (initrd_filename) {\n\n        size_t initrd_size;\n\n        initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                initrd_max);\n\n        reset_info->initrd_base = initrd_base;\n\n        reset_info->initrd_size = initrd_size;\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n"},{"project":"qemu","commit_id":"616cbc78a50c638b94cc4756a565f11bb10dbfeb","target":0,"func":"PCIBus *pci_register_bus(DeviceState *parent, const char *name,\n\n                         pci_set_irq_fn set_irq, pci_map_irq_fn map_irq,\n\n                         qemu_irq *pic, int devfn_min, int nirq)\n\n{\n\n    PCIBus *bus;\n\n    static int nbus = 0;\n\n\n\n    bus = FROM_QBUS(PCIBus, qbus_create(&pci_bus_info, parent, name));\n\n    bus->set_irq = set_irq;\n\n    bus->map_irq = map_irq;\n\n    bus->irq_opaque = pic;\n\n    bus->devfn_min = devfn_min;\n\n    bus->nirq = nirq;\n\n    bus->irq_count = qemu_malloc(nirq * sizeof(bus->irq_count[0]));\n\n    bus->next = first_bus;\n\n    first_bus = bus;\n\n    register_savevm(\"PCIBUS\", nbus++, 1, pcibus_save, pcibus_load, bus);\n\n    qemu_register_reset(pci_bus_reset, bus);\n\n    return bus;\n\n}\n"},{"project":"qemu","commit_id":"45eb768c706d3a5fbe55224c589e8b4e252781d9","target":0,"func":"static void pci_init_mask_bridge(PCIDevice *d)\n\n{\n\n    \/* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and\n\n       PCI_SEC_LETENCY_TIMER *\/\n\n    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);\n\n\n\n    \/* base and limit *\/\n\n    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;\n\n    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;\n\n    pci_set_word(d->wmask + PCI_MEMORY_BASE,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n\n\n    \/* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 *\/\n\n    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);\n\n\n\n    \/* Supported memory and i\/o types *\/\n\n    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;\n\n    d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n\n\n\/* TODO: add this define to pci_regs.h in linux and then in qemu. *\/\n\n#define  PCI_BRIDGE_CTL_VGA_16BIT\t0x10\t\/* VGA 16-bit decode *\/\n\n#define  PCI_BRIDGE_CTL_DISCARD\t\t0x100\t\/* Primary discard timer *\/\n\n#define  PCI_BRIDGE_CTL_SEC_DISCARD\t0x200\t\/* Secondary discard timer *\/\n\n#define  PCI_BRIDGE_CTL_DISCARD_STATUS\t0x400\t\/* Discard timer status *\/\n\n#define  PCI_BRIDGE_CTL_DISCARD_SERR\t0x800\t\/* Discard timer SERR# enable *\/\n\n\/*\n\n * TODO: Bridges default to 10-bit VGA decoding but we currently only\n\n * implement 16-bit decoding (no alias support).\n\n *\/\n\n    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_PARITY |\n\n                 PCI_BRIDGE_CTL_SERR |\n\n                 PCI_BRIDGE_CTL_ISA |\n\n                 PCI_BRIDGE_CTL_VGA |\n\n                 PCI_BRIDGE_CTL_VGA_16BIT |\n\n                 PCI_BRIDGE_CTL_MASTER_ABORT |\n\n                 PCI_BRIDGE_CTL_BUS_RESET |\n\n                 PCI_BRIDGE_CTL_FAST_BACK |\n\n                 PCI_BRIDGE_CTL_DISCARD |\n\n                 PCI_BRIDGE_CTL_SEC_DISCARD |\n\n                 PCI_BRIDGE_CTL_DISCARD_SERR);\n\n    \/* Below does not do anything as we never set this bit, put here for\n\n     * completeness. *\/\n\n    pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_DISCARD_STATUS);\n\n    d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;\n\n    d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n}\n"},{"project":"qemu","commit_id":"6b7d4c55586a849aa8313282d79432917eade3bf","target":0,"func":"static int coroutine_fn copy_sectors(BlockDriverState *bs,\n\n                                     uint64_t start_sect,\n\n                                     uint64_t cluster_offset,\n\n                                     int n_start, int n_end)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QEMUIOVector qiov;\n\n    struct iovec iov;\n\n    int n, ret;\n\n\n\n    \/*\n\n     * If this is the last cluster and it is only partially used, we must only\n\n     * copy until the end of the image, or bdrv_check_request will fail for the\n\n     * bdrv_read\/write calls below.\n\n     *\/\n\n    if (start_sect + n_end > bs->total_sectors) {\n\n        n_end = bs->total_sectors - start_sect;\n\n    }\n\n\n\n    n = n_end - n_start;\n\n    if (n <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    iov.iov_len = n * BDRV_SECTOR_SIZE;\n\n    iov.iov_base = qemu_blockalign(bs, iov.iov_len);\n\n\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_COW_READ);\n\n\n\n    if (!bs->drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n\n\n    \/* Call .bdrv_co_readv() directly instead of using the public block-layer\n\n     * interface.  This avoids double I\/O throttling and request tracking,\n\n     * which can lead to deadlock when block layer copy-on-read is enabled.\n\n     *\/\n\n    ret = bs->drv->bdrv_co_readv(bs, start_sect + n_start, n, &qiov);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    if (s->crypt_method) {\n\n        qcow2_encrypt_sectors(s, start_sect + n_start,\n\n                        iov.iov_base, iov.iov_base, n, 1,\n\n                        &s->aes_encrypt_key);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0,\n\n            cluster_offset + n_start * BDRV_SECTOR_SIZE, n * BDRV_SECTOR_SIZE);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_COW_WRITE);\n\n    ret = bdrv_co_writev(bs->file, (cluster_offset >> 9) + n_start, n, &qiov);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    qemu_vfree(iov.iov_base);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"e4f4fb1eca795e36f363b4647724221e774523c1","target":1,"func":"static void sysbus_device_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *k = DEVICE_CLASS(klass);\n\n    k->init = sysbus_device_init;\n\n    k->bus_type = TYPE_SYSTEM_BUS;\n\n\n\n\n\n\n\n\n\n\n\n\n}"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void mmio_ide_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    MMIOState *s = opaque;\n\n    addr >>= s->shift;\n\n    if (addr & 7)\n\n        ide_ioport_write(&s->bus, addr, val);\n\n    else\n\n        ide_data_writew(&s->bus, 0, val);\n\n}\n"},{"project":"qemu","commit_id":"69583490856713f693291b32fc74b6d0f5992b72","target":1,"func":"static int hdev_get_max_segments(const struct stat *st)\n\n{\n\n#ifdef CONFIG_LINUX\n\n    char buf[32];\n\n    const char *end;\n\n    char *sysfspath;\n\n    int ret;\n\n    int fd = -1;\n\n    long max_segments;\n\n\n\n    sysfspath = g_strdup_printf(\"\/sys\/dev\/block\/%u:%u\/queue\/max_segments\",\n\n                                major(st->st_rdev), minor(st->st_rdev));\n\n    fd = open(sysfspath, O_RDONLY);\n\n    if (fd == -1) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n    do {\n\n        ret = read(fd, buf, sizeof(buf));\n\n    } while (ret == -1 && errno == EINTR);\n\n    if (ret < 0) {\n\n        ret = -errno;\n\n        goto out;\n\n    } else if (ret == 0) {\n\n        ret = -EIO;\n\n        goto out;\n\n    }\n\n    buf[ret] = 0;\n\n    \/* The file is ended with '\\n', pass 'end' to accept that. *\/\n\n    ret = qemu_strtol(buf, &end, 10, &max_segments);\n\n    if (ret == 0 && end && *end == '\\n') {\n\n        ret = max_segments;\n\n    }\n\n\n\nout:\n\n    g_free(sysfspath);\n\n    return ret;\n\n#else\n\n    return -ENOTSUP;\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"4baef2679e029c76707be1e2ed54bf3dd21693fe","target":0,"func":"int qemu_strtoul(const char *nptr, const char **endptr, int base,\n\n                 unsigned long *result)\n\n{\n\n    char *ep;\n\n    int err = 0;\n\n    if (!nptr) {\n\n        if (endptr) {\n\n            *endptr = nptr;\n\n        }\n\n        err = -EINVAL;\n\n    } else {\n\n        errno = 0;\n\n        *result = strtoul(nptr, &ep, base);\n\n        \/* Windows returns 1 for negative out-of-range values.  *\/\n\n        if (errno == ERANGE) {\n\n            *result = -1;\n\n        }\n\n        err = check_strtox_error(nptr, ep, endptr, errno);\n\n    }\n\n    return err;\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xff);\n\n}\n"},{"project":"qemu","commit_id":"24b856ca63f1c72b5043af6b291e7cc35900f4d6","target":0,"func":"static int i6300esb_init(PCIDevice *dev)\n\n{\n\n    I6300State *d = DO_UPCAST(I6300State, dev, dev);\n\n    uint8_t *pci_conf;\n\n    int io_mem;\n\n    static CPUReadMemoryFunc * const mem_read[3] = {\n\n        i6300esb_mem_readb,\n\n        i6300esb_mem_readw,\n\n        i6300esb_mem_readl,\n\n    };\n\n    static CPUWriteMemoryFunc * const mem_write[3] = {\n\n        i6300esb_mem_writeb,\n\n        i6300esb_mem_writew,\n\n        i6300esb_mem_writel,\n\n    };\n\n\n\n    i6300esb_debug(\"I6300State = %p\\n\", d);\n\n\n\n    d->timer = qemu_new_timer_ns(vm_clock, i6300esb_timer_expired, d);\n\n    d->previous_reboot_flag = 0;\n\n\n\n    pci_conf = d->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_ESB_9);\n\n    pci_config_set_class(pci_conf, PCI_CLASS_SYSTEM_OTHER);\n\n\n\n    io_mem = cpu_register_io_memory(mem_read, mem_write, d,\n\n                                    DEVICE_NATIVE_ENDIAN);\n\n    pci_register_bar_simple(&d->dev, 0, 0x10, 0, io_mem);\n\n    \/* qemu_register_coalesced_mmio (addr, 0x10); ? *\/\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static uint64_t omap_pwl_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    struct omap_pwl_s *s = (struct omap_pwl_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_read8(opaque, addr);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t\/* PWL_LEVEL *\/\n\n        return s->level;\n\n    case 0x04:\t\/* PWL_CTRL *\/\n\n        return s->enable;\n\n    }\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"2928207ac1bb2751a1554ea0f9a9641179f51488","target":1,"func":"static int dump_init(DumpState *s, int fd, bool has_format,\n\n                     DumpGuestMemoryFormat format, bool paging, bool has_filter,\n\n                     int64_t begin, int64_t length, Error **errp)\n\n{\n\n    CPUState *cpu;\n\n    int nr_cpus;\n\n    Error *err = NULL;\n\n    int ret;\n\n\n\n    \/* kdump-compressed is conflict with paging and filter *\/\n\n    if (has_format && format != DUMP_GUEST_MEMORY_FORMAT_ELF) {\n\n        assert(!paging && !has_filter);\n\n    }\n\n\n\n    if (runstate_is_running()) {\n\n        vm_stop(RUN_STATE_SAVE_VM);\n\n        s->resume = true;\n\n    } else {\n\n        s->resume = false;\n\n    }\n\n\n\n    \/* If we use KVM, we should synchronize the registers before we get dump\n\n     * info or physmap info.\n\n     *\/\n\n    cpu_synchronize_all_states();\n\n    nr_cpus = 0;\n\n    CPU_FOREACH(cpu) {\n\n        nr_cpus++;\n\n    }\n\n\n\n    s->fd = fd;\n\n    s->has_filter = has_filter;\n\n    s->begin = begin;\n\n    s->length = length;\n\n\n\n    guest_phys_blocks_init(&s->guest_phys_blocks);\n\n    guest_phys_blocks_append(&s->guest_phys_blocks);\n\n\n\n    s->start = get_start_block(s);\n\n    if (s->start == -1) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, \"begin\");\n\n        goto cleanup;\n\n    }\n\n\n\n    \/* get dump info: endian, class and architecture.\n\n     * If the target architecture is not supported, cpu_get_dump_info() will\n\n     * return -1.\n\n     *\/\n\n    ret = cpu_get_dump_info(&s->dump_info, &s->guest_phys_blocks);\n\n    if (ret < 0) {\n\n        error_set(errp, QERR_UNSUPPORTED);\n\n        goto cleanup;\n\n    }\n\n\n\n    s->note_size = cpu_get_note_size(s->dump_info.d_class,\n\n                                     s->dump_info.d_machine, nr_cpus);\n\n    if (s->note_size < 0) {\n\n        error_set(errp, QERR_UNSUPPORTED);\n\n        goto cleanup;\n\n    }\n\n\n\n    \/* get memory mapping *\/\n\n    memory_mapping_list_init(&s->list);\n\n    if (paging) {\n\n        qemu_get_guest_memory_mapping(&s->list, &s->guest_phys_blocks, &err);\n\n        if (err != NULL) {\n\n            error_propagate(errp, err);\n\n            goto cleanup;\n\n        }\n\n    } else {\n\n        qemu_get_guest_simple_memory_mapping(&s->list, &s->guest_phys_blocks);\n\n    }\n\n\n\n    s->nr_cpus = nr_cpus;\n\n\n\n    get_max_mapnr(s);\n\n\n\n    uint64_t tmp;\n\n    tmp = DIV_ROUND_UP(DIV_ROUND_UP(s->max_mapnr, CHAR_BIT), TARGET_PAGE_SIZE);\n\n    s->len_dump_bitmap = tmp * TARGET_PAGE_SIZE;\n\n\n\n    \/* init for kdump-compressed format *\/\n\n    if (has_format && format != DUMP_GUEST_MEMORY_FORMAT_ELF) {\n\n        switch (format) {\n\n        case DUMP_GUEST_MEMORY_FORMAT_KDUMP_ZLIB:\n\n            s->flag_compress = DUMP_DH_COMPRESSED_ZLIB;\n\n            break;\n\n\n\n        case DUMP_GUEST_MEMORY_FORMAT_KDUMP_LZO:\n\n#ifdef CONFIG_LZO\n\n            if (lzo_init() != LZO_E_OK) {\n\n                error_setg(errp, \"failed to initialize the LZO library\");\n\n                goto cleanup;\n\n            }\n\n#endif\n\n            s->flag_compress = DUMP_DH_COMPRESSED_LZO;\n\n            break;\n\n\n\n        case DUMP_GUEST_MEMORY_FORMAT_KDUMP_SNAPPY:\n\n            s->flag_compress = DUMP_DH_COMPRESSED_SNAPPY;\n\n            break;\n\n\n\n        default:\n\n            s->flag_compress = 0;\n\n        }\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (s->has_filter) {\n\n        memory_mapping_filter(&s->list, s->begin, s->length);\n\n    }\n\n\n\n    \/*\n\n     * calculate phdr_num\n\n     *\n\n     * the type of ehdr->e_phnum is uint16_t, so we should avoid overflow\n\n     *\/\n\n    s->phdr_num = 1; \/* PT_NOTE *\/\n\n    if (s->list.num < UINT16_MAX - 2) {\n\n        s->phdr_num += s->list.num;\n\n        s->have_section = false;\n\n    } else {\n\n        s->have_section = true;\n\n        s->phdr_num = PN_XNUM;\n\n        s->sh_info = 1; \/* PT_NOTE *\/\n\n\n\n        \/* the type of shdr->sh_info is uint32_t, so we should avoid overflow *\/\n\n        if (s->list.num <= UINT32_MAX - 1) {\n\n            s->sh_info += s->list.num;\n\n        } else {\n\n            s->sh_info = UINT32_MAX;\n\n        }\n\n    }\n\n\n\n    if (s->dump_info.d_class == ELFCLASS64) {\n\n        if (s->have_section) {\n\n            s->memory_offset = sizeof(Elf64_Ehdr) +\n\n                               sizeof(Elf64_Phdr) * s->sh_info +\n\n                               sizeof(Elf64_Shdr) + s->note_size;\n\n        } else {\n\n            s->memory_offset = sizeof(Elf64_Ehdr) +\n\n                               sizeof(Elf64_Phdr) * s->phdr_num + s->note_size;\n\n        }\n\n    } else {\n\n        if (s->have_section) {\n\n            s->memory_offset = sizeof(Elf32_Ehdr) +\n\n                               sizeof(Elf32_Phdr) * s->sh_info +\n\n                               sizeof(Elf32_Shdr) + s->note_size;\n\n        } else {\n\n            s->memory_offset = sizeof(Elf32_Ehdr) +\n\n                               sizeof(Elf32_Phdr) * s->phdr_num + s->note_size;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\ncleanup:\n\n    guest_phys_blocks_free(&s->guest_phys_blocks);\n\n\n\n    if (s->resume) {\n\n        vm_start();\n\n    }\n\n\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"c444dfabfc21cb5f093862100e333b808eea32e4","target":0,"func":"static void tx_fifo_push(lan9118_state *s, uint32_t val)\n\n{\n\n    int n;\n\n\n\n    if (s->txp->fifo_used == s->tx_fifo_size) {\n\n        s->int_sts |= TDFO_INT;\n\n        return;\n\n    }\n\n    switch (s->txp->state) {\n\n    case TX_IDLE:\n\n        s->txp->cmd_a = val & 0x831f37ff;\n\n        s->txp->fifo_used++;\n\n        s->txp->state = TX_B;\n\n        s->txp->buffer_size = extract32(s->txp->cmd_a, 0, 11);\n\n        s->txp->offset = extract32(s->txp->cmd_a, 16, 5);\n\n        break;\n\n    case TX_B:\n\n        if (s->txp->cmd_a & 0x2000) {\n\n            \/* First segment *\/\n\n            s->txp->cmd_b = val;\n\n            s->txp->fifo_used++;\n\n            \/* End alignment does not include command words.  *\/\n\n            n = (s->txp->buffer_size + s->txp->offset + 3) >> 2;\n\n            switch ((n >> 24) & 3) {\n\n            case 1:\n\n                n = (-n) & 3;\n\n                break;\n\n            case 2:\n\n                n = (-n) & 7;\n\n                break;\n\n            default:\n\n                n = 0;\n\n            }\n\n            s->txp->pad = n;\n\n            s->txp->len = 0;\n\n        }\n\n        DPRINTF(\"Block len:%d offset:%d pad:%d cmd %08x\\n\",\n\n                s->txp->buffer_size, s->txp->offset, s->txp->pad,\n\n                s->txp->cmd_a);\n\n        s->txp->state = TX_DATA;\n\n        break;\n\n    case TX_DATA:\n\n        if (s->txp->offset >= 4) {\n\n            s->txp->offset -= 4;\n\n            break;\n\n        }\n\n        if (s->txp->buffer_size <= 0 && s->txp->pad != 0) {\n\n            s->txp->pad--;\n\n        } else {\n\n            n = 4;\n\n            while (s->txp->offset) {\n\n                val >>= 8;\n\n                n--;\n\n                s->txp->offset--;\n\n            }\n\n            \/* Documentation is somewhat unclear on the ordering of bytes\n\n               in FIFO words.  Empirical results show it to be little-endian.\n\n               *\/\n\n            \/* TODO: FIFO overflow checking.  *\/\n\n            while (n--) {\n\n                s->txp->data[s->txp->len] = val & 0xff;\n\n                s->txp->len++;\n\n                val >>= 8;\n\n                s->txp->buffer_size--;\n\n            }\n\n            s->txp->fifo_used++;\n\n        }\n\n        if (s->txp->buffer_size <= 0 && s->txp->pad == 0) {\n\n            if (s->txp->cmd_a & 0x1000) {\n\n                do_tx_packet(s);\n\n            }\n\n            if (s->txp->cmd_a & 0x80000000) {\n\n                s->int_sts |= TX_IOC_INT;\n\n            }\n\n            s->txp->state = TX_IDLE;\n\n        }\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"d20423788e3a3d5f6a2aad8315779bf3f952ca36","target":0,"func":"static int handle_utimensat(FsContext *ctx, V9fsPath *fs_path,\n\n                            const struct timespec *buf)\n\n{\n\n    int fd, ret;\n\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n    ret = futimens(fd, buf);\n\n    close(fd);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"9fbf0fa81fca8f527669dd4fa72662d66e7d6329","target":1,"func":"static int32_t bmdma_prepare_buf(IDEDMA *dma, int32_t limit)\n\n{\n\n    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n\n    IDEState *s = bmdma_active_if(bm);\n\n    PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);\n\n    struct {\n\n        uint32_t addr;\n\n        uint32_t size;\n\n    } prd;\n\n    int l, len;\n\n\n\n    pci_dma_sglist_init(&s->sg, pci_dev,\n\n                        s->nsector \/ (BMDMA_PAGE_SIZE \/ 512) + 1);\n\n    s->io_buffer_size = 0;\n\n    for(;;) {\n\n        if (bm->cur_prd_len == 0) {\n\n            \/* end of table (with a fail safe of one page) *\/\n\n            if (bm->cur_prd_last ||\n\n                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {\n\n                return s->sg.size;\n\n            }\n\n            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);\n\n            bm->cur_addr += 8;\n\n            prd.addr = le32_to_cpu(prd.addr);\n\n            prd.size = le32_to_cpu(prd.size);\n\n            len = prd.size & 0xfffe;\n\n            if (len == 0)\n\n                len = 0x10000;\n\n            bm->cur_prd_len = len;\n\n            bm->cur_prd_addr = prd.addr;\n\n            bm->cur_prd_last = (prd.size & 0x80000000);\n\n        }\n\n        l = bm->cur_prd_len;\n\n        if (l > 0) {\n\n            uint64_t sg_len;\n\n\n\n            \/* Don't add extra bytes to the SGList; consume any remaining\n\n             * PRDs from the guest, but ignore them. *\/\n\n            sg_len = MIN(limit - s->sg.size, bm->cur_prd_len);\n\n            if (sg_len) {\n\n                qemu_sglist_add(&s->sg, bm->cur_prd_addr, sg_len);\n\n            }\n\n\n\n            \/* Note: We limit the max transfer to be 2GiB.\n\n             * This should accommodate the largest ATA transaction\n\n             * for LBA48 (65,536 sectors) and 32K sector sizes. *\/\n\n            if (s->sg.size > INT32_MAX) {\n\n                error_report(\"IDE: sglist describes more than 2GiB.\");\n\n                break;\n\n            }\n\n            bm->cur_prd_addr += l;\n\n            bm->cur_prd_len -= l;\n\n            s->io_buffer_size += l;\n\n        }\n\n    }\n\n\n\n    qemu_sglist_destroy(&s->sg);\n\n    s->io_buffer_size = 0;\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"d9f62dde1303286b24ac8ce88be27e2b9b9c5f46","target":0,"func":"opts_start_list(Visitor *v, const char *name, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n\n\n    \/* we can't traverse a list in a list *\/\n\n    assert(ov->list_mode == LM_NONE);\n\n    ov->repeated_opts = lookup_distinct(ov, name, errp);\n\n    if (ov->repeated_opts != NULL) {\n\n        ov->list_mode = LM_STARTED;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"9f1d4b1d6939d39fe570d886f6a651f4764bcbcb","target":0,"func":"static void IRQ_local_pipe(OpenPICState *opp, int n_CPU, int n_IRQ)\n\n{\n\n    IRQDest *dst;\n\n    IRQSource *src;\n\n    int priority;\n\n\n\n    dst = &opp->dst[n_CPU];\n\n    src = &opp->src[n_IRQ];\n\n\n\n    if (src->output != OPENPIC_OUTPUT_INT) {\n\n        \/* On Freescale MPIC, critical interrupts ignore priority,\n\n         * IACK, EOI, etc.  Before MPIC v4.1 they also ignore\n\n         * masking.\n\n         *\/\n\n        src->ivpr |= IVPR_ACTIVITY_MASK;\n\n        DPRINTF(\"%s: Raise OpenPIC output %d cpu %d irq %d\\n\",\n\n                __func__, src->output, n_CPU, n_IRQ);\n\n        qemu_irq_raise(opp->dst[n_CPU].irqs[src->output]);\n\n        return;\n\n    }\n\n\n\n    priority = IVPR_PRIORITY(src->ivpr);\n\n    if (priority <= dst->ctpr) {\n\n        \/* Too low priority *\/\n\n        DPRINTF(\"%s: IRQ %d has too low priority on CPU %d\\n\",\n\n                __func__, n_IRQ, n_CPU);\n\n        return;\n\n    }\n\n    if (IRQ_testbit(&dst->raised, n_IRQ)) {\n\n        \/* Interrupt miss *\/\n\n        DPRINTF(\"%s: IRQ %d was missed on CPU %d\\n\",\n\n                __func__, n_IRQ, n_CPU);\n\n        return;\n\n    }\n\n    src->ivpr |= IVPR_ACTIVITY_MASK;\n\n    IRQ_setbit(&dst->raised, n_IRQ);\n\n    if (priority < dst->raised.priority) {\n\n        \/* An higher priority IRQ is already raised *\/\n\n        DPRINTF(\"%s: IRQ %d is hidden by raised IRQ %d on CPU %d\\n\",\n\n                __func__, n_IRQ, dst->raised.next, n_CPU);\n\n        return;\n\n    }\n\n    IRQ_check(opp, &dst->raised);\n\n    if (IRQ_get_next(opp, &dst->servicing) != -1 &&\n\n        priority <= dst->servicing.priority) {\n\n        DPRINTF(\"%s: IRQ %d is hidden by servicing IRQ %d on CPU %d\\n\",\n\n                __func__, n_IRQ, dst->servicing.next, n_CPU);\n\n        \/* Already servicing a higher priority IRQ *\/\n\n        return;\n\n    }\n\n    DPRINTF(\"Raise OpenPIC INT output cpu %d irq %d\\n\", n_CPU, n_IRQ);\n\n    qemu_irq_raise(opp->dst[n_CPU].irqs[OPENPIC_OUTPUT_INT]);\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void hpdmc_write(void *opaque, target_phys_addr_t addr, uint64_t value,\n\n                        unsigned size)\n\n{\n\n    MilkymistHpdmcState *s = opaque;\n\n\n\n    trace_milkymist_hpdmc_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_SYSTEM:\n\n    case R_BYPASS:\n\n    case R_TIMING:\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_IODELAY:\n\n        \/* ignore writes *\/\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_hpdmc: write access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"0188fadb7fe460d8c4c743372b1f7b25773e183e","target":1,"func":"static void setup_frame(int sig, struct target_sigaction * ka,\n\n                        target_sigset_t *set, CPUMIPSState *regs)\n\n{\n\n    struct sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    int i;\n\n\n\n    frame_addr = get_sigframe(ka, regs, sizeof(*frame));\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n\n\tgoto give_sigsegv;\n\n\n\n    install_sigtramp(frame->sf_code, TARGET_NR_sigreturn);\n\n\n\n    setup_sigcontext(regs, &frame->sf_sc);\n\n\n\n    for(i = 0; i < TARGET_NSIG_WORDS; i++) {\n\n\tif(__put_user(set->sig[i], &frame->sf_mask.sig[i]))\n\n\t    goto give_sigsegv;\n\n    }\n\n\n\n    \/*\n\n    * Arguments to signal handler:\n\n    *\n\n    *   a0 = signal number\n\n    *   a1 = 0 (should be cause)\n\n    *   a2 = pointer to struct sigcontext\n\n    *\n\n    * $25 and PC point to the signal handler, $29 points to the\n\n    * struct sigframe.\n\n    *\/\n\n    regs->active_tc.gpr[ 4] = sig;\n\n    regs->active_tc.gpr[ 5] = 0;\n\n    regs->active_tc.gpr[ 6] = frame_addr + offsetof(struct sigframe, sf_sc);\n\n    regs->active_tc.gpr[29] = frame_addr;\n\n    regs->active_tc.gpr[31] = frame_addr + offsetof(struct sigframe, sf_code);\n\n    \/* The original kernel code sets CP0_EPC to the handler\n\n    * since it returns to userland using eret\n\n    * we cannot do this here, and we must set PC directly *\/\n\n    regs->active_tc.PC = regs->active_tc.gpr[25] = ka->_sa_handler;\n\n    mips_set_hflags_isa_mode_from_pc(regs);\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    return;\n\n\n\ngive_sigsegv:\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    force_sig(TARGET_SIGSEGV\/*, current*\/);\n\n}\n"},{"project":"qemu","commit_id":"ab03b63d7a9c7978d51e56c191f0b86888d121dc","target":1,"func":"static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err)\n\n{\n\n    if (err == 0) {\n\n        v9fs_string_copy(&vs->fidp->path, &vs->fullname);\n\n        stat_to_qid(&vs->stbuf, &vs->qid);\n\n        vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid,\n\n                &vs->iounit);\n\n        err = vs->offset;\n\n    } else {\n\n        vs->fidp->fid_type = P9_FID_NONE;\n\n        close(vs->fidp->fs.fd);\n\n        err = -errno;\n\n    }\n\n\n\n    complete_pdu(s, vs->pdu, err);\n\n    v9fs_string_free(&vs->name);\n\n    v9fs_string_free(&vs->fullname);\n\n    qemu_free(vs);\n\n}\n"},{"project":"qemu","commit_id":"e3f5ec2b5e92706e3b807059f79b1fb5d936e567","target":0,"func":"static void stellaris_enet_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n    int n;\n\n    uint8_t *p;\n\n    uint32_t crc;\n\n\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n\n        return;\n\n    if (s->np >= 31) {\n\n        DPRINTF(\"Packet dropped\\n\");\n\n        return;\n\n    }\n\n\n\n    DPRINTF(\"Received packet len=%d\\n\", size);\n\n    n = s->next_packet + s->np;\n\n    if (n >= 31)\n\n        n -= 31;\n\n    s->np++;\n\n\n\n    s->rx[n].len = size + 6;\n\n    p = s->rx[n].data;\n\n    *(p++) = (size + 6);\n\n    *(p++) = (size + 6) >> 8;\n\n    memcpy (p, buf, size);\n\n    p += size;\n\n    crc = crc32(~0, buf, size);\n\n    *(p++) = crc;\n\n    *(p++) = crc >> 8;\n\n    *(p++) = crc >> 16;\n\n    *(p++) = crc >> 24;\n\n    \/* Clear the remaining bytes in the last word.  *\/\n\n    if ((size & 3) != 2) {\n\n        memset(p, 0, (6 - size) & 3);\n\n    }\n\n\n\n    s->ris |= SE_INT_RX;\n\n    stellaris_enet_update(s);\n\n}\n"},{"project":"qemu","commit_id":"19494f811a43c6bc226aa272d86300d9229224fe","target":0,"func":"qemu_irq get_cps_irq(MIPSCPSState *s, int pin_number)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(first_cpu);\n\n    CPUMIPSState *env = &cpu->env;\n\n\n\n    assert(pin_number < s->num_irq);\n\n\n\n    \/* TODO: return GIC pins once implemented *\/\n\n    return env->irq[pin_number];\n\n}\n"},{"project":"qemu","commit_id":"1a6d39fd71ddf90c5b76026cac4d5ff51fbaf8d8","target":0,"func":"static int is_allocated_sectors(const uint8_t *buf, int n, int *pnum)\n\n{\n\n    int v, i;\n\n\n\n    if (n <= 0) {\n\n        *pnum = 0;\n\n        return 0;\n\n    }\n\n    v = is_not_zero(buf, 512);\n\n    for(i = 1; i < n; i++) {\n\n        buf += 512;\n\n        if (v != is_not_zero(buf, 512))\n\n            break;\n\n    }\n\n    *pnum = i;\n\n    return v;\n\n}\n"},{"project":"qemu","commit_id":"0ac7cc2af500b948510f2481c22e84a57b0a2447","target":0,"func":"static Suite *qstring_suite(void)\n\n{\n\n    Suite *s;\n\n    TCase *qstring_public_tcase;\n\n\n\n    s = suite_create(\"QString test-suite\");\n\n\n\n    qstring_public_tcase = tcase_create(\"Public Interface\");\n\n    suite_add_tcase(s, qstring_public_tcase);\n\n    tcase_add_test(qstring_public_tcase, qstring_from_str_test);\n\n    tcase_add_test(qstring_public_tcase, qstring_destroy_test);\n\n    tcase_add_test(qstring_public_tcase, qstring_get_str_test);\n\n    tcase_add_test(qstring_public_tcase, qstring_append_chr_test);\n\n    tcase_add_test(qstring_public_tcase, qstring_from_substr_test);\n\n    tcase_add_test(qstring_public_tcase, qobject_to_qstring_test);\n\n\n\n    return s;\n\n}\n"},{"project":"qemu","commit_id":"5861a33898bbddfd1a80c2e202cb9352e3b1ba62","target":0,"func":"static void mpic_irq_raise(openpic_t *mpp, int n_CPU, IRQ_src_t *src)\n\n{\n\n    int n_ci = IDR_CI0 - n_CPU;\n\n\n\n    if(test_bit(&src->ide, n_ci)) {\n\n        qemu_irq_raise(mpp->dst[n_CPU].irqs[OPENPIC_OUTPUT_CINT]);\n\n    }\n\n    else {\n\n        qemu_irq_raise(mpp->dst[n_CPU].irqs[OPENPIC_OUTPUT_INT]);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"f090c9d4ad5812fb92843d6470a1111c15190c4c","target":0,"func":"OP(zerof64)\n\n{\n\n    set_opf64(PARAM1, 0);\n\n    FORCE_RET();\n\n}\n"},{"project":"qemu","commit_id":"d02f8adc6d2a178bcbf77d0413f9a96fdbed53f0","target":1,"func":"static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n\n{\n\n    AHCICmdHdr *cmd = ad->cur_cmd;\n\n    uint32_t opts = le32_to_cpu(cmd->opts);\n\n    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;\n\n    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;\n\n    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    int sum = 0;\n\n    int off_idx = -1;\n\n    int off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    if (!sglist_alloc_hint) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    \/* map PRDT *\/\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    \/* Get entries in the PRDT, init a qemu sglist accordingly *\/\n\n    if (sglist_alloc_hint > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < sglist_alloc_hint; i++) {\n\n            \/* flags_size is zero-based *\/\n\n            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);\n\n            if (offset <= (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %d\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),\n\n                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);\n\n\n\n        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {\n\n            \/* flags_size is zero-based *\/\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            le32_to_cpu(tbl[i].flags_size) + 1);\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n"},{"project":"qemu","commit_id":"e318a60b94b152c1e80125861a8917ae177d845e","target":1,"func":"static int disas_neon_ls_insn(CPUState * env, DisasContext *s, uint32_t insn)\n\n{\n\n    int rd, rn, rm;\n\n    int op;\n\n    int nregs;\n\n    int interleave;\n\n    int spacing;\n\n    int stride;\n\n    int size;\n\n    int reg;\n\n    int pass;\n\n    int load;\n\n    int shift;\n\n    int n;\n\n    TCGv addr;\n\n    TCGv tmp;\n\n    TCGv tmp2;\n\n    TCGv_i64 tmp64;\n\n\n\n    if (!s->vfp_enabled)\n\n      return 1;\n\n    VFP_DREG_D(rd, insn);\n\n    rn = (insn >> 16) & 0xf;\n\n    rm = insn & 0xf;\n\n    load = (insn & (1 << 21)) != 0;\n\n    addr = tcg_temp_new_i32();\n\n    if ((insn & (1 << 23)) == 0) {\n\n        \/* Load store all elements.  *\/\n\n        op = (insn >> 8) & 0xf;\n\n        size = (insn >> 6) & 3;\n\n        if (op > 10)\n\n            return 1;\n\n        nregs = neon_ls_element_type[op].nregs;\n\n        interleave = neon_ls_element_type[op].interleave;\n\n        spacing = neon_ls_element_type[op].spacing;\n\n        if (size == 3 && (interleave | spacing) != 1)\n\n            return 1;\n\n        load_reg_var(s, addr, rn);\n\n        stride = (1 << size) * interleave;\n\n        for (reg = 0; reg < nregs; reg++) {\n\n            if (interleave > 2 || (interleave == 2 && nregs == 2)) {\n\n                load_reg_var(s, addr, rn);\n\n                tcg_gen_addi_i32(addr, addr, (1 << size) * reg);\n\n            } else if (interleave == 2 && nregs == 4 && reg == 2) {\n\n                load_reg_var(s, addr, rn);\n\n                tcg_gen_addi_i32(addr, addr, 1 << size);\n\n            }\n\n            if (size == 3) {\n\n                if (load) {\n\n                    tmp64 = gen_ld64(addr, IS_USER(s));\n\n                    neon_store_reg64(tmp64, rd);\n\n                    tcg_temp_free_i64(tmp64);\n\n                } else {\n\n                    tmp64 = tcg_temp_new_i64();\n\n                    neon_load_reg64(tmp64, rd);\n\n                    gen_st64(tmp64, addr, IS_USER(s));\n\n                }\n\n                tcg_gen_addi_i32(addr, addr, stride);\n\n            } else {\n\n                for (pass = 0; pass < 2; pass++) {\n\n                    if (size == 2) {\n\n                        if (load) {\n\n                            tmp = gen_ld32(addr, IS_USER(s));\n\n                            neon_store_reg(rd, pass, tmp);\n\n                        } else {\n\n                            tmp = neon_load_reg(rd, pass);\n\n                            gen_st32(tmp, addr, IS_USER(s));\n\n                        }\n\n                        tcg_gen_addi_i32(addr, addr, stride);\n\n                    } else if (size == 1) {\n\n                        if (load) {\n\n                            tmp = gen_ld16u(addr, IS_USER(s));\n\n                            tcg_gen_addi_i32(addr, addr, stride);\n\n                            tmp2 = gen_ld16u(addr, IS_USER(s));\n\n                            tcg_gen_addi_i32(addr, addr, stride);\n\n                            tcg_gen_shli_i32(tmp2, tmp2, 16);\n\n                            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n                            tcg_temp_free_i32(tmp2);\n\n                            neon_store_reg(rd, pass, tmp);\n\n                        } else {\n\n                            tmp = neon_load_reg(rd, pass);\n\n                            tmp2 = tcg_temp_new_i32();\n\n                            tcg_gen_shri_i32(tmp2, tmp, 16);\n\n                            gen_st16(tmp, addr, IS_USER(s));\n\n                            tcg_gen_addi_i32(addr, addr, stride);\n\n                            gen_st16(tmp2, addr, IS_USER(s));\n\n                            tcg_gen_addi_i32(addr, addr, stride);\n\n                        }\n\n                    } else \/* size == 0 *\/ {\n\n                        if (load) {\n\n                            TCGV_UNUSED(tmp2);\n\n                            for (n = 0; n < 4; n++) {\n\n                                tmp = gen_ld8u(addr, IS_USER(s));\n\n                                tcg_gen_addi_i32(addr, addr, stride);\n\n                                if (n == 0) {\n\n                                    tmp2 = tmp;\n\n                                } else {\n\n                                    tcg_gen_shli_i32(tmp, tmp, n * 8);\n\n                                    tcg_gen_or_i32(tmp2, tmp2, tmp);\n\n                                    tcg_temp_free_i32(tmp);\n\n                                }\n\n                            }\n\n                            neon_store_reg(rd, pass, tmp2);\n\n                        } else {\n\n                            tmp2 = neon_load_reg(rd, pass);\n\n                            for (n = 0; n < 4; n++) {\n\n                                tmp = tcg_temp_new_i32();\n\n                                if (n == 0) {\n\n                                    tcg_gen_mov_i32(tmp, tmp2);\n\n                                } else {\n\n                                    tcg_gen_shri_i32(tmp, tmp2, n * 8);\n\n                                }\n\n                                gen_st8(tmp, addr, IS_USER(s));\n\n                                tcg_gen_addi_i32(addr, addr, stride);\n\n                            }\n\n                            tcg_temp_free_i32(tmp2);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            rd += spacing;\n\n        }\n\n        stride = nregs * 8;\n\n    } else {\n\n        size = (insn >> 10) & 3;\n\n        if (size == 3) {\n\n            \/* Load single element to all lanes.  *\/\n\n            int a = (insn >> 4) & 1;\n\n            if (!load) {\n\n                return 1;\n\n            }\n\n            size = (insn >> 6) & 3;\n\n            nregs = ((insn >> 8) & 3) + 1;\n\n\n\n            if (size == 3) {\n\n                if (nregs != 4 || a == 0) {\n\n                    return 1;\n\n                }\n\n                \/* For VLD4 size==3 a == 1 means 32 bits at 16 byte alignment *\/\n\n                size = 2;\n\n            }\n\n            if (nregs == 1 && a == 1 && size == 0) {\n\n                return 1;\n\n            }\n\n            if (nregs == 3 && a == 1) {\n\n                return 1;\n\n            }\n\n            load_reg_var(s, addr, rn);\n\n            if (nregs == 1) {\n\n                \/* VLD1 to all lanes: bit 5 indicates how many Dregs to write *\/\n\n                tmp = gen_load_and_replicate(s, addr, size);\n\n                tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd, 0));\n\n                tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd, 1));\n\n                if (insn & (1 << 5)) {\n\n                    tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd + 1, 0));\n\n                    tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd + 1, 1));\n\n                }\n\n                tcg_temp_free_i32(tmp);\n\n            } else {\n\n                \/* VLD2\/3\/4 to all lanes: bit 5 indicates register stride *\/\n\n                stride = (insn & (1 << 5)) ? 2 : 1;\n\n                for (reg = 0; reg < nregs; reg++) {\n\n                    tmp = gen_load_and_replicate(s, addr, size);\n\n                    tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd, 0));\n\n                    tcg_gen_st_i32(tmp, cpu_env, neon_reg_offset(rd, 1));\n\n                    tcg_temp_free_i32(tmp);\n\n                    tcg_gen_addi_i32(addr, addr, 1 << size);\n\n                    rd += stride;\n\n                }\n\n            }\n\n            stride = (1 << size) * nregs;\n\n        } else {\n\n            \/* Single element.  *\/\n\n            pass = (insn >> 7) & 1;\n\n            switch (size) {\n\n            case 0:\n\n                shift = ((insn >> 5) & 3) * 8;\n\n                stride = 1;\n\n                break;\n\n            case 1:\n\n                shift = ((insn >> 6) & 1) * 16;\n\n                stride = (insn & (1 << 5)) ? 2 : 1;\n\n                break;\n\n            case 2:\n\n                shift = 0;\n\n                stride = (insn & (1 << 6)) ? 2 : 1;\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n            nregs = ((insn >> 8) & 3) + 1;\n\n            load_reg_var(s, addr, rn);\n\n            for (reg = 0; reg < nregs; reg++) {\n\n                if (load) {\n\n                    switch (size) {\n\n                    case 0:\n\n                        tmp = gen_ld8u(addr, IS_USER(s));\n\n                        break;\n\n                    case 1:\n\n                        tmp = gen_ld16u(addr, IS_USER(s));\n\n                        break;\n\n                    case 2:\n\n                        tmp = gen_ld32(addr, IS_USER(s));\n\n                        break;\n\n                    default: \/* Avoid compiler warnings.  *\/\n\n                        abort();\n\n                    }\n\n                    if (size != 2) {\n\n                        tmp2 = neon_load_reg(rd, pass);\n\n                        gen_bfi(tmp, tmp2, tmp, shift, size ? 0xffff : 0xff);\n\n                        tcg_temp_free_i32(tmp2);\n\n                    }\n\n                    neon_store_reg(rd, pass, tmp);\n\n                } else { \/* Store *\/\n\n                    tmp = neon_load_reg(rd, pass);\n\n                    if (shift)\n\n                        tcg_gen_shri_i32(tmp, tmp, shift);\n\n                    switch (size) {\n\n                    case 0:\n\n                        gen_st8(tmp, addr, IS_USER(s));\n\n                        break;\n\n                    case 1:\n\n                        gen_st16(tmp, addr, IS_USER(s));\n\n                        break;\n\n                    case 2:\n\n                        gen_st32(tmp, addr, IS_USER(s));\n\n                        break;\n\n                    }\n\n                }\n\n                rd += stride;\n\n                tcg_gen_addi_i32(addr, addr, 1 << size);\n\n            }\n\n            stride = nregs * (1 << size);\n\n        }\n\n    }\n\n    tcg_temp_free_i32(addr);\n\n    if (rm != 15) {\n\n        TCGv base;\n\n\n\n        base = load_reg(s, rn);\n\n        if (rm == 13) {\n\n            tcg_gen_addi_i32(base, base, stride);\n\n        } else {\n\n            TCGv index;\n\n            index = load_reg(s, rm);\n\n            tcg_gen_add_i32(base, base, index);\n\n            tcg_temp_free_i32(index);\n\n        }\n\n        store_reg(s, rn, base);\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"3d002df33eb034757d98e1ae529318f57df78f91","target":0,"func":"static size_t buffered_set_rate_limit(void *opaque, size_t new_rate)\n\n{\n\n    QEMUFileBuffered *s = opaque;\n\n\n\n    if (s->has_error)\n\n        goto out;\n\n\n\n    s->xfer_limit = new_rate \/ 10;\n\n    \n\nout:\n\n    return s->xfer_limit;\n\n}\n"},{"project":"qemu","commit_id":"e9db8ff38e539260a2cb5a7918d1155b7d92a264","target":1,"func":"static struct glfs *qemu_gluster_glfs_init(BlockdevOptionsGluster *gconf,\n\n                                           Error **errp)\n\n{\n\n    struct glfs *glfs;\n\n    int ret;\n\n    int old_errno;\n\n    GlusterServerList *server;\n\n\n\n    glfs = glfs_new(gconf->volume);\n\n    if (!glfs) {\n\n        goto out;\n\n    }\n\n\n\n    for (server = gconf->server; server; server = server->next) {\n\n        if (server->value->type  == GLUSTER_TRANSPORT_UNIX) {\n\n            ret = glfs_set_volfile_server(glfs,\n\n                                   GlusterTransport_lookup[server->value->type],\n\n                                   server->value->u.q_unix.path, 0);\n\n        } else {\n\n            ret = glfs_set_volfile_server(glfs,\n\n                                   GlusterTransport_lookup[server->value->type],\n\n                                   server->value->u.tcp.host,\n\n                                   atoi(server->value->u.tcp.port));\n\n        }\n\n\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    ret = glfs_set_logging(glfs, \"-\", gconf->debug_level);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    ret = glfs_init(glfs);\n\n    if (ret) {\n\n        error_setg(errp, \"Gluster connection for volume %s, path %s failed\"\n\n                         \" to connect\", gconf->volume, gconf->path);\n\n        for (server = gconf->server; server; server = server->next) {\n\n            if (server->value->type  == GLUSTER_TRANSPORT_UNIX) {\n\n                error_append_hint(errp, \"hint: failed on socket %s \",\n\n                                  server->value->u.q_unix.path);\n\n            } else {\n\n                error_append_hint(errp, \"hint: failed on host %s and port %s \",\n\n                                  server->value->u.tcp.host,\n\n                                  server->value->u.tcp.port);\n\n            }\n\n        }\n\n\n\n        error_append_hint(errp, \"Please refer to gluster logs for more info\\n\");\n\n\n\n        \/* glfs_init sometimes doesn't set errno although docs suggest that *\/\n\n        if (errno == 0) {\n\n            errno = EINVAL;\n\n        }\n\n\n\n        goto out;\n\n    }\n\n    return glfs;\n\n\n\nout:\n\n    if (glfs) {\n\n        old_errno = errno;\n\n        glfs_fini(glfs);\n\n        errno = old_errno;\n\n    }\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"5cb9b56acfc0b50acf7ccd2d044ab4991c47fdde","target":1,"func":"static int print_int32(DeviceState *dev, Property *prop, char *dest, size_t len)\n\n{\n\n    int32_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    return snprintf(dest, len, \"%\" PRId32, *ptr);\n\n}\n"},{"project":"qemu","commit_id":"bc7c08a2c375acb7ae4d433054415588b176d34c","target":0,"func":"static void test_qemu_strtoull_negative(void)\n\n{\n\n    const char *str = \"  \\t -321\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, -321);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n"},{"project":"qemu","commit_id":"62112d181ca33fea976100c4335dfc3e2f727e6c","target":0,"func":"int net_init_tap(QemuOpts *opts, Monitor *mon, const char *name, VLANState *vlan)\n\n{\n\n    TAPState *s;\n\n    int fd, vnet_hdr = 0;\n\n\n\n    if (qemu_opt_get(opts, \"fd\")) {\n\n        if (qemu_opt_get(opts, \"ifname\") ||\n\n            qemu_opt_get(opts, \"script\") ||\n\n            qemu_opt_get(opts, \"downscript\") ||\n\n            qemu_opt_get(opts, \"vnet_hdr\")) {\n\n            qemu_error(\"ifname=, script=, downscript= and vnet_hdr= is invalid with fd=\\n\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_handle_fd_param(mon, qemu_opt_get(opts, \"fd\"));\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n    } else {\n\n        if (!qemu_opt_get(opts, \"script\")) {\n\n            qemu_opt_set(opts, \"script\", DEFAULT_NETWORK_SCRIPT);\n\n        }\n\n\n\n        if (!qemu_opt_get(opts, \"downscript\")) {\n\n            qemu_opt_set(opts, \"downscript\", DEFAULT_NETWORK_DOWN_SCRIPT);\n\n        }\n\n\n\n        fd = net_tap_init(opts, &vnet_hdr);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    s = net_tap_fd_init(vlan, \"tap\", name, fd, vnet_hdr);\n\n    if (!s) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    if (tap_set_sndbuf(s->fd, opts) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"fd\")) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);\n\n    } else {\n\n        const char *ifname, *script, *downscript;\n\n\n\n        ifname     = qemu_opt_get(opts, \"ifname\");\n\n        script     = qemu_opt_get(opts, \"script\");\n\n        downscript = qemu_opt_get(opts, \"downscript\");\n\n\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n                 \"ifname=%s,script=%s,downscript=%s\",\n\n                 ifname, script, downscript);\n\n\n\n        if (strcmp(downscript, \"no\") != 0) {\n\n            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);\n\n            snprintf(s->down_script_arg, sizeof(s->down_script_arg), \"%s\", ifname);\n\n        }\n\n    }\n\n\n\n    if (vlan) {\n\n        vlan->nb_host_devs++;\n\n    }\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"a89f364ae8740dfc31b321eed9ee454e996dc3c1","target":0,"func":"static void pxa2xx_gpio_set(void *opaque, int line, int level)\n\n{\n\n    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;\n\n    CPUState *cpu = CPU(s->cpu);\n\n    int bank;\n\n    uint32_t mask;\n\n\n\n    if (line >= s->lines) {\n\n        printf(\"%s: No GPIO pin %i\\n\", __FUNCTION__, line);\n\n        return;\n\n    }\n\n\n\n    bank = line >> 5;\n\n    mask = 1U << (line & 31);\n\n\n\n    if (level) {\n\n        s->status[bank] |= s->rising[bank] & mask &\n\n                ~s->ilevel[bank] & ~s->dir[bank];\n\n        s->ilevel[bank] |= mask;\n\n    } else {\n\n        s->status[bank] |= s->falling[bank] & mask &\n\n                s->ilevel[bank] & ~s->dir[bank];\n\n        s->ilevel[bank] &= ~mask;\n\n    }\n\n\n\n    if (s->status[bank] & mask)\n\n        pxa2xx_gpio_irq_update(s);\n\n\n\n    \/* Wake-up GPIOs *\/\n\n    if (cpu->halted && (mask & ~s->dir[bank] & pxa2xx_gpio_wake[bank])) {\n\n        cpu_interrupt(cpu, CPU_INTERRUPT_EXITTB);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a7e47d4bfcbf256fae06891a8599950ff8e1b61b","target":1,"func":"static int connect_to_sdog(const char *addr, const char *port)\n\n{\n\n    char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];\n\n    int fd, ret;\n\n    struct addrinfo hints, *res, *res0;\n\n\n\n    if (!addr) {\n\n        addr = SD_DEFAULT_ADDR;\n\n        port = SD_DEFAULT_PORT;\n\n    }\n\n\n\n    memset(&hints, 0, sizeof(hints));\n\n    hints.ai_socktype = SOCK_STREAM;\n\n\n\n    ret = getaddrinfo(addr, port, &hints, &res0);\n\n    if (ret) {\n\n        error_report(\"unable to get address info %s, %s\",\n\n                     addr, strerror(errno));\n\n        return -errno;\n\n    }\n\n\n\n    for (res = res0; res; res = res->ai_next) {\n\n        ret = getnameinfo(res->ai_addr, res->ai_addrlen, hbuf, sizeof(hbuf),\n\n                          sbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV);\n\n        if (ret) {\n\n            continue;\n\n        }\n\n\n\n        fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n        if (fd < 0) {\n\n            continue;\n\n        }\n\n\n\n    reconnect:\n\n        ret = connect(fd, res->ai_addr, res->ai_addrlen);\n\n        if (ret < 0) {\n\n            if (errno == EINTR) {\n\n                goto reconnect;\n\n            }\n\n\n            break;\n\n        }\n\n\n\n        dprintf(\"connected to %s:%s\\n\", addr, port);\n\n        goto success;\n\n    }\n\n    fd = -errno;\n\n    error_report(\"failed connect to %s:%s\", addr, port);\n\nsuccess:\n\n    freeaddrinfo(res0);\n\n    return fd;\n\n}"},{"project":"qemu","commit_id":"34d49937e480edfa173d71e8c17972ad866b56c6","target":1,"func":"static void *atomic_mmu_lookup(CPUArchState *env, target_ulong addr,\n\n                               TCGMemOpIdx oi, uintptr_t retaddr)\n\n{\n\n    size_t mmu_idx = get_mmuidx(oi);\n\n    size_t index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    CPUTLBEntry *tlbe = &env->tlb_table[mmu_idx][index];\n\n    target_ulong tlb_addr = tlbe->addr_write;\n\n    TCGMemOp mop = get_memop(oi);\n\n    int a_bits = get_alignment_bits(mop);\n\n    int s_bits = mop & MO_SIZE;\n\n\n\n    \/* Adjust the given return address.  *\/\n\n    retaddr -= GETPC_ADJ;\n\n\n\n    \/* Enforce guest required alignment.  *\/\n\n    if (unlikely(a_bits > 0 && (addr & ((1 << a_bits) - 1)))) {\n\n        \/* ??? Maybe indicate atomic op to cpu_unaligned_access *\/\n\n        cpu_unaligned_access(ENV_GET_CPU(env), addr, MMU_DATA_STORE,\n\n                             mmu_idx, retaddr);\n\n    }\n\n\n\n    \/* Enforce qemu required alignment.  *\/\n\n    if (unlikely(addr & ((1 << s_bits) - 1))) {\n\n        \/* We get here if guest alignment was not requested,\n\n           or was not enforced by cpu_unaligned_access above.\n\n           We might widen the access and emulate, but for now\n\n           mark an exception and exit the cpu loop.  *\/\n\n        goto stop_the_world;\n\n    }\n\n\n\n    \/* Check TLB entry and enforce page permissions.  *\/\n\n    if ((addr & TARGET_PAGE_MASK)\n\n        != (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {\n\n        if (!VICTIM_TLB_HIT(addr_write, addr)) {\n\n            tlb_fill(ENV_GET_CPU(env), addr, MMU_DATA_STORE, mmu_idx, retaddr);\n\n        }\n\n        tlb_addr = tlbe->addr_write & ~TLB_INVALID_MASK;\n\n    }\n\n\n\n    \/* Check notdirty *\/\n\n    if (unlikely(tlb_addr & TLB_NOTDIRTY)) {\n\n        tlb_set_dirty(ENV_GET_CPU(env), addr);\n\n        tlb_addr = tlb_addr & ~TLB_NOTDIRTY;\n\n    }\n\n\n\n    \/* Notice an IO access  *\/\n\n    if (unlikely(tlb_addr & ~TARGET_PAGE_MASK)) {\n\n        \/* There's really nothing that can be done to\n\n           support this apart from stop-the-world.  *\/\n\n        goto stop_the_world;\n\n    }\n\n\n\n    \/* Let the guest notice RMW on a write-only page.  *\/\n\n    if (unlikely(tlbe->addr_read != tlb_addr)) {\n\n        tlb_fill(ENV_GET_CPU(env), addr, MMU_DATA_LOAD, mmu_idx, retaddr);\n\n        \/* Since we don't support reads and writes to different addresses,\n\n           and we do have the proper page loaded for write, this shouldn't\n\n           ever return.  But just in case, handle via stop-the-world.  *\/\n\n        goto stop_the_world;\n\n    }\n\n\n\n    return (void *)((uintptr_t)addr + tlbe->addend);\n\n\n\n stop_the_world:\n\n    cpu_loop_exit_atomic(ENV_GET_CPU(env), retaddr);\n\n}\n"},{"project":"qemu","commit_id":"2b147555f78c3c20080b201fd1506467fa0ddf43","target":0,"func":"static int kvm_s390_check_enable_cmma(KVMState *s)\n\n{\n\n    struct kvm_device_attr attr = {\n\n        .group = KVM_S390_VM_MEM_CTRL,\n\n        .attr = KVM_S390_VM_MEM_ENABLE_CMMA,\n\n    };\n\n\n\n    return kvm_vm_ioctl(s, KVM_HAS_DEVICE_ATTR, &attr);\n\n}\n"},{"project":"qemu","commit_id":"4f4321c11ff6e98583846bfd6f0e81954924b003","target":1,"func":"static int usb_bt_handle_control(USBDevice *dev, USBPacket *p,\n\n               int request, int value, int index, int length, uint8_t *data)\n\n{\n\n    struct USBBtState *s = (struct USBBtState *) dev->opaque;\n\n    int ret;\n\n\n\n    ret = usb_desc_handle_control(dev, p, request, value, index, length, data);\n\n    if (ret >= 0) {\n\n        switch (request) {\n\n        case DeviceRequest | USB_REQ_GET_CONFIGURATION:\n\n            s->config = 0;\n\n            break;\n\n        case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n\n            s->config = 1;\n\n            usb_bt_fifo_reset(&s->evt);\n\n            usb_bt_fifo_reset(&s->acl);\n\n            usb_bt_fifo_reset(&s->sco);\n\n            break;\n\n        }\n\n        return ret;\n\n    }\n\n\n\n    ret = 0;\n\n    switch (request) {\n\n    case InterfaceRequest | USB_REQ_GET_STATUS:\n\n    case EndpointRequest | USB_REQ_GET_STATUS:\n\n        data[0] = 0x00;\n\n        data[1] = 0x00;\n\n        ret = 2;\n\n        break;\n\n    case InterfaceOutRequest | USB_REQ_CLEAR_FEATURE:\n\n    case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:\n\n        goto fail;\n\n    case InterfaceOutRequest | USB_REQ_SET_FEATURE:\n\n    case EndpointOutRequest | USB_REQ_SET_FEATURE:\n\n        goto fail;\n\n        break;\n\n    case InterfaceRequest | USB_REQ_GET_INTERFACE:\n\n        if (value != 0 || (index & ~1) || length != 1)\n\n            goto fail;\n\n        if (index == 1)\n\n            data[0] = s->altsetting;\n\n        else\n\n            data[0] = 0;\n\n        ret = 1;\n\n        break;\n\n    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:\n\n        if ((index & ~1) || length != 0 ||\n\n                        (index == 1 && (value < 0 || value > 4)) ||\n\n                        (index == 0 && value != 0)) {\n\n            printf(\"%s: Wrong SET_INTERFACE request (%i, %i)\\n\",\n\n                            __FUNCTION__, index, value);\n\n            goto fail;\n\n        }\n\n        s->altsetting = value;\n\n        ret = 0;\n\n        break;\n\n    case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_DEVICE) << 8):\n\n        if (s->config)\n\n            usb_bt_fifo_out_enqueue(s, &s->outcmd, s->hci->cmd_send,\n\n                            usb_bt_hci_cmd_complete, data, length);\n\n        break;\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"a7812ae412311d7d47f8aa85656faadac9d64b56","target":0,"func":"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n"},{"project":"qemu","commit_id":"a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf","target":1,"func":"static void qobject_input_optional(Visitor *v, const char *name, bool *present)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, false, NULL);\n\n\n\n    if (!qobj) {\n\n        *present = false;\n\n        return;\n\n    }\n\n\n\n    *present = true;\n\n}\n"},{"project":"qemu","commit_id":"bdb5ee3064d5ae786b0bcb6cf6ff4e3554a72990","target":0,"func":"void do_info_roms(Monitor *mon)\n\n{\n\n    Rom *rom;\n\n\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n\n        if (!rom->fw_file) {\n\n            monitor_printf(mon, \"addr=\" TARGET_FMT_plx\n\n                           \" size=0x%06zx mem=%s name=\\\"%s\\\" \\n\",\n\n                           rom->addr, rom->romsize,\n\n                           rom->isrom ? \"rom\" : \"ram\",\n\n                           rom->name);\n\n        } else {\n\n            monitor_printf(mon, \"fw=%s%s%s\"\n\n                           \" size=0x%06zx name=\\\"%s\\\" \\n\",\n\n                           rom->fw_dir ? rom->fw_dir : \"\",\n\n                           rom->fw_dir ? \"\/\" : \"\",\n\n                           rom->fw_file,\n\n                           rom->romsize,\n\n                           rom->name);\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"b0d768c35e08d2057b63e8e77e7a513c447199fa","target":1,"func":"static gboolean pty_chr_timer(gpointer opaque)\n\n{\n\n    struct CharDriverState *chr = opaque;\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (s->connected) {\n\n        goto out;\n\n    }\n\n\n\n    \/* Next poll ... *\/\n\n    pty_chr_update_read_handler(chr);\n\n\n\nout:\n\n    s->timer_tag = 0;\n\n    return FALSE;\n\n}\n"},{"project":"qemu","commit_id":"2572b37a4751cc967582d7d04f21d9bf97187ae5","target":0,"func":"static BlockDriverAIOCB *bdrv_aio_rw_vector(BlockDriverState *bs,\n\n                                            int64_t sector_num,\n\n                                            QEMUIOVector *qiov,\n\n                                            int nb_sectors,\n\n                                            BlockDriverCompletionFunc *cb,\n\n                                            void *opaque,\n\n                                            int is_write)\n\n\n\n{\n\n    BlockDriverAIOCBSync *acb;\n\n\n\n    acb = qemu_aio_get(&bdrv_em_aiocb_info, bs, cb, opaque);\n\n    acb->is_write = is_write;\n\n    acb->qiov = qiov;\n\n    acb->bounce = qemu_blockalign(bs, qiov->size);\n\n    acb->bh = qemu_bh_new(bdrv_aio_bh_cb, acb);\n\n\n\n    if (is_write) {\n\n        qemu_iovec_to_buf(acb->qiov, 0, acb->bounce, qiov->size);\n\n        acb->ret = bs->drv->bdrv_write(bs, sector_num, acb->bounce, nb_sectors);\n\n    } else {\n\n        acb->ret = bs->drv->bdrv_read(bs, sector_num, acb->bounce, nb_sectors);\n\n    }\n\n\n\n    qemu_bh_schedule(acb->bh);\n\n\n\n    return &acb->common;\n\n}\n"},{"project":"qemu","commit_id":"5c8f44b7dbdec77eff2ed3e239ea31d649894932","target":1,"func":"static void dec_barrel(DisasContext *dc)\n\n{\n\n    TCGv t0;\n\n    bool s, t;\n\n\n\n    if ((dc->tb_flags & MSR_EE_FLAG)\n\n          && (dc->cpu->env.pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)\n\n          && !dc->cpu->cfg.use_barrel) {\n\n        tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);\n\n        t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n        return;\n\n    }\n\n\n\n    s = extract32(dc->imm, 10, 1);\n\n    t = extract32(dc->imm, 9, 1);\n\n\n\n    LOG_DIS(\"bs%s%s r%d r%d r%d\\n\",\n\n            s ? \"l\" : \"r\", t ? \"a\" : \"l\", dc->rd, dc->ra, dc->rb);\n\n\n\n    t0 = tcg_temp_new();\n\n\n\n    tcg_gen_mov_tl(t0, *(dec_alu_op_b(dc)));\n\n    tcg_gen_andi_tl(t0, t0, 31);\n\n\n\n    if (s) {\n\n        tcg_gen_shl_tl(cpu_R[dc->rd], cpu_R[dc->ra], t0);\n\n    } else {\n\n        if (t) {\n\n            tcg_gen_sar_tl(cpu_R[dc->rd], cpu_R[dc->ra], t0);\n\n        } else {\n\n            tcg_gen_shr_tl(cpu_R[dc->rd], cpu_R[dc->ra], t0);\n\n        }\n\n    }\n\n\n}"},{"project":"qemu","commit_id":"0ae18ceeaaa2c1749e742c4b112f6c3bf0896408","target":0,"func":"static void versatile_init(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model,\n\n                     int board_id)\n\n{\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    qemu_irq *sic;\n\n    void *scsi_hba;\n\n    PCIBus *pci_bus;\n\n    NICInfo *nd;\n\n    int n;\n\n    int done_smc = 0;\n\n    int index;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    \/* ??? RAM should repeat to fill physical memory space.  *\/\n\n    \/* SDRAM at address zero.  *\/\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    arm_sysctl_init(0x10000000, 0x41007004);\n\n    pic = arm_pic_init_cpu(env);\n\n    pic = pl190_init(0x10140000, pic[0], pic[1]);\n\n    sic = vpb_sic_init(0x10003000, pic, 31);\n\n    pl050_init(0x10006000, sic[3], 0);\n\n    pl050_init(0x10007000, sic[4], 1);\n\n\n\n    pci_bus = pci_vpb_init(sic, 27, 0);\n\n    \/* The Versatile PCI bridge does not provide access to PCI IO space,\n\n       so many of the qemu PCI devices are not useable.  *\/\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n        if (!nd->model)\n\n            nd->model = done_smc ? \"rtl8139\" : \"smc91c111\";\n\n        if (strcmp(nd->model, \"smc91c111\") == 0) {\n\n            smc91c111_init(nd, 0x10010000, sic[25]);\n\n        } else {\n\n            pci_nic_init(pci_bus, nd, -1);\n\n        }\n\n    }\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, 3, -1);\n\n    }\n\n    if (drive_get_max_bus(IF_SCSI) > 0) {\n\n        fprintf(stderr, \"qemu: too many SCSI bus\\n\");\n\n        exit(1);\n\n    }\n\n    scsi_hba = lsi_scsi_init(pci_bus, -1);\n\n    for (n = 0; n < LSI_MAX_DEVS; n++) {\n\n        index = drive_get_index(IF_SCSI, 0, n);\n\n        if (index == -1)\n\n            continue;\n\n        lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n);\n\n    }\n\n\n\n    pl011_init(0x101f1000, pic[12], serial_hds[0], PL011_ARM);\n\n    pl011_init(0x101f2000, pic[13], serial_hds[1], PL011_ARM);\n\n    pl011_init(0x101f3000, pic[14], serial_hds[2], PL011_ARM);\n\n    pl011_init(0x10009000, sic[6], serial_hds[3], PL011_ARM);\n\n\n\n    pl080_init(0x10130000, pic[17], 8);\n\n    sp804_init(0x101e2000, pic[4]);\n\n    sp804_init(0x101e3000, pic[5]);\n\n\n\n    \/* The versatile\/PB actually has a modified Color LCD controller\n\n       that includes hardware cursor support from the PL111.  *\/\n\n    pl110_init(ds, 0x10120000, pic[16], 1);\n\n\n\n    index = drive_get_index(IF_SD, 0, 0);\n\n    if (index == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    pl181_init(0x10005000, drives_table[index].bdrv, sic[22], sic[1]);\n\n#if 0\n\n    \/* Disabled because there's no way of specifying a block device.  *\/\n\n    pl181_init(0x1000b000, NULL, sic, 23, 2);\n\n#endif\n\n\n\n    \/* Add PL031 Real Time Clock. *\/\n\n    pl031_init(0x101e8000,pic[10]);\n\n\n\n    \/* Memory map for Versatile\/PB:  *\/\n\n    \/* 0x10000000 System registers.  *\/\n\n    \/* 0x10001000 PCI controller config registers.  *\/\n\n    \/* 0x10002000 Serial bus interface.  *\/\n\n    \/*  0x10003000 Secondary interrupt controller.  *\/\n\n    \/* 0x10004000 AACI (audio).  *\/\n\n    \/*  0x10005000 MMCI0.  *\/\n\n    \/*  0x10006000 KMI0 (keyboard).  *\/\n\n    \/*  0x10007000 KMI1 (mouse).  *\/\n\n    \/* 0x10008000 Character LCD Interface.  *\/\n\n    \/*  0x10009000 UART3.  *\/\n\n    \/* 0x1000a000 Smart card 1.  *\/\n\n    \/*  0x1000b000 MMCI1.  *\/\n\n    \/*  0x10010000 Ethernet.  *\/\n\n    \/* 0x10020000 USB.  *\/\n\n    \/* 0x10100000 SSMC.  *\/\n\n    \/* 0x10110000 MPMC.  *\/\n\n    \/*  0x10120000 CLCD Controller.  *\/\n\n    \/*  0x10130000 DMA Controller.  *\/\n\n    \/*  0x10140000 Vectored interrupt controller.  *\/\n\n    \/* 0x101d0000 AHB Monitor Interface.  *\/\n\n    \/* 0x101e0000 System Controller.  *\/\n\n    \/* 0x101e1000 Watchdog Interface.  *\/\n\n    \/* 0x101e2000 Timer 0\/1.  *\/\n\n    \/* 0x101e3000 Timer 2\/3.  *\/\n\n    \/* 0x101e4000 GPIO port 0.  *\/\n\n    \/* 0x101e5000 GPIO port 1.  *\/\n\n    \/* 0x101e6000 GPIO port 2.  *\/\n\n    \/* 0x101e7000 GPIO port 3.  *\/\n\n    \/* 0x101e8000 RTC.  *\/\n\n    \/* 0x101f0000 Smart card 0.  *\/\n\n    \/*  0x101f1000 UART0.  *\/\n\n    \/*  0x101f2000 UART1.  *\/\n\n    \/*  0x101f3000 UART2.  *\/\n\n    \/* 0x101f4000 SSPI.  *\/\n\n\n\n    versatile_binfo.ram_size = ram_size;\n\n    versatile_binfo.kernel_filename = kernel_filename;\n\n    versatile_binfo.kernel_cmdline = kernel_cmdline;\n\n    versatile_binfo.initrd_filename = initrd_filename;\n\n    versatile_binfo.board_id = board_id;\n\n    arm_load_kernel(env, &versatile_binfo);\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static void virtio_blk_set_status(VirtIODevice *vdev, uint8_t status)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    uint32_t features;\n\n\n\n    if (s->dataplane && !(status & (VIRTIO_CONFIG_S_DRIVER |\n\n                                    VIRTIO_CONFIG_S_DRIVER_OK))) {\n\n        virtio_blk_data_plane_stop(s->dataplane);\n\n    }\n\n\n\n    if (!(status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\n        return;\n\n    }\n\n\n\n    features = vdev->guest_features;\n\n\n\n    \/* A guest that supports VIRTIO_BLK_F_CONFIG_WCE must be able to send\n\n     * cache flushes.  Thus, the \"auto writethrough\" behavior is never\n\n     * necessary for guests that support the VIRTIO_BLK_F_CONFIG_WCE feature.\n\n     * Leaving it enabled would break the following sequence:\n\n     *\n\n     *     Guest started with \"-drive cache=writethrough\"\n\n     *     Guest sets status to 0\n\n     *     Guest sets DRIVER bit in status field\n\n     *     Guest reads host features (WCE=0, CONFIG_WCE=1)\n\n     *     Guest writes guest features (WCE=0, CONFIG_WCE=1)\n\n     *     Guest writes 1 to the WCE configuration field (writeback mode)\n\n     *     Guest sets DRIVER_OK bit in status field\n\n     *\n\n     * s->bs would erroneously be placed in writethrough mode.\n\n     *\/\n\n    if (!(features & (1 << VIRTIO_BLK_F_CONFIG_WCE))) {\n\n        aio_context_acquire(bdrv_get_aio_context(s->bs));\n\n        bdrv_set_enable_write_cache(s->bs,\n\n                                    !!(features & (1 << VIRTIO_BLK_F_WCE)));\n\n        aio_context_release(bdrv_get_aio_context(s->bs));\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"83d08f2673504a299194dcac1657a13754b5932a","target":0,"func":"void pc_init_pci64_hole(PcPciInfo *pci_info, uint64_t pci_hole64_start,\n\n                        uint64_t pci_hole64_size)\n\n{\n\n    if ((sizeof(hwaddr) == 4) || (!pci_hole64_size)) {\n\n        return;\n\n    }\n\n    \/*\n\n     * BIOS does not set MTRR entries for the 64 bit window, so no need to\n\n     * align address to power of two.  Align address at 1G, this makes sure\n\n     * it can be exactly covered with a PAT entry even when using huge\n\n     * pages.\n\n     *\/\n\n    pci_info->w64.begin = ROUND_UP(pci_hole64_start, 0x1ULL << 30);\n\n    pci_info->w64.end = pci_info->w64.begin + pci_hole64_size;\n\n    assert(pci_info->w64.begin <= pci_info->w64.end);\n\n}\n"},{"project":"qemu","commit_id":"a7812ae412311d7d47f8aa85656faadac9d64b56","target":0,"func":"static unsigned int dec_addi_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"addi.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));\n\n\tcris_cc_mask(dc, 0);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\ttcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));\n\n\ttcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n"},{"project":"qemu","commit_id":"3a661f1eabf7e8db66e28489884d9b54aacb94ea","target":1,"func":"static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,\n\n                                       const uint8_t *key, size_t nkey,\n\n                                       Error **errp)\n\n{\n\n    QCryptoCipherBuiltin *ctxt;\n\n\n\n    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {\n\n        error_setg(errp, \"Unsupported cipher mode %d\", cipher->mode);\n\n        return -1;\n\n    }\n\n\n\n    ctxt = g_new0(QCryptoCipherBuiltin, 1);\n\n\n\n    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);\n\n    memcpy(ctxt->state.desrfb.key, key, nkey);\n\n    ctxt->state.desrfb.nkey = nkey;\n\n\n\n\n    ctxt->free = qcrypto_cipher_free_des_rfb;\n\n    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;\n\n    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;\n\n    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;\n\n\n\n    cipher->opaque = ctxt;\n\n\n\n    return 0;\n\n}"},{"project":"qemu","commit_id":"b7f26e523914b982a1c1bfa8295f77ff9787c33c","target":1,"func":"static void gen_bitops (DisasContext *ctx, uint32_t opc, int rt,\n\n                        int rs, int lsb, int msb)\n\n{\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_new();\n\n\n\n    gen_load_gpr(t1, rs);\n\n    switch (opc) {\n\n    case OPC_EXT:\n\n        if (lsb + msb > 31)\n\n            goto fail;\n\n        tcg_gen_shri_tl(t0, t1, lsb);\n\n        if (msb != 31) {\n\n            tcg_gen_andi_tl(t0, t0, (1 << (msb + 1)) - 1);\n\n        } else {\n\n            tcg_gen_ext32s_tl(t0, t0);\n\n        }\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DEXTM:\n\n        tcg_gen_shri_tl(t0, t1, lsb);\n\n        if (msb != 31) {\n\n            tcg_gen_andi_tl(t0, t0, (1ULL << (msb + 1 + 32)) - 1);\n\n        }\n\n        break;\n\n    case OPC_DEXTU:\n\n        tcg_gen_shri_tl(t0, t1, lsb + 32);\n\n        tcg_gen_andi_tl(t0, t0, (1ULL << (msb + 1)) - 1);\n\n        break;\n\n    case OPC_DEXT:\n\n        tcg_gen_shri_tl(t0, t1, lsb);\n\n        tcg_gen_andi_tl(t0, t0, (1ULL << (msb + 1)) - 1);\n\n        break;\n\n#endif\n\n    case OPC_INS:\n\n        if (lsb > msb)\n\n            goto fail;\n\n        gen_load_gpr(t0, rt);\n\n        tcg_gen_deposit_tl(t0, t0, t1, lsb, msb - lsb + 1);\n\n        tcg_gen_ext32s_tl(t0, t0);\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DINSM:\n\n        gen_load_gpr(t0, rt);\n\n        tcg_gen_deposit_tl(t0, t0, t1, lsb, msb + 32 - lsb + 1);\n\n        break;\n\n    case OPC_DINSU:\n\n        gen_load_gpr(t0, rt);\n\n        tcg_gen_deposit_tl(t0, t0, t1, lsb + 32, msb - lsb + 1);\n\n        break;\n\n    case OPC_DINS:\n\n        gen_load_gpr(t0, rt);\n\n        tcg_gen_deposit_tl(t0, t0, t1, lsb, msb - lsb + 1);\n\n        break;\n\n#endif\n\n    default:\n\nfail:\n\n        MIPS_INVAL(\"bitops\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        tcg_temp_free(t0);\n\n        tcg_temp_free(t1);\n\n        return;\n\n    }\n\n    gen_store_gpr(t0, rt);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void pci_apb_iowritew (void *opaque, target_phys_addr_t addr,\n\n                                  uint32_t val)\n\n{\n\n    cpu_outw(addr & IOPORTS_MASK, bswap16(val));\n\n}\n"},{"project":"qemu","commit_id":"b3a6a2e0417c78ec5491347eb85a7d125a5fefdc","target":1,"func":"int32 float32_to_int32_round_to_zero( float32 a STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp, shiftCount;\n\n    uint32_t aSig;\n\n    int32 z;\n\n    a = float32_squash_input_denormal(a STATUS_VAR);\n\n\n\n    aSig = extractFloat32Frac( a );\n\n    aExp = extractFloat32Exp( a );\n\n    aSign = extractFloat32Sign( a );\n\n    shiftCount = aExp - 0x9E;\n\n    if ( 0 <= shiftCount ) {\n\n        if ( float32_val(a) != 0xCF000000 ) {\n\n            float_raise( float_flag_invalid STATUS_VAR);\n\n            if ( ! aSign || ( ( aExp == 0xFF ) && aSig ) ) return 0x7FFFFFFF;\n\n        }\n\n        return (int32_t) 0x80000000;\n\n    }\n\n    else if ( aExp <= 0x7E ) {\n\n        if ( aExp | aSig ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n        return 0;\n\n    }\n\n    aSig = ( aSig | 0x00800000 )<<8;\n\n    z = aSig>>( - shiftCount );\n\n    if ( (uint32_t) ( aSig<<( shiftCount & 31 ) ) ) {\n\n        STATUS(float_exception_flags) |= float_flag_inexact;\n\n    }\n\n    if ( aSign ) z = - z;\n\n    return z;\n\n\n\n}\n"},{"project":"qemu","commit_id":"f689d2811a36894618087e1e2cc3ade78e758e94","target":1,"func":"static uint64_t ivshmem_io_read(void *opaque, hwaddr addr,\n\n                                unsigned size)\n\n{\n\n\n\n    IVShmemState *s = opaque;\n\n    uint32_t ret;\n\n\n\n    switch (addr)\n\n    {\n\n        case INTRMASK:\n\n            ret = ivshmem_IntrMask_read(s);\n\n            break;\n\n\n\n        case INTRSTATUS:\n\n            ret = ivshmem_IntrStatus_read(s);\n\n            break;\n\n\n\n        case IVPOSITION:\n\n            \/* return my VM ID if the memory is mapped *\/\n\n            if (s->shm_fd >= 0) {\n\n                ret = s->vm_id;\n\n            } else {\n\n                ret = -1;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            IVSHMEM_DPRINTF(\"why are we reading \" TARGET_FMT_plx \"\\n\", addr);\n\n            ret = 0;\n\n    }\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"7fe7b68b32ba609faeeee03556aac0eb1b187c91","target":1,"func":"static ssize_t nbd_co_receive_request(NBDRequest *req, struct nbd_request *request)\n\n{\n\n    NBDClient *client = req->client;\n\n    int csock = client->sock;\n\n    ssize_t rc;\n\n\n\n    client->recv_coroutine = qemu_coroutine_self();\n\n    if (nbd_receive_request(csock, request) < 0) {\n\n        rc = -EIO;\n\n        goto out;\n\n    }\n\n\n\n    if (request->len > NBD_BUFFER_SIZE) {\n\n        LOG(\"len (%u) is larger than max len (%u)\",\n\n            request->len, NBD_BUFFER_SIZE);\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if ((request->from + request->len) < request->from) {\n\n        LOG(\"integer overflow detected! \"\n\n            \"you're probably being attacked\");\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    TRACE(\"Decoding type\");\n\n\n\n    if ((request->type & NBD_CMD_MASK_COMMAND) == NBD_CMD_WRITE) {\n\n        TRACE(\"Reading %u byte(s)\", request->len);\n\n\n\n        if (qemu_co_recv(csock, req->data, request->len) != request->len) {\n\n            LOG(\"reading from socket failed\");\n\n            rc = -EIO;\n\n            goto out;\n\n        }\n\n    }\n\n    rc = 0;\n\n\n\nout:\n\n    client->recv_coroutine = NULL;\n\n    return rc;\n\n}\n"},{"project":"qemu","commit_id":"0ca4f94195cce77b624edc6d9abcf14a3bf01f06","target":1,"func":"static void bonito_writel(void *opaque, hwaddr addr,\n\n                          uint64_t val, unsigned size)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t saddr;\n\n    int reset = 0;\n\n\n\n    saddr = (addr - BONITO_REGBASE) >> 2;\n\n\n\n    DPRINTF(\"bonito_writel \"TARGET_FMT_plx\" val %x saddr %x\\n\", addr, val, saddr);\n\n    switch (saddr) {\n\n    case BONITO_BONPONCFG:\n\n    case BONITO_IODEVCFG:\n\n    case BONITO_SDCFG:\n\n    case BONITO_PCIMAP:\n\n    case BONITO_PCIMEMBASECFG:\n\n    case BONITO_PCIMAP_CFG:\n\n    case BONITO_GPIODATA:\n\n    case BONITO_GPIOIE:\n\n    case BONITO_INTEDGE:\n\n    case BONITO_INTSTEER:\n\n    case BONITO_INTPOL:\n\n    case BONITO_PCIMAIL0:\n\n    case BONITO_PCIMAIL1:\n\n    case BONITO_PCIMAIL2:\n\n    case BONITO_PCIMAIL3:\n\n    case BONITO_PCICACHECTRL:\n\n    case BONITO_PCICACHETAG:\n\n    case BONITO_PCIBADADDR:\n\n    case BONITO_PCIMSTAT:\n\n    case BONITO_TIMECFG:\n\n    case BONITO_CPUCFG:\n\n    case BONITO_DQCFG:\n\n    case BONITO_MEMSIZE:\n\n        s->regs[saddr] = val;\n\n        break;\n\n    case BONITO_BONGENCFG:\n\n        if (!(s->regs[saddr] & 0x04) && (val & 0x04)) {\n\n            reset = 1; \/* bit 2 jump from 0 to 1 cause reset *\/\n\n        }\n\n        s->regs[saddr] = val;\n\n        if (reset) {\n\n            qemu_system_reset_request();\n\n        }\n\n        break;\n\n    case BONITO_INTENSET:\n\n        s->regs[BONITO_INTENSET] = val;\n\n        s->regs[BONITO_INTEN] |= val;\n\n        break;\n\n    case BONITO_INTENCLR:\n\n        s->regs[BONITO_INTENCLR] = val;\n\n        s->regs[BONITO_INTEN] &= ~val;\n\n        break;\n\n    case BONITO_INTEN:\n\n    case BONITO_INTISR:\n\n        DPRINTF(\"write to readonly bonito register %x\\n\", saddr);\n\n        break;\n\n    default:\n\n        DPRINTF(\"write to unknown bonito register %x\\n\", saddr);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"8d04fb55dec381bc5105cb47f29d918e579e8cbd","target":1,"func":"void ppc_set_irq(PowerPCCPU *cpu, int n_IRQ, int level)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n    unsigned int old_pending = env->pending_interrupts;\n\n\n\n    if (level) {\n\n        env->pending_interrupts |= 1 << n_IRQ;\n\n        cpu_interrupt(cs, CPU_INTERRUPT_HARD);\n\n    } else {\n\n        env->pending_interrupts &= ~(1 << n_IRQ);\n\n        if (env->pending_interrupts == 0) {\n\n            cpu_reset_interrupt(cs, CPU_INTERRUPT_HARD);\n\n        }\n\n    }\n\n\n\n    if (old_pending != env->pending_interrupts) {\n\n#ifdef CONFIG_KVM\n\n        kvmppc_set_interrupt(cpu, n_IRQ, level);\n\n#endif\n\n    }\n\n\n\n    LOG_IRQ(\"%s: %p n_IRQ %d level %d => pending %08\" PRIx32\n\n                \"req %08x\\n\", __func__, env, n_IRQ, level,\n\n                env->pending_interrupts, CPU(cpu)->interrupt_request);\n\n}\n"},{"project":"qemu","commit_id":"678421650dc166cd6cb35bb2bc0baf1b481b40ca","target":0,"func":"static uint64_t pchip_read(void *opaque, hwaddr addr, unsigned size)\n\n{\n\n    TyphoonState *s = opaque;\n\n    uint64_t ret = 0;\n\n\n\n    if (addr & 4) {\n\n        return s->latch_tmp;\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x0000:\n\n        \/* WSBA0: Window Space Base Address Register.  *\/\n\n        ret = s->pchip.win[0].base_addr;\n\n        break;\n\n    case 0x0040:\n\n        \/* WSBA1 *\/\n\n        ret = s->pchip.win[1].base_addr;\n\n        break;\n\n    case 0x0080:\n\n        \/* WSBA2 *\/\n\n        ret = s->pchip.win[2].base_addr;\n\n        break;\n\n    case 0x00c0:\n\n        \/* WSBA3 *\/\n\n        ret = s->pchip.win[3].base_addr;\n\n        break;\n\n\n\n    case 0x0100:\n\n        \/* WSM0: Window Space Mask Register.  *\/\n\n        ret = s->pchip.win[0].mask;\n\n        break;\n\n    case 0x0140:\n\n        \/* WSM1 *\/\n\n        ret = s->pchip.win[1].mask;\n\n        break;\n\n    case 0x0180:\n\n        \/* WSM2 *\/\n\n        ret = s->pchip.win[2].mask;\n\n        break;\n\n    case 0x01c0:\n\n        \/* WSM3 *\/\n\n        ret = s->pchip.win[3].mask;\n\n        break;\n\n\n\n    case 0x0200:\n\n        \/* TBA0: Translated Base Address Register.  *\/\n\n        ret = (uint64_t)s->pchip.win[0].translated_base_pfn << 10;\n\n        break;\n\n    case 0x0240:\n\n        \/* TBA1 *\/\n\n        ret = (uint64_t)s->pchip.win[1].translated_base_pfn << 10;\n\n        break;\n\n    case 0x0280:\n\n        \/* TBA2 *\/\n\n        ret = (uint64_t)s->pchip.win[2].translated_base_pfn << 10;\n\n        break;\n\n    case 0x02c0:\n\n        \/* TBA3 *\/\n\n        ret = (uint64_t)s->pchip.win[3].translated_base_pfn << 10;\n\n        break;\n\n\n\n    case 0x0300:\n\n        \/* PCTL: Pchip Control Register.  *\/\n\n        ret = s->pchip.ctl;\n\n        break;\n\n    case 0x0340:\n\n        \/* PLAT: Pchip Master Latency Register.  *\/\n\n        break;\n\n    case 0x03c0:\n\n        \/* PERROR: Pchip Error Register.  *\/\n\n        break;\n\n    case 0x0400:\n\n        \/* PERRMASK: Pchip Error Mask Register.  *\/\n\n        break;\n\n    case 0x0440:\n\n        \/* PERRSET: Pchip Error Set Register.  *\/\n\n        break;\n\n    case 0x0480:\n\n        \/* TLBIV: Translation Buffer Invalidate Virtual Register (WO).  *\/\n\n        break;\n\n    case 0x04c0:\n\n        \/* TLBIA: Translation Buffer Invalidate All Register (WO).  *\/\n\n        break;\n\n    case 0x0500: \/* PMONCTL *\/\n\n    case 0x0540: \/* PMONCNT *\/\n\n    case 0x0800: \/* SPRST *\/\n\n        break;\n\n\n\n    default:\n\n        cpu_unassigned_access(current_cpu, addr, false, false, 0, size);\n\n        return -1;\n\n    }\n\n\n\n    s->latch_tmp = ret >> 32;\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"c363acef772647f66becdbf46dd54e70e67f3cc9","target":0,"func":"static void test_visitor_out_union_flat(TestOutputVisitorData *data,\n\n                                        const void *unused)\n\n{\n\n    QObject *arg;\n\n    QDict *qdict;\n\n\n\n    Error *err = NULL;\n\n\n\n    UserDefFlatUnion *tmp = g_malloc0(sizeof(UserDefFlatUnion));\n\n    tmp->enum1 = ENUM_ONE_VALUE1;\n\n    tmp->string = g_strdup(\"str\");\n\n    tmp->value1 = g_malloc0(sizeof(UserDefA));\n\n    \/* TODO when generator bug is fixed: tmp->integer = 41; *\/\n\n    tmp->value1->boolean = true;\n\n\n\n    visit_type_UserDefFlatUnion(data->ov, &tmp, NULL, &err);\n\n    g_assert(err == NULL);\n\n    arg = qmp_output_get_qobject(data->qov);\n\n\n\n    g_assert(qobject_type(arg) == QTYPE_QDICT);\n\n    qdict = qobject_to_qdict(arg);\n\n\n\n    g_assert_cmpstr(qdict_get_str(qdict, \"enum1\"), ==, \"value1\");\n\n    g_assert_cmpstr(qdict_get_str(qdict, \"string\"), ==, \"str\");\n\n    \/* TODO g_assert_cmpint(qdict_get_int(qdict, \"integer\"), ==, 41); *\/\n\n    g_assert_cmpint(qdict_get_bool(qdict, \"boolean\"), ==, true);\n\n\n\n    qapi_free_UserDefFlatUnion(tmp);\n\n    QDECREF(qdict);\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"void blockdev_mark_auto_del(BlockDriverState *bs)\n\n{\n\n    BlockBackend *blk = bs->blk;\n\n    DriveInfo *dinfo = blk_legacy_dinfo(blk);\n\n\n\n    if (dinfo && !dinfo->enable_auto_del) {\n\n        return;\n\n    }\n\n\n\n    if (bs->job) {\n\n        block_job_cancel(bs->job);\n\n    }\n\n    if (dinfo) {\n\n        dinfo->auto_del = 1;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static void scsi_aio_complete(void *opaque, int ret)\n\n{\n\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    assert(r->req.aiocb != NULL);\n\n    r->req.aiocb = NULL;\n\n    block_acct_done(bdrv_get_stats(s->qdev.conf.bs), &r->acct);\n\n    if (r->req.io_canceled) {\n\n        scsi_req_cancel_complete(&r->req);\n\n        goto done;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        if (scsi_handle_rw_error(r, -ret)) {\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    scsi_req_complete(&r->req, GOOD);\n\n\n\ndone:\n\n    scsi_req_unref(&r->req);\n\n}\n"},{"project":"qemu","commit_id":"b769d8fef6c06ddb39ef0337882a4f8872b9c2bc","target":0,"func":"CPUSPARCState *cpu_sparc_init(void)\n\n{\n\n    CPUSPARCState *env;\n\n\n\n    cpu_exec_init();\n\n\n\n    if (!(env = malloc(sizeof(CPUSPARCState))))\n\n\treturn (NULL);\n\n    memset(env, 0, sizeof(*env));\n\n    env->cwp = 0;\n\n    env->wim = 1;\n\n    env->regwptr = env->regbase + (env->cwp * 16);\n\n    env->access_type = ACCESS_DATA;\n\n#if defined(CONFIG_USER_ONLY)\n\n    env->user_mode_only = 1;\n\n#else\n\n    \/* Emulate Prom *\/\n\n    env->psrs = 1;\n\n    env->pc = 0x4000;\n\n    env->npc = env->pc + 4;\n\n    env->mmuregs[0] = (0x10<<24) | MMU_E; \/* Impl 1, ver 0, MMU Enabled *\/\n\n    env->mmuregs[1] = 0x3000 >> 4; \/* MMU Context table *\/\n\n#endif\n\n    cpu_single_env = env;\n\n    return (env);\n\n}\n"},{"project":"qemu","commit_id":"895b00f62a7e86724dc7352d67c7808d37366130","target":1,"func":"struct GuestFileSeek *qmp_guest_file_seek(int64_t handle, int64_t offset,\n\n                                          int64_t whence, Error **errp)\n\n{\n\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n    GuestFileSeek *seek_data = NULL;\n\n    FILE *fh;\n\n    int ret;\n\n\n\n    if (!gfh) {\n\n        return NULL;\n\n\n\n\n    fh = gfh->fh;\n\n    ret = fseek(fh, offset, whence);\n\n    if (ret == -1) {\n\n        error_setg_errno(errp, errno, \"failed to seek file\");\n\n\n\n\n\n    } else {\n\n        seek_data = g_new0(GuestFileSeek, 1);\n\n        seek_data->position = ftell(fh);\n\n        seek_data->eof = feof(fh);\n\n\n\n    clearerr(fh);\n\n\n\n    return seek_data;\n"},{"project":"qemu","commit_id":"e6afc87f804abee7d0479be5e8e31c56d885fafb","target":1,"func":"static float32 addFloat32Sigs( float32 a, float32 b, flag zSign STATUS_PARAM)\n\n{\n\n    int16 aExp, bExp, zExp;\n\n    uint32_t aSig, bSig, zSig;\n\n    int16 expDiff;\n\n\n\n    aSig = extractFloat32Frac( a );\n\n    aExp = extractFloat32Exp( a );\n\n    bSig = extractFloat32Frac( b );\n\n    bExp = extractFloat32Exp( b );\n\n    expDiff = aExp - bExp;\n\n    aSig <<= 6;\n\n    bSig <<= 6;\n\n    if ( 0 < expDiff ) {\n\n        if ( aExp == 0xFF ) {\n\n            if ( aSig ) return propagateFloat32NaN( a, b STATUS_VAR );\n\n            return a;\n\n        }\n\n        if ( bExp == 0 ) {\n\n            --expDiff;\n\n        }\n\n        else {\n\n            bSig |= 0x20000000;\n\n        }\n\n        shift32RightJamming( bSig, expDiff, &bSig );\n\n        zExp = aExp;\n\n    }\n\n    else if ( expDiff < 0 ) {\n\n        if ( bExp == 0xFF ) {\n\n            if ( bSig ) return propagateFloat32NaN( a, b STATUS_VAR );\n\n            return packFloat32( zSign, 0xFF, 0 );\n\n        }\n\n        if ( aExp == 0 ) {\n\n            ++expDiff;\n\n        }\n\n        else {\n\n            aSig |= 0x20000000;\n\n        }\n\n        shift32RightJamming( aSig, - expDiff, &aSig );\n\n        zExp = bExp;\n\n    }\n\n    else {\n\n        if ( aExp == 0xFF ) {\n\n            if ( aSig | bSig ) return propagateFloat32NaN( a, b STATUS_VAR );\n\n            return a;\n\n        }\n\n        if ( aExp == 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat32( zSign, 0, 0 );\n\n            return packFloat32( zSign, 0, ( aSig + bSig )>>6 );\n\n        }\n\n        zSig = 0x40000000 + aSig + bSig;\n\n        zExp = aExp;\n\n        goto roundAndPack;\n\n    }\n\n    aSig |= 0x20000000;\n\n    zSig = ( aSig + bSig )<<1;\n\n    --zExp;\n\n    if ( (int32_t) zSig < 0 ) {\n\n        zSig = aSig + bSig;\n\n        ++zExp;\n\n    }\n\n roundAndPack:\n\n    return roundAndPackFloat32( zSign, zExp, zSig STATUS_VAR );\n\n\n\n}\n"},{"project":"qemu","commit_id":"6eb8f212d2686ed9b17077d554465df7ae06f805","target":0,"func":"static void sigp_cpu_reset(void *arg)\n\n{\n\n    CPUState *cpu = arg;\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);\n\n\n\n    cpu_synchronize_state(cpu);\n\n    scc->cpu_reset(cpu);\n\n    cpu_synchronize_post_reset(cpu);\n\n}\n"},{"project":"qemu","commit_id":"133e9b228df16d11de01529c217417e78d1d9370","target":1,"func":"static int pci_init_multifunction(PCIBus *bus, PCIDevice *dev)\n\n{\n\n    uint8_t slot = PCI_SLOT(dev->devfn);\n\n    uint8_t func;\n\n\n\n    if (dev->cap_present & QEMU_PCI_CAP_MULTIFUNCTION) {\n\n        dev->config[PCI_HEADER_TYPE] |= PCI_HEADER_TYPE_MULTI_FUNCTION;\n\n    }\n\n\n\n    \/*\n\n     * multifunction bit is interpreted in two ways as follows.\n\n     *   - all functions must set the bit to 1.\n\n     *     Example: Intel X53\n\n     *   - function 0 must set the bit, but the rest function (> 0)\n\n     *     is allowed to leave the bit to 0.\n\n     *     Example: PIIX3(also in qemu), PIIX4(also in qemu), ICH10,\n\n     *\n\n     * So OS (at least Linux) checks the bit of only function 0,\n\n     * and doesn't see the bit of function > 0.\n\n     *\n\n     * The below check allows both interpretation.\n\n     *\/\n\n    if (PCI_FUNC(dev->devfn)) {\n\n        PCIDevice *f0 = bus->devices[PCI_DEVFN(slot, 0)];\n\n        if (f0 && !(f0->cap_present & QEMU_PCI_CAP_MULTIFUNCTION)) {\n\n            \/* function 0 should set multifunction bit *\/\n\n            error_report(\"PCI: single function device can't be populated \"\n\n                         \"in function %x.%x\", slot, PCI_FUNC(dev->devfn));\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (dev->cap_present & QEMU_PCI_CAP_MULTIFUNCTION) {\n\n        return 0;\n\n    }\n\n    \/* function 0 indicates single function, so function > 0 must be NULL *\/\n\n    for (func = 1; func < PCI_FUNC_MAX; ++func) {\n\n        if (bus->devices[PCI_DEVFN(slot, func)]) {\n\n            error_report(\"PCI: %x.0 indicates single function, \"\n\n                         \"but %x.%x is already populated.\",\n\n                         slot, slot, func);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"89ae337acbe4dba5b2481007aec1277252d2b86c","target":0,"func":"void address_space_destroy_dispatch(AddressSpace *as)\n\n{\n\n    AddressSpaceDispatch *d = as->dispatch;\n\n\n\n    memory_listener_unregister(&d->listener);\n\n    g_free(d);\n\n    as->dispatch = NULL;\n\n}\n"},{"project":"qemu","commit_id":"2b316774f60291f57ca9ecb6a9f0712c532cae34","target":1,"func":"static void fd_chr_update_read_handler(CharDriverState *chr)\n\n{\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    if (s->fd_in_tag) {\n\n        g_source_remove(s->fd_in_tag);\n\n        s->fd_in_tag = 0;\n\n    }\n\n\n\n    if (s->fd_in) {\n\n        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b","target":1,"func":"void sdl_display_init(DisplayState *ds, int full_screen, int no_frame)\n\n{\n\n    int flags;\n\n    uint8_t data = 0;\n\n    const SDL_VideoInfo *vi;\n\n    char *filename;\n\n\n\n#if defined(__APPLE__)\n\n    \/* always use generic keymaps *\/\n\n    if (!keyboard_layout)\n\n        keyboard_layout = \"en-us\";\n\n#endif\n\n    if(keyboard_layout) {\n\n        kbd_layout = init_keyboard_layout(name2keysym, keyboard_layout);\n\n        if (!kbd_layout)\n\n            exit(1);\n\n    }\n\n\n\n    if (no_frame)\n\n        gui_noframe = 1;\n\n\n\n    if (!full_screen) {\n\n        setenv(\"SDL_VIDEO_ALLOW_SCREENSAVER\", \"1\", 0);\n\n    }\n\n#ifdef __linux__\n\n    \/* on Linux, SDL may use fbcon|directfb|svgalib when run without\n\n     * accessible $DISPLAY to open X11 window.  This is often the case\n\n     * when qemu is run using sudo.  But in this case, and when actually\n\n     * run in X11 environment, SDL fights with X11 for the video card,\n\n     * making current display unavailable, often until reboot.\n\n     * So make x11 the default SDL video driver if this variable is unset.\n\n     * This is a bit hackish but saves us from bigger problem.\n\n     * Maybe it's a good idea to fix this in SDL instead.\n\n     *\/\n\n    setenv(\"SDL_VIDEODRIVER\", \"x11\", 0);\n\n#endif\n\n\n\n    \/* Enable normal up\/down events for Caps-Lock and Num-Lock keys.\n\n     * This requires SDL >= 1.2.14. *\/\n\n    setenv(\"SDL_DISABLE_LOCK_KEYS\", \"1\", 1);\n\n\n\n    flags = SDL_INIT_VIDEO | SDL_INIT_NOPARACHUTE;\n\n    if (SDL_Init (flags)) {\n\n        fprintf(stderr, \"Could not initialize SDL(%s) - exiting\\n\",\n\n                SDL_GetError());\n\n        exit(1);\n\n    }\n\n    vi = SDL_GetVideoInfo();\n\n    host_format = *(vi->vfmt);\n\n\n\n    \/* Load a 32x32x4 image. White pixels are transparent. *\/\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"qemu-icon.bmp\");\n\n    if (filename) {\n\n        SDL_Surface *image = SDL_LoadBMP(filename);\n\n        if (image) {\n\n            uint32_t colorkey = SDL_MapRGB(image->format, 255, 255, 255);\n\n            SDL_SetColorKey(image, SDL_SRCCOLORKEY, colorkey);\n\n            SDL_WM_SetIcon(image, NULL);\n\n        }\n\n        g_free(filename);\n\n    }\n\n\n\n    if (full_screen) {\n\n        gui_fullscreen = 1;\n\n        sdl_grab_start();\n\n    }\n\n\n\n    dcl = g_malloc0(sizeof(DisplayChangeListener));\n\n    dcl->ops = &dcl_ops;\n\n    register_displaychangelistener(dcl);\n\n\n\n    mouse_mode_notifier.notify = sdl_mouse_mode_change;\n\n    qemu_add_mouse_mode_change_notifier(&mouse_mode_notifier);\n\n\n\n    sdl_update_caption();\n\n    SDL_EnableKeyRepeat(250, 50);\n\n    gui_grab = 0;\n\n\n\n    sdl_cursor_hidden = SDL_CreateCursor(&data, &data, 8, 1, 0, 0);\n\n    sdl_cursor_normal = SDL_GetCursor();\n\n\n\n    atexit(sdl_cleanup);\n\n}\n"},{"project":"qemu","commit_id":"c679e74d2e29fa08ede9121d59aee4e9675611d7","target":0,"func":"int css_do_ssch(SubchDev *sch, ORB *orb)\n\n{\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    int ret;\n\n\n\n    if (!(p->flags & (PMCW_FLAGS_MASK_DNV | PMCW_FLAGS_MASK_ENA))) {\n\n        ret = -ENODEV;\n\n        goto out;\n\n    }\n\n\n\n    if (s->ctrl & SCSW_STCTL_STATUS_PEND) {\n\n        ret = -EINPROGRESS;\n\n        goto out;\n\n    }\n\n\n\n    if (s->ctrl & (SCSW_FCTL_START_FUNC |\n\n                   SCSW_FCTL_HALT_FUNC |\n\n                   SCSW_FCTL_CLEAR_FUNC)) {\n\n        ret = -EBUSY;\n\n        goto out;\n\n    }\n\n\n\n    \/* If monitoring is active, update counter. *\/\n\n    if (channel_subsys.chnmon_active) {\n\n        css_update_chnmon(sch);\n\n    }\n\n    sch->channel_prog = orb->cpa;\n\n    \/* Trigger the start function. *\/\n\n    s->ctrl |= (SCSW_FCTL_START_FUNC | SCSW_ACTL_START_PEND);\n\n    s->flags &= ~SCSW_FLAGS_MASK_PNO;\n\n\n\n    do_subchannel_work(sch, orb);\n\n    ret = 0;\n\n\n\nout:\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"39ac8455106af1ed669b8e10223420cf1ac5b190","target":1,"func":"void spapr_register_hypercall(target_ulong opcode, spapr_hcall_fn fn)\n\n{\n\n    spapr_hcall_fn old_fn;\n\n\n\n    assert(opcode <= MAX_HCALL_OPCODE);\n\n    assert((opcode & 0x3) == 0);\n\n\n\n    old_fn = hypercall_table[opcode \/ 4];\n\n\n\n    assert(!old_fn || (fn == old_fn));\n\n\n\n    hypercall_table[opcode \/ 4] = fn;\n\n}\n"},{"project":"qemu","commit_id":"7d175d29c9430fcba7a98f2c71925137b7870da4","target":0,"func":"static int os_host_main_loop_wait(int64_t timeout)\n\n{\n\n    int ret;\n\n    static int spin_counter;\n\n\n\n    glib_pollfds_fill(&timeout);\n\n\n\n    \/* If the I\/O thread is very busy or we are incorrectly busy waiting in\n\n     * the I\/O thread, this can lead to starvation of the BQL such that the\n\n     * VCPU threads never run.  To make sure we can detect the later case,\n\n     * print a message to the screen.  If we run into this condition, create\n\n     * a fake timeout in order to give the VCPU threads a chance to run.\n\n     *\/\n\n    if (!timeout && (spin_counter > MAX_MAIN_LOOP_SPIN)) {\n\n        static bool notified;\n\n\n\n        if (!notified && !qtest_driver()) {\n\n            fprintf(stderr,\n\n                    \"main-loop: WARNING: I\/O thread spun for %d iterations\\n\",\n\n                    MAX_MAIN_LOOP_SPIN);\n\n            notified = true;\n\n        }\n\n\n\n        timeout = SCALE_MS;\n\n    }\n\n\n\n    if (timeout) {\n\n        spin_counter = 0;\n\n        qemu_mutex_unlock_iothread();\n\n    } else {\n\n        spin_counter++;\n\n    }\n\n\n\n    ret = qemu_poll_ns((GPollFD *)gpollfds->data, gpollfds->len, timeout);\n\n\n\n    if (timeout) {\n\n        qemu_mutex_lock_iothread();\n\n    }\n\n\n\n    glib_pollfds_poll();\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"a89ef0c357abfbf1f76e2d7418fe3c880e0364bd","target":0,"func":"int nbd_client_co_flush(BlockDriverState *bs)\n\n{\n\n    NbdClientSession *client = nbd_get_client_session(bs);\n\n    struct nbd_request request = { .type = NBD_CMD_FLUSH };\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {\n\n        return 0;\n\n    }\n\n\n\n    if (client->nbdflags & NBD_FLAG_SEND_FUA) {\n\n        request.type |= NBD_CMD_FLAG_FUA;\n\n    }\n\n\n\n    request.from = 0;\n\n    request.len = 0;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(bs, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL, 0);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n}\n"},{"project":"qemu","commit_id":"a12a5a1a0132527afe87c079e4aae4aad372bd94","target":1,"func":"static void test_dealloc_partial(void)\n\n{\n\n    static const char text[] = \"don't leak me\";\n\n\n\n    UserDefTwo *ud2 = NULL;\n\n    Error *err = NULL;\n\n\n\n    \/* create partial object *\/\n\n    {\n\n        QDict *ud2_dict;\n\n        QmpInputVisitor *qiv;\n\n\n\n        ud2_dict = qdict_new();\n\n        qdict_put_obj(ud2_dict, \"string0\", QOBJECT(qstring_from_str(text)));\n\n\n\n        qiv = qmp_input_visitor_new(QOBJECT(ud2_dict));\n\n        visit_type_UserDefTwo(qmp_input_get_visitor(qiv), &ud2, NULL, &err);\n\n        qmp_input_visitor_cleanup(qiv);\n\n        QDECREF(ud2_dict);\n\n    }\n\n\n\n    \/* verify partial success *\/\n\n    assert(ud2 != NULL);\n\n    assert(ud2->string0 != NULL);\n\n    assert(strcmp(ud2->string0, text) == 0);\n\n    assert(ud2->dict1 == NULL);\n\n\n\n    \/* confirm & release construction error *\/\n\n    assert(err != NULL);\n\n    error_free(err);\n\n\n\n    \/* tear down partial object *\/\n\n    qapi_free_UserDefTwo(ud2);\n\n}\n"},{"project":"qemu","commit_id":"c1568af597d71b2171c9b2ffffb336c2fdee205e","target":0,"func":"static int v9fs_do_open2(V9fsState *s, V9fsCreateState *vs)\n\n{\n\n    FsCred cred;\n\n    int flags;\n\n\n\n    cred_init(&cred);\n\n    cred.fc_uid = vs->fidp->uid;\n\n    cred.fc_mode = vs->perm & 0777;\n\n    flags = omode_to_uflags(vs->mode) | O_CREAT;\n\n\n\n    return s->ops->open2(&s->ctx, vs->fullname.data, flags, &cred);\n\n}\n"},{"project":"qemu","commit_id":"8dfe8e7f4facef400ef1c220f29196ae5cfc526c","target":0,"func":"static void ppc_spapr_init(MachineState *machine)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    PowerPCCPU *cpu;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *rma_region;\n\n    void *rma = NULL;\n\n    hwaddr rma_alloc_size;\n\n    hwaddr node0_size = spapr_node0_size();\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    \/* Allocate RMA if necessary *\/\n\n    rma_alloc_size = kvmppc_alloc_rma(&rma);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        error_report(\"Unable to create RMA\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < node0_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = node0_size;\n\n\n\n        \/* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         *\/\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size > node0_size) {\n\n        error_report(\"Numa node 0 has to span the RMA (%#08\"HWADDR_PRIx\")\",\n\n                     spapr->rma_size);\n\n        exit(1);\n\n    }\n\n\n\n    \/* Setup a load limit for the ramdisk leaving room for SLOF and FDT *\/\n\n    load_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;\n\n\n\n    \/* We aim for a hash table of size 1\/128 the size of RAM.  The\n\n     * normal rule of thumb is 1\/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. *\/\n\n    spapr->htab_shift = 18; \/* Minimum architected size *\/\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= machine->maxram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n    spapr_alloc_htab(spapr);\n\n\n\n    \/* Set up Interrupt Controller before we create the VCPUs *\/\n\n    spapr->icp = xics_system_init(machine,\n\n                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),\n\n                                               smp_threads),\n\n                                  XICS_IRQS, &error_fatal);\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_validate_node_memory(machine, &error_fatal);\n\n    }\n\n\n\n    \/* init CPUs *\/\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            error_report(\"Unable to find PowerPC CPU definition\");\n\n            exit(1);\n\n        }\n\n        spapr_cpu_init(spapr, cpu, &error_fatal);\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        \/* Enable H_LOGICAL_CI_* so SLOF can talk to in-kernel devices *\/\n\n        kvmppc_enable_logical_ci_hcalls();\n\n        kvmppc_enable_set_mode_hcall();\n\n    }\n\n\n\n    \/* allocate RAM *\/\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_spapr.ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    if (rma_alloc_size && rma) {\n\n        rma_region = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram_ptr(rma_region, NULL, \"ppc_spapr.rma\",\n\n                                   rma_alloc_size, rma);\n\n        vmstate_register_ram_global(rma_region);\n\n        memory_region_add_subregion(sysmem, 0, rma_region);\n\n    }\n\n\n\n    \/* initialize hotplug memory address space *\/\n\n    if (machine->ram_size < machine->maxram_size) {\n\n        ram_addr_t hotplug_mem_size = machine->maxram_size - machine->ram_size;\n\n\n\n        if (machine->ram_slots > SPAPR_MAX_RAM_SLOTS) {\n\n            error_report(\"Specified number of memory slots %\"\n\n                         PRIu64\" exceeds max supported %d\",\n\n                         machine->ram_slots, SPAPR_MAX_RAM_SLOTS);\n\n            exit(1);\n\n        }\n\n\n\n        spapr->hotplug_memory.base = ROUND_UP(machine->ram_size,\n\n                                              SPAPR_HOTPLUG_MEM_ALIGN);\n\n        memory_region_init(&spapr->hotplug_memory.mr, OBJECT(spapr),\n\n                           \"hotplug-memory\", hotplug_mem_size);\n\n        memory_region_add_subregion(sysmem, spapr->hotplug_memory.base,\n\n                                    &spapr->hotplug_memory.mr);\n\n    }\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_create_lmb_dr_connectors(spapr);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR rtas '%s'\", \"spapr-rtas.bin\");\n\n        exit(1);\n\n    }\n\n    spapr->rtas_size = get_image_size(filename);\n\n    spapr->rtas_blob = g_malloc(spapr->rtas_size);\n\n    if (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {\n\n        error_report(\"Could not load LPAR rtas '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        error_report(\"RTAS too big ! 0x%zx bytes (max is 0x%x)\",\n\n                     (size_t)spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    \/* Set up EPOW events infrastructure *\/\n\n    spapr_events_init(spapr);\n\n\n\n    \/* Set up the RTC RTAS interfaces *\/\n\n    spapr_rtc_create(spapr);\n\n\n\n    \/* Set up VIO bus *\/\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    \/* We always have at least the nvram device on VIO *\/\n\n    spapr_create_nvram(spapr);\n\n\n\n    \/* Set up PCI *\/\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    \/* Graphics *\/\n\n    if (spapr_vga_init(phb->bus, &error_fatal)) {\n\n        spapr->has_graphics = true;\n\n        machine->usb |= defaults_enabled() && !machine->usb_disabled;\n\n    }\n\n\n\n    if (machine->usb) {\n\n        if (smc->use_ohci_by_default) {\n\n            pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        } else {\n\n            pci_create_simple(phb->bus, -1, \"nec-usb-xhci\");\n\n        }\n\n\n\n        if (spapr->has_graphics) {\n\n            USBBus *usb_bus = usb_bus_find(-1);\n\n\n\n            usb_create_simple(usb_bus, \"usb-kbd\");\n\n            usb_create_simple(usb_bus, \"usb-mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        error_report(\n\n            \"pSeries SLOF firmware requires >= %ldM guest RMA (Real Mode Area memory)\",\n\n            MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, PPC_ELF_MACHINE, 0);\n\n        if (kernel_size == ELF_LOAD_WRONG_ENDIAN) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, PPC_ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            error_report(\"error loading %s: %s\",\n\n                         kernel_filename, load_elf_strerror(kernel_size));\n\n            exit(1);\n\n        }\n\n\n\n        \/* load initrd *\/\n\n        if (initrd_filename) {\n\n            \/* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             *\/\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                error_report(\"could not load initial ram disk '%s'\",\n\n                             initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR firmware '%s'\", bios_name);\n\n        exit(1);\n\n    }\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size <= 0) {\n\n        error_report(\"Could not load LPAR firmware '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    \/* FIXME: Should register things through the MachineState's qdev\n\n     * interface, this is a legacy from the sPAPREnvironment structure\n\n     * which predated MachineState but had a similar function *\/\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr\/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    \/* Prepare the device tree *\/\n\n    spapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            kernel_cmdline,\n\n                                            spapr->check_exception_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n\n\n    \/* used by RTAS *\/\n\n    QTAILQ_INIT(&spapr->ccs_list);\n\n    qemu_register_reset(spapr_ccs_reset_hook, spapr);\n\n\n\n    qemu_register_boot_set(spapr_boot_set, spapr);\n\n}\n"},{"project":"qemu","commit_id":"eb700029c7836798046191d62d595363d92c84d4","target":0,"func":"void net_tx_pkt_build_vheader(struct NetTxPkt *pkt, bool tso_enable,\n\n    bool csum_enable, uint32_t gso_size)\n\n{\n\n    struct tcp_hdr l4hdr;\n\n    assert(pkt);\n\n\n\n    \/* csum has to be enabled if tso is. *\/\n\n    assert(csum_enable || !tso_enable);\n\n\n\n    pkt->virt_hdr.gso_type = net_tx_pkt_get_gso_type(pkt, tso_enable);\n\n\n\n    switch (pkt->virt_hdr.gso_type & ~VIRTIO_NET_HDR_GSO_ECN) {\n\n    case VIRTIO_NET_HDR_GSO_NONE:\n\n        pkt->virt_hdr.hdr_len = 0;\n\n        pkt->virt_hdr.gso_size = 0;\n\n        break;\n\n\n\n    case VIRTIO_NET_HDR_GSO_UDP:\n\n        pkt->virt_hdr.gso_size = IP_FRAG_ALIGN_SIZE(gso_size);\n\n        pkt->virt_hdr.hdr_len = pkt->hdr_len + sizeof(struct udp_header);\n\n        break;\n\n\n\n    case VIRTIO_NET_HDR_GSO_TCPV4:\n\n    case VIRTIO_NET_HDR_GSO_TCPV6:\n\n        iov_to_buf(&pkt->vec[NET_TX_PKT_PL_START_FRAG], pkt->payload_frags,\n\n                   0, &l4hdr, sizeof(l4hdr));\n\n        pkt->virt_hdr.hdr_len = pkt->hdr_len + l4hdr.th_off * sizeof(uint32_t);\n\n        pkt->virt_hdr.gso_size = IP_FRAG_ALIGN_SIZE(gso_size);\n\n        break;\n\n\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    if (csum_enable) {\n\n        switch (pkt->l4proto) {\n\n        case IP_PROTO_TCP:\n\n            pkt->virt_hdr.flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\n            pkt->virt_hdr.csum_start = pkt->hdr_len;\n\n            pkt->virt_hdr.csum_offset = offsetof(struct tcp_hdr, th_sum);\n\n            break;\n\n        case IP_PROTO_UDP:\n\n            pkt->virt_hdr.flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\n            pkt->virt_hdr.csum_start = pkt->hdr_len;\n\n            pkt->virt_hdr.csum_offset = offsetof(struct udp_hdr, uh_sum);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"3dc6f8693694a649a9c83f1e2746565b47683923","target":0,"func":"static void pc_init1(MachineState *machine,\n\n                     const char *host_type, const char *pci_type)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *system_io = get_system_io();\n\n    int i;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *i8259;\n\n    qemu_irq smi_irq;\n\n    GSIState *gsi_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n    MemoryRegion *ram_memory;\n\n    MemoryRegion *pci_memory;\n\n    MemoryRegion *rom_memory;\n\n    ram_addr_t lowmem;\n\n\n\n    \/*\n\n     * Calculate ram split, for memory below and above 4G.  It's a bit\n\n     * complicated for backward compatibility reasons ...\n\n     *\n\n     *  - Traditional split is 3.5G (lowmem = 0xe0000000).  This is the\n\n     *    default value for max_ram_below_4g now.\n\n     *\n\n     *  - Then, to gigabyte align the memory, we move the split to 3G\n\n     *    (lowmem = 0xc0000000).  But only in case we have to split in\n\n     *    the first place, i.e. ram_size is larger than (traditional)\n\n     *    lowmem.  And for new machine types (gigabyte_align = true)\n\n     *    only, for live migration compatibility reasons.\n\n     *\n\n     *  - Next the max-ram-below-4g option was added, which allowed to\n\n     *    reduce lowmem to a smaller value, to allow a larger PCI I\/O\n\n     *    window below 4G.  qemu doesn't enforce gigabyte alignment here,\n\n     *    but prints a warning.\n\n     *\n\n     *  - Finally max-ram-below-4g got updated to also allow raising lowmem,\n\n     *    so legacy non-PAE guests can get as much memory as possible in\n\n     *    the 32bit address space below 4G.\n\n     *\n\n     *  - Note that Xen has its own ram setp code in xen_ram_init(),\n\n     *    called via xen_hvm_init().\n\n     *\n\n     * Examples:\n\n     *    qemu -M pc-1.7 -m 4G    (old default)    -> 3584M low,  512M high\n\n     *    qemu -M pc -m 4G        (new default)    -> 3072M low, 1024M high\n\n     *    qemu -M pc,max-ram-below-4g=2G -m 4G     -> 2048M low, 2048M high\n\n     *    qemu -M pc,max-ram-below-4g=4G -m 3968M  -> 3968M low (=4G-128M)\n\n     *\/\n\n    if (xen_enabled()) {\n\n        xen_hvm_init(pcms, &ram_memory);\n\n    } else {\n\n        if (!pcms->max_ram_below_4g) {\n\n            pcms->max_ram_below_4g = 0xe0000000; \/* default: 3.5G *\/\n\n        }\n\n        lowmem = pcms->max_ram_below_4g;\n\n        if (machine->ram_size >= pcms->max_ram_below_4g) {\n\n            if (pcmc->gigabyte_align) {\n\n                if (lowmem > 0xc0000000) {\n\n                    lowmem = 0xc0000000;\n\n                }\n\n                if (lowmem & ((1ULL << 30) - 1)) {\n\n                    error_report(\"Warning: Large machine and max_ram_below_4g \"\n\n                                 \"(%\" PRIu64 \") not a multiple of 1G; \"\n\n                                 \"possible bad performance.\",\n\n                                 pcms->max_ram_below_4g);\n\n                }\n\n            }\n\n        }\n\n\n\n        if (machine->ram_size >= lowmem) {\n\n            pcms->above_4g_mem_size = machine->ram_size - lowmem;\n\n            pcms->below_4g_mem_size = lowmem;\n\n        } else {\n\n            pcms->above_4g_mem_size = 0;\n\n            pcms->below_4g_mem_size = machine->ram_size;\n\n        }\n\n    }\n\n\n\n    pc_cpus_init(pcms);\n\n\n\n    if (kvm_enabled() && pcmc->kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    if (pcmc->pci_enabled) {\n\n        pci_memory = g_new(MemoryRegion, 1);\n\n        memory_region_init(pci_memory, NULL, \"pci\", UINT64_MAX);\n\n        rom_memory = pci_memory;\n\n    } else {\n\n        pci_memory = NULL;\n\n        rom_memory = system_memory;\n\n    }\n\n\n\n    pc_guest_info_init(pcms);\n\n\n\n    if (pcmc->smbios_defaults) {\n\n        MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n        \/* These values are guest ABI, do not change *\/\n\n        smbios_set_defaults(\"QEMU\", \"Standard PC (i440FX + PIIX, 1996)\",\n\n                            mc->name, pcmc->smbios_legacy_mode,\n\n                            pcmc->smbios_uuid_encoded,\n\n                            SMBIOS_ENTRY_POINT_21);\n\n    }\n\n\n\n    \/* allocate ram and load rom\/bios *\/\n\n    if (!xen_enabled()) {\n\n        pc_memory_init(pcms, system_memory,\n\n                       rom_memory, &ram_memory);\n\n    } else if (machine->kernel_filename != NULL) {\n\n        \/* For xen HVM direct kernel boot, load linux here *\/\n\n        xen_load_linux(pcms);\n\n    }\n\n\n\n    gsi_state = g_malloc0(sizeof(*gsi_state));\n\n    if (kvm_ioapic_in_kernel()) {\n\n        kvm_pc_setup_irq_routing(pcmc->pci_enabled);\n\n        pcms->gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,\n\n                                       GSI_NUM_PINS);\n\n    } else {\n\n        pcms->gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);\n\n    }\n\n\n\n    if (pcmc->pci_enabled) {\n\n        pci_bus = i440fx_init(host_type,\n\n                              pci_type,\n\n                              &i440fx_state, &piix3_devfn, &isa_bus, pcms->gsi,\n\n                              system_memory, system_io, machine->ram_size,\n\n                              pcms->below_4g_mem_size,\n\n                              pcms->above_4g_mem_size,\n\n                              pci_memory, ram_memory);\n\n        pcms->bus = pci_bus;\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus = isa_bus_new(NULL, get_system_memory(), system_io,\n\n                              &error_abort);\n\n        no_hpet = 1;\n\n    }\n\n    isa_bus_irqs(isa_bus, pcms->gsi);\n\n\n\n    if (kvm_pic_in_kernel()) {\n\n        i8259 = kvm_i8259_init(isa_bus);\n\n    } else if (xen_enabled()) {\n\n        i8259 = xen_interrupt_controller_init();\n\n    } else {\n\n        i8259 = i8259_init(isa_bus, pc_allocate_cpu_irq());\n\n    }\n\n\n\n    for (i = 0; i < ISA_NUM_IRQS; i++) {\n\n        gsi_state->i8259_irq[i] = i8259[i];\n\n    }\n\n    g_free(i8259);\n\n    if (pcmc->pci_enabled) {\n\n        ioapic_init_gsi(gsi_state, \"i440fx\");\n\n    }\n\n\n\n    pc_register_ferr_irq(pcms->gsi[13]);\n\n\n\n    pc_vga_init(isa_bus, pcmc->pci_enabled ? pci_bus : NULL);\n\n\n\n    assert(pcms->vmport != ON_OFF_AUTO__MAX);\n\n    if (pcms->vmport == ON_OFF_AUTO_AUTO) {\n\n        pcms->vmport = xen_enabled() ? ON_OFF_AUTO_OFF : ON_OFF_AUTO_ON;\n\n    }\n\n\n\n    \/* init basic PC hardware *\/\n\n    pc_basic_device_init(isa_bus, pcms->gsi, &rtc_state, true,\n\n                         (pcms->vmport != ON_OFF_AUTO_ON), pcms->pit, 0x4);\n\n\n\n    pc_nic_init(isa_bus, pci_bus);\n\n\n\n    ide_drive_get(hd, ARRAY_SIZE(hd));\n\n    if (pcmc->pci_enabled) {\n\n        PCIDevice *dev;\n\n        if (xen_enabled()) {\n\n            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        } else {\n\n            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        }\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            char busname[] = \"ide.0\";\n\n            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],\n\n                               ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            \/*\n\n             * The ide bus name is ide.0 for the first bus and ide.1 for the\n\n             * second one.\n\n             *\/\n\n            busname[4] = '0' + i;\n\n            idebus[i] = qdev_get_child_bus(DEVICE(dev), busname);\n\n        }\n\n    }\n\n\n\n    pc_cmos_init(pcms, idebus[0], idebus[1], rtc_state);\n\n\n\n    if (pcmc->pci_enabled && machine_usb(machine)) {\n\n        pci_create_simple(pci_bus, piix3_devfn + 2, \"piix3-usb-uhci\");\n\n    }\n\n\n\n    if (pcmc->pci_enabled && acpi_enabled) {\n\n        DeviceState *piix4_pm;\n\n        I2CBus *smbus;\n\n\n\n        smi_irq = qemu_allocate_irq(pc_acpi_smi_interrupt, first_cpu, 0);\n\n        \/* TODO: Populate SPD eeprom data.  *\/\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              pcms->gsi[9], smi_irq,\n\n                              pc_machine_is_smm_enabled(pcms),\n\n                              &piix4_pm);\n\n        smbus_eeprom_init(smbus, 8, NULL, 0);\n\n\n\n        object_property_add_link(OBJECT(machine), PC_MACHINE_ACPI_DEVICE_PROP,\n\n                                 TYPE_HOTPLUG_HANDLER,\n\n                                 (Object **)&pcms->acpi_dev,\n\n                                 object_property_allow_set_link,\n\n                                 OBJ_PROP_LINK_UNREF_ON_RELEASE, &error_abort);\n\n        object_property_set_link(OBJECT(machine), OBJECT(piix4_pm),\n\n                                 PC_MACHINE_ACPI_DEVICE_PROP, &error_abort);\n\n    }\n\n\n\n    if (pcmc->pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n\n\n    if (pcms->acpi_nvdimm_state.is_enabled) {\n\n        nvdimm_init_acpi_state(&pcms->acpi_nvdimm_state, system_io,\n\n                               pcms->fw_cfg, OBJECT(pcms));\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"aa8f057e74ae08014736a690ff41f76c756f75f1","target":0,"func":"static void virtio_ccw_crypto_instance_init(Object *obj)\n\n{\n\n    VirtIOCryptoCcw *dev = VIRTIO_CRYPTO_CCW(obj);\n\n    VirtioCcwDevice *ccw_dev = VIRTIO_CCW_DEVICE(obj);\n\n\n\n    ccw_dev->force_revision_1 = true;\n\n    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),\n\n                                TYPE_VIRTIO_CRYPTO);\n\n\n\n    object_property_add_alias(obj, \"cryptodev\", OBJECT(&dev->vdev),\n\n                              \"cryptodev\", &error_abort);\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static void ide_sector_start_dma(IDEState *s, enum ide_dma_cmd dma_cmd)\n\n{\n\n    s->status = READY_STAT | SEEK_STAT | DRQ_STAT | BUSY_STAT;\n\n    s->io_buffer_index = 0;\n\n    s->io_buffer_size = 0;\n\n    s->dma_cmd = dma_cmd;\n\n\n\n    switch (dma_cmd) {\n\n    case IDE_DMA_READ:\n\n        block_acct_start(bdrv_get_stats(s->bs), &s->acct,\n\n                         s->nsector * BDRV_SECTOR_SIZE, BLOCK_ACCT_READ);\n\n        break;\n\n    case IDE_DMA_WRITE:\n\n        block_acct_start(bdrv_get_stats(s->bs), &s->acct,\n\n                         s->nsector * BDRV_SECTOR_SIZE, BLOCK_ACCT_WRITE);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    ide_start_dma(s, ide_dma_cb);\n\n}\n"},{"project":"qemu","commit_id":"75cc1c1fcba1987bdf3979c4289ab756c2b15742","target":1,"func":"static TRBCCode xhci_reset_ep(XHCIState *xhci, unsigned int slotid,\n\n                              unsigned int epid)\n\n{\n\n    XHCISlot *slot;\n\n    XHCIEPContext *epctx;\n\n    USBDevice *dev;\n\n\n\n    trace_usb_xhci_ep_reset(slotid, epid);\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n\n\n    if (epid < 1 || epid > 31) {\n\n        fprintf(stderr, \"xhci: bad ep %d\\n\", epid);\n\n        return CC_TRB_ERROR;\n\n    }\n\n\n\n    slot = &xhci->slots[slotid-1];\n\n\n\n    if (!slot->eps[epid-1]) {\n\n        DPRINTF(\"xhci: slot %d ep %d not enabled\\n\", slotid, epid);\n\n        return CC_EP_NOT_ENABLED_ERROR;\n\n    }\n\n\n\n    epctx = slot->eps[epid-1];\n\n\n\n    if (epctx->state != EP_HALTED) {\n\n        fprintf(stderr, \"xhci: reset EP while EP %d not halted (%d)\\n\",\n\n                epid, epctx->state);\n\n        return CC_CONTEXT_STATE_ERROR;\n\n    }\n\n\n\n    if (xhci_ep_nuke_xfers(xhci, slotid, epid) > 0) {\n\n        fprintf(stderr, \"xhci: FIXME: endpoint reset w\/ xfers running, \"\n\n                \"data might be lost\\n\");\n\n    }\n\n\n\n    uint8_t ep = epid>>1;\n\n\n\n    if (epid & 1) {\n\n        ep |= 0x80;\n\n    }\n\n\n\n    dev = xhci->slots[slotid-1].uport->dev;\n\n    if (!dev) {\n\n        return CC_USB_TRANSACTION_ERROR;\n\n    }\n\n\n\n    xhci_set_ep_state(xhci, epctx, NULL, EP_STOPPED);\n\n\n\n    if (epctx->nr_pstreams) {\n\n        xhci_reset_streams(epctx);\n\n    }\n\n\n\n    return CC_SUCCESS;\n\n}\n"},{"project":"qemu","commit_id":"44bc910794eff956ceba0030f0751a26bed748b5","target":0,"func":"static int get_physical_address(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                                target_ulong eaddr, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n#if 0\n\n    qemu_log(\"%s\\n\", __func__);\n\n#endif\n\n    if ((access_type == ACCESS_CODE && msr_ir == 0) ||\n\n        (access_type != ACCESS_CODE && msr_dr == 0)) {\n\n        if (env->mmu_model == POWERPC_MMU_BOOKE) {\n\n            \/* The BookE MMU always performs address translation. The\n\n               IS and DS bits only affect the address space.  *\/\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n        } else if (env->mmu_model == POWERPC_MMU_BOOKE206) {\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                                   access_type);\n\n        } else {\n\n            \/* No address translation.  *\/\n\n            ret = check_physical(env, ctx, eaddr, rw);\n\n        }\n\n    } else {\n\n        ret = -1;\n\n        switch (env->mmu_model) {\n\n        case POWERPC_MMU_32B:\n\n        case POWERPC_MMU_601:\n\n            \/* Try to find a BAT *\/\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                \/* We didn't match any BAT entry or don't have BATs *\/\n\n                ret = get_segment32(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n        case POWERPC_MMU_SOFT_6xx:\n\n        case POWERPC_MMU_SOFT_74xx:\n\n            \/* Try to find a BAT *\/\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                \/* We didn't match any BAT entry or don't have BATs *\/\n\n                ret = get_segment_6xx_tlb(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n#if defined(TARGET_PPC64)\n\n        case POWERPC_MMU_64B:\n\n        case POWERPC_MMU_2_06:\n\n        case POWERPC_MMU_2_06d:\n\n            ret = get_segment64(env, ctx, eaddr, rw, access_type);\n\n            break;\n\n#endif\n\n\n\n        case POWERPC_MMU_SOFT_4xx:\n\n        case POWERPC_MMU_SOFT_4xx_Z:\n\n            ret = mmu40x_get_physical_address(env, ctx, eaddr,\n\n                                              rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE:\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE206:\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                               access_type);\n\n            break;\n\n        case POWERPC_MMU_MPC8xx:\n\n            \/* XXX: TODO *\/\n\n            cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n            break;\n\n        case POWERPC_MMU_REAL:\n\n            cpu_abort(env, \"PowerPC in real mode do not do any translation\\n\");\n\n            return -1;\n\n        default:\n\n            cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n#if 0\n\n    qemu_log(\"%s address \" TARGET_FMT_lx \" => %d \" TARGET_FMT_plx \"\\n\",\n\n             __func__, eaddr, ret, ctx->raddr);\n\n#endif\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static bool scsi_block_is_passthrough(SCSIDiskState *s, uint8_t *buf)\n\n{\n\n    switch (buf[0]) {\n\n    case READ_6:\n\n    case READ_10:\n\n    case READ_12:\n\n    case READ_16:\n\n    case VERIFY_10:\n\n    case VERIFY_12:\n\n    case VERIFY_16:\n\n    case WRITE_6:\n\n    case WRITE_10:\n\n    case WRITE_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_VERIFY_16:\n\n        \/* If we are not using O_DIRECT, we might read stale data from the\n\n         * host cache if writes were made using other commands than these\n\n         * ones (such as WRITE SAME or EXTENDED COPY, etc.).  So, without\n\n         * O_DIRECT everything must go through SG_IO.\n\n         *\/\n\n        if (!(bdrv_get_flags(s->qdev.conf.bs) & BDRV_O_NOCACHE)) {\n\n            break;\n\n        }\n\n\n\n        \/* MMC writing cannot be done via pread\/pwrite, because it sometimes\n\n         * involves writing beyond the maximum LBA or to negative LBA (lead-in).\n\n         * And once you do these writes, reading from the block device is\n\n         * unreliable, too.  It is even possible that reads deliver random data\n\n         * from the host page cache (this is probably a Linux bug).\n\n         *\n\n         * We might use scsi_disk_dma_reqops as long as no writing commands are\n\n         * seen, but performance usually isn't paramount on optical media.  So,\n\n         * just make scsi-block operate the same as scsi-generic for them.\n\n         *\/\n\n        if (s->qdev.type != TYPE_ROM) {\n\n            return false;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    return true;\n\n}\n"},{"project":"qemu","commit_id":"f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7","target":0,"func":"static void test_qemu_strtosz_simple(void)\n\n{\n\n    const char *str;\n\n    char *endptr = NULL;\n\n    int64_t res;\n\n\n\n    str = \"0\";\n\n    res = qemu_strtosz(str, &endptr);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str + 1);\n\n\n\n    str = \"12345\";\n\n    res = qemu_strtosz(str, &endptr);\n\n    g_assert_cmpint(res, ==, 12345);\n\n    g_assert(endptr == str + 5);\n\n\n\n    res = qemu_strtosz(str, NULL);\n\n    g_assert_cmpint(res, ==, 12345);\n\n\n\n    \/* Note: precision is 53 bits since we're parsing with strtod() *\/\n\n\n\n    str = \"9007199254740991\"; \/* 2^53-1 *\/\n\n    res = qemu_strtosz(str, &endptr);\n\n    g_assert_cmpint(res, ==, 0x1fffffffffffff);\n\n    g_assert(endptr == str + 16);\n\n\n\n    str = \"9007199254740992\"; \/* 2^53 *\/\n\n    res = qemu_strtosz(str, &endptr);\n\n    g_assert_cmpint(res, ==, 0x20000000000000);\n\n    g_assert(endptr == str + 16);\n\n\n\n    str = \"9007199254740993\"; \/* 2^53+1 *\/\n\n    res = qemu_strtosz(str, &endptr);\n\n    g_assert_cmpint(res, ==, 0x20000000000000); \/* rounded to 53 bits *\/\n\n    g_assert(endptr == str + 16);\n\n\n\n    str = \"9223372036854774784\"; \/* 0x7ffffffffffffc00 (53 msbs set) *\/\n\n    res = qemu_strtosz(str, &endptr);\n\n    g_assert_cmpint(res, ==, 0x7ffffffffffffc00);\n\n    g_assert(endptr == str + 19);\n\n\n\n    str = \"9223372036854775295\"; \/* 0x7ffffffffffffdff *\/\n\n    res = qemu_strtosz(str, &endptr);\n\n    g_assert_cmpint(res, ==, 0x7ffffffffffffc00); \/* rounded to 53 bits *\/\n\n    g_assert(endptr == str + 19);\n\n\n\n    \/* 0x7ffffffffffffe00..0x7fffffffffffffff get rounded to\n\n     * 0x8000000000000000, thus -ERANGE; see test_qemu_strtosz_erange() *\/\n\n}\n"},{"project":"qemu","commit_id":"5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b","target":0,"func":"static uint8_t read_u8(uint8_t *data, size_t offset)\n\n{\n\n    return data[offset];\n\n}\n"},{"project":"qemu","commit_id":"a2bebfd6e09d285aa793cae3fb0fc3a39a9fee6e","target":1,"func":"long vnc_client_read_ws(VncState *vs)\n\n{\n\n    int ret, err;\n\n    uint8_t *payload;\n\n    size_t payload_size, frame_size;\n\n    VNC_DEBUG(\"Read websocket %p size %zd offset %zd\\n\", vs->ws_input.buffer,\n\n            vs->ws_input.capacity, vs->ws_input.offset);\n\n    buffer_reserve(&vs->ws_input, 4096);\n\n    ret = vnc_client_read_buf(vs, buffer_end(&vs->ws_input), 4096);\n\n    if (!ret) {\n\n        return 0;\n\n    }\n\n    vs->ws_input.offset += ret;\n\n\n\n    \/* make sure that nothing is left in the ws_input buffer *\/\n\n    do {\n\n        err = vncws_decode_frame(&vs->ws_input, &payload,\n\n                              &payload_size, &frame_size);\n\n        if (err <= 0) {\n\n            return err;\n\n        }\n\n\n\n        buffer_reserve(&vs->input, payload_size);\n\n        buffer_append(&vs->input, payload, payload_size);\n\n\n\n        buffer_advance(&vs->ws_input, frame_size);\n\n    } while (vs->ws_input.offset > 0);\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"09b9418c6d085a0728372aa760ebd10128a020b1","target":1,"func":"static void do_info_registers(Monitor *mon)\n\n{\n\n    CPUState *env;\n\n    env = mon_get_cpu();\n\n    if (!env)\n\n        return;\n\n#ifdef TARGET_I386\n\n    cpu_dump_state(env, (FILE *)mon, monitor_fprintf,\n\n                   X86_DUMP_FPU);\n\n#else\n\n    cpu_dump_state(env, (FILE *)mon, monitor_fprintf,\n\n                   0);\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"c34d440a728fd3b5099d11dec122d440ef092c23","target":0,"func":"static int kvm_mce_in_progress(CPUState *env)\n\n{\n\n    struct kvm_msr_entry msr_mcg_status = {\n\n        .index = MSR_MCG_STATUS,\n\n    };\n\n    int r;\n\n\n\n    r = kvm_get_msr(env, &msr_mcg_status, 1);\n\n    if (r == -1 || r == 0) {\n\n        fprintf(stderr, \"Failed to get MCE status\\n\");\n\n        return 0;\n\n    }\n\n    return !!(msr_mcg_status.data & MCG_STATUS_MCIP);\n\n}\n"},{"project":"qemu","commit_id":"c5acdc9ab4e6aa9b05e6242114479333b15d496b","target":0,"func":"static void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->job);\n\n    assert(bdrv_op_blocker_is_empty(bs));\n\n    assert(!bs->refcnt);\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    bdrv_close(bs);\n\n\n\n    \/* remove from list, if necessary *\/\n\n    bdrv_make_anon(bs);\n\n\n\n    g_free(bs);\n\n}\n"},{"project":"qemu","commit_id":"3c0c47e3464f3c54bd3f1cc6d4da2cbf7465e295","target":1,"func":"static void spapr_machine_device_unplug(HotplugHandler *hotplug_dev,\n\n                                      DeviceState *dev, Error **errp)\n\n{\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(qdev_get_machine());\n\n\n\n    if (object_dynamic_cast(OBJECT(dev), TYPE_PC_DIMM)) {\n\n        error_setg(errp, \"Memory hot unplug not supported by sPAPR\");\n\n    } else if (object_dynamic_cast(OBJECT(dev), TYPE_SPAPR_CPU_CORE)) {\n\n        if (!smc->dr_cpu_enabled) {\n\n            error_setg(errp, \"CPU hot unplug not supported on this machine\");\n\n            return;\n\n        }\n\n        spapr_core_unplug(hotplug_dev, dev, errp);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"bc7c08a2c375acb7ae4d433054415588b176d34c","target":0,"func":"static void test_qemu_strtoul_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, NULL, 0, &res);\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, -321ul);\n\n}\n"},{"project":"qemu","commit_id":"fde58177aa112da377bbe1af71e0ec3ee7750196","target":1,"func":"static uint64_t vmxnet3_get_command_status(VMXNET3State *s)\n\n{\n\n    uint64_t ret;\n\n\n\n    switch (s->last_command) {\n\n    case VMXNET3_CMD_ACTIVATE_DEV:\n\n        ret = (s->device_active) ? 0 : -1;\n\n        VMW_CFPRN(\"Device active: %\" PRIx64, ret);\n\n        break;\n\n\n\n    case VMXNET3_CMD_RESET_DEV:\n\n    case VMXNET3_CMD_QUIESCE_DEV:\n\n    case VMXNET3_CMD_GET_QUEUE_STATUS:\n\n        ret = 0;\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_LINK:\n\n        ret = s->link_status_and_speed;\n\n        VMW_CFPRN(\"Link and speed: %\" PRIx64, ret);\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_PERM_MAC_LO:\n\n        ret = vmxnet3_get_mac_low(&s->perm_mac);\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_PERM_MAC_HI:\n\n        ret = vmxnet3_get_mac_high(&s->perm_mac);\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_CONF_INTR:\n\n        ret = vmxnet3_get_interrupt_config(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_ADAPTIVE_RING_INFO:\n\n        ret = VMXNET3_DISABLE_ADAPTIVE_RING;\n\n        break;\n\n\n\n    default:\n\n        VMW_WRPRN(\"Received request for unknown command: %x\", s->last_command);\n\n        ret = -1;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"6687b79d636cd60ed9adb1177d0d946b58fa7717","target":1,"func":"int net_init_slirp(QemuOpts *opts, const char *name, VLANState *vlan)\n\n{\n\n    struct slirp_config_str *config;\n\n    const char *vhost;\n\n    const char *vhostname;\n\n    const char *vdhcp_start;\n\n    const char *vnamesrv;\n\n    const char *tftp_export;\n\n    const char *bootfile;\n\n    const char *smb_export;\n\n    const char *vsmbsrv;\n\n    const char *restrict_opt;\n\n    char *vnet = NULL;\n\n    int restricted = 0;\n\n    int ret;\n\n\n\n    vhost       = qemu_opt_get(opts, \"host\");\n\n    vhostname   = qemu_opt_get(opts, \"hostname\");\n\n    vdhcp_start = qemu_opt_get(opts, \"dhcpstart\");\n\n    vnamesrv    = qemu_opt_get(opts, \"dns\");\n\n    tftp_export = qemu_opt_get(opts, \"tftp\");\n\n    bootfile    = qemu_opt_get(opts, \"bootfile\");\n\n    smb_export  = qemu_opt_get(opts, \"smb\");\n\n    vsmbsrv     = qemu_opt_get(opts, \"smbserver\");\n\n\n\n    restrict_opt = qemu_opt_get(opts, \"restrict\");\n\n    if (restrict_opt) {\n\n        if (!strcmp(restrict_opt, \"on\") ||\n\n            !strcmp(restrict_opt, \"yes\") || !strcmp(restrict_opt, \"y\")) {\n\n            restricted = 1;\n\n        } else if (strcmp(restrict_opt, \"off\") &&\n\n            strcmp(restrict_opt, \"no\") && strcmp(restrict_opt, \"n\")) {\n\n            error_report(\"invalid option: 'restrict=%s'\", restrict_opt);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"ip\")) {\n\n        const char *ip = qemu_opt_get(opts, \"ip\");\n\n        int l = strlen(ip) + strlen(\"\/24\") + 1;\n\n\n\n        vnet = g_malloc(l);\n\n\n\n        \/* emulate legacy ip= parameter *\/\n\n        pstrcpy(vnet, l, ip);\n\n        pstrcat(vnet, l, \"\/24\");\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"net\")) {\n\n        if (vnet) {\n\n            g_free(vnet);\n\n        }\n\n        vnet = g_strdup(qemu_opt_get(opts, \"net\"));\n\n    }\n\n\n\n    qemu_opt_foreach(opts, net_init_slirp_configs, NULL, 0);\n\n\n\n    ret = net_slirp_init(vlan, \"user\", name, restricted, vnet, vhost,\n\n                         vhostname, tftp_export, bootfile, vdhcp_start,\n\n                         vnamesrv, smb_export, vsmbsrv);\n\n\n\n    while (slirp_configs) {\n\n        config = slirp_configs;\n\n        slirp_configs = config->next;\n\n        g_free(config);\n\n    }\n\n\n\n    g_free(vnet);\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"880a7578381d1c7ed4d41c7599ae3cc06567a824","target":0,"func":"static void gdb_read_byte(GDBState *s, int ch)\n\n{\n\n    CPUState *env = s->env;\n\n    int i, csum;\n\n    uint8_t reply;\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if (s->last_packet_len) {\n\n        \/* Waiting for a response to the last packet.  If we see the start\n\n           of a new command then abandon the previous response.  *\/\n\n        if (ch == '-') {\n\n#ifdef DEBUG_GDB\n\n            printf(\"Got NACK, retransmitting\\n\");\n\n#endif\n\n            put_buffer(s, (uint8_t *)s->last_packet, s->last_packet_len);\n\n        }\n\n#ifdef DEBUG_GDB\n\n        else if (ch == '+')\n\n            printf(\"Got ACK\\n\");\n\n        else\n\n            printf(\"Got '%c' when expecting ACK\/NACK\\n\", ch);\n\n#endif\n\n        if (ch == '+' || ch == '$')\n\n            s->last_packet_len = 0;\n\n        if (ch != '$')\n\n            return;\n\n    }\n\n    if (vm_running) {\n\n        \/* when the CPU is running, we cannot do anything except stop\n\n           it when receiving a char *\/\n\n        vm_stop(EXCP_INTERRUPT);\n\n    } else\n\n#endif\n\n    {\n\n        switch(s->state) {\n\n        case RS_IDLE:\n\n            if (ch == '$') {\n\n                s->line_buf_index = 0;\n\n                s->state = RS_GETLINE;\n\n            }\n\n            break;\n\n        case RS_GETLINE:\n\n            if (ch == '#') {\n\n            s->state = RS_CHKSUM1;\n\n            } else if (s->line_buf_index >= sizeof(s->line_buf) - 1) {\n\n                s->state = RS_IDLE;\n\n            } else {\n\n            s->line_buf[s->line_buf_index++] = ch;\n\n            }\n\n            break;\n\n        case RS_CHKSUM1:\n\n            s->line_buf[s->line_buf_index] = '\\0';\n\n            s->line_csum = fromhex(ch) << 4;\n\n            s->state = RS_CHKSUM2;\n\n            break;\n\n        case RS_CHKSUM2:\n\n            s->line_csum |= fromhex(ch);\n\n            csum = 0;\n\n            for(i = 0; i < s->line_buf_index; i++) {\n\n                csum += s->line_buf[i];\n\n            }\n\n            if (s->line_csum != (csum & 0xff)) {\n\n                reply = '-';\n\n                put_buffer(s, &reply, 1);\n\n                s->state = RS_IDLE;\n\n            } else {\n\n                reply = '+';\n\n                put_buffer(s, &reply, 1);\n\n                s->state = gdb_handle_packet(s, env, s->line_buf);\n\n            }\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"37f51384ae05bd50f83308339dbffa3e78404874","target":0,"func":"static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    uint8_t bus_n = pci_bus_num(vtd_as->bus);\n\n    VTDContextEntry ce;\n\n\n\n    \/*\n\n     * The replay can be triggered by either a invalidation or a newly\n\n     * created entry. No matter what, we release existing mappings\n\n     * (it means flushing caches for UNMAP-only registers).\n\n     *\/\n\n    vtd_address_space_unmap(vtd_as, n);\n\n\n\n    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {\n\n        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                  PCI_FUNC(vtd_as->devfn),\n\n                                  VTD_CONTEXT_ENTRY_DID(ce.hi),\n\n                                  ce.hi, ce.lo);\n\n        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);\n\n    } else {\n\n        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                    PCI_FUNC(vtd_as->devfn));\n\n    }\n\n\n\n    return;\n\n}\n"},{"project":"qemu","commit_id":"9be385980d37e8f4fd33f605f5fb1c3d144170a8","target":0,"func":"static uint64_t megasas_fw_time(void)\n\n{\n\n    struct tm curtime;\n\n    uint64_t bcd_time;\n\n\n\n    qemu_get_timedate(&curtime, 0);\n\n    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |\n\n        ((uint64_t)curtime.tm_min & 0xff)  << 40 |\n\n        ((uint64_t)curtime.tm_hour & 0xff) << 32 |\n\n        ((uint64_t)curtime.tm_mday & 0xff) << 24 |\n\n        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |\n\n        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);\n\n\n\n    return bcd_time;\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static int omap_validate_emifs_addr(struct omap_mpu_state_s *s,\n\n                target_phys_addr_t addr)\n\n{\n\n    return range_covers_byte(OMAP_EMIFS_BASE, OMAP_EMIFF_BASE - OMAP_EMIFS_BASE,\n\n                             addr);\n\n}\n"},{"project":"qemu","commit_id":"7f0278435df1fa845b3bd9556942f89296d4246b","target":1,"func":"const char *qdict_get_str(const QDict *qdict, const char *key)\n\n{\n\n    QObject *obj = qdict_get_obj(qdict, key, QTYPE_QSTRING);\n\n    return qstring_get_str(qobject_to_qstring(obj));\n\n}\n"},{"project":"qemu","commit_id":"ef0e64a9838c0a20b5cb8a0bd2dcbcc59b0b812d","target":0,"func":"BlockAIOCB *ide_issue_trim(\n\n        int64_t offset, QEMUIOVector *qiov,\n\n        BlockCompletionFunc *cb, void *cb_opaque, void *opaque)\n\n{\n\n    BlockBackend *blk = opaque;\n\n    TrimAIOCB *iocb;\n\n\n\n    iocb = blk_aio_get(&trim_aiocb_info, blk, cb, cb_opaque);\n\n    iocb->blk = blk;\n\n    iocb->bh = qemu_bh_new(ide_trim_bh_cb, iocb);\n\n    iocb->ret = 0;\n\n    iocb->qiov = qiov;\n\n    iocb->i = -1;\n\n    iocb->j = 0;\n\n    ide_issue_trim_cb(iocb, 0);\n\n    return &iocb->common;\n\n}\n"},{"project":"qemu","commit_id":"0e9b9edae7bebfd31fdbead4ccbbce03876a7edd","target":0,"func":"GArray *bios_linker_loader_init(void)\n\n{\n\n    return g_array_new(false, true \/* clear *\/, 1);\n\n}\n"},{"project":"qemu","commit_id":"2bd3bce8efebe86b031beab5c0e3b9bbaec0b502","target":1,"func":"void bdrv_error_action(BlockDriverState *bs, BlockErrorAction action,\n\n                       bool is_read, int error)\n\n{\n\n    assert(error >= 0);\n\n    bdrv_emit_qmp_error_event(bs, QEVENT_BLOCK_IO_ERROR, action, is_read);\n\n    if (action == BDRV_ACTION_STOP) {\n\n        vm_stop(RUN_STATE_IO_ERROR);\n\n        bdrv_iostatus_set_err(bs, error);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"027d9a7d2911e993cdcbd21c7c35d1dd058f05bb","target":1,"func":"static inline void cpu_handle_interrupt(CPUState *cpu,\n\n                                        TranslationBlock **last_tb)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    int interrupt_request = cpu->interrupt_request;\n\n\n\n    if (unlikely(interrupt_request)) {\n\n        if (unlikely(cpu->singlestep_enabled & SSTEP_NOIRQ)) {\n\n            \/* Mask out external interrupts for this step. *\/\n\n            interrupt_request &= ~CPU_INTERRUPT_SSTEP_MASK;\n\n        }\n\n        if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n            cpu->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n            cpu->exception_index = EXCP_DEBUG;\n\n            cpu_loop_exit(cpu);\n\n        }\n\n        if (replay_mode == REPLAY_MODE_PLAY && !replay_has_interrupt()) {\n\n            \/* Do nothing *\/\n\n        } else if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n            replay_interrupt();\n\n            cpu->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n            cpu->halted = 1;\n\n            cpu->exception_index = EXCP_HLT;\n\n            cpu_loop_exit(cpu);\n\n        }\n\n#if defined(TARGET_I386)\n\n        else if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n            X86CPU *x86_cpu = X86_CPU(cpu);\n\n            CPUArchState *env = &x86_cpu->env;\n\n            replay_interrupt();\n\n            cpu_svm_check_intercept_param(env, SVM_EXIT_INIT, 0);\n\n            do_cpu_init(x86_cpu);\n\n            cpu->exception_index = EXCP_HALTED;\n\n            cpu_loop_exit(cpu);\n\n        }\n\n#else\n\n        else if (interrupt_request & CPU_INTERRUPT_RESET) {\n\n            replay_interrupt();\n\n            cpu_reset(cpu);\n\n            cpu_loop_exit(cpu);\n\n        }\n\n#endif\n\n        \/* The target hook has 3 exit conditions:\n\n           False when the interrupt isn't processed,\n\n           True when it is, and we should restart on a new TB,\n\n           and via longjmp via cpu_loop_exit.  *\/\n\n        else {\n\n            replay_interrupt();\n\n            if (cc->cpu_exec_interrupt(cpu, interrupt_request)) {\n\n                *last_tb = NULL;\n\n            }\n\n            \/* The target hook may have updated the 'cpu->interrupt_request';\n\n             * reload the 'interrupt_request' value *\/\n\n            interrupt_request = cpu->interrupt_request;\n\n        }\n\n        if (interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n            cpu->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n            \/* ensure that no TB jump will be modified as\n\n               the program flow was changed *\/\n\n            *last_tb = NULL;\n\n        }\n\n    }\n\n    if (unlikely(cpu->exit_request || replay_has_interrupt())) {\n\n        cpu->exit_request = 0;\n\n        cpu->exception_index = EXCP_INTERRUPT;\n\n        cpu_loop_exit(cpu);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"3bc36a401e0f33e63a4d2c58b646ddf78efb567c","target":1,"func":"static USBDevice *usb_serial_init(USBBus *bus, const char *filename)\n\n{\n\n    USBDevice *dev;\n\n    CharDriverState *cdrv;\n\n    uint32_t vendorid = 0, productid = 0;\n\n    char label[32];\n\n    static int index;\n\n\n\n    while (*filename && *filename != ':') {\n\n        const char *p;\n\n        char *e;\n\n        if (strstart(filename, \"vendorid=\", &p)) {\n\n            vendorid = strtol(p, &e, 16);\n\n            if (e == p || (*e && *e != ',' && *e != ':')) {\n\n                error_report(\"bogus vendor ID %s\", p);\n\n                return NULL;\n\n            }\n\n            filename = e;\n\n        } else if (strstart(filename, \"productid=\", &p)) {\n\n            productid = strtol(p, &e, 16);\n\n            if (e == p || (*e && *e != ',' && *e != ':')) {\n\n                error_report(\"bogus product ID %s\", p);\n\n                return NULL;\n\n            }\n\n            filename = e;\n\n        } else {\n\n            error_report(\"unrecognized serial USB option %s\", filename);\n\n            return NULL;\n\n        }\n\n        while(*filename == ',')\n\n            filename++;\n\n    }\n\n    if (!*filename) {\n\n        error_report(\"character device specification needed\");\n\n        return NULL;\n\n    }\n\n    filename++;\n\n\n\n    snprintf(label, sizeof(label), \"usbserial%d\", index++);\n\n    cdrv = qemu_chr_new(label, filename, NULL);\n\n    if (!cdrv)\n\n        return NULL;\n\n\n\n    dev = usb_create(bus, \"usb-serial\");\n\n    qdev_prop_set_chr(&dev->qdev, \"chardev\", cdrv);\n\n    if (vendorid)\n\n        qdev_prop_set_uint16(&dev->qdev, \"vendorid\", vendorid);\n\n    if (productid)\n\n        qdev_prop_set_uint16(&dev->qdev, \"productid\", productid);\n\n    qdev_init_nofail(&dev->qdev);\n\n\n\n    return dev;\n\n}\n"},{"project":"qemu","commit_id":"e1833e1f96456fd8fc17463246fe0b2050e68efb","target":0,"func":"static void spr_write_40x_dbcr0 (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_40x_dbcr0();\n\n    \/* We must stop translation as we may have rebooted *\/\n\n    RET_STOP(ctx);\n\n}\n"},{"project":"qemu","commit_id":"8917c3bdba37d6fe4393db0fad3fabbde9530d6b","target":0,"func":"sofcantrcvmore(struct socket *so)\n\n{\n\n\tif ((so->so_state & SS_NOFDREF) == 0) {\n\n\t\tshutdown(so->s,0);\n\n\t\tif(global_writefds) {\n\n\t\t  FD_CLR(so->s,global_writefds);\n\n\t\t}\n\n\t}\n\n\tso->so_state &= ~(SS_ISFCONNECTING);\n\n\tif (so->so_state & SS_FCANTSENDMORE) {\n\n\t   so->so_state &= SS_PERSISTENT_MASK;\n\n\t   so->so_state |= SS_NOFDREF; \/* Don't select it *\/\n\n\t} else {\n\n\t   so->so_state |= SS_FCANTRCVMORE;\n\n\t}\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"void *iommu_dma_memory_map(DMAContext *dma, dma_addr_t addr, dma_addr_t *len,\n\n                           DMADirection dir)\n\n{\n\n    int err;\n\n    target_phys_addr_t paddr, plen;\n\n    void *buf;\n\n\n\n    if (dma->map) {\n\n        return dma->map(dma, addr, len, dir);\n\n    }\n\n\n\n    plen = *len;\n\n    err = dma->translate(dma, addr, &paddr, &plen, dir);\n\n    if (err) {\n\n        return NULL;\n\n    }\n\n\n\n    \/*\n\n     * If this is true, the virtual region is contiguous,\n\n     * but the translated physical region isn't. We just\n\n     * clamp *len, much like address_space_map() does.\n\n     *\/\n\n    if (plen < *len) {\n\n        *len = plen;\n\n    }\n\n\n\n    buf = address_space_map(dma->as, paddr, &plen, dir == DMA_DIRECTION_FROM_DEVICE);\n\n    *len = plen;\n\n\n\n    return buf;\n\n}\n"},{"project":"qemu","commit_id":"5706db1deb061ee9affdcea81e59c4c2cad7c41e","target":1,"func":"static int line_out_init (HWVoiceOut *hw, struct audsettings *as)\n\n{\n\n    SpiceVoiceOut *out = container_of (hw, SpiceVoiceOut, hw);\n\n    struct audsettings settings;\n\n\n\n#if SPICE_INTERFACE_PLAYBACK_MAJOR > 1 || SPICE_INTERFACE_PLAYBACK_MINOR >= 3\n\n    settings.freq       = spice_server_get_best_playback_rate(NULL);\n\n#else\n\n    settings.freq       = SPICE_INTERFACE_PLAYBACK_FREQ;\n\n#endif\n\n    settings.nchannels  = SPICE_INTERFACE_PLAYBACK_CHAN;\n\n    settings.fmt        = AUD_FMT_S16;\n\n    settings.endianness = AUDIO_HOST_ENDIANNESS;\n\n\n\n    audio_pcm_init_info (&hw->info, &settings);\n\n    hw->samples = LINE_OUT_SAMPLES;\n\n    out->active = 0;\n\n\n\n    out->sin.base.sif = &playback_sif.base;\n\n    qemu_spice_add_interface (&out->sin.base);\n\n#if SPICE_INTERFACE_PLAYBACK_MAJOR > 1 || SPICE_INTERFACE_PLAYBACK_MINOR >= 3\n\n    spice_server_set_playback_rate(&out->sin, settings.freq);\n\n#endif\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"e6afc87f804abee7d0479be5e8e31c56d885fafb","target":1,"func":"static float32 roundAndPackFloat32( flag zSign, int16 zExp, uint32_t zSig STATUS_PARAM)\n\n{\n\n    int8 roundingMode;\n\n    flag roundNearestEven;\n\n    int8 roundIncrement, roundBits;\n\n    flag isTiny;\n\n\n\n    roundingMode = STATUS(float_rounding_mode);\n\n    roundNearestEven = ( roundingMode == float_round_nearest_even );\n\n    roundIncrement = 0x40;\n\n    if ( ! roundNearestEven ) {\n\n        if ( roundingMode == float_round_to_zero ) {\n\n            roundIncrement = 0;\n\n        }\n\n        else {\n\n            roundIncrement = 0x7F;\n\n            if ( zSign ) {\n\n                if ( roundingMode == float_round_up ) roundIncrement = 0;\n\n            }\n\n            else {\n\n                if ( roundingMode == float_round_down ) roundIncrement = 0;\n\n            }\n\n        }\n\n    }\n\n    roundBits = zSig & 0x7F;\n\n    if ( 0xFD <= (uint16_t) zExp ) {\n\n        if (    ( 0xFD < zExp )\n\n             || (    ( zExp == 0xFD )\n\n                  && ( (int32_t) ( zSig + roundIncrement ) < 0 ) )\n\n           ) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat32( zSign, 0xFF, - ( roundIncrement == 0 ));\n\n        }\n\n        if ( zExp < 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat32( zSign, 0, 0 );\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < -1 )\n\n                || ( zSig + roundIncrement < 0x80000000 );\n\n            shift32RightJamming( zSig, - zExp, &zSig );\n\n            zExp = 0;\n\n            roundBits = zSig & 0x7F;\n\n            if ( isTiny && roundBits ) float_raise( float_flag_underflow STATUS_VAR);\n\n        }\n\n    }\n\n    if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    zSig = ( zSig + roundIncrement )>>7;\n\n    zSig &= ~ ( ( ( roundBits ^ 0x40 ) == 0 ) & roundNearestEven );\n\n    if ( zSig == 0 ) zExp = 0;\n\n    return packFloat32( zSign, zExp, zSig );\n\n\n\n}\n"},{"project":"qemu","commit_id":"9706e0162d2405218fd7376ffdf13baed8569a4b","target":0,"func":"int bitbang_i2c_set(bitbang_i2c_interface *i2c, int line, int level)\n\n{\n\n    int data;\n\n\n\n    if (level != 0 && level != 1) {\n\n        abort();\n\n    }\n\n\n\n    if (line == BITBANG_I2C_SDA) {\n\n        if (level == i2c->last_data) {\n\n            return bitbang_i2c_nop(i2c);\n\n        }\n\n        i2c->last_data = level;\n\n        if (i2c->last_clock == 0) {\n\n            return bitbang_i2c_nop(i2c);\n\n        }\n\n        if (level == 0) {\n\n            DPRINTF(\"START\\n\");\n\n            \/* START condition.  *\/\n\n            i2c->state = SENDING_BIT7;\n\n            i2c->current_addr = -1;\n\n        } else {\n\n            \/* STOP condition.  *\/\n\n            bitbang_i2c_enter_stop(i2c);\n\n        }\n\n        return bitbang_i2c_ret(i2c, 1);\n\n    }\n\n\n\n    data = i2c->last_data;\n\n    if (i2c->last_clock == level) {\n\n        return bitbang_i2c_nop(i2c);\n\n    }\n\n    i2c->last_clock = level;\n\n    if (level == 0) {\n\n        \/* State is set\/read at the start of the clock pulse.\n\n           release the data line at the end.  *\/\n\n        return bitbang_i2c_ret(i2c, 1);\n\n    }\n\n    switch (i2c->state) {\n\n    case STOPPED:\n\n    case SENT_NACK:\n\n        return bitbang_i2c_ret(i2c, 1);\n\n\n\n    case SENDING_BIT7 ... SENDING_BIT0:\n\n        i2c->buffer = (i2c->buffer << 1) | data;\n\n        \/* will end up in WAITING_FOR_ACK *\/\n\n        i2c->state++; \n\n        return bitbang_i2c_ret(i2c, 1);\n\n\n\n    case WAITING_FOR_ACK:\n\n        if (i2c->current_addr < 0) {\n\n            i2c->current_addr = i2c->buffer;\n\n            DPRINTF(\"Address 0x%02x\\n\", i2c->current_addr);\n\n            i2c_start_transfer(i2c->bus, i2c->current_addr >> 1,\n\n                               i2c->current_addr & 1);\n\n        } else {\n\n            DPRINTF(\"Sent 0x%02x\\n\", i2c->buffer);\n\n            i2c_send(i2c->bus, i2c->buffer);\n\n        }\n\n        if (i2c->current_addr & 1) {\n\n            i2c->state = RECEIVING_BIT7;\n\n        } else {\n\n            i2c->state = SENDING_BIT7;\n\n        }\n\n        return bitbang_i2c_ret(i2c, 0);\n\n\n\n    case RECEIVING_BIT7:\n\n        i2c->buffer = i2c_recv(i2c->bus);\n\n        DPRINTF(\"RX byte 0x%02x\\n\", i2c->buffer);\n\n        \/* Fall through... *\/\n\n    case RECEIVING_BIT6 ... RECEIVING_BIT0:\n\n        data = i2c->buffer >> 7;\n\n        \/* will end up in SENDING_ACK *\/\n\n        i2c->state++;\n\n        i2c->buffer <<= 1;\n\n        return bitbang_i2c_ret(i2c, data);\n\n\n\n    case SENDING_ACK:\n\n        i2c->state = RECEIVING_BIT7;\n\n        if (data != 0) {\n\n            DPRINTF(\"NACKED\\n\");\n\n            i2c->state = SENT_NACK;\n\n            i2c_nack(i2c->bus);\n\n        } else {\n\n            DPRINTF(\"ACKED\\n\");\n\n        }\n\n        return bitbang_i2c_ret(i2c, 1);\n\n    }\n\n    abort();\n\n}\n"},{"project":"qemu","commit_id":"7466bc49107fbd84336ba680f860d5eadd6def13","target":0,"func":"void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    sdpy.ds = ds;\n\n    sdpy.bufsize = (16 * 1024 * 1024);\n\n    sdpy.buf = qemu_malloc(sdpy.bufsize);\n\n    pthread_mutex_init(&sdpy.lock, NULL);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_add_vm_change_state_handler(qemu_spice_vm_change_state_handler, &sdpy);\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void bmdma_addr_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t data, unsigned width)\n\n{\n\n    BMDMAState *bm = opaque;\n\n    int shift = addr * 8;\n\n    uint32_t mask = (1ULL << (width * 8)) - 1;\n\n\n\n#ifdef DEBUG_IDE\n\n    printf(\"%s: 0x%08x\\n\", __func__, (unsigned)data);\n\n#endif\n\n    bm->addr &= ~(mask << shift);\n\n    bm->addr |= ((data & mask) << shift) & ~3;\n\n}\n"},{"project":"qemu","commit_id":"72cf2d4f0e181d0d3a3122e04129c58a95da713e","target":0,"func":"int cpu_watchpoint_insert(CPUState *env, target_ulong addr, target_ulong len,\n\n                          int flags, CPUWatchpoint **watchpoint)\n\n{\n\n    target_ulong len_mask = ~(len - 1);\n\n    CPUWatchpoint *wp;\n\n\n\n    \/* sanity checks: allow power-of-2 lengths, deny unaligned watchpoints *\/\n\n    if ((len != 1 && len != 2 && len != 4 && len != 8) || (addr & ~len_mask)) {\n\n        fprintf(stderr, \"qemu: tried to set invalid watchpoint at \"\n\n                TARGET_FMT_lx \", len=\" TARGET_FMT_lu \"\\n\", addr, len);\n\n        return -EINVAL;\n\n    }\n\n    wp = qemu_malloc(sizeof(*wp));\n\n\n\n    wp->vaddr = addr;\n\n    wp->len_mask = len_mask;\n\n    wp->flags = flags;\n\n\n\n    \/* keep all GDB-injected watchpoints in front *\/\n\n    if (flags & BP_GDB)\n\n        TAILQ_INSERT_HEAD(&env->watchpoints, wp, entry);\n\n    else\n\n        TAILQ_INSERT_TAIL(&env->watchpoints, wp, entry);\n\n\n\n    tlb_flush_page(env, addr);\n\n\n\n    if (watchpoint)\n\n        *watchpoint = wp;\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"b5469b1104a4b0c870dd805d9fb9d844b56d987e","target":1,"func":"void vnc_tight_clear(VncState *vs)\n\n{\n\n    int i;\n\n    for (i=0; i<ARRAY_SIZE(vs->tight.stream); i++) {\n\n        if (vs->tight.stream[i].opaque) {\n\n            deflateEnd(&vs->tight.stream[i]);\n\n        }\n\n    }\n\n\n\n    buffer_free(&vs->tight.tight);\n\n    buffer_free(&vs->tight.zlib);\n\n    buffer_free(&vs->tight.gradient);\n\n#ifdef CONFIG_VNC_JPEG\n\n    buffer_free(&vs->tight.jpeg);\n\n\n\n\n\n}"},{"project":"qemu","commit_id":"b86160555f8d1fe11d6bcec393e08e645d7e1e8d","target":1,"func":"static void integratorcp_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    ARMCPU *cpu;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_alias = g_new(MemoryRegion, 1);\n\n    qemu_irq pic[32];\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"arm926\";\n\n    }\n\n    cpu = cpu_arm_init(cpu_model);\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(ram, NULL, \"integrator.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    \/* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  *\/\n\n    \/* ??? RAM should repeat to fill physical memory space.  *\/\n\n    \/* SDRAM at address zero*\/\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n    \/* And again at address 0x80000000 *\/\n\n    memory_region_init_alias(ram_alias, NULL, \"ram.alias\", ram, 0, ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias);\n\n\n\n    dev = qdev_create(NULL, TYPE_INTEGRATOR_CM);\n\n    qdev_prop_set_uint32(dev, \"memsz\", ram_size >> 20);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map((SysBusDevice *)dev, 0, 0x10000000);\n\n\n\n    dev = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000,\n\n                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ),\n\n                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ),\n\n                                NULL);\n\n    for (i = 0; i < 32; i++) {\n\n        pic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic[26]);\n\n    sysbus_create_varargs(\"integrator_pit\", 0x13000000,\n\n                          pic[5], pic[6], pic[7], NULL);\n\n    sysbus_create_simple(\"pl031\", 0x15000000, pic[8]);\n\n    sysbus_create_simple(\"pl011\", 0x16000000, pic[1]);\n\n    sysbus_create_simple(\"pl011\", 0x17000000, pic[2]);\n\n    icp_control_init(0xcb000000);\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x18000000, pic[3]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x19000000, pic[4]);\n\n\n    sysbus_create_varargs(\"pl181\", 0x1c000000, pic[23], pic[24], NULL);\n\n    if (nd_table[0].used)\n\n        smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n\n\n    sysbus_create_simple(\"pl110\", 0xc0000000, pic[22]);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(cpu, &integrator_binfo);\n\n}"},{"project":"qemu","commit_id":"b3ceef24f4fee8d5ed96b8c4a5d3e80c0a651f0b","target":0,"func":"static void ss10_init(int ram_size, int vga_ram_size, int boot_device,\n\n                            DisplayState *ds, const char **fd_filename, int snapshot,\n\n                            const char *kernel_filename, const char *kernel_cmdline,\n\n                            const char *initrd_filename, const char *cpu_model)\n\n{\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"TI SuperSparc II\";\n\n    sun4m_common_init(ram_size, boot_device, ds, kernel_filename,\n\n                      kernel_cmdline, initrd_filename, cpu_model,\n\n                      1, PROM_ADDR); \/\/ XXX prom overlap, actually first 4GB ok\n\n}\n"},{"project":"qemu","commit_id":"4fa4ce7107c6ec432f185307158c5df91ce54308","target":0,"func":"static int local_opendir(FsContext *ctx,\n\n                         V9fsPath *fs_path, V9fsFidOpenState *fs)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    fs->dir = opendir(rpath(ctx, path, buffer));\n\n    if (!fs->dir) {\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"6bdc21c050a2a7b92cbbd0b2a1f8934e9b5f896f","target":0,"func":"void virtqueue_map(VirtIODevice *vdev, VirtQueueElement *elem)\n\n{\n\n    virtqueue_map_iovec(vdev, elem->in_sg, elem->in_addr, &elem->in_num,\n\n                        MIN(ARRAY_SIZE(elem->in_sg), ARRAY_SIZE(elem->in_addr)),\n\n                        1);\n\n    virtqueue_map_iovec(vdev, elem->out_sg, elem->out_addr, &elem->out_num,\n\n                        MIN(ARRAY_SIZE(elem->out_sg),\n\n                        ARRAY_SIZE(elem->out_addr)),\n\n                        0);\n\n}\n"},{"project":"qemu","commit_id":"df45892c1290c6c853010b83e5afebe8740cb9fa","target":1,"func":"static ram_addr_t qxl_rom_size(void)\n\n{\n\n    uint32_t required_rom_size = sizeof(QXLRom) + sizeof(QXLModes) +\n\n                                 sizeof(qxl_modes);\n\n    uint32_t rom_size = 8192; \/* two pages *\/\n\n\n\n    QEMU_BUILD_BUG_ON(required_rom_size > rom_size);\n\n    return rom_size;\n\n}\n"},{"project":"qemu","commit_id":"73a8912b8aeed1c992e3f9cb4880e9d1edb935de","target":1,"func":"static void decompress_data_with_multi_threads(QEMUFile *f,\n\n                                               void *host, int len)\n\n{\n\n    int idx, thread_count;\n\n\n\n    thread_count = migrate_decompress_threads();\n\n    while (true) {\n\n        for (idx = 0; idx < thread_count; idx++) {\n\n            if (!decomp_param[idx].start) {\n\n                qemu_get_buffer(f, decomp_param[idx].compbuf, len);\n\n                decomp_param[idx].des = host;\n\n                decomp_param[idx].len = len;\n\n                start_decompression(&decomp_param[idx]);\n\n                break;\n\n            }\n\n        }\n\n        if (idx < thread_count) {\n\n            break;\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"4099df586a0f16522383c4e4a9613e7c2dcd2491","target":0,"func":"static int hdev_create(const char *filename, QEMUOptionParameter *options)\n\n{\n\n    int fd;\n\n    int ret = 0;\n\n    struct stat stat_buf;\n\n    int64_t total_size = 0;\n\n\n\n    \/* Read out options *\/\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, \"size\")) {\n\n            total_size = options->value.n \/ 512;\n\n        }\n\n        options++;\n\n    }\n\n\n\n    fd = open(filename, O_WRONLY | O_BINARY);\n\n    if (fd < 0)\n\n        return -EIO;\n\n\n\n    if (fstat(fd, &stat_buf) < 0)\n\n        ret = -EIO;\n\n    else if (!S_ISBLK(stat_buf.st_mode))\n\n        ret = -EIO;\n\n    else if (lseek(fd, 0, SEEK_END) < total_size * 512)\n\n        ret = -ENOSPC;\n\n\n\n    close(fd);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"6092666ebdc68b2634db050689292c71a5c368c0","target":0,"func":"static void phys_sections_clear(PhysPageMap *map)\n\n{\n\n    while (map->sections_nb > 0) {\n\n        MemoryRegionSection *section = &map->sections[--map->sections_nb];\n\n        phys_section_destroy(section->mr);\n\n    }\n\n    g_free(map->sections);\n\n    g_free(map->nodes);\n\n}\n"},{"project":"qemu","commit_id":"c650c008e326f3a1e84083bc269265456057a212","target":0,"func":"static void setup_frame(int sig, struct target_sigaction *ka,\n\n                        target_sigset_t *set, CPUPPCState *env)\n\n{\n\n    struct target_sigframe *frame;\n\n    struct target_sigcontext *sc;\n\n    target_ulong frame_addr, newsp;\n\n    int err = 0;\n\n    int signal;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof(*frame));\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))\n\n        goto sigsegv;\n\n    sc = &frame->sctx;\n\n\n\n    signal = current_exec_domain_sig(sig);\n\n\n\n    __put_user(ka->_sa_handler, &sc->handler);\n\n    __put_user(set->sig[0], &sc->oldmask);\n\n#if defined(TARGET_PPC64)\n\n    __put_user(set->sig[0] >> 32, &sc->_unused[3]);\n\n#else\n\n    __put_user(set->sig[1], &sc->_unused[3]);\n\n#endif\n\n    __put_user(h2g(&frame->mctx), &sc->regs);\n\n    __put_user(sig, &sc->signal);\n\n\n\n    \/* Save user regs.  *\/\n\n    err |= save_user_regs(env, &frame->mctx, TARGET_NR_sigreturn);\n\n\n\n    \/* The kernel checks for the presence of a VDSO here.  We don't\n\n       emulate a vdso, so use a sigreturn system call.  *\/\n\n    env->lr = (target_ulong) h2g(frame->mctx.tramp);\n\n\n\n    \/* Turn off all fp exceptions.  *\/\n\n    env->fpscr = 0;\n\n\n\n    \/* Create a stack frame for the caller of the handler.  *\/\n\n    newsp = frame_addr - SIGNAL_FRAMESIZE;\n\n    err |= put_user(env->gpr[1], newsp, target_ulong);\n\n\n\n    if (err)\n\n        goto sigsegv;\n\n\n\n    \/* Set up registers for signal handler.  *\/\n\n    env->gpr[1] = newsp;\n\n    env->gpr[3] = signal;\n\n    env->gpr[4] = frame_addr + offsetof(struct target_sigframe, sctx);\n\n    env->nip = (target_ulong) ka->_sa_handler;\n\n    \/* Signal handlers are entered in big-endian mode.  *\/\n\n    env->msr &= ~MSR_LE;\n\n\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    return;\n\n\n\nsigsegv:\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    qemu_log(\"segfaulting from setup_frame\\n\");\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n"},{"project":"qemu","commit_id":"60fe637bf0e4d7989e21e50f52526444765c63b4","target":1,"func":"uint64_t blk_mig_bytes_remaining(void)\n\n{\n\n    return blk_mig_bytes_total() - blk_mig_bytes_transferred();\n\n}\n"},{"project":"qemu","commit_id":"6f2d8978728c48ca46f5c01835438508aace5c64","target":1,"func":"static always_inline void powerpc_excp (CPUState *env,\n\n                                        int excp_model, int excp)\n\n{\n\n    target_ulong msr, new_msr, vector;\n\n    int srr0, srr1, asrr0, asrr1;\n\n#if defined(TARGET_PPC64H)\n\n    int lpes0, lpes1, lev;\n\n\n\n    lpes0 = (env->spr[SPR_LPCR] >> 1) & 1;\n\n    lpes1 = (env->spr[SPR_LPCR] >> 2) & 1;\n\n#endif\n\n\n\n    if (loglevel & CPU_LOG_INT) {\n\n        fprintf(logfile, \"Raise exception at 0x\" ADDRX \" => 0x%08x (%02x)\\n\",\n\n                env->nip, excp, env->error_code);\n\n    }\n\n    msr = env->msr;\n\n    new_msr = msr;\n\n    srr0 = SPR_SRR0;\n\n    srr1 = SPR_SRR1;\n\n    asrr0 = -1;\n\n    asrr1 = -1;\n\n    msr &= ~((target_ulong)0x783F0000);\n\n    switch (excp) {\n\n    case POWERPC_EXCP_NONE:\n\n        \/* Should never happen *\/\n\n        return;\n\n    case POWERPC_EXCP_CRITICAL:    \/* Critical input                         *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); \/* XXX: check this *\/\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_40x:\n\n            srr0 = SPR_40x_SRR2;\n\n            srr1 = SPR_40x_SRR3;\n\n            break;\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        case POWERPC_EXCP_G2:\n\n            break;\n\n        default:\n\n            goto excp_invalid;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_MCHECK:    \/* Machine check exception                  *\/\n\n        if (msr_me == 0) {\n\n            \/* Machine check exception is not enabled.\n\n             * Enter checkstop state.\n\n             *\/\n\n            if (loglevel != 0) {\n\n                fprintf(logfile, \"Machine check while not allowed. \"\n\n                        \"Entering checkstop state\\n\");\n\n            } else {\n\n                fprintf(stderr, \"Machine check while not allowed. \"\n\n                        \"Entering checkstop state\\n\");\n\n            }\n\n            env->halted = 1;\n\n            env->interrupt_request |= CPU_INTERRUPT_EXITTB;\n\n        }\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n        new_msr &= ~((target_ulong)1 << MSR_ME);\n\n#if defined(TARGET_PPC64H)\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        \/* XXX: should also have something loaded in DAR \/ DSISR *\/\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_40x:\n\n            srr0 = SPR_40x_SRR2;\n\n            srr1 = SPR_40x_SRR3;\n\n            break;\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_MCSRR0;\n\n            srr1 = SPR_BOOKE_MCSRR1;\n\n            asrr0 = SPR_BOOKE_CSRR0;\n\n            asrr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_DSI:       \/* Data storage exception                   *\/\n\n#if defined (DEBUG_EXCEPTIONS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"DSI exception: DSISR=0x\" ADDRX\" DAR=0x\" ADDRX\n\n                    \"\\n\", env->spr[SPR_DSISR], env->spr[SPR_DAR]);\n\n        }\n\n#endif\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n    case POWERPC_EXCP_ISI:       \/* Instruction storage exception            *\/\n\n#if defined (DEBUG_EXCEPTIONS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"ISI exception: msr=0x\" ADDRX \", nip=0x\" ADDRX\n\n                    \"\\n\", msr, env->nip);\n\n        }\n\n#endif\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        msr |= env->error_code;\n\n        goto store_next;\n\n    case POWERPC_EXCP_EXTERNAL:  \/* External input                           *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes0 == 1)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n    case POWERPC_EXCP_ALIGN:     \/* Alignment exception                      *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        \/* XXX: this is false *\/\n\n        \/* Get rS\/rD and rA from faulting opcode *\/\n\n        env->spr[SPR_DSISR] |= (ldl_code((env->nip - 4)) & 0x03FF0000) >> 16;\n\n        goto store_current;\n\n    case POWERPC_EXCP_PROGRAM:   \/* Program exception                        *\/\n\n        switch (env->error_code & ~0xF) {\n\n        case POWERPC_EXCP_FP:\n\n            if ((msr_fe0 == 0 && msr_fe1 == 0) || msr_fp == 0) {\n\n#if defined (DEBUG_EXCEPTIONS)\n\n                if (loglevel != 0) {\n\n                    fprintf(logfile, \"Ignore floating point exception\\n\");\n\n                }\n\n#endif\n\n                env->exception_index = POWERPC_EXCP_NONE;\n\n                env->error_code = 0;\n\n                return;\n\n            }\n\n            new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n            msr |= 0x00100000;\n\n            if (msr_fe0 == msr_fe1)\n\n                goto store_next;\n\n            msr |= 0x00010000;\n\n            break;\n\n        case POWERPC_EXCP_INVAL:\n\n#if defined (DEBUG_EXCEPTIONS)\n\n            if (loglevel != 0) {\n\n                fprintf(logfile, \"Invalid instruction at 0x\" ADDRX \"\\n\",\n\n                        env->nip);\n\n            }\n\n#endif\n\n            new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n            msr |= 0x00080000;\n\n            break;\n\n        case POWERPC_EXCP_PRIV:\n\n            new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n            msr |= 0x00040000;\n\n            break;\n\n        case POWERPC_EXCP_TRAP:\n\n            new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n            msr |= 0x00020000;\n\n            break;\n\n        default:\n\n            \/* Should never occur *\/\n\n            cpu_abort(env, \"Invalid program exception %d. Aborting\\n\",\n\n                      env->error_code);\n\n            break;\n\n        }\n\n        goto store_current;\n\n    case POWERPC_EXCP_FPU:       \/* Floating-point unavailable exception     *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_current;\n\n    case POWERPC_EXCP_SYSCALL:   \/* System call exception                    *\/\n\n        \/* NOTE: this is a temporary hack to support graphics OSI\n\n           calls from the MOL driver *\/\n\n        \/* XXX: To be removed *\/\n\n        if (env->gpr[3] == 0x113724fa && env->gpr[4] == 0x77810f9b &&\n\n            env->osi_call) {\n\n            if (env->osi_call(env) != 0) {\n\n                env->exception_index = POWERPC_EXCP_NONE;\n\n                env->error_code = 0;\n\n                return;\n\n            }\n\n        }\n\n        if (loglevel & CPU_LOG_INT) {\n\n            dump_syscall(env);\n\n        }\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        lev = env->error_code;\n\n        if (lev == 1 || (lpes0 == 0 && lpes1 == 0))\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n    case POWERPC_EXCP_APU:       \/* Auxiliary processor unavailable          *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n        goto store_current;\n\n    case POWERPC_EXCP_DECR:      \/* Decrementer exception                    *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n    case POWERPC_EXCP_FIT:       \/* Fixed-interval timer interrupt           *\/\n\n        \/* FIT on 4xx *\/\n\n#if defined (DEBUG_EXCEPTIONS)\n\n        if (loglevel != 0)\n\n            fprintf(logfile, \"FIT exception\\n\");\n\n#endif\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); \/* XXX: check this *\/\n\n        goto store_next;\n\n    case POWERPC_EXCP_WDT:       \/* Watchdog timer interrupt                 *\/\n\n#if defined (DEBUG_EXCEPTIONS)\n\n        if (loglevel != 0)\n\n            fprintf(logfile, \"WDT exception\\n\");\n\n#endif\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); \/* XXX: check this *\/\n\n        goto store_next;\n\n    case POWERPC_EXCP_DTLB:      \/* Data TLB error                           *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); \/* XXX: check this *\/\n\n        goto store_next;\n\n    case POWERPC_EXCP_ITLB:      \/* Instruction TLB error                    *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); \/* XXX: check this *\/\n\n        goto store_next;\n\n    case POWERPC_EXCP_DEBUG:     \/* Debug interrupt                          *\/\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_DSRR0;\n\n            srr1 = SPR_BOOKE_DSRR1;\n\n            asrr0 = SPR_BOOKE_CSRR0;\n\n            asrr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"Debug exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n#if defined(TARGET_PPCEMB)\n\n    case POWERPC_EXCP_SPEU:      \/* SPE\/embedded floating-point unavailable  *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); \/* XXX: check this *\/\n\n        goto store_current;\n\n    case POWERPC_EXCP_EFPDI:     \/* Embedded floating-point data interrupt   *\/\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"Embedded floating point data exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EFPRI:     \/* Embedded floating-point round interrupt  *\/\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"Embedded floating point round exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EPERFM:    \/* Embedded performance monitor interrupt   *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env,\n\n                  \"Performance counter exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DOORI:     \/* Embedded doorbell interrupt              *\/\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env,\n\n                  \"Embedded doorbell interrupt is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DOORCI:    \/* Embedded doorbell critical interrupt     *\/\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"Embedded doorbell critical interrupt \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n#endif \/* defined(TARGET_PPCEMB) *\/\n\n    case POWERPC_EXCP_RESET:     \/* System reset exception                   *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_EXCP_DSEG:      \/* Data segment exception                   *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n    case POWERPC_EXCP_ISEG:      \/* Instruction segment exception            *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n#endif \/* defined(TARGET_PPC64) *\/\n\n#if defined(TARGET_PPC64H)\n\n    case POWERPC_EXCP_HDECR:     \/* Hypervisor decrementer exception         *\/\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n        goto store_next;\n\n#endif\n\n    case POWERPC_EXCP_TRACE:     \/* Trace exception                          *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_next;\n\n#if defined(TARGET_PPC64H)\n\n    case POWERPC_EXCP_HDSI:      \/* Hypervisor data storage exception        *\/\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n        goto store_next;\n\n    case POWERPC_EXCP_HISI:      \/* Hypervisor instruction storage exception *\/\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDSEG:     \/* Hypervisor data segment exception        *\/\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n        goto store_next;\n\n    case POWERPC_EXCP_HISEG:     \/* Hypervisor instruction segment exception *\/\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)1 << MSR_HV;\n\n        goto store_next;\n\n#endif \/* defined(TARGET_PPC64H) *\/\n\n    case POWERPC_EXCP_VPU:       \/* Vector unavailable exception             *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        goto store_current;\n\n    case POWERPC_EXCP_PIT:       \/* Programmable interval timer interrupt    *\/\n\n#if defined (DEBUG_EXCEPTIONS)\n\n        if (loglevel != 0)\n\n            fprintf(logfile, \"PIT exception\\n\");\n\n#endif\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); \/* XXX: check this *\/\n\n        goto store_next;\n\n    case POWERPC_EXCP_IO:        \/* IO error exception                       *\/\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"601 IO error exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_RUNM:      \/* Run mode exception                       *\/\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"601 run mode exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EMUL:      \/* Emulation trap exception                 *\/\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"602 emulation trap exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IFTLB:     \/* Instruction fetch TLB error              *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); \/* XXX: check this *\/\n\n#if defined(TARGET_PPC64H) \/* XXX: check this *\/\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n            goto tlb_miss_tgpr;\n\n        case POWERPC_EXCP_7x5:\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_74xx:\n\n            goto tlb_miss_74xx;\n\n        default:\n\n            cpu_abort(env, \"Invalid instruction TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        break;\n\n    case POWERPC_EXCP_DLTLB:     \/* Data load TLB miss                       *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); \/* XXX: check this *\/\n\n#if defined(TARGET_PPC64H) \/* XXX: check this *\/\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n            goto tlb_miss_tgpr;\n\n        case POWERPC_EXCP_7x5:\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_74xx:\n\n            goto tlb_miss_74xx;\n\n        default:\n\n            cpu_abort(env, \"Invalid data load TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        break;\n\n    case POWERPC_EXCP_DSTLB:     \/* Data store TLB miss                      *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI); \/* XXX: check this *\/\n\n#if defined(TARGET_PPC64H) \/* XXX: check this *\/\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n        tlb_miss_tgpr:\n\n            \/* Swap temporary saved registers with GPRs *\/\n\n            if (!(new_msr & ((target_ulong)1 << MSR_TGPR))) {\n\n                new_msr |= (target_ulong)1 << MSR_TGPR;\n\n                hreg_swap_gpr_tgpr(env);\n\n            }\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_7x5:\n\n        tlb_miss:\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n            if (loglevel != 0) {\n\n                const unsigned char *es;\n\n                target_ulong *miss, *cmp;\n\n                int en;\n\n                if (excp == POWERPC_EXCP_IFTLB) {\n\n                    es = \"I\";\n\n                    en = 'I';\n\n                    miss = &env->spr[SPR_IMISS];\n\n                    cmp = &env->spr[SPR_ICMP];\n\n                } else {\n\n                    if (excp == POWERPC_EXCP_DLTLB)\n\n                        es = \"DL\";\n\n                    else\n\n                        es = \"DS\";\n\n                    en = 'D';\n\n                    miss = &env->spr[SPR_DMISS];\n\n                    cmp = &env->spr[SPR_DCMP];\n\n                }\n\n                fprintf(logfile, \"6xx %sTLB miss: %cM \" ADDRX \" %cC \" ADDRX\n\n                        \" H1 \" ADDRX \" H2 \" ADDRX \" %08x\\n\",\n\n                        es, en, *miss, en, *cmp,\n\n                        env->spr[SPR_HASH1], env->spr[SPR_HASH2],\n\n                        env->error_code);\n\n            }\n\n#endif\n\n            msr |= env->crf[0] << 28;\n\n            msr |= env->error_code; \/* key, D\/I, S\/L bits *\/\n\n            \/* Set way using a LRU mechanism *\/\n\n            msr |= ((env->last_way + 1) & (env->nb_ways - 1)) << 17;\n\n            break;\n\n        case POWERPC_EXCP_74xx:\n\n        tlb_miss_74xx:\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n            if (loglevel != 0) {\n\n                const unsigned char *es;\n\n                target_ulong *miss, *cmp;\n\n                int en;\n\n                if (excp == POWERPC_EXCP_IFTLB) {\n\n                    es = \"I\";\n\n                    en = 'I';\n\n                    miss = &env->spr[SPR_TLBMISS];\n\n                    cmp = &env->spr[SPR_PTEHI];\n\n                } else {\n\n                    if (excp == POWERPC_EXCP_DLTLB)\n\n                        es = \"DL\";\n\n                    else\n\n                        es = \"DS\";\n\n                    en = 'D';\n\n                    miss = &env->spr[SPR_TLBMISS];\n\n                    cmp = &env->spr[SPR_PTEHI];\n\n                }\n\n                fprintf(logfile, \"74xx %sTLB miss: %cM \" ADDRX \" %cC \" ADDRX\n\n                        \" %08x\\n\",\n\n                        es, en, *miss, en, *cmp, env->error_code);\n\n            }\n\n#endif\n\n            msr |= env->error_code; \/* key bit *\/\n\n            break;\n\n        default:\n\n            cpu_abort(env, \"Invalid data store TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_FPA:       \/* Floating-point assist exception          *\/\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"Floating point assist exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IABR:      \/* Instruction address breakpoint           *\/\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"IABR exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SMI:       \/* System management interrupt              *\/\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"SMI exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_THERM:     \/* Thermal interrupt                        *\/\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"Thermal management exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_PERFM:     \/* Embedded performance monitor interrupt   *\/\n\n        new_msr &= ~((target_ulong)1 << MSR_RI);\n\n#if defined(TARGET_PPC64H)\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)1 << MSR_HV;\n\n#endif\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env,\n\n                  \"Performance counter exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_VPUA:      \/* Vector assist exception                  *\/\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env, \"VPU assist exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SOFTP:     \/* Soft patch exception                     *\/\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env,\n\n                  \"970 soft-patch exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_MAINT:     \/* Maintenance exception                    *\/\n\n        \/* XXX: TODO *\/\n\n        cpu_abort(env,\n\n                  \"970 maintenance exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    default:\n\n    excp_invalid:\n\n        cpu_abort(env, \"Invalid PowerPC exception %d. Aborting\\n\", excp);\n\n        break;\n\n    store_current:\n\n        \/* save current instruction location *\/\n\n        env->spr[srr0] = env->nip - 4;\n\n        break;\n\n    store_next:\n\n        \/* save next instruction location *\/\n\n        env->spr[srr0] = env->nip;\n\n        break;\n\n    }\n\n    \/* Save MSR *\/\n\n    env->spr[srr1] = msr;\n\n    \/* If any alternate SRR register are defined, duplicate saved values *\/\n\n    if (asrr0 != -1)\n\n        env->spr[asrr0] = env->spr[srr0];\n\n    if (asrr1 != -1)\n\n        env->spr[asrr1] = env->spr[srr1];\n\n    \/* If we disactivated any translation, flush TLBs *\/\n\n    if (new_msr & ((1 << MSR_IR) | (1 << MSR_DR)))\n\n        tlb_flush(env, 1);\n\n    \/* reload MSR with correct bits *\/\n\n    new_msr &= ~((target_ulong)1 << MSR_EE);\n\n    new_msr &= ~((target_ulong)1 << MSR_PR);\n\n    new_msr &= ~((target_ulong)1 << MSR_FP);\n\n    new_msr &= ~((target_ulong)1 << MSR_FE0);\n\n    new_msr &= ~((target_ulong)1 << MSR_SE);\n\n    new_msr &= ~((target_ulong)1 << MSR_BE);\n\n    new_msr &= ~((target_ulong)1 << MSR_FE1);\n\n    new_msr &= ~((target_ulong)1 << MSR_IR);\n\n    new_msr &= ~((target_ulong)1 << MSR_DR);\n\n#if 0 \/* Fix this: not on all targets *\/\n\n    new_msr &= ~((target_ulong)1 << MSR_PMM);\n\n#endif\n\n    new_msr &= ~((target_ulong)1 << MSR_LE);\n\n    if (msr_ile)\n\n        new_msr |= (target_ulong)1 << MSR_LE;\n\n    else\n\n        new_msr &= ~((target_ulong)1 << MSR_LE);\n\n    \/* Jump to handler *\/\n\n    vector = env->excp_vectors[excp];\n\n    if (vector == (target_ulong)-1) {\n\n        cpu_abort(env, \"Raised an exception without defined vector %d\\n\",\n\n                  excp);\n\n    }\n\n    vector |= env->excp_prefix;\n\n#if defined(TARGET_PPC64)\n\n    if (excp_model == POWERPC_EXCP_BOOKE) {\n\n        if (!msr_icm) {\n\n            new_msr &= ~((target_ulong)1 << MSR_CM);\n\n            vector = (uint32_t)vector;\n\n        } else {\n\n            new_msr |= (target_ulong)1 << MSR_CM;\n\n        }\n\n    } else {\n\n        if (!msr_isf) {\n\n            new_msr &= ~((target_ulong)1 << MSR_SF);\n\n            vector = (uint32_t)vector;\n\n        } else {\n\n            new_msr |= (target_ulong)1 << MSR_SF;\n\n        }\n\n    }\n\n#endif\n\n    \/* XXX: we don't use hreg_store_msr here as already have treated\n\n     *      any special case that could occur. Just store MSR and update hflags\n\n     *\/\n\n    env->msr = new_msr;\n\n    env->hflags_nmsr = 0x00000000;\n\n    hreg_compute_hflags(env);\n\n    env->nip = vector;\n\n    \/* Reset exception state *\/\n\n    env->exception_index = POWERPC_EXCP_NONE;\n\n    env->error_code = 0;\n\n}\n"},{"project":"qemu","commit_id":"01c097f7960b330c4bf038d34bae17ad6c1ba499","target":0,"func":"static void ats_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)\n\n{\n\n    hwaddr phys_addr;\n\n    target_ulong page_size;\n\n    int prot;\n\n    int ret, is_user = ri->opc2 & 2;\n\n    int access_type = ri->opc2 & 1;\n\n\n\n    ret = get_phys_addr(env, value, access_type, is_user,\n\n                        &phys_addr, &prot, &page_size);\n\n    if (extended_addresses_enabled(env)) {\n\n        \/* ret is a DFSR\/IFSR value for the long descriptor\n\n         * translation table format, but with WnR always clear.\n\n         * Convert it to a 64-bit PAR.\n\n         *\/\n\n        uint64_t par64 = (1 << 11); \/* LPAE bit always set *\/\n\n        if (ret == 0) {\n\n            par64 |= phys_addr & ~0xfffULL;\n\n            \/* We don't set the ATTR or SH fields in the PAR. *\/\n\n        } else {\n\n            par64 |= 1; \/* F *\/\n\n            par64 |= (ret & 0x3f) << 1; \/* FS *\/\n\n            \/* Note that S2WLK and FSTAGE are always zero, because we don't\n\n             * implement virtualization and therefore there can't be a stage 2\n\n             * fault.\n\n             *\/\n\n        }\n\n        env->cp15.par_el1 = par64;\n\n    } else {\n\n        \/* ret is a DFSR\/IFSR value for the short descriptor\n\n         * translation table format (with WnR always clear).\n\n         * Convert it to a 32-bit PAR.\n\n         *\/\n\n        if (ret == 0) {\n\n            \/* We do not set any attribute bits in the PAR *\/\n\n            if (page_size == (1 << 24)\n\n                && arm_feature(env, ARM_FEATURE_V7)) {\n\n                env->cp15.par_el1 = (phys_addr & 0xff000000) | 1 << 1;\n\n            } else {\n\n                env->cp15.par_el1 = phys_addr & 0xfffff000;\n\n            }\n\n        } else {\n\n            env->cp15.par_el1 = ((ret & (1 << 10)) >> 5) |\n\n                ((ret & (1 << 12)) >> 6) |\n\n                ((ret & 0xf) << 1) | 1;\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"cea5f9a28faa528b6b1b117c9ab2d8828f473fef","target":0,"func":"static TranslationBlock *tb_find_slow(target_ulong pc,\n\n                                      target_ulong cs_base,\n\n                                      uint64_t flags)\n\n{\n\n    TranslationBlock *tb, **ptb1;\n\n    unsigned int h;\n\n    tb_page_addr_t phys_pc, phys_page1, phys_page2;\n\n    target_ulong virt_page2;\n\n\n\n    tb_invalidated_flag = 0;\n\n\n\n    \/* find translated block using physical mappings *\/\n\n    phys_pc = get_page_addr_code(env, pc);\n\n    phys_page1 = phys_pc & TARGET_PAGE_MASK;\n\n    phys_page2 = -1;\n\n    h = tb_phys_hash_func(phys_pc);\n\n    ptb1 = &tb_phys_hash[h];\n\n    for(;;) {\n\n        tb = *ptb1;\n\n        if (!tb)\n\n            goto not_found;\n\n        if (tb->pc == pc &&\n\n            tb->page_addr[0] == phys_page1 &&\n\n            tb->cs_base == cs_base &&\n\n            tb->flags == flags) {\n\n            \/* check next page if needed *\/\n\n            if (tb->page_addr[1] != -1) {\n\n                virt_page2 = (pc & TARGET_PAGE_MASK) +\n\n                    TARGET_PAGE_SIZE;\n\n                phys_page2 = get_page_addr_code(env, virt_page2);\n\n                if (tb->page_addr[1] == phys_page2)\n\n                    goto found;\n\n            } else {\n\n                goto found;\n\n            }\n\n        }\n\n        ptb1 = &tb->phys_hash_next;\n\n    }\n\n not_found:\n\n   \/* if no translated code available, then translate it now *\/\n\n    tb = tb_gen_code(env, pc, cs_base, flags, 0);\n\n\n\n found:\n\n    \/* Move the last found TB to the head of the list *\/\n\n    if (likely(*ptb1)) {\n\n        *ptb1 = tb->phys_hash_next;\n\n        tb->phys_hash_next = tb_phys_hash[h];\n\n        tb_phys_hash[h] = tb;\n\n    }\n\n    \/* we add the TB in the virtual pc hash table *\/\n\n    env->tb_jmp_cache[tb_jmp_cache_hash_func(pc)] = tb;\n\n    return tb;\n\n}\n"},{"project":"qemu","commit_id":"b8afb520e479e693c227aa39c2fb7670743e104f","target":1,"func":"BdrvDirtyBitmap *bdrv_create_dirty_bitmap(BlockDriverState *bs, int granularity)\n\n{\n\n    int64_t bitmap_size;\n\n    BdrvDirtyBitmap *bitmap;\n\n\n\n    assert((granularity & (granularity - 1)) == 0);\n\n\n\n    granularity >>= BDRV_SECTOR_BITS;\n\n    assert(granularity);\n\n    bitmap_size = (bdrv_getlength(bs) >> BDRV_SECTOR_BITS);\n\n    bitmap = g_malloc0(sizeof(BdrvDirtyBitmap));\n\n    bitmap->bitmap = hbitmap_alloc(bitmap_size, ffs(granularity) - 1);\n\n    QLIST_INSERT_HEAD(&bs->dirty_bitmaps, bitmap, list);\n\n    return bitmap;\n\n}\n"},{"project":"qemu","commit_id":"edf779ffccc836661a7b654d320571a6c220caea","target":0,"func":"static void setup_frame(int sig, struct emulated_sigaction *ka,\n\n\t\t\ttarget_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\terr |= __put_user((\/*current->exec_domain\n\n\t\t           && current->exec_domain->signal_invmap\n\n\t\t           && sig < 32\n\n\t\t           ? current->exec_domain->signal_invmap[sig]\n\n\t\t           : *\/ sig),\n\n\t\t          &frame->sig);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tsetup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tif (TARGET_NSIG_WORDS > 1) {\n\n\t\terr |= __copy_to_user(frame->extramask, &set->sig[1],\n\n\t\t\t\t      sizeof(frame->extramask));\n\n\t}\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t\/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  *\/\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t\/* This is popl %eax ; movl $,%eax ; int $0x80 *\/\n\n\t\terr |= __put_user(0xb858, (short *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode+2));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+6));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t\/* Set up registers for signal handler *\/\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV \/* , current *\/);\n\n}\n"},{"project":"qemu","commit_id":"062ba099e01ff1474be98c0a4f3da351efab5d9d","target":1,"func":"static bool arm_cpu_has_work(CPUState *cs)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n\n\n    return !cpu->powered_off\n\n        && cs->interrupt_request &\n\n        (CPU_INTERRUPT_FIQ | CPU_INTERRUPT_HARD\n\n         | CPU_INTERRUPT_VFIQ | CPU_INTERRUPT_VIRQ\n\n         | CPU_INTERRUPT_EXITTB);\n\n}\n"},{"project":"qemu","commit_id":"fdda170e50b8af062cf5741e12c4fb5e57a2eacf","target":1,"func":"static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n\n{\n\n    struct Vmxnet3_TxCompDesc txcq_descr;\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n\n\n    VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n\n\n\n\n    txcq_descr.txdIdx = tx_ridx;\n\n    txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n\n\n\n    vmxnet3_ring_write_curr_cell(d, &s->txq_descr[qidx].comp_ring, &txcq_descr);\n\n\n\n    \/* Flush changes in TX descriptor before changing the counter value *\/\n\n    smp_wmb();\n\n\n\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n\n}"},{"project":"qemu","commit_id":"456d60692310e7ac25cf822cc1e98192ad636ece","target":1,"func":"static void rng_egd_opened(RngBackend *b, Error **errp)\n{\n    RngEgd *s = RNG_EGD(b);\n    if (s->chr_name == NULL) {\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE,\n                  \"chardev\", \"a valid character device\");\n    s->chr = qemu_chr_find(s->chr_name);\n    if (s->chr == NULL) {\n        error_set(errp, QERR_DEVICE_NOT_FOUND, s->chr_name);\n    \/* FIXME we should resubmit pending requests when the CDS reconnects. *\/\n    qemu_chr_add_handlers(s->chr, rng_egd_chr_can_read, rng_egd_chr_read,\n                          NULL, s);"},{"project":"qemu","commit_id":"ec45bbe5f1921c6553fbf9c0c76b358b0403c22d","target":1,"func":"envlist_create(void)\n\n{\n\n\tenvlist_t *envlist;\n\n\n\n\tif ((envlist = malloc(sizeof (*envlist))) == NULL)\n\n\t\treturn (NULL);\n\n\n\n\tQLIST_INIT(&envlist->el_entries);\n\n\tenvlist->el_count = 0;\n\n\n\n\treturn (envlist);\n\n}\n"},{"project":"qemu","commit_id":"5f758366c0710d23e43f4d0f83816b98616a13d0","target":1,"func":"static CharDriverState *qmp_chardev_open_serial(ChardevHostdev *serial,\n\n                                                Error **errp)\n\n{\n\n#ifdef HAVE_CHARDEV_TTY\n\n    int fd;\n\n\n\n    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);\n\n    if (error_is_set(errp)) {\n\n        return NULL;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n    return qemu_chr_open_tty_fd(fd);\n\n#else\n\n    error_setg(errp, \"character device backend type 'serial' not supported\");\n\n    return NULL;\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"0e9b9edae7bebfd31fdbead4ccbbce03876a7edd","target":0,"func":"void nvdimm_build_acpi(GArray *table_offsets, GArray *table_data,\n\n                       GArray *linker)\n\n{\n\n    GSList *device_list;\n\n\n\n    \/* no NVDIMM device is plugged. *\/\n\n    device_list = nvdimm_get_plugged_device_list();\n\n    if (!device_list) {\n\n        return;\n\n    }\n\n    nvdimm_build_nfit(device_list, table_offsets, table_data, linker);\n\n    nvdimm_build_ssdt(device_list, table_offsets, table_data, linker);\n\n    g_slist_free(device_list);\n\n}\n"},{"project":"qemu","commit_id":"761731b1805f6ef64eb615e5b82a0801db3cde78","target":0,"func":"void qmp_drive_backup(const char *device, const char *target,\n\n                      bool has_format, const char *format,\n\n                      enum MirrorSyncMode sync,\n\n                      bool has_mode, enum NewImageMode mode,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_on_source_error, BlockdevOnError on_source_error,\n\n                      bool has_on_target_error, BlockdevOnError on_target_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *target_bs;\n\n    BlockDriverState *source = NULL;\n\n    BlockDriver *drv = NULL;\n\n    Error *local_err = NULL;\n\n    int flags;\n\n    int64_t size;\n\n    int ret;\n\n\n\n    if (!has_speed) {\n\n        speed = 0;\n\n    }\n\n    if (!has_on_source_error) {\n\n        on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_on_target_error) {\n\n        on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_mode) {\n\n        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n    }\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(bs)) {\n\n        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (!has_format) {\n\n        format = mode == NEW_IMAGE_MODE_EXISTING ? NULL : bs->drv->format_name;\n\n    }\n\n    if (format) {\n\n        drv = bdrv_find_format(format);\n\n        if (!drv) {\n\n            error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {\n\n        return;\n\n    }\n\n\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n\n\n    \/* See if we have a backing HD we can use to create our new image\n\n     * on top of. *\/\n\n    if (sync == MIRROR_SYNC_MODE_TOP) {\n\n        source = bs->backing_hd;\n\n        if (!source) {\n\n            sync = MIRROR_SYNC_MODE_FULL;\n\n        }\n\n    }\n\n    if (sync == MIRROR_SYNC_MODE_NONE) {\n\n        source = bs;\n\n    }\n\n\n\n    size = bdrv_getlength(bs);\n\n    if (size < 0) {\n\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n\n        return;\n\n    }\n\n\n\n    if (mode != NEW_IMAGE_MODE_EXISTING) {\n\n        assert(format && drv);\n\n        if (source) {\n\n            bdrv_img_create(target, format, source->filename,\n\n                            source->drv->format_name, NULL,\n\n                            size, flags, &local_err, false);\n\n        } else {\n\n            bdrv_img_create(target, format, NULL, NULL, NULL,\n\n                            size, flags, &local_err, false);\n\n        }\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    target_bs = NULL;\n\n    ret = bdrv_open(&target_bs, target, NULL, NULL, flags, drv, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    backup_start(bs, target_bs, speed, sync, on_source_error, on_target_error,\n\n                 block_job_cb, bs, &local_err);\n\n    if (local_err != NULL) {\n\n        bdrv_unref(target_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"21e00fa55f3fdfcbb20da7c6876c91ef3609b387","target":0,"func":"bool memory_region_is_skip_dump(MemoryRegion *mr)\n\n{\n\n    return mr->skip_dump;\n\n}\n"},{"project":"qemu","commit_id":"73a652a1b08445e8d91e50cdbb2da50e571c61b3","target":1,"func":"void qmp_guest_fstrim(bool has_minimum, int64_t minimum, Error **errp)\n\n{\n\n    int ret = 0;\n\n    FsMountList mounts;\n\n    struct FsMount *mount;\n\n    int fd;\n\n    Error *local_err = NULL;\n\n    struct fstrim_range r = {\n\n        .start = 0,\n\n        .len = -1,\n\n        .minlen = has_minimum ? minimum : 0,\n\n    };\n\n\n\n    slog(\"guest-fstrim called\");\n\n\n\n    QTAILQ_INIT(&mounts);\n\n    build_fs_mount_list(&mounts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    QTAILQ_FOREACH(mount, &mounts, next) {\n\n        fd = qemu_open(mount->dirname, O_RDONLY);\n\n        if (fd == -1) {\n\n            error_setg_errno(errp, errno, \"failed to open %s\", mount->dirname);\n\n            goto error;\n\n        }\n\n\n\n        \/* We try to cull filesytems we know won't work in advance, but other\n\n         * filesytems may not implement fstrim for less obvious reasons.  These\n\n         * will report EOPNOTSUPP; we simply ignore these errors.  Any other\n\n         * error means an unexpected error, so return it in those cases.  In\n\n         * some other cases ENOTTY will be reported (e.g. CD-ROMs).\n\n         *\/\n\n        ret = ioctl(fd, FITRIM, &r);\n\n        if (ret == -1) {\n\n            if (errno != ENOTTY && errno != EOPNOTSUPP) {\n\n                error_setg_errno(errp, errno, \"failed to trim %s\",\n\n                                 mount->dirname);\n\n                close(fd);\n\n                goto error;\n\n            }\n\n        }\n\n        close(fd);\n\n    }\n\n\n\nerror:\n\n    free_fs_mount_list(&mounts);\n\n}\n"},{"project":"qemu","commit_id":"73d60fa5fae60c8e07e1f295d8c7fd5d04320160","target":1,"func":"static void get_sensor_type(IPMIBmcSim *ibs,\n\n                               uint8_t *cmd, unsigned int cmd_len,\n\n                               uint8_t *rsp, unsigned int *rsp_len,\n\n                               unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n            !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(sens->sensor_type);\n\n    IPMI_ADD_RSP_DATA(sens->evt_reading_type_code);\n\n}\n"},{"project":"qemu","commit_id":"698235aab6f55e960203dc2ef9a3a580982dae2f","target":1,"func":"static int get_physical_address(CPUState *env, target_phys_addr_t *physical,\n\n                                int *prot, int *access_index,\n\n                                target_ulong address, int rw, int mmu_idx)\n\n{\n\n    int access_perms = 0;\n\n    target_phys_addr_t pde_ptr;\n\n    uint32_t pde;\n\n    int error_code = 0, is_dirty, is_user;\n\n    unsigned long page_offset;\n\n\n\n    is_user = mmu_idx == MMU_USER_IDX;\n\n\n\n    if ((env->mmuregs[0] & MMU_E) == 0) { \/* MMU disabled *\/\n\n        \/\/ Boot mode: instruction fetches are taken from PROM\n\n        if (rw == 2 && (env->mmuregs[0] & env->def->mmu_bm)) {\n\n            *physical = env->prom_addr | (address & 0x7ffffULL);\n\n            *prot = PAGE_READ | PAGE_EXEC;\n\n            return 0;\n\n        }\n\n        *physical = address;\n\n        *prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n        return 0;\n\n    }\n\n\n\n    *access_index = ((rw & 1) << 2) | (rw & 2) | (is_user? 0 : 1);\n\n    *physical = 0xffffffffffff0000ULL;\n\n\n\n    \/* SPARC reference MMU table walk: Context table->L1->L2->PTE *\/\n\n    \/* Context base + context number *\/\n\n    pde_ptr = (env->mmuregs[1] << 4) + (env->mmuregs[2] << 2);\n\n    pde = ldl_phys(pde_ptr);\n\n\n\n    \/* Ctx pde *\/\n\n    switch (pde & PTE_ENTRYTYPE_MASK) {\n\n    default:\n\n    case 0: \/* Invalid *\/\n\n        return 1 << 2;\n\n    case 2: \/* L0 PTE, maybe should not happen? *\/\n\n    case 3: \/* Reserved *\/\n\n        return 4 << 2;\n\n    case 1: \/* L0 PDE *\/\n\n        pde_ptr = ((address >> 22) & ~3) + ((pde & ~3) << 4);\n\n        pde = ldl_phys(pde_ptr);\n\n\n\n        switch (pde & PTE_ENTRYTYPE_MASK) {\n\n        default:\n\n        case 0: \/* Invalid *\/\n\n            return (1 << 8) | (1 << 2);\n\n        case 3: \/* Reserved *\/\n\n            return (1 << 8) | (4 << 2);\n\n        case 1: \/* L1 PDE *\/\n\n            pde_ptr = ((address & 0xfc0000) >> 16) + ((pde & ~3) << 4);\n\n            pde = ldl_phys(pde_ptr);\n\n\n\n            switch (pde & PTE_ENTRYTYPE_MASK) {\n\n            default:\n\n            case 0: \/* Invalid *\/\n\n                return (2 << 8) | (1 << 2);\n\n            case 3: \/* Reserved *\/\n\n                return (2 << 8) | (4 << 2);\n\n            case 1: \/* L2 PDE *\/\n\n                pde_ptr = ((address & 0x3f000) >> 10) + ((pde & ~3) << 4);\n\n                pde = ldl_phys(pde_ptr);\n\n\n\n                switch (pde & PTE_ENTRYTYPE_MASK) {\n\n                default:\n\n                case 0: \/* Invalid *\/\n\n                    return (3 << 8) | (1 << 2);\n\n                case 1: \/* PDE, should not happen *\/\n\n                case 3: \/* Reserved *\/\n\n                    return (3 << 8) | (4 << 2);\n\n                case 2: \/* L3 PTE *\/\n\n                    page_offset = (address & TARGET_PAGE_MASK) &\n\n                        (TARGET_PAGE_SIZE - 1);\n\n                }\n\n                break;\n\n            case 2: \/* L2 PTE *\/\n\n                page_offset = address & 0x3ffff;\n\n            }\n\n            break;\n\n        case 2: \/* L1 PTE *\/\n\n            page_offset = address & 0xffffff;\n\n        }\n\n    }\n\n\n\n    \/* update page modified and dirty bits *\/\n\n    is_dirty = (rw & 1) && !(pde & PG_MODIFIED_MASK);\n\n    if (!(pde & PG_ACCESSED_MASK) || is_dirty) {\n\n        pde |= PG_ACCESSED_MASK;\n\n        if (is_dirty)\n\n            pde |= PG_MODIFIED_MASK;\n\n        stl_phys_notdirty(pde_ptr, pde);\n\n    }\n\n    \/* check access *\/\n\n    access_perms = (pde & PTE_ACCESS_MASK) >> PTE_ACCESS_SHIFT;\n\n    error_code = access_table[*access_index][access_perms];\n\n    if (error_code && !((env->mmuregs[0] & MMU_NF) && is_user))\n\n        return error_code;\n\n\n\n    \/* the page can be put in the TLB *\/\n\n    *prot = perm_table[is_user][access_perms];\n\n    if (!(pde & PG_MODIFIED_MASK)) {\n\n        \/* only set write access if already dirty... otherwise wait\n\n           for dirty access *\/\n\n        *prot &= ~PAGE_WRITE;\n\n    }\n\n\n\n    \/* Even if large ptes, we map only one 4KB page in the cache to\n\n       avoid filling it too fast *\/\n\n    *physical = ((target_phys_addr_t)(pde & PTE_ADDR_MASK) << 4) + page_offset;\n\n    return error_code;\n\n}\n"},{"project":"qemu","commit_id":"bc0f0674f037a01f2ce0870ad6270a356a7a8347","target":0,"func":"static bool e1000_full_mac_needed(void *opaque)\n\n{\n\n    E1000State *s = opaque;\n\n\n\n    return s->compat_flags & E1000_FLAG_MAC;\n\n}\n"},{"project":"qemu","commit_id":"3558f8055f37a34762b7a2a0f02687e6eeab893d","target":0,"func":"static inline void gen_op_addl_A0_seg(DisasContext *s, int reg)\n\n{\n\n    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUX86State, segs[reg].base));\n\n    if (CODE64(s)) {\n\n        tcg_gen_ext32u_tl(cpu_A0, cpu_A0);\n\n        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_tmp0);\n\n    } else {\n\n        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_tmp0);\n\n        tcg_gen_ext32u_tl(cpu_A0, cpu_A0);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"8a5956ad6392f115521dad774055c737c49fb0dd","target":0,"func":"static void *rcu_q_reader(void *arg)\n\n{\n\n    long long j, n_reads_local = 0;\n\n    struct list_element *el;\n\n\n\n    *(struct rcu_reader_data **)arg = &rcu_reader;\n\n    atomic_inc(&nthreadsrunning);\n\n    while (goflag == GOFLAG_INIT) {\n\n        g_usleep(1000);\n\n    }\n\n\n\n    while (goflag == GOFLAG_RUN) {\n\n        rcu_read_lock();\n\n        QLIST_FOREACH_RCU(el, &Q_list_head, entry) {\n\n            j = atomic_read(&el->val);\n\n            (void)j;\n\n            n_reads_local++;\n\n            if (goflag == GOFLAG_STOP) {\n\n                break;\n\n            }\n\n        }\n\n        rcu_read_unlock();\n\n\n\n        g_usleep(100);\n\n    }\n\n    atomic_add(&n_reads, n_reads_local);\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"58aebb946acff82c62383f350cab593e55cc13dc","target":0,"func":"int cpu_cris_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n\n                               int mmu_idx, int is_softmmu)\n\n{\n\n\tstruct cris_mmu_result res;\n\n\tint prot, miss;\n\n\tint r = -1;\n\n\ttarget_ulong phy;\n\n\n\n\tD(printf (\"%s addr=%x pc=%x rw=%x\\n\", __func__, address, env->pc, rw));\n\n\tmiss = cris_mmu_translate(&res, env, address & TARGET_PAGE_MASK,\n\n\t\t\t\t  rw, mmu_idx, 0);\n\n\tif (miss)\n\n\t{\n\n\t\tif (env->exception_index == EXCP_BUSFAULT)\n\n\t\t\tcpu_abort(env,\n\n\t\t\t\t  \"CRIS: Illegal recursive bus fault.\"\n\n\t\t\t\t \"addr=%x rw=%d\\n\",\n\n\t\t\t\t address, rw);\n\n\n\n\t\tenv->pregs[PR_EDA] = address;\n\n\t\tenv->exception_index = EXCP_BUSFAULT;\n\n\t\tenv->fault_vector = res.bf_vec;\n\n\t\tr = 1;\n\n\t}\n\n\telse\n\n\t{\n\n\t\t\/*\n\n\t\t * Mask off the cache selection bit. The ETRAX busses do not\n\n\t\t * see the top bit.\n\n\t\t *\/\n\n\t\tphy = res.phy & ~0x80000000;\n\n\t\tprot = res.prot;\n\n\t\ttlb_set_page(env, address & TARGET_PAGE_MASK, phy,\n\n                             prot | PAGE_EXEC, mmu_idx, TARGET_PAGE_SIZE);\n\n                r = 0;\n\n\t}\n\n\tif (r > 0)\n\n\t\tD_LOG(\"%s returns %d irqreq=%x addr=%x\"\n\n\t\t\t  \" phy=%x ismmu=%d vec=%x pc=%x\\n\", \n\n\t\t\t  __func__, r, env->interrupt_request, \n\n\t\t\t  address, res.phy, is_softmmu, res.bf_vec, env->pc);\n\n\treturn r;\n\n}\n"},{"project":"qemu","commit_id":"fe0bd475aa31e60674f7f53b85dc293108026202","target":1,"func":"static void gen_wsr(DisasContext *dc, uint32_t sr, TCGv_i32 s)\n\n{\n\n    static void (* const wsr_handler[256])(DisasContext *dc,\n\n            uint32_t sr, TCGv_i32 v) = {\n\n        [LBEG] = gen_wsr_lbeg,\n\n        [LEND] = gen_wsr_lend,\n\n        [SAR] = gen_wsr_sar,\n\n        [BR] = gen_wsr_br,\n\n        [LITBASE] = gen_wsr_litbase,\n\n        [ACCHI] = gen_wsr_acchi,\n\n        [WINDOW_BASE] = gen_wsr_windowbase,\n\n        [WINDOW_START] = gen_wsr_windowstart,\n\n        [PTEVADDR] = gen_wsr_ptevaddr,\n\n        [RASID] = gen_wsr_rasid,\n\n        [ITLBCFG] = gen_wsr_tlbcfg,\n\n        [DTLBCFG] = gen_wsr_tlbcfg,\n\n        [IBREAKENABLE] = gen_wsr_ibreakenable,\n\n        [ATOMCTL] = gen_wsr_atomctl,\n\n        [IBREAKA] = gen_wsr_ibreaka,\n\n        [IBREAKA + 1] = gen_wsr_ibreaka,\n\n        [DBREAKA] = gen_wsr_dbreaka,\n\n        [DBREAKA + 1] = gen_wsr_dbreaka,\n\n        [DBREAKC] = gen_wsr_dbreakc,\n\n        [DBREAKC + 1] = gen_wsr_dbreakc,\n\n        [CPENABLE] = gen_wsr_cpenable,\n\n        [INTSET] = gen_wsr_intset,\n\n        [INTCLEAR] = gen_wsr_intclear,\n\n        [INTENABLE] = gen_wsr_intenable,\n\n        [PS] = gen_wsr_ps,\n\n        [DEBUGCAUSE] = gen_wsr_debugcause,\n\n        [PRID] = gen_wsr_prid,\n\n        [ICOUNT] = gen_wsr_icount,\n\n        [ICOUNTLEVEL] = gen_wsr_icountlevel,\n\n        [CCOMPARE] = gen_wsr_ccompare,\n\n        [CCOMPARE + 1] = gen_wsr_ccompare,\n\n        [CCOMPARE + 2] = gen_wsr_ccompare,\n\n    };\n\n\n\n    if (sregnames[sr]) {\n\n        if (wsr_handler[sr]) {\n\n            wsr_handler[sr](dc, sr, s);\n\n        } else {\n\n            tcg_gen_mov_i32(cpu_SR[sr], s);\n\n        }\n\n    } else {\n\n        qemu_log(\"WSR %d not implemented, \", sr);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static uint64_t sysbus_esp_mem_read(void *opaque, target_phys_addr_t addr,\n\n                                    unsigned int size)\n\n{\n\n    SysBusESPState *sysbus = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = addr >> sysbus->it_shift;\n\n    return esp_reg_read(&sysbus->esp, saddr);\n\n}\n"},{"project":"qemu","commit_id":"3dc6f8693694a649a9c83f1e2746565b47683923","target":0,"func":"BlockJob *backup_job_create(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *target, int64_t speed,\n\n                  MirrorSyncMode sync_mode, BdrvDirtyBitmap *sync_bitmap,\n\n                  bool compress,\n\n                  BlockdevOnError on_source_error,\n\n                  BlockdevOnError on_target_error,\n\n                  int creation_flags,\n\n                  BlockCompletionFunc *cb, void *opaque,\n\n                  BlockJobTxn *txn, Error **errp)\n\n{\n\n    int64_t len;\n\n    BlockDriverInfo bdi;\n\n    BackupBlockJob *job = NULL;\n\n    int ret;\n\n\n\n    assert(bs);\n\n    assert(target);\n\n\n\n    if (bs == target) {\n\n        error_setg(errp, \"Source and target cannot be the same\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(bs)) {\n\n        error_setg(errp, \"Device is not inserted: %s\",\n\n                   bdrv_get_device_name(bs));\n\n        return NULL;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(target)) {\n\n        error_setg(errp, \"Device is not inserted: %s\",\n\n                   bdrv_get_device_name(target));\n\n        return NULL;\n\n    }\n\n\n\n    if (compress && target->drv->bdrv_co_pwritev_compressed == NULL) {\n\n        error_setg(errp, \"Compression is not supported for this drive %s\",\n\n                   bdrv_get_device_name(target));\n\n        return NULL;\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {\n\n        return NULL;\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(target, BLOCK_OP_TYPE_BACKUP_TARGET, errp)) {\n\n        return NULL;\n\n    }\n\n\n\n    if (sync_mode == MIRROR_SYNC_MODE_INCREMENTAL) {\n\n        if (!sync_bitmap) {\n\n            error_setg(errp, \"must provide a valid bitmap name for \"\n\n                             \"\\\"incremental\\\" sync mode\");\n\n            return NULL;\n\n        }\n\n\n\n        \/* Create a new bitmap, and freeze\/disable this one. *\/\n\n        if (bdrv_dirty_bitmap_create_successor(bs, sync_bitmap, errp) < 0) {\n\n            return NULL;\n\n        }\n\n    } else if (sync_bitmap) {\n\n        error_setg(errp,\n\n                   \"a sync_bitmap was provided to backup_run, \"\n\n                   \"but received an incompatible sync_mode (%s)\",\n\n                   MirrorSyncMode_lookup[sync_mode]);\n\n        return NULL;\n\n    }\n\n\n\n    len = bdrv_getlength(bs);\n\n    if (len < 0) {\n\n        error_setg_errno(errp, -len, \"unable to get length for '%s'\",\n\n                         bdrv_get_device_name(bs));\n\n        goto error;\n\n    }\n\n\n\n    \/* job->common.len is fixed, so we can't allow resize *\/\n\n    job = block_job_create(job_id, &backup_job_driver, bs,\n\n                           BLK_PERM_CONSISTENT_READ,\n\n                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE |\n\n                           BLK_PERM_WRITE_UNCHANGED | BLK_PERM_GRAPH_MOD,\n\n                           speed, creation_flags, cb, opaque, errp);\n\n    if (!job) {\n\n        goto error;\n\n    }\n\n\n\n    \/* The target must match the source in size, so no resize here either *\/\n\n    job->target = blk_new(BLK_PERM_WRITE,\n\n                          BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE |\n\n                          BLK_PERM_WRITE_UNCHANGED | BLK_PERM_GRAPH_MOD);\n\n    ret = blk_insert_bs(job->target, target, errp);\n\n    if (ret < 0) {\n\n        goto error;\n\n    }\n\n\n\n    job->on_source_error = on_source_error;\n\n    job->on_target_error = on_target_error;\n\n    job->sync_mode = sync_mode;\n\n    job->sync_bitmap = sync_mode == MIRROR_SYNC_MODE_INCREMENTAL ?\n\n                       sync_bitmap : NULL;\n\n    job->compress = compress;\n\n\n\n    \/* If there is no backing file on the target, we cannot rely on COW if our\n\n     * backup cluster size is smaller than the target cluster size. Even for\n\n     * targets with a backing file, try to avoid COW if possible. *\/\n\n    ret = bdrv_get_info(target, &bdi);\n\n    if (ret == -ENOTSUP && !target->backing) {\n\n        \/* Cluster size is not defined *\/\n\n        error_report(\"WARNING: The target block device doesn't provide \"\n\n                     \"information about the block size and it doesn't have a \"\n\n                     \"backing file. The default block size of %u bytes is \"\n\n                     \"used. If the actual block size of the target exceeds \"\n\n                     \"this default, the backup may be unusable\",\n\n                     BACKUP_CLUSTER_SIZE_DEFAULT);\n\n        job->cluster_size = BACKUP_CLUSTER_SIZE_DEFAULT;\n\n    } else if (ret < 0 && !target->backing) {\n\n        error_setg_errno(errp, -ret,\n\n            \"Couldn't determine the cluster size of the target image, \"\n\n            \"which has no backing file\");\n\n        error_append_hint(errp,\n\n            \"Aborting, since this may create an unusable destination image\\n\");\n\n        goto error;\n\n    } else if (ret < 0 && target->backing) {\n\n        \/* Not fatal; just trudge on ahead. *\/\n\n        job->cluster_size = BACKUP_CLUSTER_SIZE_DEFAULT;\n\n    } else {\n\n        job->cluster_size = MAX(BACKUP_CLUSTER_SIZE_DEFAULT, bdi.cluster_size);\n\n    }\n\n\n\n    \/* Required permissions are already taken with target's blk_new() *\/\n\n    block_job_add_bdrv(&job->common, \"target\", target, 0, BLK_PERM_ALL,\n\n                       &error_abort);\n\n    job->common.len = len;\n\n    block_job_txn_add_job(txn, &job->common);\n\n\n\n    return &job->common;\n\n\n\n error:\n\n    if (sync_bitmap) {\n\n        bdrv_reclaim_dirty_bitmap(bs, sync_bitmap, NULL);\n\n    }\n\n    if (job) {\n\n        backup_clean(&job->common);\n\n        block_job_early_fail(&job->common);\n\n    }\n\n\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"35337cc391245f251bfb9134f181c33e6375d6c1","target":0,"func":"static bool get_phys_addr(CPUARMState *env, target_ulong address,\n\n                          MMUAccessType access_type, ARMMMUIdx mmu_idx,\n\n                          hwaddr *phys_ptr, MemTxAttrs *attrs, int *prot,\n\n                          target_ulong *page_size, uint32_t *fsr,\n\n                          ARMMMUFaultInfo *fi)\n\n{\n\n    if (mmu_idx == ARMMMUIdx_S12NSE0 || mmu_idx == ARMMMUIdx_S12NSE1) {\n\n        \/* Call ourselves recursively to do the stage 1 and then stage 2\n\n         * translations.\n\n         *\/\n\n        if (arm_feature(env, ARM_FEATURE_EL2)) {\n\n            hwaddr ipa;\n\n            int s2_prot;\n\n            int ret;\n\n\n\n            ret = get_phys_addr(env, address, access_type,\n\n                                stage_1_mmu_idx(mmu_idx), &ipa, attrs,\n\n                                prot, page_size, fsr, fi);\n\n\n\n            \/* If S1 fails or S2 is disabled, return early.  *\/\n\n            if (ret || regime_translation_disabled(env, ARMMMUIdx_S2NS)) {\n\n                *phys_ptr = ipa;\n\n                return ret;\n\n            }\n\n\n\n            \/* S1 is done. Now do S2 translation.  *\/\n\n            ret = get_phys_addr_lpae(env, ipa, access_type, ARMMMUIdx_S2NS,\n\n                                     phys_ptr, attrs, &s2_prot,\n\n                                     page_size, fsr, fi);\n\n            fi->s2addr = ipa;\n\n            \/* Combine the S1 and S2 perms.  *\/\n\n            *prot &= s2_prot;\n\n            return ret;\n\n        } else {\n\n            \/*\n\n             * For non-EL2 CPUs a stage1+stage2 translation is just stage 1.\n\n             *\/\n\n            mmu_idx = stage_1_mmu_idx(mmu_idx);\n\n        }\n\n    }\n\n\n\n    \/* The page table entries may downgrade secure to non-secure, but\n\n     * cannot upgrade an non-secure translation regime's attributes\n\n     * to secure.\n\n     *\/\n\n    attrs->secure = regime_is_secure(env, mmu_idx);\n\n    attrs->user = regime_is_user(env, mmu_idx);\n\n\n\n    \/* Fast Context Switch Extension. This doesn't exist at all in v8.\n\n     * In v7 and earlier it affects all stage 1 translations.\n\n     *\/\n\n    if (address < 0x02000000 && mmu_idx != ARMMMUIdx_S2NS\n\n        && !arm_feature(env, ARM_FEATURE_V8)) {\n\n        if (regime_el(env, mmu_idx) == 3) {\n\n            address += env->cp15.fcseidr_s;\n\n        } else {\n\n            address += env->cp15.fcseidr_ns;\n\n        }\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_PMSA)) {\n\n        bool ret;\n\n        *page_size = TARGET_PAGE_SIZE;\n\n\n\n        if (arm_feature(env, ARM_FEATURE_V8)) {\n\n            \/* PMSAv8 *\/\n\n            ret = get_phys_addr_pmsav8(env, address, access_type, mmu_idx,\n\n                                       phys_ptr, prot, fsr);\n\n        } else if (arm_feature(env, ARM_FEATURE_V7)) {\n\n            \/* PMSAv7 *\/\n\n            ret = get_phys_addr_pmsav7(env, address, access_type, mmu_idx,\n\n                                       phys_ptr, prot, fsr);\n\n        } else {\n\n            \/* Pre-v7 MPU *\/\n\n            ret = get_phys_addr_pmsav5(env, address, access_type, mmu_idx,\n\n                                       phys_ptr, prot, fsr);\n\n        }\n\n        qemu_log_mask(CPU_LOG_MMU, \"PMSA MPU lookup for %s at 0x%08\" PRIx32\n\n                      \" mmu_idx %u -> %s (prot %c%c%c)\\n\",\n\n                      access_type == MMU_DATA_LOAD ? \"reading\" :\n\n                      (access_type == MMU_DATA_STORE ? \"writing\" : \"execute\"),\n\n                      (uint32_t)address, mmu_idx,\n\n                      ret ? \"Miss\" : \"Hit\",\n\n                      *prot & PAGE_READ ? 'r' : '-',\n\n                      *prot & PAGE_WRITE ? 'w' : '-',\n\n                      *prot & PAGE_EXEC ? 'x' : '-');\n\n\n\n        return ret;\n\n    }\n\n\n\n    \/* Definitely a real MMU, not an MPU *\/\n\n\n\n    if (regime_translation_disabled(env, mmu_idx)) {\n\n        \/* MMU disabled. *\/\n\n        *phys_ptr = address;\n\n        *prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n        *page_size = TARGET_PAGE_SIZE;\n\n        return 0;\n\n    }\n\n\n\n    if (regime_using_lpae_format(env, mmu_idx)) {\n\n        return get_phys_addr_lpae(env, address, access_type, mmu_idx, phys_ptr,\n\n                                  attrs, prot, page_size, fsr, fi);\n\n    } else if (regime_sctlr(env, mmu_idx) & SCTLR_XP) {\n\n        return get_phys_addr_v6(env, address, access_type, mmu_idx, phys_ptr,\n\n                                attrs, prot, page_size, fsr, fi);\n\n    } else {\n\n        return get_phys_addr_v5(env, address, access_type, mmu_idx, phys_ptr,\n\n                                prot, page_size, fsr, fi);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"f7613bee32ebd13ff4a8d721a59cf27b1fe5d94b","target":0,"func":"static int v9fs_do_chown(V9fsState *s, V9fsString *path, uid_t uid, gid_t gid)\n\n{\n\n    return s->ops->chown(&s->ctx, path->data, uid, gid);\n\n}\n"},{"project":"qemu","commit_id":"a90a7425cf592a3afeff3eaf32f543b83050ee5c","target":0,"func":"static void tap_update_fd_handler(TAPState *s)\n\n{\n\n    qemu_set_fd_handler2(s->fd,\n\n                         s->read_poll && s->enabled ? tap_can_send : NULL,\n\n                         s->read_poll && s->enabled ? tap_send     : NULL,\n\n                         s->write_poll && s->enabled ? tap_writable : NULL,\n\n                         s);\n\n}\n"},{"project":"qemu","commit_id":"788cf9f8c8cbda53843e060540f3e91a060eb744","target":1,"func":"void hmp_change(Monitor *mon, const QDict *qdict)\n\n{\n\n    const char *device = qdict_get_str(qdict, \"device\");\n\n    const char *target = qdict_get_str(qdict, \"target\");\n\n    const char *arg = qdict_get_try_str(qdict, \"arg\");\n\n    const char *read_only = qdict_get_try_str(qdict, \"read-only-mode\");\n\n    BlockdevChangeReadOnlyMode read_only_mode = 0;\n\n    Error *err = NULL;\n\n\n\n    if (strcmp(device, \"vnc\") == 0) {\n\n        if (read_only) {\n\n            monitor_printf(mon,\n\n                           \"Parameter 'read-only-mode' is invalid for VNC\\n\");\n\n            return;\n\n        }\n\n        if (strcmp(target, \"passwd\") == 0 ||\n\n            strcmp(target, \"password\") == 0) {\n\n            if (!arg) {\n\n                monitor_read_password(mon, hmp_change_read_arg, NULL);\n\n                return;\n\n            }\n\n        }\n\n        qmp_change(\"vnc\", target, !!arg, arg, &err);\n\n    } else {\n\n        if (read_only) {\n\n            read_only_mode =\n\n                qapi_enum_parse(BlockdevChangeReadOnlyMode_lookup,\n\n                                read_only, BLOCKDEV_CHANGE_READ_ONLY_MODE__MAX,\n\n                                BLOCKDEV_CHANGE_READ_ONLY_MODE_RETAIN, &err);\n\n            if (err) {\n\n                hmp_handle_error(mon, &err);\n\n                return;\n\n            }\n\n        }\n\n\n\n        qmp_blockdev_change_medium(true, device, false, NULL, target,\n\n                                   !!arg, arg, !!read_only, read_only_mode,\n\n                                   &err);\n\n        if (err &&\n\n            error_get_class(err) == ERROR_CLASS_DEVICE_ENCRYPTED) {\n\n            error_free(err);\n\n            monitor_read_block_device_key(mon, device, NULL, NULL);\n\n            return;\n\n        }\n\n    }\n\n\n\n    hmp_handle_error(mon, &err);\n\n}\n"},{"project":"qemu","commit_id":"b7d1f77adaab790d20232df261d4e2ff6a77f556","target":1,"func":"static void ppc_spapr_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    const char *boot_device = machine->boot_order;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *rma_region;\n\n    void *rma = NULL;\n\n    hwaddr rma_alloc_size;\n\n    hwaddr node0_size = spapr_node0_size();\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, rtas_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    spapr = g_malloc0(sizeof(*spapr));\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    \/* Allocate RMA if necessary *\/\n\n    rma_alloc_size = kvmppc_alloc_rma(&rma);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        hw_error(\"qemu: Unable to create RMA\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < node0_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = node0_size;\n\n\n\n        \/* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         *\/\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size > node0_size) {\n\n        fprintf(stderr, \"Error: Numa node 0 has to span the RMA (%#08\"HWADDR_PRIx\")\\n\",\n\n                spapr->rma_size);\n\n        exit(1);\n\n    }\n\n\n\n    \/* We place the device tree and RTAS just below either the top of the RMA,\n\n     * or just below 2GB, whichever is lowere, so that it can be\n\n     * processed with 32-bit real mode code if necessary *\/\n\n    rtas_limit = MIN(spapr->rma_size, 0x80000000);\n\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n\n\n\n    \/* We aim for a hash table of size 1\/128 the size of RAM.  The\n\n     * normal rule of thumb is 1\/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. *\/\n\n    spapr->htab_shift = 18; \/* Minimum architected size *\/\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n\n\n    \/* Set up Interrupt Controller before we create the VCPUs *\/\n\n    spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() \/ smp_threads,\n\n                                  XICS_IRQS);\n\n\n\n    \/* init CPUs *\/\n\n    if (cpu_model == NULL) {\n\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        \/* Set time-base frequency to 512 MHz *\/\n\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n\n\n\n        \/* PAPR always has exception vectors in RAM not ROM. To ensure this,\n\n         * MSR[IP] should never be set.\n\n         *\/\n\n        env->msr_mask &= ~(1 << 6);\n\n\n\n        \/* Tell KVM that we're in PAPR mode *\/\n\n        if (kvm_enabled()) {\n\n            kvmppc_set_papr(cpu);\n\n        }\n\n\n\n        if (cpu->max_compat) {\n\n            if (ppc_set_compat(cpu, cpu->max_compat) < 0) {\n\n                exit(1);\n\n            }\n\n        }\n\n\n\n        xics_cpu_setup(spapr->icp, cpu);\n\n\n\n        qemu_register_reset(spapr_cpu_reset, cpu);\n\n    }\n\n\n\n    \/* allocate RAM *\/\n\n    spapr->ram_limit = ram_size;\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_spapr.ram\",\n\n                                         spapr->ram_limit);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    if (rma_alloc_size && rma) {\n\n        rma_region = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram_ptr(rma_region, NULL, \"ppc_spapr.rma\",\n\n                                   rma_alloc_size, rma);\n\n        vmstate_register_ram_global(rma_region);\n\n        memory_region_add_subregion(sysmem, 0, rma_region);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n\n                                           rtas_limit - spapr->rtas_addr);\n\n    if (spapr->rtas_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    \/* Set up EPOW events infrastructure *\/\n\n    spapr_events_init(spapr);\n\n\n\n    \/* Set up VIO bus *\/\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    \/* We always have at least the nvram device on VIO *\/\n\n    spapr_create_nvram(spapr);\n\n\n\n    \/* Set up PCI *\/\n\n    spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW);\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    \/* Graphics *\/\n\n    if (spapr_vga_init(phb->bus)) {\n\n        spapr->has_graphics = true;\n\n    }\n\n\n\n    if (usb_enabled(spapr->has_graphics)) {\n\n        pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        if (spapr->has_graphics) {\n\n            usbdevice_create(\"keyboard\");\n\n            usbdevice_create(\"mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size == ELF_LOAD_WRONG_ENDIAN) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: error loading %s: %s\\n\",\n\n                    kernel_filename, load_elf_strerror(kernel_size));\n\n            exit(1);\n\n        }\n\n\n\n        \/* load initrd *\/\n\n        if (initrd_filename) {\n\n            \/* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             *\/\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    spapr->entry_point = 0x100;\n\n\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr\/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    \/* Prepare the device tree *\/\n\n    spapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            boot_device, kernel_cmdline,\n\n                                            spapr->epow_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n}\n"},{"project":"qemu","commit_id":"c9baa30f42a87f61627391698f63fa4d1566d9d8","target":1,"func":"static void query_facilities(void)\n\n{\n\n    struct sigaction sa_old, sa_new;\n\n    register int r0 __asm__(\"0\");\n\n    register void *r1 __asm__(\"1\");\n\n    int fail;\n\n\n\n    memset(&sa_new, 0, sizeof(sa_new));\n\n    sa_new.sa_handler = sigill_handler;\n\n    sigaction(SIGILL, &sa_new, &sa_old);\n\n\n\n    \/* First, try STORE FACILITY LIST EXTENDED.  If this is present, then\n\n       we need not do any more probing.  Unfortunately, this itself is an\n\n       extension and the original STORE FACILITY LIST instruction is\n\n       kernel-only, storing its results at absolute address 200.  *\/\n\n    \/* stfle 0(%r1) *\/\n\n    r1 = &facilities;\n\n    asm volatile(\".word 0xb2b0,0x1000\"\n\n                 : \"=r\"(r0) : \"0\"(0), \"r\"(r1) : \"memory\", \"cc\");\n\n\n\n    if (got_sigill) {\n\n        \/* STORE FACILITY EXTENDED is not available.  Probe for one of each\n\n           kind of instruction that we're interested in.  *\/\n\n        \/* ??? Possibly some of these are in practice never present unless\n\n           the store-facility-extended facility is also present.  But since\n\n           that isn't documented it's just better to probe for each.  *\/\n\n\n\n        \/* Test for z\/Architecture.  Required even in 31-bit mode.  *\/\n\n        got_sigill = 0;\n\n        \/* agr %r0,%r0 *\/\n\n        asm volatile(\".word 0xb908,0x0000\" : \"=r\"(r0) : : \"cc\");\n\n        if (!got_sigill) {\n\n            facilities |= FACILITY_ZARCH_ACTIVE;\n\n        }\n\n\n\n        \/* Test for long displacement.  *\/\n\n        got_sigill = 0;\n\n        \/* ly %r0,0(%r1) *\/\n\n        r1 = &facilities;\n\n        asm volatile(\".word 0xe300,0x1000,0x0058\"\n\n                     : \"=r\"(r0) : \"r\"(r1) : \"cc\");\n\n        if (!got_sigill) {\n\n            facilities |= FACILITY_LONG_DISP;\n\n        }\n\n\n\n        \/* Test for extended immediates.  *\/\n\n        got_sigill = 0;\n\n        \/* afi %r0,0 *\/\n\n        asm volatile(\".word 0xc209,0x0000,0x0000\" : : : \"cc\");\n\n        if (!got_sigill) {\n\n            facilities |= FACILITY_EXT_IMM;\n\n        }\n\n\n\n        \/* Test for general-instructions-extension.  *\/\n\n        got_sigill = 0;\n\n        \/* msfi %r0,1 *\/\n\n        asm volatile(\".word 0xc201,0x0000,0x0001\");\n\n        if (!got_sigill) {\n\n            facilities |= FACILITY_GEN_INST_EXT;\n\n        }\n\n    }\n\n\n\n    sigaction(SIGILL, &sa_old, NULL);\n\n\n\n    \/* The translator currently uses these extensions unconditionally.\n\n       Pruning this back to the base ESA\/390 architecture doesn't seem\n\n       worthwhile, since even the KVM target requires z\/Arch.  *\/\n\n    fail = 0;\n\n    if ((facilities & FACILITY_ZARCH_ACTIVE) == 0) {\n\n        fprintf(stderr, \"TCG: z\/Arch facility is required.\\n\");\n\n        fprintf(stderr, \"TCG: Boot with a 64-bit enabled kernel.\\n\");\n\n        fail = 1;\n\n    }\n\n    if ((facilities & FACILITY_LONG_DISP) == 0) {\n\n        fprintf(stderr, \"TCG: long-displacement facility is required.\\n\");\n\n        fail = 1;\n\n    }\n\n\n\n    \/* So far there's just enough support for 31-bit mode to let the\n\n       compile succeed.  This is good enough to run QEMU with KVM.  *\/\n\n    if (sizeof(void *) != 8) {\n\n        fprintf(stderr, \"TCG: 31-bit mode is not supported.\\n\");\n\n        fail = 1;\n\n    }\n\n\n\n    if (fail) {\n\n        exit(-1);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"65c0f1e9558c7c762cdb333406243fff1d687117","target":0,"func":"static QObject *parse_array(JSONParserContext *ctxt, QList **tokens, va_list *ap)\n\n{\n\n    QList *list = NULL;\n\n    QObject *token, *peek;\n\n    QList *working = qlist_copy(*tokens);\n\n\n\n    token = qlist_pop(working);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (!token_is_operator(token, '[')) {\n\n        goto out;\n\n    }\n\n    qobject_decref(token);\n\n    token = NULL;\n\n\n\n    list = qlist_new();\n\n\n\n    peek = qlist_peek(working);\n\n    if (peek == NULL) {\n\n        parse_error(ctxt, NULL, \"premature EOI\");\n\n        goto out;\n\n    }\n\n\n\n    if (!token_is_operator(peek, ']')) {\n\n        QObject *obj;\n\n\n\n        obj = parse_value(ctxt, &working, ap);\n\n        if (obj == NULL) {\n\n            parse_error(ctxt, token, \"expecting value\");\n\n            goto out;\n\n        }\n\n\n\n        qlist_append_obj(list, obj);\n\n\n\n        token = qlist_pop(working);\n\n        if (token == NULL) {\n\n            parse_error(ctxt, NULL, \"premature EOI\");\n\n            goto out;\n\n        }\n\n\n\n        while (!token_is_operator(token, ']')) {\n\n            if (!token_is_operator(token, ',')) {\n\n                parse_error(ctxt, token, \"expected separator in list\");\n\n                goto out;\n\n            }\n\n\n\n            qobject_decref(token);\n\n            token = NULL;\n\n\n\n            obj = parse_value(ctxt, &working, ap);\n\n            if (obj == NULL) {\n\n                parse_error(ctxt, token, \"expecting value\");\n\n                goto out;\n\n            }\n\n\n\n            qlist_append_obj(list, obj);\n\n\n\n            token = qlist_pop(working);\n\n            if (token == NULL) {\n\n                parse_error(ctxt, NULL, \"premature EOI\");\n\n                goto out;\n\n            }\n\n        }\n\n\n\n        qobject_decref(token);\n\n        token = NULL;\n\n    } else {\n\n        token = qlist_pop(working);\n\n        qobject_decref(token);\n\n        token = NULL;\n\n    }\n\n\n\n    QDECREF(*tokens);\n\n    *tokens = working;\n\n\n\n    return QOBJECT(list);\n\n\n\nout:\n\n    qobject_decref(token);\n\n    QDECREF(working);\n\n    QDECREF(list);\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"b3db211f3c80bb996a704d665fe275619f728bd4","target":0,"func":"static void test_visitor_in_struct(TestInputVisitorData *data,\n\n                                   const void *unused)\n\n{\n\n    TestStruct *p = NULL;\n\n    Visitor *v;\n\n\n\n    v = visitor_input_test_init(data, \"{ 'integer': -42, 'boolean': true, 'string': 'foo' }\");\n\n\n\n    visit_type_TestStruct(v, NULL, &p, &error_abort);\n\n    g_assert_cmpint(p->integer, ==, -42);\n\n    g_assert(p->boolean == true);\n\n    g_assert_cmpstr(p->string, ==, \"foo\");\n\n\n\n    g_free(p->string);\n\n    g_free(p);\n\n}\n"},{"project":"qemu","commit_id":"72cf2d4f0e181d0d3a3122e04129c58a95da713e","target":0,"func":"static BusState *qbus_find_bus(DeviceState *dev, char *elem)\n\n{\n\n    BusState *child;\n\n\n\n    LIST_FOREACH(child, &dev->child_bus, sibling) {\n\n        if (strcmp(child->name, elem) == 0) {\n\n            return child;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"178e785fb4507ec3462dc772bbe08303416ece47","target":1,"func":"static int pci_qdev_init(DeviceState *qdev)\n\n{\n\n    PCIDevice *pci_dev = (PCIDevice *)qdev;\n\n    PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pci_dev);\n\n    PCIBus *bus;\n\n    int rc;\n\n    bool is_default_rom;\n\n\n\n    \/* initialize cap_present for pci_is_express() and pci_config_size() *\/\n\n    if (pc->is_express) {\n\n        pci_dev->cap_present |= QEMU_PCI_CAP_EXPRESS;\n\n    }\n\n\n\n    bus = PCI_BUS(qdev_get_parent_bus(qdev));\n\n    pci_dev = do_pci_register_device(pci_dev, bus,\n\n                                     object_get_typename(OBJECT(qdev)),\n\n                                     pci_dev->devfn);\n\n    if (pci_dev == NULL)\n\n        return -1;\n\n\n\n    if (pc->init) {\n\n        rc = pc->init(pci_dev);\n\n        if (rc != 0) {\n\n            do_pci_unregister_device(pci_dev);\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    \/* rom loading *\/\n\n    is_default_rom = false;\n\n    if (pci_dev->romfile == NULL && pc->romfile != NULL) {\n\n        pci_dev->romfile = g_strdup(pc->romfile);\n\n        is_default_rom = true;\n\n    }\n\n    pci_add_option_rom(pci_dev, is_default_rom);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"db39fcf1f690b02d612e2bfc00980700887abe03","target":0,"func":"static CharDriverState *qemu_chr_open_mux(CharDriverState *drv)\n\n{\n\n    CharDriverState *chr;\n\n    MuxDriver *d;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    d = g_malloc0(sizeof(MuxDriver));\n\n\n\n    chr->opaque = d;\n\n    d->drv = drv;\n\n    d->focus = -1;\n\n    chr->chr_write = mux_chr_write;\n\n    chr->chr_update_read_handler = mux_chr_update_read_handler;\n\n    chr->chr_accept_input = mux_chr_accept_input;\n\n    \/* Frontend guest-open \/ -close notification is not support with muxes *\/\n\n    chr->chr_set_fe_open = NULL;\n\n    \/* only default to opened state if we've realized the initial\n\n     * set of muxes\n\n     *\/\n\n    chr->explicit_be_open = muxes_realized ? 0 : 1;\n\n    chr->is_mux = 1;\n\n\n\n    return chr;\n\n}\n"},{"project":"qemu","commit_id":"f2ad97ff81da51c064b9e87720ff48a0874f45d4","target":1,"func":"static USBPort *xhci_lookup_uport(XHCIState *xhci, uint32_t *slot_ctx)\n\n{\n\n    USBPort *uport;\n\n    char path[32];\n\n    int i, pos, port;\n\n\n\n    port = (slot_ctx[1]>>16) & 0xFF;\n\n\n\n\n    port = xhci->ports[port-1].uport->index+1;\n\n    pos = snprintf(path, sizeof(path), \"%d\", port);\n\n    for (i = 0; i < 5; i++) {\n\n        port = (slot_ctx[0] >> 4*i) & 0x0f;\n\n        if (!port) {\n\n            break;\n\n\n        pos += snprintf(path + pos, sizeof(path) - pos, \".%d\", port);\n\n\n\n\n    QTAILQ_FOREACH(uport, &xhci->bus.used, next) {\n\n        if (strcmp(uport->path, path) == 0) {\n\n            return uport;\n\n\n\n"},{"project":"qemu","commit_id":"027d9a7d2911e993cdcbd21c7c35d1dd058f05bb","target":1,"func":"static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)\n\n{\n\n    CPUArchState *env = cpu->env_ptr;\n\n    uintptr_t ret;\n\n    TranslationBlock *last_tb;\n\n    int tb_exit;\n\n    uint8_t *tb_ptr = itb->tc_ptr;\n\n\n\n    qemu_log_mask_and_addr(CPU_LOG_EXEC, itb->pc,\n\n                           \"Trace %p [\" TARGET_FMT_lx \"] %s\\n\",\n\n                           itb->tc_ptr, itb->pc, lookup_symbol(itb->pc));\n\n\n\n#if defined(DEBUG_DISAS)\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_CPU)\n\n        && qemu_log_in_addr_range(itb->pc)) {\n\n#if defined(TARGET_I386)\n\n        log_cpu_state(cpu, CPU_DUMP_CCOP);\n\n#elif defined(TARGET_M68K)\n\n        \/* ??? Should not modify env state for dumping.  *\/\n\n        cpu_m68k_flush_flags(env, env->cc_op);\n\n        env->cc_op = CC_OP_FLAGS;\n\n        env->sr = (env->sr & 0xffe0) | env->cc_dest | (env->cc_x << 4);\n\n        log_cpu_state(cpu, 0);\n\n#else\n\n        log_cpu_state(cpu, 0);\n\n#endif\n\n    }\n\n#endif \/* DEBUG_DISAS *\/\n\n\n\n    cpu->can_do_io = !use_icount;\n\n    ret = tcg_qemu_tb_exec(env, tb_ptr);\n\n    cpu->can_do_io = 1;\n\n    last_tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);\n\n    tb_exit = ret & TB_EXIT_MASK;\n\n    trace_exec_tb_exit(last_tb, tb_exit);\n\n\n\n    if (tb_exit > TB_EXIT_IDX1) {\n\n        \/* We didn't start executing this TB (eg because the instruction\n\n         * counter hit zero); we must restore the guest PC to the address\n\n         * of the start of the TB.\n\n         *\/\n\n        CPUClass *cc = CPU_GET_CLASS(cpu);\n\n        qemu_log_mask_and_addr(CPU_LOG_EXEC, last_tb->pc,\n\n                               \"Stopped execution of TB chain before %p [\"\n\n                               TARGET_FMT_lx \"] %s\\n\",\n\n                               last_tb->tc_ptr, last_tb->pc,\n\n                               lookup_symbol(last_tb->pc));\n\n        if (cc->synchronize_from_tb) {\n\n            cc->synchronize_from_tb(cpu, last_tb);\n\n        } else {\n\n            assert(cc->set_pc);\n\n            cc->set_pc(cpu, last_tb->pc);\n\n        }\n\n    }\n\n    if (tb_exit == TB_EXIT_REQUESTED) {\n\n        \/* We were asked to stop executing TBs (probably a pending\n\n         * interrupt. We've now stopped, so clear the flag.\n\n         *\/\n\n        cpu->tcg_exit_req = 0;\n\n    }\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"c572f23a3e7180dbeab5e86583e43ea2afed6271","target":1,"func":"static void v9fs_fsync(void *opaque)\n{\n    int err;\n    int32_t fid;\n    int datasync;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    pdu_unmarshal(pdu, offset, \"dd\", &fid, &datasync);\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_fsync(pdu, fidp, datasync);\n    if (!err) {\n        err = offset;\n    }\n    put_fid(pdu, fidp);\nout_nofid:\n    complete_pdu(s, pdu, err);\n}"},{"project":"qemu","commit_id":"b9bec74bcb16519a876ec21cd5277c526a9b512d","target":0,"func":"static int kvm_get_xcrs(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XCRS\n\n    int i, ret;\n\n    struct kvm_xcrs xcrs;\n\n\n\n    if (!kvm_has_xcrs())\n\n        return 0;\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_GET_XCRS, &xcrs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < xcrs.nr_xcrs; i++)\n\n        \/* Only support xcr0 now *\/\n\n        if (xcrs.xcrs[0].xcr == 0) {\n\n            env->xcr0 = xcrs.xcrs[0].value;\n\n            break;\n\n        }\n\n    return 0;\n\n#else\n\n    return 0;\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"b591dc59bc98ee558db4ca512aa117748ebfdeef","target":0,"func":"static void temp_allocate_frame(TCGContext *s, int temp)\n\n{\n\n    TCGTemp *ts;\n\n    ts = &s->temps[temp];\n\n    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);\n\n    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)\n\n        tcg_abort();\n\n    ts->mem_offset = s->current_frame_offset;\n\n    ts->mem_reg = s->frame_reg;\n\n    ts->mem_allocated = 1;\n\n    s->current_frame_offset += sizeof(tcg_target_long);\n\n}\n"},{"project":"qemu","commit_id":"d368ba4376b2c1c24175c74b3733b8fe64dbe8a6","target":0,"func":"static uint32_t sdhci_read_dataport(SDHCIState *s, unsigned size)\n\n{\n\n    uint32_t value = 0;\n\n    int i;\n\n\n\n    \/* first check that a valid data exists in host controller input buffer *\/\n\n    if ((s->prnsts & SDHC_DATA_AVAILABLE) == 0) {\n\n        ERRPRINT(\"Trying to read from empty buffer\\n\");\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        value |= s->fifo_buffer[s->data_count] << i * 8;\n\n        s->data_count++;\n\n        \/* check if we've read all valid data (blksize bytes) from buffer *\/\n\n        if ((s->data_count) >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"All %u bytes of data have been read from input buffer\\n\",\n\n                    s->data_count);\n\n            s->prnsts &= ~SDHC_DATA_AVAILABLE; \/* no more data in a buffer *\/\n\n            s->data_count = 0;  \/* next buff read must start at position [0] *\/\n\n\n\n            if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n                s->blkcnt--;\n\n            }\n\n\n\n            \/* if that was the last block of data *\/\n\n            if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||\n\n                ((s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0)) ||\n\n                 \/* stop at gap request *\/\n\n                (s->stopped_state == sdhc_gap_read &&\n\n                 !(s->prnsts & SDHC_DAT_LINE_ACTIVE))) {\n\n                SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n            } else { \/* if there are more data, read next block from card *\/\n\n                SDHCI_GET_CLASS(s)->read_block_from_card(s);\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return value;\n\n}\n"},{"project":"qemu","commit_id":"13f12430d48b62e2304e0e5a7c607279af68b98a","target":0,"func":"qcrypto_tls_session_new(QCryptoTLSCreds *creds,\n\n                        const char *hostname,\n\n                        const char *aclname,\n\n                        QCryptoTLSCredsEndpoint endpoint,\n\n                        Error **errp)\n\n{\n\n    QCryptoTLSSession *session;\n\n    int ret;\n\n\n\n    session = g_new0(QCryptoTLSSession, 1);\n\n    trace_qcrypto_tls_session_new(\n\n        session, creds, hostname ? hostname : \"<none>\",\n\n        aclname ? aclname : \"<none>\", endpoint);\n\n\n\n    if (hostname) {\n\n        session->hostname = g_strdup(hostname);\n\n    }\n\n    if (aclname) {\n\n        session->aclname = g_strdup(aclname);\n\n    }\n\n    session->creds = creds;\n\n    object_ref(OBJECT(creds));\n\n\n\n    if (creds->endpoint != endpoint) {\n\n        error_setg(errp, \"Credentials endpoint doesn't match session\");\n\n        goto error;\n\n    }\n\n\n\n    if (endpoint == QCRYPTO_TLS_CREDS_ENDPOINT_SERVER) {\n\n        ret = gnutls_init(&session->handle, GNUTLS_SERVER);\n\n    } else {\n\n        ret = gnutls_init(&session->handle, GNUTLS_CLIENT);\n\n    }\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Cannot initialize TLS session: %s\",\n\n                   gnutls_strerror(ret));\n\n        goto error;\n\n    }\n\n\n\n    if (object_dynamic_cast(OBJECT(creds),\n\n                            TYPE_QCRYPTO_TLS_CREDS_ANON)) {\n\n        QCryptoTLSCredsAnon *acreds = QCRYPTO_TLS_CREDS_ANON(creds);\n\n\n\n        ret = gnutls_priority_set_direct(session->handle,\n\n                                         \"NORMAL:+ANON-DH\", NULL);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Unable to set TLS session priority: %s\",\n\n                       gnutls_strerror(ret));\n\n            goto error;\n\n        }\n\n        if (creds->endpoint == QCRYPTO_TLS_CREDS_ENDPOINT_SERVER) {\n\n            ret = gnutls_credentials_set(session->handle,\n\n                                         GNUTLS_CRD_ANON,\n\n                                         acreds->data.server);\n\n        } else {\n\n            ret = gnutls_credentials_set(session->handle,\n\n                                         GNUTLS_CRD_ANON,\n\n                                         acreds->data.client);\n\n        }\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Cannot set session credentials: %s\",\n\n                       gnutls_strerror(ret));\n\n            goto error;\n\n        }\n\n    } else if (object_dynamic_cast(OBJECT(creds),\n\n                                   TYPE_QCRYPTO_TLS_CREDS_X509)) {\n\n        QCryptoTLSCredsX509 *tcreds = QCRYPTO_TLS_CREDS_X509(creds);\n\n\n\n        ret = gnutls_set_default_priority(session->handle);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Cannot set default TLS session priority: %s\",\n\n                       gnutls_strerror(ret));\n\n            goto error;\n\n        }\n\n        ret = gnutls_credentials_set(session->handle,\n\n                                     GNUTLS_CRD_CERTIFICATE,\n\n                                     tcreds->data);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Cannot set session credentials: %s\",\n\n                       gnutls_strerror(ret));\n\n            goto error;\n\n        }\n\n\n\n        if (creds->endpoint == QCRYPTO_TLS_CREDS_ENDPOINT_SERVER) {\n\n            \/* This requests, but does not enforce a client cert.\n\n             * The cert checking code later does enforcement *\/\n\n            gnutls_certificate_server_set_request(session->handle,\n\n                                                  GNUTLS_CERT_REQUEST);\n\n        }\n\n    } else {\n\n        error_setg(errp, \"Unsupported TLS credentials type %s\",\n\n                   object_get_typename(OBJECT(creds)));\n\n        goto error;\n\n    }\n\n\n\n    gnutls_transport_set_ptr(session->handle, session);\n\n    gnutls_transport_set_push_function(session->handle,\n\n                                       qcrypto_tls_session_push);\n\n    gnutls_transport_set_pull_function(session->handle,\n\n                                       qcrypto_tls_session_pull);\n\n\n\n    return session;\n\n\n\n error:\n\n    qcrypto_tls_session_free(session);\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"f738cfc843055238ad969782db69156929873832","target":0,"func":"BlockBackend *blk_new(uint64_t perm, uint64_t shared_perm)\n\n{\n\n    BlockBackend *blk;\n\n\n\n    blk = g_new0(BlockBackend, 1);\n\n    blk->refcnt = 1;\n\n    blk->perm = perm;\n\n    blk->shared_perm = shared_perm;\n\n    blk_set_enable_write_cache(blk, true);\n\n\n\n    qemu_co_mutex_init(&blk->public.throttle_group_member.throttled_reqs_lock);\n\n    qemu_co_queue_init(&blk->public.throttle_group_member.throttled_reqs[0]);\n\n    qemu_co_queue_init(&blk->public.throttle_group_member.throttled_reqs[1]);\n\n    block_acct_init(&blk->stats);\n\n\n\n    notifier_list_init(&blk->remove_bs_notifiers);\n\n    notifier_list_init(&blk->insert_bs_notifiers);\n\n\n\n    QTAILQ_INSERT_TAIL(&block_backends, blk, link);\n\n    return blk;\n\n}\n"},{"project":"qemu","commit_id":"61007b316cd71ee7333ff7a0a749a8949527575f","target":0,"func":"int bdrv_is_allocated_above(BlockDriverState *top,\n\n                            BlockDriverState *base,\n\n                            int64_t sector_num,\n\n                            int nb_sectors, int *pnum)\n\n{\n\n    BlockDriverState *intermediate;\n\n    int ret, n = nb_sectors;\n\n\n\n    intermediate = top;\n\n    while (intermediate && intermediate != base) {\n\n        int pnum_inter;\n\n        ret = bdrv_is_allocated(intermediate, sector_num, nb_sectors,\n\n                                &pnum_inter);\n\n        if (ret < 0) {\n\n            return ret;\n\n        } else if (ret) {\n\n            *pnum = pnum_inter;\n\n            return 1;\n\n        }\n\n\n\n        \/*\n\n         * [sector_num, nb_sectors] is unallocated on top but intermediate\n\n         * might have\n\n         *\n\n         * [sector_num+x, nr_sectors] allocated.\n\n         *\/\n\n        if (n > pnum_inter &&\n\n            (intermediate == top ||\n\n             sector_num + pnum_inter < intermediate->total_sectors)) {\n\n            n = pnum_inter;\n\n        }\n\n\n\n        intermediate = intermediate->backing_hd;\n\n    }\n\n\n\n    *pnum = n;\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"b25b387fa5928e516cb2c9e7fde68e958bd7e50a","target":0,"func":"static int64_t coroutine_fn qcow2_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum, BlockDriverState **file)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t cluster_offset;\n\n    int index_in_cluster, ret;\n\n    unsigned int bytes;\n\n    int64_t status = 0;\n\n\n\n    bytes = MIN(INT_MAX, nb_sectors * BDRV_SECTOR_SIZE);\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_get_cluster_offset(bs, sector_num << 9, &bytes,\n\n                                   &cluster_offset);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    *pnum = bytes >> BDRV_SECTOR_BITS;\n\n\n\n    if (cluster_offset != 0 && ret != QCOW2_CLUSTER_COMPRESSED &&\n\n        !s->cipher) {\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        cluster_offset |= (index_in_cluster << BDRV_SECTOR_BITS);\n\n        *file = bs->file->bs;\n\n        status |= BDRV_BLOCK_OFFSET_VALID | cluster_offset;\n\n    }\n\n    if (ret == QCOW2_CLUSTER_ZERO_PLAIN || ret == QCOW2_CLUSTER_ZERO_ALLOC) {\n\n        status |= BDRV_BLOCK_ZERO;\n\n    } else if (ret != QCOW2_CLUSTER_UNALLOCATED) {\n\n        status |= BDRV_BLOCK_DATA;\n\n    }\n\n    return status;\n\n}\n"},{"project":"qemu","commit_id":"bec1631100323fac0900aea71043d5c4e22fc2fa","target":0,"func":"static inline int tcg_gen_code_common(TCGContext *s,\n\n                                      tcg_insn_unit *gen_code_buf,\n\n                                      long search_pc)\n\n{\n\n    int oi, oi_next;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP))) {\n\n        qemu_log(\"OP:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->opt_time -= profile_getclock();\n\n#endif\n\n\n\n#ifdef USE_TCG_OPTIMIZATIONS\n\n    tcg_optimize(s);\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->opt_time += profile_getclock();\n\n    s->la_time -= profile_getclock();\n\n#endif\n\n\n\n    tcg_liveness_analysis(s);\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->la_time += profile_getclock();\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP_OPT))) {\n\n        qemu_log(\"OP after optimization and liveness analysis:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    tcg_reg_alloc_start(s);\n\n\n\n    s->code_buf = gen_code_buf;\n\n    s->code_ptr = gen_code_buf;\n\n\n\n    tcg_out_tb_init(s);\n\n\n\n    for (oi = s->gen_first_op_idx; oi >= 0; oi = oi_next) {\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGArg * const args = &s->gen_opparam_buf[op->args];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n        uint16_t dead_args = s->op_dead_args[oi];\n\n        uint8_t sync_args = s->op_sync_args[oi];\n\n\n\n        oi_next = op->next;\n\n#ifdef CONFIG_PROFILER\n\n        tcg_table_op_count[opc]++;\n\n#endif\n\n\n\n        switch (opc) {\n\n        case INDEX_op_mov_i32:\n\n        case INDEX_op_mov_i64:\n\n            tcg_reg_alloc_mov(s, def, args, dead_args, sync_args);\n\n            break;\n\n        case INDEX_op_movi_i32:\n\n        case INDEX_op_movi_i64:\n\n            tcg_reg_alloc_movi(s, args, dead_args, sync_args);\n\n            break;\n\n        case INDEX_op_debug_insn_start:\n\n            break;\n\n        case INDEX_op_discard:\n\n            temp_dead(s, args[0]);\n\n            break;\n\n        case INDEX_op_set_label:\n\n            tcg_reg_alloc_bb_end(s, s->reserved_regs);\n\n            tcg_out_label(s, args[0], s->code_ptr);\n\n            break;\n\n        case INDEX_op_call:\n\n            tcg_reg_alloc_call(s, op->callo, op->calli, args,\n\n                               dead_args, sync_args);\n\n            break;\n\n        default:\n\n            \/* Sanity check that we've not introduced any unhandled opcodes. *\/\n\n            if (def->flags & TCG_OPF_NOT_PRESENT) {\n\n                tcg_abort();\n\n            }\n\n            \/* Note: in order to speed up the code, it would be much\n\n               faster to have specialized register allocator functions for\n\n               some common argument patterns *\/\n\n            tcg_reg_alloc_op(s, def, opc, args, dead_args, sync_args);\n\n            break;\n\n        }\n\n        if (search_pc >= 0 && search_pc < tcg_current_code_size(s)) {\n\n            return oi;\n\n        }\n\n#ifndef NDEBUG\n\n        check_regs(s);\n\n#endif\n\n    }\n\n\n\n    \/* Generate TB finalization at the end of block *\/\n\n    tcg_out_tb_finalize(s);\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"823bd7391c96ba675f20fd6d952d1cb6e1ffb851","target":1,"func":"static int32_t scsi_disk_emulate_command(SCSIRequest *req, uint8_t *buf)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    uint8_t *outbuf;\n\n    int buflen;\n\n\n\n    switch (req->cmd.buf[0]) {\n\n    case INQUIRY:\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n    case RESERVE:\n\n    case RESERVE_10:\n\n    case RELEASE:\n\n    case RELEASE_10:\n\n    case START_STOP:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case GET_CONFIGURATION:\n\n    case GET_EVENT_STATUS_NOTIFICATION:\n\n    case MECHANISM_STATUS:\n\n    case REQUEST_SENSE:\n\n        break;\n\n\n\n    default:\n\n        if (s->tray_open || !bdrv_is_inserted(s->qdev.conf.bs)) {\n\n            scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n\n            return 0;\n\n        }\n\n        break;\n\n    }\n\n\n\n    \/*\n\n     * FIXME: we shouldn't return anything bigger than 4k, but the code\n\n     * requires the buffer to be as big as req->cmd.xfer in several\n\n     * places.  So, do not allow CDBs with a very large ALLOCATION\n\n     * LENGTH.  The real fix would be to modify scsi_read_data and\n\n     * dma_buf_read, so that they return data beyond the buflen\n\n     * as all zeros.\n\n     *\/\n\n    if (req->cmd.xfer > 65536) {\n\n        goto illegal_request;\n\n    }\n\n    r->buflen = MAX(4096, req->cmd.xfer);\n\n\n\n    if (!r->iov.iov_base) {\n\n        r->iov.iov_base = qemu_blockalign(s->qdev.conf.bs, r->buflen);\n\n    }\n\n\n\n    buflen = req->cmd.xfer;\n\n    outbuf = r->iov.iov_base;\n\n    memset(outbuf, 0, r->buflen);\n\n    switch (req->cmd.buf[0]) {\n\n    case TEST_UNIT_READY:\n\n        assert(!s->tray_open && bdrv_is_inserted(s->qdev.conf.bs));\n\n        break;\n\n    case INQUIRY:\n\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_TOC:\n\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RESERVE:\n\n        if (req->cmd.buf[1] & 1) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RESERVE_10:\n\n        if (req->cmd.buf[1] & 3) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RELEASE:\n\n        if (req->cmd.buf[1] & 1) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RELEASE_10:\n\n        if (req->cmd.buf[1] & 3) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case START_STOP:\n\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n\n            return 0;\n\n        }\n\n        break;\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n        s->tray_locked = req->cmd.buf[4] & 1;\n\n        bdrv_lock_medium(s->qdev.conf.bs, req->cmd.buf[4] & 1);\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        \/* The normal LEN field for this command is zero.  *\/\n\n        memset(outbuf, 0, 8);\n\n        bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n        if (!nb_sectors) {\n\n            scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n            return 0;\n\n        }\n\n        if ((req->cmd.buf[8] & 1) == 0 && req->cmd.lba) {\n\n            goto illegal_request;\n\n        }\n\n        nb_sectors \/= s->qdev.blocksize \/ 512;\n\n        \/* Returned value is the address of the last sector.  *\/\n\n        nb_sectors--;\n\n        \/* Remember the new size for read\/write sanity checking. *\/\n\n        s->qdev.max_lba = nb_sectors;\n\n        \/* Clip to 2TB, instead of returning capacity modulo 2TB. *\/\n\n        if (nb_sectors > UINT32_MAX) {\n\n            nb_sectors = UINT32_MAX;\n\n        }\n\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n\n        outbuf[3] = nb_sectors & 0xff;\n\n        outbuf[4] = 0;\n\n        outbuf[5] = 0;\n\n        outbuf[6] = s->qdev.blocksize >> 8;\n\n        outbuf[7] = 0;\n\n        break;\n\n    case REQUEST_SENSE:\n\n        \/* Just return \"NO SENSE\".  *\/\n\n        buflen = scsi_build_sense(NULL, 0, outbuf, r->buflen,\n\n                                  (req->cmd.buf[1] & 1) == 0);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case MECHANISM_STATUS:\n\n        buflen = scsi_emulate_mechanism_status(s, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case GET_CONFIGURATION:\n\n        buflen = scsi_get_configuration(s, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case GET_EVENT_STATUS_NOTIFICATION:\n\n        buflen = scsi_get_event_status_notification(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_DISC_INFORMATION:\n\n        buflen = scsi_read_disc_information(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_DVD_STRUCTURE:\n\n        buflen = scsi_read_dvd_structure(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case SERVICE_ACTION_IN_16:\n\n        \/* Service Action In subcommands. *\/\n\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n\n            memset(outbuf, 0, req->cmd.xfer);\n\n            bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n            if (!nb_sectors) {\n\n                scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n                return 0;\n\n            }\n\n            if ((req->cmd.buf[14] & 1) == 0 && req->cmd.lba) {\n\n                goto illegal_request;\n\n            }\n\n            nb_sectors \/= s->qdev.blocksize \/ 512;\n\n            \/* Returned value is the address of the last sector.  *\/\n\n            nb_sectors--;\n\n            \/* Remember the new size for read\/write sanity checking. *\/\n\n            s->qdev.max_lba = nb_sectors;\n\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n\n            outbuf[7] = nb_sectors & 0xff;\n\n            outbuf[8] = 0;\n\n            outbuf[9] = 0;\n\n            outbuf[10] = s->qdev.blocksize >> 8;\n\n            outbuf[11] = 0;\n\n            outbuf[12] = 0;\n\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n\n\n            \/* set TPE bit if the format supports discard *\/\n\n            if (s->qdev.conf.discard_granularity) {\n\n                outbuf[14] = 0x80;\n\n            }\n\n\n\n            \/* Protection, exponent and lowest lba field left blank. *\/\n\n            break;\n\n        }\n\n        DPRINTF(\"Unsupported Service Action In\\n\");\n\n        goto illegal_request;\n\n    case SYNCHRONIZE_CACHE:\n\n        \/* The request is used as the AIO opaque value, so add a ref.  *\/\n\n        scsi_req_ref(&r->req);\n\n        bdrv_acct_start(s->qdev.conf.bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n\n        r->req.aiocb = bdrv_aio_flush(s->qdev.conf.bs, scsi_aio_complete, r);\n\n        return 0;\n\n    case SEEK_10:\n\n        DPRINTF(\"Seek(10) (sector %\" PRId64 \")\\n\", r->req.cmd.lba);\n\n        if (r->req.cmd.lba > s->qdev.max_lba) {\n\n            goto illegal_lba;\n\n        }\n\n        break;\n\n    case MODE_SELECT:\n\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        break;\n\n    case MODE_SELECT_10:\n\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        break;\n\n    case UNMAP:\n\n        DPRINTF(\"Unmap (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        break;\n\n    case WRITE_SAME_10:\n\n    case WRITE_SAME_16:\n\n        nb_sectors = scsi_data_cdb_length(r->req.cmd.buf);\n\n        if (bdrv_is_read_only(s->qdev.conf.bs)) {\n\n            scsi_check_condition(r, SENSE_CODE(WRITE_PROTECTED));\n\n            return 0;\n\n        }\n\n        if (!check_lba_range(s, r->req.cmd.lba, nb_sectors)) {\n\n            goto illegal_lba;\n\n        }\n\n\n\n        \/*\n\n         * We only support WRITE SAME with the unmap bit set for now.\n\n         *\/\n\n        if (!(req->cmd.buf[1] & 0x8)) {\n\n            goto illegal_request;\n\n        }\n\n\n\n        \/* The request is used as the AIO opaque value, so add a ref.  *\/\n\n        scsi_req_ref(&r->req);\n\n        r->req.aiocb = bdrv_aio_discard(s->qdev.conf.bs,\n\n                                        r->req.cmd.lba * (s->qdev.blocksize \/ 512),\n\n                                        nb_sectors * (s->qdev.blocksize \/ 512),\n\n                                        scsi_aio_complete, r);\n\n        return 0;\n\n    default:\n\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n\n        return 0;\n\n    }\n\n    assert(!r->req.aiocb);\n\n    r->iov.iov_len = MIN(r->buflen, req->cmd.xfer);\n\n    if (r->iov.iov_len == 0) {\n\n        scsi_req_complete(&r->req, GOOD);\n\n    }\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n\n        assert(r->iov.iov_len == req->cmd.xfer);\n\n        return -r->iov.iov_len;\n\n    } else {\n\n        return r->iov.iov_len;\n\n    }\n\n\n\nillegal_request:\n\n    if (r->req.status == -1) {\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n\n    }\n\n    return 0;\n\n\n\nillegal_lba:\n\n    scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"fb7b5c0df6e3c501973ce4d57eb2b1d4344a519d","target":0,"func":"static void scsi_unrealize(SCSIDevice *s, Error **errp)\n\n{\n\n    scsi_device_purge_requests(s, SENSE_CODE(NO_SENSE));\n\n    blockdev_mark_auto_del(s->conf.blk);\n\n}\n"},{"project":"qemu","commit_id":"ce8f0905a59232982c8a220169e11c14c73e7dea","target":1,"func":"static void pl011_write(void *opaque, hwaddr offset,\n\n                        uint64_t value, unsigned size)\n\n{\n\n    PL011State *s = (PL011State *)opaque;\n\n    unsigned char ch;\n\n\n\n    switch (offset >> 2) {\n\n    case 0: \/* UARTDR *\/\n\n        \/* ??? Check if transmitter is enabled.  *\/\n\n        ch = value;\n\n        if (s->chr)\n\n            qemu_chr_fe_write(s->chr, &ch, 1);\n\n        s->int_level |= PL011_INT_TX;\n\n        pl011_update(s);\n\n        break;\n\n    case 1: \/* UARTCR *\/\n\n        s->cr = value;\n\n        break;\n\n    case 6: \/* UARTFR *\/\n\n        \/* Writes to Flag register are ignored.  *\/\n\n        break;\n\n    case 8: \/* UARTUARTILPR *\/\n\n        s->ilpr = value;\n\n        break;\n\n    case 9: \/* UARTIBRD *\/\n\n        s->ibrd = value;\n\n        break;\n\n    case 10: \/* UARTFBRD *\/\n\n        s->fbrd = value;\n\n        break;\n\n    case 11: \/* UARTLCR_H *\/\n\n        \/* Reset the FIFO state on FIFO enable or disable *\/\n\n        if ((s->lcr ^ value) & 0x10) {\n\n            s->read_count = 0;\n\n            s->read_pos = 0;\n\n        }\n\n        s->lcr = value;\n\n        pl011_set_read_trigger(s);\n\n        break;\n\n    case 12: \/* UARTCR *\/\n\n        \/* ??? Need to implement the enable and loopback bits.  *\/\n\n        s->cr = value;\n\n        break;\n\n    case 13: \/* UARTIFS *\/\n\n        s->ifl = value;\n\n        pl011_set_read_trigger(s);\n\n        break;\n\n    case 14: \/* UARTIMSC *\/\n\n        s->int_enabled = value;\n\n        pl011_update(s);\n\n        break;\n\n    case 17: \/* UARTICR *\/\n\n        s->int_level &= ~value;\n\n        pl011_update(s);\n\n        break;\n\n    case 18: \/* UARTDMACR *\/\n\n        s->dmacr = value;\n\n        if (value & 3) {\n\n            qemu_log_mask(LOG_UNIMP, \"pl011: DMA not implemented\\n\");\n\n        }\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pl011_write: Bad offset %x\\n\", (int)offset);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"758ead31c7e17bf17a9ef2e0ca1c3e86ab296b43","target":1,"func":"void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)\n\n{\n\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n\n\n    \/* virtio-1 compliant devices cannot change the alignment *\/\n\n    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        error_report(\"tried to modify queue alignment for virtio-1 device\");\n\n        return;\n\n    }\n\n    \/* Check that the transport told us it was going to do this\n\n     * (so a buggy transport will immediately assert rather than\n\n     * silently failing to migrate this state)\n\n     *\/\n\n    assert(k->has_variable_vring_alignment);\n\n\n\n    vdev->vq[n].vring.align = align;\n\n    virtio_queue_update_rings(vdev, n);\n\n}\n"},{"project":"qemu","commit_id":"7bb5d6ade6d8afbcad72a871f712370ffae457c6","target":0,"func":"static void pc_dimm_init(Object *obj)\n\n{\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n\n\n    object_property_add(obj, PC_DIMM_SIZE_PROP, \"int\", pc_dimm_get_size,\n\n                        NULL, NULL, NULL, &error_abort);\n\n    object_property_add_link(obj, PC_DIMM_MEMDEV_PROP, TYPE_MEMORY_BACKEND,\n\n                             (Object **)&dimm->hostmem,\n\n                             qdev_prop_allow_set_link_before_realize,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n\n                             &error_abort);\n\n}\n"},{"project":"qemu","commit_id":"8e9b0d24fb986d4241ae3b77752eca5dab4cb486","target":0,"func":"void vnc_disconnect_finish(VncState *vs)\n\n{\n\n    int i;\n\n\n\n    vnc_jobs_join(vs); \/* Wait encoding jobs *\/\n\n\n\n    vnc_lock_output(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_DISCONNECTED);\n\n\n\n    buffer_free(&vs->input);\n\n    buffer_free(&vs->output);\n\n#ifdef CONFIG_VNC_WS\n\n    buffer_free(&vs->ws_input);\n\n    buffer_free(&vs->ws_output);\n\n#endif \/* CONFIG_VNC_WS *\/\n\n\n\n    qapi_free_VncClientInfo(vs->info);\n\n\n\n    vnc_zlib_clear(vs);\n\n    vnc_tight_clear(vs);\n\n    vnc_zrle_clear(vs);\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    vnc_tls_client_cleanup(vs);\n\n#endif \/* CONFIG_VNC_TLS *\/\n\n#ifdef CONFIG_VNC_SASL\n\n    vnc_sasl_client_cleanup(vs);\n\n#endif \/* CONFIG_VNC_SASL *\/\n\n    audio_del(vs);\n\n    vnc_release_modifiers(vs);\n\n\n\n    if (vs->initialized) {\n\n        QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n\n        qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n\n    }\n\n\n\n    if (vs->vd->lock_key_sync)\n\n        qemu_remove_led_event_handler(vs->led);\n\n    vnc_unlock_output(vs);\n\n\n\n    qemu_mutex_destroy(&vs->output_mutex);\n\n    if (vs->bh != NULL) {\n\n        qemu_bh_delete(vs->bh);\n\n    }\n\n    buffer_free(&vs->jobs_buffer);\n\n\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        g_free(vs->lossy_rect[i]);\n\n    }\n\n    g_free(vs->lossy_rect);\n\n    g_free(vs);\n\n}\n"},{"project":"qemu","commit_id":"846424350b292f16b732b573273a5c1f195cd7a3","target":1,"func":"int scsi_build_sense(uint8_t *in_buf, int in_len,\n\n                     uint8_t *buf, int len, bool fixed)\n\n{\n\n    bool fixed_in;\n\n    SCSISense sense;\n\n    if (!fixed && len < 8) {\n\n        return 0;\n\n    }\n\n\n\n    if (in_len == 0) {\n\n        sense.key = NO_SENSE;\n\n        sense.asc = 0;\n\n        sense.ascq = 0;\n\n    } else {\n\n        fixed_in = (in_buf[0] & 2) == 0;\n\n\n\n        if (fixed == fixed_in) {\n\n            memcpy(buf, in_buf, MIN(len, in_len));\n\n            return MIN(len, in_len);\n\n        }\n\n\n\n        if (fixed_in) {\n\n            sense.key = in_buf[2];\n\n            sense.asc = in_buf[12];\n\n            sense.ascq = in_buf[13];\n\n        } else {\n\n            sense.key = in_buf[1];\n\n            sense.asc = in_buf[2];\n\n            sense.ascq = in_buf[3];\n\n        }\n\n    }\n\n\n\n    memset(buf, 0, len);\n\n    if (fixed) {\n\n        \/* Return fixed format sense buffer *\/\n\n        buf[0] = 0x70;\n\n        buf[2] = sense.key;\n\n        buf[7] = 10;\n\n        buf[12] = sense.asc;\n\n        buf[13] = sense.ascq;\n\n        return MIN(len, 18);\n\n    } else {\n\n        \/* Return descriptor format sense buffer *\/\n\n        buf[0] = 0x72;\n\n        buf[1] = sense.key;\n\n        buf[2] = sense.asc;\n\n        buf[3] = sense.ascq;\n\n        return 8;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"b769d8fef6c06ddb39ef0337882a4f8872b9c2bc","target":0,"func":"CPUPPCState *cpu_ppc_init(void)\n\n{\n\n    CPUPPCState *env;\n\n\n\n    cpu_exec_init();\n\n\n\n    env = qemu_mallocz(sizeof(CPUPPCState));\n\n    if (!env)\n\n        return NULL;\n\n#if !defined(CONFIG_USER_ONLY) && defined (USE_OPEN_FIRMWARE)\n\n    setup_machine(env, 0);\n\n#else\n\n\/\/    env->spr[PVR] = 0; \/* Basic PPC *\/\n\n    env->spr[PVR] = 0x00080100; \/* G3 CPU *\/\n\n\/\/    env->spr[PVR] = 0x00083100; \/* MPC755 (G3 embedded) *\/\n\n\/\/    env->spr[PVR] = 0x00070100; \/* IBM 750FX *\/\n\n#endif\n\n    tlb_flush(env, 1);\n\n#if defined (DO_SINGLE_STEP)\n\n    \/* Single step trace mode *\/\n\n    msr_se = 1;\n\n#endif\n\n    msr_fp = 1; \/* Allow floating point exceptions *\/\n\n    msr_me = 1; \/* Allow machine check exceptions  *\/\n\n#if defined(CONFIG_USER_ONLY)\n\n    msr_pr = 1;\n\n    cpu_ppc_register(env, 0x00080000);\n\n#else\n\n    env->nip = 0xFFFFFFFC;\n\n#endif\n\n    env->access_type = ACCESS_INT;\n\n    cpu_single_env = env;\n\n    return env;\n\n}\n"},{"project":"qemu","commit_id":"2e6fc7eb1a4af1b127df5f07b8bb28af891946fa","target":0,"func":"static void raw_close(BlockDriverState *bs)\n\n{\n\n}\n"},{"project":"qemu","commit_id":"245f7b51c0ea04fb2224b1127430a096c91aee70","target":0,"func":"static void jpeg_init_destination(j_compress_ptr cinfo)\n\n{\n\n    VncState *vs = cinfo->client_data;\n\n    Buffer *buffer = &vs->tight_jpeg;\n\n\n\n    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;\n\n    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);\n\n}\n"},{"project":"qemu","commit_id":"b25f23e7dbc6bc0dcda010222a4f178669d1aedc","target":1,"func":"QList *qdict_get_qlist(const QDict *qdict, const char *key)\n\n{\n\n    return qobject_to_qlist(qdict_get_obj(qdict, key, QTYPE_QLIST));\n\n}\n"},{"project":"qemu","commit_id":"a33609cae0d57a7574608145f553cc5279221c31","target":1,"func":"int kvm_arch_init_vcpu(CPUState *env)\n\n{\n\n    struct {\n\n        struct kvm_cpuid2 cpuid;\n\n        struct kvm_cpuid_entry2 entries[100];\n\n    } __attribute__((packed)) cpuid_data;\n\n    uint32_t limit, i, j, cpuid_i;\n\n    uint32_t eax, ebx, ecx, edx;\n\n\n\n    cpuid_i = 0;\n\n\n\n    cpu_x86_cpuid(env, 0, 0, &eax, &ebx, &ecx, &edx);\n\n    limit = eax;\n\n\n\n    for (i = 0; i <= limit; i++) {\n\n        struct kvm_cpuid_entry2 *c = &cpuid_data.entries[cpuid_i++];\n\n\n\n        switch (i) {\n\n        case 2: {\n\n            \/* Keep reading function 2 till all the input is received *\/\n\n            int times;\n\n\n\n            cpu_x86_cpuid(env, i, 0, &eax, &ebx, &ecx, &edx);\n\n            times = eax & 0xff;\n\n\n\n            c->function = i;\n\n            c->flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;\n\n            c->flags |= KVM_CPUID_FLAG_STATE_READ_NEXT;\n\n            c->eax = eax;\n\n            c->ebx = ebx;\n\n            c->ecx = ecx;\n\n            c->edx = edx;\n\n\n\n            for (j = 1; j < times; ++j) {\n\n                cpu_x86_cpuid(env, i, 0, &eax, &ebx, &ecx, &edx);\n\n                c->function = i;\n\n                c->flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;\n\n                c->eax = eax;\n\n                c->ebx = ebx;\n\n                c->ecx = ecx;\n\n                c->edx = edx;\n\n                c = &cpuid_data.entries[++cpuid_i];\n\n            }\n\n            break;\n\n        }\n\n        case 4:\n\n        case 0xb:\n\n        case 0xd:\n\n            for (j = 0; ; j++) {\n\n                cpu_x86_cpuid(env, i, j, &eax, &ebx, &ecx, &edx);\n\n                c->function = i;\n\n                c->flags = KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\n                c->index = j;\n\n                c->eax = eax;\n\n                c->ebx = ebx;\n\n                c->ecx = ecx;\n\n                c->edx = edx;\n\n                c = &cpuid_data.entries[++cpuid_i];\n\n\n\n                if (i == 4 && eax == 0)\n\n                    break;\n\n                if (i == 0xb && !(ecx & 0xff00))\n\n                    break;\n\n                if (i == 0xd && eax == 0)\n\n                    break;\n\n            }\n\n            break;\n\n        default:\n\n            cpu_x86_cpuid(env, i, 0, &eax, &ebx, &ecx, &edx);\n\n            c->function = i;\n\n            c->eax = eax;\n\n            c->ebx = ebx;\n\n            c->ecx = ecx;\n\n            c->edx = edx;\n\n            break;\n\n        }\n\n    }\n\n    cpu_x86_cpuid(env, 0x80000000, 0, &eax, &ebx, &ecx, &edx);\n\n    limit = eax;\n\n\n\n    for (i = 0x80000000; i <= limit; i++) {\n\n        struct kvm_cpuid_entry2 *c = &cpuid_data.entries[cpuid_i++];\n\n\n\n        cpu_x86_cpuid(env, i, 0, &eax, &ebx, &ecx, &edx);\n\n        c->function = i;\n\n        c->eax = eax;\n\n        c->ebx = ebx;\n\n        c->ecx = ecx;\n\n        c->edx = edx;\n\n    }\n\n\n\n    cpuid_data.cpuid.nent = cpuid_i;\n\n\n\n    return kvm_vcpu_ioctl(env, KVM_SET_CPUID2, &cpuid_data);\n\n}\n"},{"project":"qemu","commit_id":"550830f9351291c585c963204ad9127998b1c1ce","target":0,"func":"static int coroutine_fn cow_read(BlockDriverState *bs, int64_t sector_num,\n\n                                 uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVCowState *s = bs->opaque;\n\n    int ret, n;\n\n\n\n    while (nb_sectors > 0) {\n\n        ret = cow_co_is_allocated(bs, sector_num, nb_sectors, &n);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        if (ret) {\n\n            ret = bdrv_pread(bs->file,\n\n                        s->cow_sectors_offset + sector_num * 512,\n\n                        buf, n * 512);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n        } else {\n\n            if (bs->backing_hd) {\n\n                \/* read from the base image *\/\n\n                ret = bdrv_read(bs->backing_hd, sector_num, buf, n);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n            } else {\n\n                memset(buf, 0, n * 512);\n\n            }\n\n        }\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"ee640c625e190a0c0e6b8966adc0e4720fb75200","target":1,"func":"static void ivshmem_common_realize(PCIDevice *dev, Error **errp)\n\n{\n\n    IVShmemState *s = IVSHMEM_COMMON(dev);\n\n    Error *err = NULL;\n\n    uint8_t *pci_conf;\n\n    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n        PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n    Error *local_err = NULL;\n\n\n\n    \/* IRQFD requires MSI *\/\n\n    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&\n\n        !ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        error_setg(errp, \"ioeventfd\/irqfd requires MSI\");\n\n        return;\n\n    }\n\n\n\n    pci_conf = dev->config;\n\n    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n\n\n\n    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,\n\n                          \"ivshmem-mmio\", IVSHMEM_REG_BAR_SIZE);\n\n\n\n    \/* region for registers*\/\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     &s->ivshmem_mmio);\n\n\n\n    if (s->not_legacy_32bit) {\n\n        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n\n    }\n\n\n\n    if (s->hostmem != NULL) {\n\n        IVSHMEM_DPRINTF(\"using hostmem\\n\");\n\n\n\n        s->ivshmem_bar2 = host_memory_backend_get_memory(s->hostmem,\n\n                                                         &error_abort);\n\n    } else {\n\n        Chardev *chr = qemu_chr_fe_get_driver(&s->server_chr);\n\n        assert(chr);\n\n\n\n        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\\n\",\n\n                        chr->filename);\n\n\n\n        \/* we allocate enough space for 16 peers and grow as needed *\/\n\n        resize_peers(s, 16);\n\n\n\n        \/*\n\n         * Receive setup messages from server synchronously.\n\n         * Older versions did it asynchronously, but that creates a\n\n         * number of entertaining race conditions.\n\n         *\/\n\n        ivshmem_recv_setup(s, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n\n\n        if (s->master == ON_OFF_AUTO_ON && s->vm_id != 0) {\n\n            error_setg(errp,\n\n                       \"master must connect to the server before any peers\");\n\n            return;\n\n        }\n\n\n\n        qemu_chr_fe_set_handlers(&s->server_chr, ivshmem_can_receive,\n\n                                 ivshmem_read, NULL, s, NULL, true);\n\n\n\n        if (ivshmem_setup_interrupts(s) < 0) {\n\n            error_setg(errp, \"failed to initialize interrupts\");\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (s->master == ON_OFF_AUTO_AUTO) {\n\n        s->master = s->vm_id == 0 ? ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF;\n\n    }\n\n\n\n    if (!ivshmem_is_master(s)) {\n\n        error_setg(&s->migration_blocker,\n\n                   \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\");\n\n        migrate_add_blocker(s->migration_blocker, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            error_free(s->migration_blocker);\n\n            return;\n\n        }\n\n    }\n\n\n\n    vmstate_register_ram(s->ivshmem_bar2, DEVICE(s));\n\n    pci_register_bar(PCI_DEVICE(s), 2, attr, s->ivshmem_bar2);\n\n}\n"},{"project":"qemu","commit_id":"245f7b51c0ea04fb2224b1127430a096c91aee70","target":0,"func":"int vnc_tight_send_framebuffer_update(VncState *vs, int x, int y,\n\n                                      int w, int h)\n\n{\n\n    int max_rows;\n\n\n\n    if (vs->clientds.pf.bytes_per_pixel == 4 && vs->clientds.pf.rmax == 0xFF &&\n\n        vs->clientds.pf.bmax == 0xFF && vs->clientds.pf.gmax == 0xFF) {\n\n        vs->tight_pixel24 = true;\n\n    } else {\n\n        vs->tight_pixel24 = false;\n\n    }\n\n\n\n    if (w * h < VNC_TIGHT_MIN_SPLIT_RECT_SIZE)\n\n        return send_rect_simple(vs, x, y, w, h);\n\n\n\n    \/* Calculate maximum number of rows in one non-solid rectangle. *\/\n\n\n\n    max_rows = tight_conf[vs->tight_compression].max_rect_size;\n\n    max_rows \/= MIN(tight_conf[vs->tight_compression].max_rect_width, w);\n\n\n\n    return find_large_solid_color_rect(vs, x, y, w, h, max_rows);\n\n}\n"},{"project":"qemu","commit_id":"4083733db5e4120939acee57019ff52db1f45b9d","target":0,"func":"static void text_console_update(void *opaque, console_ch_t *chardata)\n\n{\n\n    QemuConsole *s = (QemuConsole *) opaque;\n\n    int i, j, src;\n\n\n\n    if (s->text_x[0] <= s->text_x[1]) {\n\n        src = (s->y_base + s->text_y[0]) * s->width;\n\n        chardata += s->text_y[0] * s->width;\n\n        for (i = s->text_y[0]; i <= s->text_y[1]; i ++)\n\n            for (j = 0; j < s->width; j ++, src ++)\n\n                console_write_ch(chardata ++, s->cells[src].ch |\n\n                                (s->cells[src].t_attrib.fgcol << 12) |\n\n                                (s->cells[src].t_attrib.bgcol << 8) |\n\n                                (s->cells[src].t_attrib.bold << 21));\n\n        dpy_text_update(s, s->text_x[0], s->text_y[0],\n\n                        s->text_x[1] - s->text_x[0], i - s->text_y[0]);\n\n        s->text_x[0] = s->width;\n\n        s->text_y[0] = s->height;\n\n        s->text_x[1] = 0;\n\n        s->text_y[1] = 0;\n\n    }\n\n    if (s->cursor_invalidate) {\n\n        dpy_text_cursor(s, s->x, s->y);\n\n        s->cursor_invalidate = 0;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"42119fa3568dc7e8c82447c861678a5987d06d91","target":0,"func":"vcard_emul_mirror_card(VReader *vreader)\n\n{\n\n    \/*\n\n     * lookup certs using the C_FindObjects. The Stan Cert handle won't give\n\n     * us the real certs until we log in.\n\n     *\/\n\n    PK11GenericObject *firstObj, *thisObj;\n\n    int cert_count;\n\n    unsigned char **certs;\n\n    int *cert_len;\n\n    VCardKey **keys;\n\n    PK11SlotInfo *slot;\n\n    VCard *card;\n\n\n\n    slot = vcard_emul_reader_get_slot(vreader);\n\n    if (slot == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    firstObj = PK11_FindGenericObjects(slot, CKO_CERTIFICATE);\n\n    if (firstObj == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    \/* count the certs *\/\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        cert_count++;\n\n    }\n\n\n\n    if (cert_count == 0) {\n\n        PK11_DestroyGenericObjects(firstObj);\n\n        return NULL;\n\n    }\n\n\n\n    \/* allocate the arrays *\/\n\n    vcard_emul_alloc_arrays(&certs, &cert_len, &keys, cert_count);\n\n\n\n    \/* fill in the arrays *\/\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        SECItem derCert;\n\n        CERTCertificate *cert;\n\n        SECStatus rv;\n\n\n\n        rv = PK11_ReadRawAttribute(PK11_TypeGeneric, thisObj,\n\n                                   CKA_VALUE, &derCert);\n\n        if (rv != SECSuccess) {\n\n            continue;\n\n        }\n\n        \/* create floating temp cert. This gives us a cert structure even if\n\n         * the token isn't logged in *\/\n\n        cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), &derCert,\n\n                                       NULL, PR_FALSE, PR_TRUE);\n\n        SECITEM_FreeItem(&derCert, PR_FALSE);\n\n        if (cert == NULL) {\n\n            continue;\n\n        }\n\n\n\n        certs[cert_count] = cert->derCert.data;\n\n        cert_len[cert_count] = cert->derCert.len;\n\n        keys[cert_count] = vcard_emul_make_key(slot, cert);\n\n        cert_count++;\n\n        CERT_DestroyCertificate(cert); \/* key obj still has a reference *\/\n\n    }\n\n\n\n    \/* now create the card *\/\n\n    card = vcard_emul_make_card(vreader, certs, cert_len, keys, cert_count);\n\n    g_free(certs);\n\n    g_free(cert_len);\n\n    g_free(keys);\n\n\n\n    return card;\n\n}\n"},{"project":"qemu","commit_id":"089da572b956ef0f8f5b8d5917358e07892a77c2","target":1,"func":"void fw_cfg_add_bytes(FWCfgState *s, uint16_t key, uint8_t *data, uint32_t len)\n\n{\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    assert(key < FW_CFG_MAX_ENTRY);\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n}\n"},{"project":"qemu","commit_id":"e58d695e6c3a5cfa0aa2fc91b87ade017ef28b05","target":1,"func":"void visit_type_any(Visitor *v, const char *name, QObject **obj, Error **errp)\n\n{\n\n    v->type_any(v, name, obj, errp);\n\n}\n"},{"project":"qemu","commit_id":"ae261c86aaed62e7acddafab8262a2bf286d40b7","target":0,"func":"static int get_whole_cluster(BlockDriverState *bs,\n\n                VmdkExtent *extent,\n\n                uint64_t cluster_offset,\n\n                uint64_t offset,\n\n                bool allocate)\n\n{\n\n    \/* 128 sectors * 512 bytes each = grain size 64KB *\/\n\n    uint8_t  whole_grain[extent->cluster_sectors * 512];\n\n\n\n    \/* we will be here if it's first write on non-exist grain(cluster).\n\n     * try to read from parent image, if exist *\/\n\n    if (bs->backing_hd) {\n\n        int ret;\n\n\n\n        if (!vmdk_is_cid_valid(bs))\n\n            return -1;\n\n\n\n        \/* floor offset to cluster *\/\n\n        offset -= offset % (extent->cluster_sectors * 512);\n\n        ret = bdrv_read(bs->backing_hd, offset >> 9, whole_grain,\n\n                extent->cluster_sectors);\n\n        if (ret < 0) {\n\n            return -1;\n\n        }\n\n\n\n        \/* Write grain only into the active image *\/\n\n        ret = bdrv_write(extent->file, cluster_offset, whole_grain,\n\n                extent->cluster_sectors);\n\n        if (ret < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"a808c0865b720e22ca2929ec3d362d4610fbad51","target":1,"func":"static void mmio_interface_realize(DeviceState *dev, Error **errp)\n\n{\n\n    MMIOInterface *s = MMIO_INTERFACE(dev);\n\n\n\n    DPRINTF(\"realize from 0x%\" PRIX64 \" to 0x%\" PRIX64 \" map host pointer\"\n\n            \" %p\\n\", s->start, s->end, s->host_ptr);\n\n\n\n    if (!s->host_ptr) {\n\n        error_setg(errp, \"host_ptr property must be set\");\n\n\n    }\n\n\n\n    if (!s->subregion) {\n\n        error_setg(errp, \"subregion property must be set\");\n\n\n    }\n\n\n\n    memory_region_init_ram_ptr(&s->ram_mem, OBJECT(s), \"ram\",\n\n                               s->end - s->start + 1, s->host_ptr);\n\n    memory_region_set_readonly(&s->ram_mem, s->ro);\n\n    memory_region_add_subregion(s->subregion, s->start, &s->ram_mem);\n\n}"},{"project":"qemu","commit_id":"537b41f5013e1951fa15e8f18855b18d76124ce4","target":0,"func":"static void combine_addr(char *buf, size_t len, const char* address,\n\n                         uint16_t port)\n\n{\n\n    \/* If the address-part contains a colon, it's an IPv6 IP so needs [] *\/\n\n    if (strstr(address, \":\")) {\n\n        snprintf(buf, len, \"[%s]:%u\", address, port);\n\n    } else {\n\n        snprintf(buf, len, \"%s:%u\", address, port);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"5c53bb812152c3d7919cadfd47c210b181bf89ac","target":1,"func":"static void tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *l)\n\n{\n\n    TCGMemOp opc = l->opc;\n\n    TCGMemOp s_bits = opc & MO_SIZE;\n\n    uint8_t **label_ptr = &l->label_ptr[0];\n\n    TCGReg retaddr;\n\n\n\n    \/* resolve label address *\/\n\n    *(uint32_t *)label_ptr[0] = (uint32_t)(s->code_ptr - label_ptr[0] - 4);\n\n    if (TARGET_LONG_BITS > TCG_TARGET_REG_BITS) {\n\n        *(uint32_t *)label_ptr[1] = (uint32_t)(s->code_ptr - label_ptr[1] - 4);\n\n    }\n\n\n\n    if (TCG_TARGET_REG_BITS == 32) {\n\n        int ofs = 0;\n\n\n\n        tcg_out_st(s, TCG_TYPE_PTR, TCG_AREG0, TCG_REG_ESP, ofs);\n\n        ofs += 4;\n\n\n\n        tcg_out_st(s, TCG_TYPE_I32, l->addrlo_reg, TCG_REG_ESP, ofs);\n\n        ofs += 4;\n\n\n\n        if (TARGET_LONG_BITS == 64) {\n\n            tcg_out_st(s, TCG_TYPE_I32, l->addrhi_reg, TCG_REG_ESP, ofs);\n\n            ofs += 4;\n\n        }\n\n\n\n        tcg_out_st(s, TCG_TYPE_I32, l->datalo_reg, TCG_REG_ESP, ofs);\n\n        ofs += 4;\n\n\n\n        if (s_bits == MO_64) {\n\n            tcg_out_st(s, TCG_TYPE_I32, l->datahi_reg, TCG_REG_ESP, ofs);\n\n            ofs += 4;\n\n        }\n\n\n\n        tcg_out_sti(s, TCG_TYPE_I32, TCG_REG_ESP, ofs, l->mem_index);\n\n        ofs += 4;\n\n\n\n        retaddr = TCG_REG_EAX;\n\n        tcg_out_movi(s, TCG_TYPE_I32, retaddr, (uintptr_t)l->raddr);\n\n        tcg_out_st(s, TCG_TYPE_I32, retaddr, TCG_REG_ESP, ofs);\n\n    } else {\n\n        tcg_out_mov(s, TCG_TYPE_PTR, tcg_target_call_iarg_regs[0], TCG_AREG0);\n\n        \/* The second argument is already loaded with addrlo.  *\/\n\n        tcg_out_mov(s, (s_bits == MO_64 ? TCG_TYPE_I64 : TCG_TYPE_I32),\n\n                    tcg_target_call_iarg_regs[2], l->datalo_reg);\n\n        tcg_out_movi(s, TCG_TYPE_I32, tcg_target_call_iarg_regs[3],\n\n                     l->mem_index);\n\n\n\n        if (ARRAY_SIZE(tcg_target_call_iarg_regs) > 4) {\n\n            retaddr = tcg_target_call_iarg_regs[4];\n\n            tcg_out_movi(s, TCG_TYPE_PTR, retaddr, (uintptr_t)l->raddr);\n\n        } else {\n\n            retaddr = TCG_REG_RAX;\n\n            tcg_out_movi(s, TCG_TYPE_PTR, retaddr, (uintptr_t)l->raddr);\n\n            tcg_out_st(s, TCG_TYPE_PTR, retaddr, TCG_REG_ESP, 0);\n\n        }\n\n    }\n\n\n\n    \/* \"Tail call\" to the helper, with the return address back inline.  *\/\n\n    tcg_out_push(s, retaddr);\n\n    tcg_out_jmp(s, (uintptr_t)qemu_st_helpers[opc]);\n\n}\n"},{"project":"qemu","commit_id":"08a2d4c4ffde60e48819449f461274c43ad6e2d3","target":0,"func":"static void sdl_grab_start(void)\n\n{\n\n    if (guest_cursor) {\n\n        SDL_SetCursor(guest_sprite);\n\n        SDL_WarpMouse(guest_x, guest_y);\n\n    } else\n\n        sdl_hide_cursor();\n\n\n\n    if (SDL_WM_GrabInput(SDL_GRAB_ON) == SDL_GRAB_ON) {\n\n        gui_grab = 1;\n\n        sdl_update_caption();\n\n    } else\n\n        sdl_show_cursor();\n\n}\n"},{"project":"qemu","commit_id":"33577b47c64435fcc2a1bc01c7e82534256f1fc3","target":0,"func":"static void replay_add_event(ReplayAsyncEventKind event_kind,\n\n                             void *opaque,\n\n                             void *opaque2, uint64_t id)\n\n{\n\n    assert(event_kind < REPLAY_ASYNC_COUNT);\n\n\n\n    if (!replay_file || replay_mode == REPLAY_MODE_NONE\n\n        || !events_enabled) {\n\n        Event e;\n\n        e.event_kind = event_kind;\n\n        e.opaque = opaque;\n\n        e.opaque2 = opaque2;\n\n        e.id = id;\n\n        replay_run_event(&e);\n\n        return;\n\n    }\n\n\n\n    Event *event = g_malloc0(sizeof(Event));\n\n    event->event_kind = event_kind;\n\n    event->opaque = opaque;\n\n    event->opaque2 = opaque2;\n\n    event->id = id;\n\n\n\n    replay_mutex_lock();\n\n    QTAILQ_INSERT_TAIL(&events_list, event, events);\n\n    replay_mutex_unlock();\n\n}\n"},{"project":"qemu","commit_id":"9603ceba2edd1dc7e3823da76d84706d3d1c3d78","target":0,"func":"static void do_info_uuid(Monitor *mon)\n\n{\n\n    monitor_printf(mon, UUID_FMT \"\\n\", qemu_uuid[0], qemu_uuid[1],\n\n                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],\n\n                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],\n\n                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],\n\n                   qemu_uuid[14], qemu_uuid[15]);\n\n}\n"},{"project":"qemu","commit_id":"c0c24b95542bc1a4dc3fc6ea71475ae04fa69189","target":1,"func":"static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n\n            goto out;\n\n        }\n\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n\n            goto out;\n\n        }\n\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}"},{"project":"qemu","commit_id":"37ad223c515da2fe9f1c679768cb5ccaa42e57e1","target":0,"func":"build_mcfg(GArray *table_data, GArray *linker, VirtGuestInfo *guest_info)\n\n{\n\n    AcpiTableMcfg *mcfg;\n\n    const MemMapEntry *memmap = guest_info->memmap;\n\n    int len = sizeof(*mcfg) + sizeof(mcfg->allocation[0]);\n\n\n\n    mcfg = acpi_data_push(table_data, len);\n\n    mcfg->allocation[0].address = cpu_to_le64(memmap[VIRT_PCIE_ECAM].base);\n\n\n\n    \/* Only a single allocation so no need to play with segments *\/\n\n    mcfg->allocation[0].pci_segment = cpu_to_le16(0);\n\n    mcfg->allocation[0].start_bus_number = 0;\n\n    mcfg->allocation[0].end_bus_number = (memmap[VIRT_PCIE_ECAM].size\n\n                                          \/ PCIE_MMCFG_SIZE_MIN) - 1;\n\n\n\n    build_header(linker, table_data, (void *)mcfg, \"MCFG\", len, 1, NULL);\n\n}\n"},{"project":"qemu","commit_id":"7d1b0095bff7157e856d1d0e6c4295641ced2752","target":1,"func":"static int cp15_tls_load_store(CPUState *env, DisasContext *s, uint32_t insn, uint32_t rd)\n\n{\n\n    TCGv tmp;\n\n    int cpn = (insn >> 16) & 0xf;\n\n    int cpm = insn & 0xf;\n\n    int op = ((insn >> 5) & 7) | ((insn >> 18) & 0x38);\n\n\n\n    if (!arm_feature(env, ARM_FEATURE_V6K))\n\n        return 0;\n\n\n\n    if (!(cpn == 13 && cpm == 0))\n\n        return 0;\n\n\n\n    if (insn & ARM_CP_RW_BIT) {\n\n        switch (op) {\n\n        case 2:\n\n            tmp = load_cpu_field(cp15.c13_tls1);\n\n            break;\n\n        case 3:\n\n            tmp = load_cpu_field(cp15.c13_tls2);\n\n            break;\n\n        case 4:\n\n            tmp = load_cpu_field(cp15.c13_tls3);\n\n            break;\n\n        default:\n\n            return 0;\n\n        }\n\n        store_reg(s, rd, tmp);\n\n\n\n    } else {\n\n        tmp = load_reg(s, rd);\n\n        switch (op) {\n\n        case 2:\n\n            store_cpu_field(tmp, cp15.c13_tls1);\n\n            break;\n\n        case 3:\n\n            store_cpu_field(tmp, cp15.c13_tls2);\n\n            break;\n\n        case 4:\n\n            store_cpu_field(tmp, cp15.c13_tls3);\n\n            break;\n\n        default:\n\n            dead_tmp(tmp);\n\n            return 0;\n\n        }\n\n    }\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3","target":0,"func":"void sparc64_set_context(CPUSPARCState *env)\n\n{\n\n    abi_ulong ucp_addr;\n\n    struct target_ucontext *ucp;\n\n    target_mc_gregset_t *grp;\n\n    abi_ulong pc, npc, tstate;\n\n    abi_ulong fp, i7, w_addr;\n\n    int err;\n\n    unsigned int i;\n\n\n\n    ucp_addr = env->regwptr[UREG_I0];\n\n    if (!lock_user_struct(VERIFY_READ, ucp, ucp_addr, 1))\n\n        goto do_sigsegv;\n\n    grp  = &ucp->tuc_mcontext.mc_gregs;\n\n    err  = __get_user(pc, &((*grp)[MC_PC]));\n\n    err |= __get_user(npc, &((*grp)[MC_NPC]));\n\n    if (err || ((pc | npc) & 3))\n\n        goto do_sigsegv;\n\n    if (env->regwptr[UREG_I1]) {\n\n        target_sigset_t target_set;\n\n        sigset_t set;\n\n\n\n        if (TARGET_NSIG_WORDS == 1) {\n\n            if (__get_user(target_set.sig[0], &ucp->tuc_sigmask.sig[0]))\n\n                goto do_sigsegv;\n\n        } else {\n\n            abi_ulong *src, *dst;\n\n            src = ucp->tuc_sigmask.sig;\n\n            dst = target_set.sig;\n\n            for (i = 0; i < TARGET_NSIG_WORDS; i++, dst++, src++) {\n\n                err |= __get_user(*dst, src);\n\n            }\n\n            if (err)\n\n                goto do_sigsegv;\n\n        }\n\n        target_to_host_sigset_internal(&set, &target_set);\n\n        sigprocmask(SIG_SETMASK, &set, NULL);\n\n    }\n\n    env->pc = pc;\n\n    env->npc = npc;\n\n    err |= __get_user(env->y, &((*grp)[MC_Y]));\n\n    err |= __get_user(tstate, &((*grp)[MC_TSTATE]));\n\n    env->asi = (tstate >> 24) & 0xff;\n\n    cpu_put_ccr(env, tstate >> 32);\n\n    cpu_put_cwp64(env, tstate & 0x1f);\n\n    err |= __get_user(env->gregs[1], (&(*grp)[MC_G1]));\n\n    err |= __get_user(env->gregs[2], (&(*grp)[MC_G2]));\n\n    err |= __get_user(env->gregs[3], (&(*grp)[MC_G3]));\n\n    err |= __get_user(env->gregs[4], (&(*grp)[MC_G4]));\n\n    err |= __get_user(env->gregs[5], (&(*grp)[MC_G5]));\n\n    err |= __get_user(env->gregs[6], (&(*grp)[MC_G6]));\n\n    err |= __get_user(env->gregs[7], (&(*grp)[MC_G7]));\n\n    err |= __get_user(env->regwptr[UREG_I0], (&(*grp)[MC_O0]));\n\n    err |= __get_user(env->regwptr[UREG_I1], (&(*grp)[MC_O1]));\n\n    err |= __get_user(env->regwptr[UREG_I2], (&(*grp)[MC_O2]));\n\n    err |= __get_user(env->regwptr[UREG_I3], (&(*grp)[MC_O3]));\n\n    err |= __get_user(env->regwptr[UREG_I4], (&(*grp)[MC_O4]));\n\n    err |= __get_user(env->regwptr[UREG_I5], (&(*grp)[MC_O5]));\n\n    err |= __get_user(env->regwptr[UREG_I6], (&(*grp)[MC_O6]));\n\n    err |= __get_user(env->regwptr[UREG_I7], (&(*grp)[MC_O7]));\n\n\n\n    err |= __get_user(fp, &(ucp->tuc_mcontext.mc_fp));\n\n    err |= __get_user(i7, &(ucp->tuc_mcontext.mc_i7));\n\n\n\n    w_addr = TARGET_STACK_BIAS+env->regwptr[UREG_I6];\n\n    if (put_user(fp, w_addr + offsetof(struct target_reg_window, ins[6]), \n\n                 abi_ulong) != 0)\n\n        goto do_sigsegv;\n\n    if (put_user(i7, w_addr + offsetof(struct target_reg_window, ins[7]), \n\n                 abi_ulong) != 0)\n\n        goto do_sigsegv;\n\n    \/* FIXME this does not match how the kernel handles the FPU in\n\n     * its sparc64_set_context implementation. In particular the FPU\n\n     * is only restored if fenab is non-zero in:\n\n     *   __get_user(fenab, &(ucp->tuc_mcontext.mc_fpregs.mcfpu_enab));\n\n     *\/\n\n    err |= __get_user(env->fprs, &(ucp->tuc_mcontext.mc_fpregs.mcfpu_fprs));\n\n    {\n\n        uint32_t *src = ucp->tuc_mcontext.mc_fpregs.mcfpu_fregs.sregs;\n\n        for (i = 0; i < 64; i++, src++) {\n\n            if (i & 1) {\n\n                err |= __get_user(env->fpr[i\/2].l.lower, src);\n\n            } else {\n\n                err |= __get_user(env->fpr[i\/2].l.upper, src);\n\n            }\n\n        }\n\n    }\n\n    err |= __get_user(env->fsr,\n\n                      &(ucp->tuc_mcontext.mc_fpregs.mcfpu_fsr));\n\n    err |= __get_user(env->gsr,\n\n                      &(ucp->tuc_mcontext.mc_fpregs.mcfpu_gsr));\n\n    if (err)\n\n        goto do_sigsegv;\n\n    unlock_user_struct(ucp, ucp_addr, 0);\n\n    return;\n\n do_sigsegv:\n\n    unlock_user_struct(ucp, ucp_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n"},{"project":"qemu","commit_id":"48bf7ea81aa848027bad24f7e7791b503dff727d","target":1,"func":"void blk_io_limits_disable(BlockBackend *blk)\n\n{\n\n    assert(blk->public.throttle_group_member.throttle_state);\n\n    bdrv_drained_begin(blk_bs(blk));\n\n    throttle_group_unregister_tgm(&blk->public.throttle_group_member);\n\n    bdrv_drained_end(blk_bs(blk));\n\n}\n"},{"project":"qemu","commit_id":"5f758366c0710d23e43f4d0f83816b98616a13d0","target":1,"func":"static CharDriverState *qmp_chardev_open_file(ChardevFile *file, Error **errp)\n\n{\n\n    int flags, in = -1, out = -1;\n\n\n\n    flags = O_WRONLY | O_TRUNC | O_CREAT | O_BINARY;\n\n    out = qmp_chardev_open_file_source(file->out, flags, errp);\n\n    if (error_is_set(errp)) {\n\n        return NULL;\n\n    }\n\n\n\n    if (file->has_in) {\n\n        flags = O_RDONLY;\n\n        in = qmp_chardev_open_file_source(file->in, flags, errp);\n\n        if (error_is_set(errp)) {\n\n            qemu_close(out);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    return qemu_chr_open_fd(in, out);\n\n}\n"},{"project":"qemu","commit_id":"4534ff5426afeeae5238ba10a696cafa9a0168ee","target":0,"func":"int bdrv_check(BlockDriverState *bs, BdrvCheckResult *res)\n\n{\n\n    if (bs->drv->bdrv_check == NULL) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    memset(res, 0, sizeof(*res));\n\n    return bs->drv->bdrv_check(bs, res);\n\n}\n"},{"project":"qemu","commit_id":"d9bce9d99f4656ae0b0127f7472db9067b8f84ab","target":1,"func":"void do_405_check_sat (void)\n\n{\n\n    if (!likely(((T1 ^ T2) >> 31) || !((T0 ^ T2) >> 31))) {\n\n        \/* Saturate result *\/\n\n        if (T2 >> 31) {\n\n            T0 = INT32_MIN;\n\n        } else {\n\n            T0 = INT32_MAX;\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void uart_write(void *opaque, target_phys_addr_t addr, uint64_t value,\n\n                       unsigned size)\n\n{\n\n    MilkymistUartState *s = opaque;\n\n    unsigned char ch = value;\n\n\n\n    trace_milkymist_uart_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_RXTX:\n\n        if (s->chr) {\n\n            qemu_chr_fe_write(s->chr, &ch, 1);\n\n        }\n\n        s->regs[R_STAT] |= STAT_TX_EVT;\n\n        break;\n\n    case R_DIV:\n\n    case R_CTRL:\n\n    case R_DBG:\n\n        s->regs[addr] = value;\n\n        break;\n\n\n\n    case R_STAT:\n\n        \/* write one to clear bits *\/\n\n        s->regs[addr] &= ~(value & (STAT_RX_EVT | STAT_TX_EVT));\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_uart: write access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n\n\n    uart_update_irq(s);\n\n}\n"},{"project":"qemu","commit_id":"7fb439115de7354b3ac2becf24457acaf828296b","target":0,"func":"void qemu_del_net_client(NetClientState *nc)\n\n{\n\n    NetClientState *ncs[MAX_QUEUE_NUM];\n\n    int queues, i;\n\n\n\n    \/* If the NetClientState belongs to a multiqueue backend, we will change all\n\n     * other NetClientStates also.\n\n     *\/\n\n    queues = qemu_find_net_clients_except(nc->name, ncs,\n\n                                          NET_CLIENT_OPTIONS_KIND_NIC,\n\n                                          MAX_QUEUE_NUM);\n\n    assert(queues != 0);\n\n\n\n    \/* If there is a peer NIC, delete and cleanup client, but do not free. *\/\n\n    if (nc->peer && nc->peer->info->type == NET_CLIENT_OPTIONS_KIND_NIC) {\n\n        NICState *nic = qemu_get_nic(nc->peer);\n\n        if (nic->peer_deleted) {\n\n            return;\n\n        }\n\n        nic->peer_deleted = true;\n\n\n\n        for (i = 0; i < queues; i++) {\n\n            ncs[i]->peer->link_down = true;\n\n        }\n\n\n\n        if (nc->peer->info->link_status_changed) {\n\n            nc->peer->info->link_status_changed(nc->peer);\n\n        }\n\n\n\n        for (i = 0; i < queues; i++) {\n\n            qemu_cleanup_net_client(ncs[i]);\n\n        }\n\n\n\n        return;\n\n    }\n\n\n\n    assert(nc->info->type != NET_CLIENT_OPTIONS_KIND_NIC);\n\n\n\n    for (i = 0; i < queues; i++) {\n\n        qemu_cleanup_net_client(ncs[i]);\n\n        qemu_free_net_client(ncs[i]);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"ce5b1bbf624b977a55ff7f85bb3871682d03baff","target":1,"func":"void cpu_exec_init(CPUState *cpu, Error **errp)\n\n{\n\n    CPUClass *cc ATTRIBUTE_UNUSED = CPU_GET_CLASS(cpu);\n\n\n\n    cpu_list_add(cpu);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {\n\n        vmstate_register(NULL, cpu->cpu_index, &vmstate_cpu_common, cpu);\n\n    }\n\n    if (cc->vmsd != NULL) {\n\n        vmstate_register(NULL, cpu->cpu_index, cc->vmsd, cpu);\n\n    }\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"7848c8d19f8556666df25044bbd5d8b29439c368","target":0,"func":"void helper_sysenter(CPUX86State *env)\n\n{\n\n    if (env->sysenter_cs == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n    env->eflags &= ~(VM_MASK | IF_MASK | RF_MASK);\n\n    cpu_x86_set_cpl(env, 0);\n\n\n\n#ifdef TARGET_X86_64\n\n    if (env->hflags & HF_LMA_MASK) {\n\n        cpu_x86_load_seg_cache(env, R_CS, env->sysenter_cs & 0xfffc,\n\n                               0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK |\n\n                               DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK |\n\n                               DESC_L_MASK);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_x86_load_seg_cache(env, R_CS, env->sysenter_cs & 0xfffc,\n\n                               0, 0xffffffff,\n\n                               DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                               DESC_S_MASK |\n\n                               DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK);\n\n    }\n\n    cpu_x86_load_seg_cache(env, R_SS, (env->sysenter_cs + 8) & 0xfffc,\n\n                           0, 0xffffffff,\n\n                           DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                           DESC_S_MASK |\n\n                           DESC_W_MASK | DESC_A_MASK);\n\n    env->regs[R_ESP] = env->sysenter_esp;\n\n    env->eip = env->sysenter_eip;\n\n}\n"},{"project":"qemu","commit_id":"2061c14c9bea67f8f1fc6bc7acb33c903a0586c1","target":1,"func":"static int handle_secondary_tcp_pkt(NetFilterState *nf,\n\n                                    Connection *conn,\n\n                                    Packet *pkt)\n\n{\n\n    struct tcphdr *tcp_pkt;\n\n\n\n    tcp_pkt = (struct tcphdr *)pkt->transport_header;\n\n\n\n    if (trace_event_get_state(TRACE_COLO_FILTER_REWRITER_DEBUG)) {\n\n        char *sdebug, *ddebug;\n\n        sdebug = strdup(inet_ntoa(pkt->ip->ip_src));\n\n        ddebug = strdup(inet_ntoa(pkt->ip->ip_dst));\n\n        trace_colo_filter_rewriter_pkt_info(__func__, sdebug, ddebug,\n\n                    ntohl(tcp_pkt->th_seq), ntohl(tcp_pkt->th_ack),\n\n                    tcp_pkt->th_flags);\n\n        trace_colo_filter_rewriter_conn_offset(conn->offset);\n\n        g_free(sdebug);\n\n        g_free(ddebug);\n\n    }\n\n\n\n    if (((tcp_pkt->th_flags & (TH_ACK | TH_SYN)) == (TH_ACK | TH_SYN))) {\n\n        \/*\n\n         * save offset = secondary_seq and then\n\n         * in handle_primary_tcp_pkt make offset\n\n         * = secondary_seq - primary_seq\n\n         *\/\n\n        conn->offset = ntohl(tcp_pkt->th_seq);\n\n    }\n\n\n\n    if ((tcp_pkt->th_flags & (TH_ACK | TH_SYN)) == TH_ACK) {\n\n        \/* handle packets to the primary from the secondary*\/\n\n        tcp_pkt->th_seq = htonl(ntohl(tcp_pkt->th_seq) - conn->offset);\n\n\n\n        net_checksum_calculate((uint8_t *)pkt->data, pkt->size);\n\n    }\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"3453f9a0dfa58578e6dadf0905ff4528b428ec73","target":1,"func":"static void usb_uas_command(UASDevice *uas, uas_ui *ui)\n{\n    UASRequest *req;\n    uint32_t len;\n    uint16_t tag = be16_to_cpu(ui->hdr.tag);\n    if (uas_using_streams(uas) && tag > UAS_MAX_STREAMS) {\n        goto invalid_tag;\n    }\n    req = usb_uas_find_request(uas, tag);\n    if (req) {\n        goto overlapped_tag;\n    }\n    req = usb_uas_alloc_request(uas, ui);\n    if (req->dev == NULL) {\n        goto bad_target;\n    }\n    trace_usb_uas_command(uas->dev.addr, req->tag,\n                          usb_uas_get_lun(req->lun),\n                          req->lun >> 32, req->lun & 0xffffffff);\n    QTAILQ_INSERT_TAIL(&uas->requests, req, next);\n    if (uas_using_streams(uas) && uas->data3[req->tag] != NULL) {\n        req->data = uas->data3[req->tag];\n        req->data_async = true;\n        uas->data3[req->tag] = NULL;\n    }\n    req->req = scsi_req_new(req->dev, req->tag,\n                            usb_uas_get_lun(req->lun),\n                            ui->command.cdb, req);\n    if (uas->requestlog) {\n        scsi_req_print(req->req);\n    }\n    len = scsi_req_enqueue(req->req);\n    if (len) {\n        req->data_size = len;\n        scsi_req_continue(req->req);\n    }\noverlapped_tag:\n    usb_uas_queue_fake_sense(uas, tag, sense_code_OVERLAPPED_COMMANDS);\nbad_target:\n    usb_uas_queue_fake_sense(uas, tag, sense_code_LUN_NOT_SUPPORTED);\n    g_free(req);\n}"},{"project":"qemu","commit_id":"29f2601aa605f0af0cba8eedcff7812c6c8532e9","target":1,"func":"static int openfile(char *name, int flags, int growable, QDict *opts)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    if (qemuio_bs) {\n\n        fprintf(stderr, \"file open already, try 'help close'\\n\");\n\n\n        return 1;\n\n    }\n\n\n\n    if (growable) {\n\n        if (bdrv_open(&qemuio_bs, name, NULL, opts, flags | BDRV_O_PROTOCOL,\n\n                      NULL, &local_err))\n\n        {\n\n            fprintf(stderr, \"%s: can't open device %s: %s\\n\", progname, name,\n\n                    error_get_pretty(local_err));\n\n            error_free(local_err);\n\n            return 1;\n\n        }\n\n    } else {\n\n        qemuio_bs = bdrv_new(\"hda\", &error_abort);\n\n\n\n        if (bdrv_open(&qemuio_bs, name, NULL, opts, flags, NULL, &local_err)\n\n            < 0)\n\n        {\n\n            fprintf(stderr, \"%s: can't open device %s: %s\\n\", progname, name,\n\n                    error_get_pretty(local_err));\n\n            error_free(local_err);\n\n            bdrv_unref(qemuio_bs);\n\n            qemuio_bs = NULL;\n\n            return 1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}"},{"project":"qemu","commit_id":"dc162c8e4f088b08575460cca35b042d58c141aa","target":0,"func":"void bdrv_set_dirty_iter(HBitmapIter *hbi, int64_t offset)\n\n{\n\n    assert(hbi->hb);\n\n    hbitmap_iter_init(hbi, hbi->hb, offset);\n\n}\n"},{"project":"qemu","commit_id":"8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a","target":1,"func":"static void isa_ipmi_bmc_check(Object *obj, const char *name,\n\n                               Object *val, Error **errp)\n\n{\n\n    IPMIBmc *bmc = IPMI_BMC(val);\n\n\n\n    if (bmc->intf)\n\n        error_setg(errp, \"BMC object is already in use\");\n\n}\n"},{"project":"qemu","commit_id":"838ef602498b8d1985a231a06f5e328e2946a81d","target":0,"func":"static void curl_multi_read(BDRVCURLState *s)\n\n{\n\n    int msgs_in_queue;\n\n\n\n    \/* Try to find done transfers, so we can free the easy\n\n     * handle again. *\/\n\n    do {\n\n        CURLMsg *msg;\n\n        msg = curl_multi_info_read(s->multi, &msgs_in_queue);\n\n\n\n        if (!msg)\n\n            break;\n\n        if (msg->msg == CURLMSG_NONE)\n\n            break;\n\n\n\n        switch (msg->msg) {\n\n            case CURLMSG_DONE:\n\n            {\n\n                CURLState *state = NULL;\n\n                curl_easy_getinfo(msg->easy_handle, CURLINFO_PRIVATE,\n\n                                  (char **)&state);\n\n\n\n                \/* ACBs for successful messages get completed in curl_read_cb *\/\n\n                if (msg->data.result != CURLE_OK) {\n\n                    int i;\n\n                    for (i = 0; i < CURL_NUM_ACB; i++) {\n\n                        CURLAIOCB *acb = state->acb[i];\n\n\n\n                        if (acb == NULL) {\n\n                            continue;\n\n                        }\n\n\n\n                        acb->common.cb(acb->common.opaque, -EIO);\n\n                        qemu_aio_release(acb);\n\n                        state->acb[i] = NULL;\n\n                    }\n\n                }\n\n\n\n                curl_clean_state(state);\n\n                break;\n\n            }\n\n            default:\n\n                msgs_in_queue = 0;\n\n                break;\n\n        }\n\n    } while(msgs_in_queue);\n\n}\n"},{"project":"qemu","commit_id":"302fa283789a2f9b1199c327047cfad2258a23a2","target":1,"func":"const char *memory_region_name(const MemoryRegion *mr)\n\n{\n\n    return object_get_canonical_path_component(OBJECT(mr));\n\n}\n"},{"project":"qemu","commit_id":"e9af2fef242ce92f86d3d5c1a94c3199ff1e24c9","target":1,"func":"int kvm_irqchip_add_adapter_route(KVMState *s, AdapterInfo *adapter)\n\n{\n\n    struct kvm_irq_routing_entry kroute;\n\n    int virq;\n\n\n\n    if (!kvm_gsi_routing_enabled()) {\n\n        return -ENOSYS;\n\n    }\n\n\n\n    virq = kvm_irqchip_get_virq(s);\n\n    if (virq < 0) {\n\n        return virq;\n\n    }\n\n\n\n    kroute.gsi = virq;\n\n    kroute.type = KVM_IRQ_ROUTING_S390_ADAPTER;\n\n    kroute.flags = 0;\n\n    kroute.u.adapter.summary_addr = adapter->summary_addr;\n\n    kroute.u.adapter.ind_addr = adapter->ind_addr;\n\n    kroute.u.adapter.summary_offset = adapter->summary_offset;\n\n    kroute.u.adapter.ind_offset = adapter->ind_offset;\n\n    kroute.u.adapter.adapter_id = adapter->adapter_id;\n\n\n\n    kvm_add_routing_entry(s, &kroute);\n\n    kvm_irqchip_commit_routes(s);\n\n\n\n    return virq;\n\n}\n"},{"project":"qemu","commit_id":"b4ba67d9a702507793c2724e56f98e9b0f7be02b","target":1,"func":"static void qvirtio_pci_set_queue_address(QVirtioDevice *d, uint32_t pfn)\n\n{\n\n    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;\n\n    qpci_io_writel(dev->pdev, dev->addr + VIRTIO_PCI_QUEUE_PFN, pfn);\n\n}\n"},{"project":"qemu","commit_id":"60fe637bf0e4d7989e21e50f52526444765c63b4","target":1,"func":"static void put_uint32(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint32_t *v = pv;\n\n    qemu_put_be32s(f, v);\n\n}\n"},{"project":"qemu","commit_id":"f91cbefe2d0eb3f7b5071bcb1fd3a02970f1a776","target":1,"func":"static void init_mbr(BDRVVVFATState* s)\n\n{\n\n    \/* TODO: if the files mbr.img and bootsect.img exist, use them *\/\n\n    mbr_t* real_mbr=(mbr_t*)s->first_sectors;\n\n    partition_t* partition = &(real_mbr->partition[0]);\n\n    int lba;\n\n\n\n    memset(s->first_sectors,0,512);\n\n\n\n    \/* Win NT Disk Signature *\/\n\n    real_mbr->nt_id= cpu_to_le32(0xbe1afdfa);\n\n\n\n    partition->attributes=0x80; \/* bootable *\/\n\n\n\n    \/* LBA is used when partition is outside the CHS geometry *\/\n\n    lba = sector2CHS(s->bs, &partition->start_CHS, s->first_sectors_number-1);\n\n    lba|= sector2CHS(s->bs, &partition->end_CHS,   s->sector_count);\n\n\n\n    \/*LBA partitions are identified only by start\/length_sector_long not by CHS*\/\n\n    partition->start_sector_long =cpu_to_le32(s->first_sectors_number-1);\n\n    partition->length_sector_long=cpu_to_le32(s->sector_count - s->first_sectors_number+1);\n\n\n\n    \/* FAT12\/FAT16\/FAT32 *\/\n\n    \/* DOS uses different types when partition is LBA,\n\n       probably to prevent older versions from using CHS on them *\/\n\n    partition->fs_type= s->fat_type==12 ? 0x1:\n\n                        s->fat_type==16 ? (lba?0xe:0x06):\n\n                         \/*fat_tyoe==32*\/ (lba?0xc:0x0b);\n\n\n\n    real_mbr->magic[0]=0x55; real_mbr->magic[1]=0xaa;\n\n}\n"},{"project":"qemu","commit_id":"6a81dd172cd5d03fce593741629cb4c78fff10cb","target":0,"func":"sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn,\n\n                                   uint64_t bus_offset,\n\n                                   uint32_t page_shift,\n\n                                   uint32_t nb_table,\n\n                                   bool vfio_accel)\n\n{\n\n    sPAPRTCETable *tcet;\n\n    char tmp[64];\n\n\n\n    if (spapr_tce_find_by_liobn(liobn)) {\n\n        fprintf(stderr, \"Attempted to create TCE table with duplicate\"\n\n                \" LIOBN 0x%x\\n\", liobn);\n\n        return NULL;\n\n    }\n\n\n\n    if (!nb_table) {\n\n        return NULL;\n\n    }\n\n\n\n    tcet = SPAPR_TCE_TABLE(object_new(TYPE_SPAPR_TCE_TABLE));\n\n    tcet->liobn = liobn;\n\n    tcet->bus_offset = bus_offset;\n\n    tcet->page_shift = page_shift;\n\n    tcet->nb_table = nb_table;\n\n    tcet->vfio_accel = vfio_accel;\n\n\n\n    snprintf(tmp, sizeof(tmp), \"tce-table-%x\", liobn);\n\n    object_property_add_child(OBJECT(owner), tmp, OBJECT(tcet), NULL);\n\n\n\n    object_property_set_bool(OBJECT(tcet), true, \"realized\", NULL);\n\n\n\n    return tcet;\n\n}\n"},{"project":"qemu","commit_id":"1beb99f787ba110a9de44254e7d62a1cb9117de8","target":0,"func":"void acpi_pm_tmr_init(ACPIREGS *ar, acpi_update_sci_fn update_sci,\n\n                      MemoryRegion *parent)\n\n{\n\n    ar->tmr.update_sci = update_sci;\n\n    ar->tmr.timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, acpi_pm_tmr_timer, ar);\n\n    memory_region_init_io(&ar->tmr.io, memory_region_owner(parent),\n\n                          &acpi_pm_tmr_ops, ar, \"acpi-tmr\", 4);\n\n    memory_region_clear_global_locking(&ar->tmr.io);\n\n    memory_region_add_subregion(parent, 8, &ar->tmr.io);\n\n}\n"},{"project":"qemu","commit_id":"142e0950cfaf023a81112dc3cdfa799d769886a4","target":0,"func":"bool hpet_find(void)\n\n{\n\n    return object_resolve_path_type(\"\", TYPE_HPET, NULL);\n\n}\n"},{"project":"qemu","commit_id":"b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef","target":1,"func":"static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\n\t\t\t\t     int off_pitch, int bytesperline,\n\n\t\t\t\t     int lines)\n\n{\n\n    int y;\n\n    int off_cur;\n\n    int off_cur_end;\n\n\n\n    for (y = 0; y < lines; y++) {\n\n\toff_cur = off_begin;\n\n\toff_cur_end = off_cur + bytesperline;\n\n\toff_cur &= TARGET_PAGE_MASK;\n\n\twhile (off_cur < off_cur_end) {\n\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\n\t    off_cur += TARGET_PAGE_SIZE;\n\n\t}\n\n\toff_begin += off_pitch;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"6acbe4c6f18e7de00481ff30574262b58526de45","target":0,"func":"static void virtio_serial_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->init = virtio_serial_init_pci;\n\n    k->exit = virtio_serial_exit_pci;\n\n    k->vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;\n\n    k->device_id = PCI_DEVICE_ID_VIRTIO_CONSOLE;\n\n    k->revision = VIRTIO_PCI_ABI_VERSION;\n\n    k->class_id = PCI_CLASS_COMMUNICATION_OTHER;\n\n    dc->alias = \"virtio-serial\";\n\n    dc->reset = virtio_pci_reset;\n\n    dc->props = virtio_serial_properties;\n\n}\n"},{"project":"qemu","commit_id":"0c402e5abb8c2755390eee864b43a98280fc2453","target":0,"func":"static int usb_host_scan_dev(void *opaque, USBScanFunc *func)\n\n{\n\n    FILE *f = NULL;\n\n    char line[1024];\n\n    char buf[1024];\n\n    int bus_num, addr, speed, device_count, class_id, product_id, vendor_id;\n\n    char product_name[512];\n\n    int ret = 0;\n\n\n\n    if (!usb_host_device_path) {\n\n        perror(\"husb: USB Host Device Path not set\");\n\n        goto the_end;\n\n    }\n\n    snprintf(line, sizeof(line), \"%s\/devices\", usb_host_device_path);\n\n    f = fopen(line, \"r\");\n\n    if (!f) {\n\n        perror(\"husb: cannot open devices file\");\n\n        goto the_end;\n\n    }\n\n\n\n    device_count = 0;\n\n    bus_num = addr = class_id = product_id = vendor_id = 0;\n\n    speed = -1; \/* Can't get the speed from \/[proc|dev]\/bus\/usb\/devices *\/\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL) {\n\n            break;\n\n        }\n\n        if (strlen(line) > 0) {\n\n            line[strlen(line) - 1] = '\\0';\n\n        }\n\n        if (line[0] == 'T' && line[1] == ':') {\n\n            if (device_count && (vendor_id || product_id)) {\n\n                \/* New device.  Add the previously discovered device.  *\/\n\n                ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                           product_id, product_name, speed);\n\n                if (ret) {\n\n                    goto the_end;\n\n                }\n\n            }\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Bus=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            bus_num = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Dev#=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            addr = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Spd=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            if (!strcmp(buf, \"5000\")) {\n\n                speed = USB_SPEED_SUPER;\n\n            } else if (!strcmp(buf, \"480\")) {\n\n                speed = USB_SPEED_HIGH;\n\n            } else if (!strcmp(buf, \"1.5\")) {\n\n                speed = USB_SPEED_LOW;\n\n            } else {\n\n                speed = USB_SPEED_FULL;\n\n            }\n\n            product_name[0] = '\\0';\n\n            class_id = 0xff;\n\n            device_count++;\n\n            product_id = 0;\n\n            vendor_id = 0;\n\n        } else if (line[0] == 'P' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Vendor=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            vendor_id = strtoul(buf, NULL, 16);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"ProdID=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            product_id = strtoul(buf, NULL, 16);\n\n        } else if (line[0] == 'S' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Product=\", \"\") < 0) {\n\n                goto fail;\n\n            }\n\n            pstrcpy(product_name, sizeof(product_name), buf);\n\n        } else if (line[0] == 'D' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Cls=\", \" (\") < 0) {\n\n                goto fail;\n\n            }\n\n            class_id = strtoul(buf, NULL, 16);\n\n        }\n\n    fail: ;\n\n    }\n\n    if (device_count && (vendor_id || product_id)) {\n\n        \/* Add the last device.  *\/\n\n        ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                   product_id, product_name, speed);\n\n    }\n\n the_end:\n\n    if (f) {\n\n        fclose(f);\n\n    }\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"6658ffb81ee56a510d7d77025872a508a9adce3a","target":1,"func":"static inline int gen_intermediate_code_internal(CPUState *env, \n                                                 TranslationBlock *tb, \n                                                 int search_pc)\n{\n    DisasContext dc1, *dc = &dc1;\n    uint16_t *gen_opc_end;\n    int j, lj;\n    target_ulong pc_start;\n    uint32_t next_page_start;\n    \/* generate intermediate code *\/\n    pc_start = tb->pc;\n    dc->tb = tb;\n    gen_opc_ptr = gen_opc_buf;\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n    gen_opparam_ptr = gen_opparam_buf;\n    dc->is_jmp = DISAS_NEXT;\n    dc->pc = pc_start;\n    dc->singlestep_enabled = env->singlestep_enabled;\n    dc->condjmp = 0;\n    dc->thumb = env->thumb;\n    dc->is_mem = 0;\n#if !defined(CONFIG_USER_ONLY)\n    dc->user = (env->uncached_cpsr & 0x1f) == ARM_CPU_MODE_USR;\n#endif\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n    nb_gen_labels = 0;\n    lj = -1;\n    do {\n        if (env->nb_breakpoints > 0) {\n            for(j = 0; j < env->nb_breakpoints; j++) {\n                if (env->breakpoints[j] == dc->pc) {\n                    gen_op_movl_T0_im((long)dc->pc);\n                    gen_op_movl_reg_TN[0][15]();\n                    gen_op_debug();\n                    dc->is_jmp = DISAS_JUMP;\n                }\n            }\n        }\n        if (search_pc) {\n            j = gen_opc_ptr - gen_opc_buf;\n            if (lj < j) {\n                lj++;\n                while (lj < j)\n                    gen_opc_instr_start[lj++] = 0;\n            }\n            gen_opc_pc[lj] = dc->pc;\n            gen_opc_instr_start[lj] = 1;\n        }\n        if (env->thumb)\n          disas_thumb_insn(dc);\n        else\n          disas_arm_insn(env, dc);\n        if (dc->condjmp && !dc->is_jmp) {\n            gen_set_label(dc->condlabel);\n            dc->condjmp = 0;\n        }\n        \/* Translation stops when a conditional branch is enoutered.\n         * Otherwise the subsequent code could get translated several times.\n         * Also stop translation when a page boundary is reached.  This\n         * ensures prefech aborts occur at the right place.  *\/\n    } while (!dc->is_jmp && gen_opc_ptr < gen_opc_end &&\n             !env->singlestep_enabled &&\n             dc->pc < next_page_start);\n    \/* At this stage dc->condjmp will only be set when the skipped\n     * instruction was a conditional branch, and the PC has already been\n     * written.  *\/\n    if (__builtin_expect(env->singlestep_enabled, 0)) {\n        \/* Make sure the pc is updated, and raise a debug exception.  *\/\n        if (dc->condjmp) {\n            gen_op_debug();\n            gen_set_label(dc->condlabel);\n        }\n        if (dc->condjmp || !dc->is_jmp) {\n            gen_op_movl_T0_im((long)dc->pc);\n            gen_op_movl_reg_TN[0][15]();\n            dc->condjmp = 0;\n        }\n        gen_op_debug();\n    } else {\n        switch(dc->is_jmp) {\n        case DISAS_NEXT:\n            gen_goto_tb(dc, 1, dc->pc);\n        default:\n        case DISAS_JUMP:\n        case DISAS_UPDATE:\n            \/* indicate that the hash table must be used to find the next TB *\/\n            gen_op_movl_T0_0();\n            gen_op_exit_tb();\n        case DISAS_TB_JUMP:\n            \/* nothing more to generate *\/\n        }\n        if (dc->condjmp) {\n            gen_set_label(dc->condlabel);\n            gen_goto_tb(dc, 1, dc->pc);\n            dc->condjmp = 0;\n        }\n    }\n    *gen_opc_ptr = INDEX_op_end;\n#ifdef DEBUG_DISAS\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n        fprintf(logfile, \"----------------\\n\");\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n        target_disas(logfile, pc_start, dc->pc - pc_start, env->thumb);\n        fprintf(logfile, \"\\n\");\n        if (loglevel & (CPU_LOG_TB_OP)) {\n            fprintf(logfile, \"OP:\\n\");\n            dump_ops(gen_opc_buf, gen_opparam_buf);\n            fprintf(logfile, \"\\n\");\n        }\n    }\n#endif\n    if (search_pc) {\n        j = gen_opc_ptr - gen_opc_buf;\n        lj++;\n        while (lj <= j)\n            gen_opc_instr_start[lj++] = 0;\n        tb->size = 0;\n    } else {\n        tb->size = dc->pc - pc_start;\n    }\n    return 0;\n}"},{"project":"qemu","commit_id":"4d1628e832dfc6ec02b0d196f6cc250aaa7bf3b3","target":1,"func":"uint64_t helper_addlv(CPUAlphaState *env, uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 = (uint32_t)(op1 + op2);\n\n    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return op1;\n\n}\n"},{"project":"qemu","commit_id":"079d0b7f1eedcc634c371fe05b617fdc55c8b762","target":0,"func":"static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    struct USBBtState *s = (struct USBBtState *) dev->opaque;\n\n    int ret = 0;\n\n\n\n    if (!s->config)\n\n        goto fail;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_IN:\n\n        switch (p->devep & 0xf) {\n\n        case USB_EVT_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->evt, p);\n\n            break;\n\n\n\n        case USB_ACL_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->acl, p);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->sco, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_OUT:\n\n        switch (p->devep & 0xf) {\n\n        case USB_ACL_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,\n\n                            usb_bt_hci_acl_complete, p);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,\n\n                            usb_bt_hci_sco_complete, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"ddca7f86ac022289840e0200fd4050b2b58e9176","target":0,"func":"static void v9fs_write(void *opaque)\n\n{\n\n    ssize_t err;\n\n    int32_t fid;\n\n    uint64_t off;\n\n    uint32_t count;\n\n    int32_t len = 0;\n\n    int32_t total = 0;\n\n    size_t offset = 7;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n    QEMUIOVector qiov_full;\n\n    QEMUIOVector qiov;\n\n\n\n    offset += pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &count);\n\n    v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset, count, true);\n\n    trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, qiov_full.niov);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -EINVAL;\n\n        goto out_nofid;\n\n    }\n\n    if (fidp->fid_type == P9_FID_FILE) {\n\n        if (fidp->fs.fd == -1) {\n\n            err = -EINVAL;\n\n            goto out;\n\n        }\n\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n\n        \/*\n\n         * setxattr operation\n\n         *\/\n\n        err = v9fs_xattr_write(s, pdu, fidp, off, count,\n\n                               qiov_full.iov, qiov_full.niov);\n\n        goto out;\n\n    } else {\n\n        err = -EINVAL;\n\n        goto out;\n\n    }\n\n    qemu_iovec_init(&qiov, qiov_full.niov);\n\n    do {\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_copy(&qiov, &qiov_full, total, qiov_full.size - total);\n\n        if (0) {\n\n            print_sg(qiov.iov, qiov.niov);\n\n        }\n\n        \/* Loop in case of EINTR *\/\n\n        do {\n\n            len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);\n\n            if (len >= 0) {\n\n                off   += len;\n\n                total += len;\n\n            }\n\n        } while (len == -EINTR && !pdu->cancelled);\n\n        if (len < 0) {\n\n            \/* IO error return the error *\/\n\n            err = len;\n\n            goto out_qiov;\n\n        }\n\n    } while (total < count && len > 0);\n\n\n\n    offset = 7;\n\n    offset += pdu_marshal(pdu, offset, \"d\", total);\n\n    err = offset;\n\n    trace_v9fs_write_return(pdu->tag, pdu->id, total, err);\n\nout_qiov:\n\n    qemu_iovec_destroy(&qiov);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    qemu_iovec_destroy(&qiov_full);\n\n    complete_pdu(s, pdu, err);\n\n}\n"},{"project":"qemu","commit_id":"79d16c21a565927943486b26789caa62413ff371","target":1,"func":"static void virtio_gpu_reset(VirtIODevice *vdev)\n\n{\n\n    VirtIOGPU *g = VIRTIO_GPU(vdev);\n\n    struct virtio_gpu_simple_resource *res, *tmp;\n\n    int i;\n\n\n\n    g->enable = 0;\n\n\n\n    QTAILQ_FOREACH_SAFE(res, &g->reslist, next, tmp) {\n\n        virtio_gpu_resource_destroy(g, res);\n\n    }\n\n    for (i = 0; i < g->conf.max_outputs; i++) {\n\n#if 0\n\n        g->req_state[i].x = 0;\n\n        g->req_state[i].y = 0;\n\n        if (i == 0) {\n\n            g->req_state[0].width = 1024;\n\n            g->req_state[0].height = 768;\n\n        } else {\n\n            g->req_state[i].width = 0;\n\n            g->req_state[i].height = 0;\n\n        }\n\n#endif\n\n        g->scanout[i].resource_id = 0;\n\n        g->scanout[i].width = 0;\n\n        g->scanout[i].height = 0;\n\n        g->scanout[i].x = 0;\n\n        g->scanout[i].y = 0;\n\n        g->scanout[i].ds = NULL;\n\n    }\n\n    g->enabled_output_bitmask = 1;\n\n\n\n#ifdef CONFIG_VIRGL\n\n    if (g->use_virgl_renderer) {\n\n        virtio_gpu_virgl_reset(g);\n\n        g->use_virgl_renderer = 0;\n\n    }\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"d14a68b6dc0cc01ddd4c1c7c5907b95c3938679c","target":0,"func":"match_insn_m68k (bfd_vma memaddr,\n\n\t\t disassemble_info * info,\n\n\t\t const struct m68k_opcode * best,\n\n\t\t struct private * priv)\n\n{\n\n  unsigned char *save_p;\n\n  unsigned char *p;\n\n  const char *d;\n\n\n\n  bfd_byte *buffer = priv->the_buffer;\n\n  fprintf_ftype save_printer = info->fprintf_func;\n\n  void (* save_print_address) (bfd_vma, struct disassemble_info *)\n\n    = info->print_address_func;\n\n\n\n  \/* Point at first word of argument data,\n\n     and at descriptor for first argument.  *\/\n\n  p = buffer + 2;\n\n\n\n  \/* Figure out how long the fixed-size portion of the instruction is.\n\n     The only place this is stored in the opcode table is\n\n     in the arguments--look for arguments which specify fields in the 2nd\n\n     or 3rd words of the instruction.  *\/\n\n  for (d = best->args; *d; d += 2)\n\n    {\n\n      \/* I don't think it is necessary to be checking d[0] here;\n\n\t I suspect all this could be moved to the case statement below.  *\/\n\n      if (d[0] == '#')\n\n\t{\n\n\t  if (d[1] == 'l' && p - buffer < 6)\n\n\t    p = buffer + 6;\n\n\t  else if (p - buffer < 4 && d[1] != 'C' && d[1] != '8')\n\n\t    p = buffer + 4;\n\n\t}\n\n\n\n      if ((d[0] == 'L' || d[0] == 'l') && d[1] == 'w' && p - buffer < 4)\n\n\tp = buffer + 4;\n\n\n\n      switch (d[1])\n\n\t{\n\n\tcase '1':\n\n\tcase '2':\n\n\tcase '3':\n\n\tcase '7':\n\n\tcase '8':\n\n\tcase '9':\n\n\tcase 'i':\n\n\t  if (p - buffer < 4)\n\n\t    p = buffer + 4;\n\n\t  break;\n\n\tcase '4':\n\n\tcase '5':\n\n\tcase '6':\n\n\t  if (p - buffer < 6)\n\n\t    p = buffer + 6;\n\n\t  break;\n\n\tdefault:\n\n\t  break;\n\n\t}\n\n    }\n\n\n\n  \/* pflusha is an exceptions.  It takes no arguments but is two words\n\n     long.  Recognize it by looking at the lower 16 bits of the mask.  *\/\n\n  if (p - buffer < 4 && (best->match & 0xFFFF) != 0)\n\n    p = buffer + 4;\n\n\n\n  \/* lpstop is another exception.  It takes a one word argument but is\n\n     three words long.  *\/\n\n  if (p - buffer < 6\n\n      && (best->match & 0xffff) == 0xffff\n\n      && best->args[0] == '#'\n\n      && best->args[1] == 'w')\n\n    {\n\n      \/* Copy the one word argument into the usual location for a one\n\n\t word argument, to simplify printing it.  We can get away with\n\n\t this because we know exactly what the second word is, and we\n\n\t aren't going to print anything based on it.  *\/\n\n      p = buffer + 6;\n\n      FETCH_DATA (info, p);\n\n      buffer[2] = buffer[4];\n\n      buffer[3] = buffer[5];\n\n    }\n\n\n\n  FETCH_DATA (info, p);\n\n\n\n  d = best->args;\n\n\n\n  save_p = p;\n\n  info->print_address_func = dummy_print_address;\n\n  info->fprintf_func = (fprintf_ftype) dummy_printer;\n\n\n\n  \/* We scan the operands twice.  The first time we don't print anything,\n\n     but look for errors.  *\/\n\n  for (; *d; d += 2)\n\n    {\n\n      int eaten = print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);\n\n\n\n      if (eaten >= 0)\n\n\tp += eaten;\n\n      else if (eaten == -1)\n\n\t{\n\n\t  info->fprintf_func = save_printer;\n\n\t  info->print_address_func = save_print_address;\n\n\t  return 0;\n\n\t}\n\n      else\n\n\t{\n\n\t  info->fprintf_func (info->stream,\n\n\t\t\t      \/* xgettext:c-format *\/\n\n\t\t\t      _(\"<internal error in opcode table: %s %s>\\n\"),\n\n\t\t\t      best->name,  best->args);\n\n\t  info->fprintf_func = save_printer;\n\n\t  info->print_address_func = save_print_address;\n\n\t  return 2;\n\n\t}\n\n    }\n\n\n\n  p = save_p;\n\n  info->fprintf_func = save_printer;\n\n  info->print_address_func = save_print_address;\n\n\n\n  d = best->args;\n\n\n\n  info->fprintf_func (info->stream, \"%s\", best->name);\n\n\n\n  if (*d)\n\n    info->fprintf_func (info->stream, \" \");\n\n\n\n  while (*d)\n\n    {\n\n      p += print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);\n\n      d += 2;\n\n\n\n      if (*d && *(d - 2) != 'I' && *d != 'k')\n\n\tinfo->fprintf_func (info->stream, \",\");\n\n    }\n\n\n\n  return p - buffer;\n\n}\n"},{"project":"qemu","commit_id":"0919ac787641db11024912651f3bc5764d4f1286","target":0,"func":"struct omap_intr_handler_s *omap_inth_init(target_phys_addr_t base,\n\n                unsigned long size, unsigned char nbanks, qemu_irq **pins,\n\n                qemu_irq parent_irq, qemu_irq parent_fiq, omap_clk clk)\n\n{\n\n    struct omap_intr_handler_s *s = (struct omap_intr_handler_s *)\n\n            g_malloc0(sizeof(struct omap_intr_handler_s) +\n\n                            sizeof(struct omap_intr_handler_bank_s) * nbanks);\n\n\n\n    s->parent_intr[0] = parent_irq;\n\n    s->parent_intr[1] = parent_fiq;\n\n    s->nbanks = nbanks;\n\n    s->pins = qemu_allocate_irqs(omap_set_intr, s, nbanks * 32);\n\n    if (pins)\n\n        *pins = s->pins;\n\n\n\n    memory_region_init_io(&s->mmio, &omap_inth_mem_ops, s, \"omap-intc\", size);\n\n    memory_region_add_subregion(get_system_memory(), base, &s->mmio);\n\n\n\n    omap_inth_reset(s);\n\n\n\n    return s;\n\n}\n"},{"project":"qemu","commit_id":"0e9b9edae7bebfd31fdbead4ccbbce03876a7edd","target":0,"func":"void acpi_setup(void)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(qdev_get_machine());\n\n    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);\n\n    AcpiBuildTables tables;\n\n    AcpiBuildState *build_state;\n\n\n\n    if (!pcms->fw_cfg) {\n\n        ACPI_BUILD_DPRINTF(\"No fw cfg. Bailing out.\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!pcmc->has_acpi_build) {\n\n        ACPI_BUILD_DPRINTF(\"ACPI build disabled. Bailing out.\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!acpi_enabled) {\n\n        ACPI_BUILD_DPRINTF(\"ACPI disabled. Bailing out.\\n\");\n\n        return;\n\n    }\n\n\n\n    build_state = g_malloc0(sizeof *build_state);\n\n\n\n    acpi_set_pci_info();\n\n\n\n    acpi_build_tables_init(&tables);\n\n    acpi_build(&tables, MACHINE(pcms));\n\n\n\n    \/* Now expose it all to Guest *\/\n\n    build_state->table_mr = acpi_add_rom_blob(build_state, tables.table_data,\n\n                                               ACPI_BUILD_TABLE_FILE,\n\n                                               ACPI_BUILD_TABLE_MAX_SIZE);\n\n    assert(build_state->table_mr != NULL);\n\n\n\n    build_state->linker_mr =\n\n        acpi_add_rom_blob(build_state, tables.linker, \"etc\/table-loader\", 0);\n\n\n\n    fw_cfg_add_file(pcms->fw_cfg, ACPI_BUILD_TPMLOG_FILE,\n\n                    tables.tcpalog->data, acpi_data_len(tables.tcpalog));\n\n\n\n    if (!pcmc->rsdp_in_ram) {\n\n        \/*\n\n         * Keep for compatibility with old machine types.\n\n         * Though RSDP is small, its contents isn't immutable, so\n\n         * we'll update it along with the rest of tables on guest access.\n\n         *\/\n\n        uint32_t rsdp_size = acpi_data_len(tables.rsdp);\n\n\n\n        build_state->rsdp = g_memdup(tables.rsdp->data, rsdp_size);\n\n        fw_cfg_add_file_callback(pcms->fw_cfg, ACPI_BUILD_RSDP_FILE,\n\n                                 acpi_build_update, build_state,\n\n                                 build_state->rsdp, rsdp_size);\n\n        build_state->rsdp_mr = NULL;\n\n    } else {\n\n        build_state->rsdp = NULL;\n\n        build_state->rsdp_mr = acpi_add_rom_blob(build_state, tables.rsdp,\n\n                                                  ACPI_BUILD_RSDP_FILE, 0);\n\n    }\n\n\n\n    qemu_register_reset(acpi_build_reset, build_state);\n\n    acpi_build_reset(build_state);\n\n    vmstate_register(NULL, 0, &vmstate_acpi_build, build_state);\n\n\n\n    \/* Cleanup tables but don't free the memory: we track it\n\n     * in build_state.\n\n     *\/\n\n    acpi_build_tables_cleanup(&tables, false);\n\n}\n"},{"project":"qemu","commit_id":"90228ee395b71cdd64e6bc844e3d553eb9ef643f","target":1,"func":"static void bmdma_map(PCIDevice *pci_dev, int region_num,\n\n                    pcibus_t addr, pcibus_t size, int type)\n\n{\n\n    PCIIDEState *d = DO_UPCAST(PCIIDEState, dev, pci_dev);\n\n    int i;\n\n\n\n    for(i = 0;i < 2; i++) {\n\n        BMDMAState *bm = &d->bmdma[i];\n\n        d->bus[i].bmdma = bm;\n\n        bm->bus = d->bus+i;\n\n\n        qemu_add_vm_change_state_handler(ide_dma_restart_cb, bm);\n\n\n\n        register_ioport_write(addr, 1, 1, bmdma_cmd_writeb, bm);\n\n\n\n        register_ioport_write(addr + 1, 3, 1, bmdma_writeb, bm);\n\n        register_ioport_read(addr, 4, 1, bmdma_readb, bm);\n\n\n\n        register_ioport_write(addr + 4, 4, 1, bmdma_addr_writeb, bm);\n\n        register_ioport_read(addr + 4, 4, 1, bmdma_addr_readb, bm);\n\n        register_ioport_write(addr + 4, 4, 2, bmdma_addr_writew, bm);\n\n        register_ioport_read(addr + 4, 4, 2, bmdma_addr_readw, bm);\n\n        register_ioport_write(addr + 4, 4, 4, bmdma_addr_writel, bm);\n\n        register_ioport_read(addr + 4, 4, 4, bmdma_addr_readl, bm);\n\n        addr += 8;\n\n    }\n\n}"},{"project":"qemu","commit_id":"efb9ee024845982a210bfe48a73298846adfe9da","target":0,"func":"static int scsi_handle_rw_error(SCSIDiskReq *r, int error, int type)\n\n{\n\n    int is_read = (type == SCSI_REQ_STATUS_RETRY_READ);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    BlockErrorAction action = bdrv_get_on_error(s->bs, is_read);\n\n\n\n    if (action == BLOCK_ERR_IGNORE) {\n\n        bdrv_mon_event(s->bs, BDRV_ACTION_IGNORE, is_read);\n\n        return 0;\n\n    }\n\n\n\n    if ((error == ENOSPC && action == BLOCK_ERR_STOP_ENOSPC)\n\n            || action == BLOCK_ERR_STOP_ANY) {\n\n\n\n        type &= SCSI_REQ_STATUS_RETRY_TYPE_MASK;\n\n        r->status |= SCSI_REQ_STATUS_RETRY | type;\n\n\n\n        bdrv_mon_event(s->bs, BDRV_ACTION_STOP, is_read);\n\n        vm_stop(VMSTOP_DISKFULL);\n\n    } else {\n\n        if (type == SCSI_REQ_STATUS_RETRY_READ) {\n\n            scsi_req_data(&r->req, 0);\n\n        }\n\n        if (error == ENOMEM) {\n\n            scsi_command_complete(r, CHECK_CONDITION,\n\n                                  SENSE_CODE(TARGET_FAILURE));\n\n        } else {\n\n            scsi_command_complete(r, CHECK_CONDITION,\n\n                                  SENSE_CODE(IO_ERROR));\n\n        }\n\n        bdrv_mon_event(s->bs, BDRV_ACTION_REPORT, is_read);\n\n    }\n\n\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"c0532a76b407af4b276dc5a62d8178db59857ea6","target":1,"func":"static void kvm_do_inject_x86_mce(void *_data)\n\n{\n\n    struct kvm_x86_mce_data *data = _data;\n\n    int r;\n\n\n\n    r = kvm_set_mce(data->env, data->mce);\n\n    if (r < 0)\n\n        perror(\"kvm_set_mce FAILED\");\n\n}\n"},{"project":"qemu","commit_id":"bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884","target":0,"func":"static int vnc_display_get_address(const char *addrstr,\n\n                                   bool websocket,\n\n                                   bool reverse,\n\n                                   int displaynum,\n\n                                   int to,\n\n                                   bool has_ipv4,\n\n                                   bool has_ipv6,\n\n                                   bool ipv4,\n\n                                   bool ipv6,\n\n                                   SocketAddressLegacy **retaddr,\n\n                                   Error **errp)\n\n{\n\n    int ret = -1;\n\n    SocketAddressLegacy *addr = NULL;\n\n\n\n    addr = g_new0(SocketAddressLegacy, 1);\n\n\n\n    if (strncmp(addrstr, \"unix:\", 5) == 0) {\n\n        addr->type = SOCKET_ADDRESS_LEGACY_KIND_UNIX;\n\n        addr->u.q_unix.data = g_new0(UnixSocketAddress, 1);\n\n        addr->u.q_unix.data->path = g_strdup(addrstr + 5);\n\n\n\n        if (websocket) {\n\n            error_setg(errp, \"UNIX sockets not supported with websock\");\n\n            goto cleanup;\n\n        }\n\n\n\n        if (to) {\n\n            error_setg(errp, \"Port range not support with UNIX socket\");\n\n            goto cleanup;\n\n        }\n\n        ret = 0;\n\n    } else {\n\n        const char *port;\n\n        size_t hostlen;\n\n        unsigned long long baseport = 0;\n\n        InetSocketAddress *inet;\n\n\n\n        port = strrchr(addrstr, ':');\n\n        if (!port) {\n\n            if (websocket) {\n\n                hostlen = 0;\n\n                port = addrstr;\n\n            } else {\n\n                error_setg(errp, \"no vnc port specified\");\n\n                goto cleanup;\n\n            }\n\n        } else {\n\n            hostlen = port - addrstr;\n\n            port++;\n\n            if (*port == '\\0') {\n\n                error_setg(errp, \"vnc port cannot be empty\");\n\n                goto cleanup;\n\n            }\n\n        }\n\n\n\n        addr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;\n\n        inet = addr->u.inet.data = g_new0(InetSocketAddress, 1);\n\n        if (addrstr[0] == '[' && addrstr[hostlen - 1] == ']') {\n\n            inet->host = g_strndup(addrstr + 1, hostlen - 2);\n\n        } else {\n\n            inet->host = g_strndup(addrstr, hostlen);\n\n        }\n\n        \/* plain VNC port is just an offset, for websocket\n\n         * port is absolute *\/\n\n        if (websocket) {\n\n            if (g_str_equal(addrstr, \"\") ||\n\n                g_str_equal(addrstr, \"on\")) {\n\n                if (displaynum == -1) {\n\n                    error_setg(errp, \"explicit websocket port is required\");\n\n                    goto cleanup;\n\n                }\n\n                inet->port = g_strdup_printf(\n\n                    \"%d\", displaynum + 5700);\n\n                if (to) {\n\n                    inet->has_to = true;\n\n                    inet->to = to + 5700;\n\n                }\n\n            } else {\n\n                inet->port = g_strdup(port);\n\n            }\n\n        } else {\n\n            int offset = reverse ? 0 : 5900;\n\n            if (parse_uint_full(port, &baseport, 10) < 0) {\n\n                error_setg(errp, \"can't convert to a number: %s\", port);\n\n                goto cleanup;\n\n            }\n\n            if (baseport > 65535 ||\n\n                baseport + offset > 65535) {\n\n                error_setg(errp, \"port %s out of range\", port);\n\n                goto cleanup;\n\n            }\n\n            inet->port = g_strdup_printf(\n\n                \"%d\", (int)baseport + offset);\n\n\n\n            if (to) {\n\n                inet->has_to = true;\n\n                inet->to = to + offset;\n\n            }\n\n        }\n\n\n\n        inet->ipv4 = ipv4;\n\n        inet->has_ipv4 = has_ipv4;\n\n        inet->ipv6 = ipv6;\n\n        inet->has_ipv6 = has_ipv6;\n\n\n\n        ret = baseport;\n\n    }\n\n\n\n    *retaddr = addr;\n\n\n\n cleanup:\n\n    if (ret < 0) {\n\n        qapi_free_SocketAddressLegacy(addr);\n\n    }\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"f3c7d0389fe8a2792fd4c1cf151b885de03c8f62","target":1,"func":"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,\n\n                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],\n\n                omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_mmc_s *s = (struct omap_mmc_s *)\n\n            g_malloc0(sizeof(struct omap_mmc_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->clk = fclk;\n\n    s->lines = 4;\n\n    s->rev = 2;\n\n\n\n    omap_mmc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, \"omap.mmc\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    \/* Instantiate the storage *\/\n\n    s->card = sd_init(bd, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];\n\n    sd_set_cb(s->card, NULL, s->cdet);\n\n\n\n    return s;\n\n}\n"},{"project":"qemu","commit_id":"07caea315a85ebfe90851f9c2e4ef3fdd24117b5","target":1,"func":"static void realview_init(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    ram_addr_t ram_offset;\n\n    DeviceState *dev;\n\n    qemu_irq *irqp;\n\n    qemu_irq pic[64];\n\n    PCIBus *pci_bus;\n\n    NICInfo *nd;\n\n    int n;\n\n    int done_smc = 0;\n\n    qemu_irq cpu_irq[4];\n\n    int ncpu;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    \/* FIXME: obey smp_cpus.  *\/\n\n    if (strcmp(cpu_model, \"arm11mpcore\") == 0) {\n\n        ncpu = 4;\n\n    } else {\n\n        ncpu = 1;\n\n    }\n\n\n\n    for (n = 0; n < ncpu; n++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        irqp = arm_pic_init_cpu(env);\n\n        cpu_irq[n] = irqp[ARM_PIC_CPU_IRQ];\n\n        if (n > 0) {\n\n            \/* Set entry point for secondary CPUs.  This assumes we're using\n\n               the init code from arm_boot.c.  Real hardware resets all CPUs\n\n               the same.  *\/\n\n            env->regs[15] = 0x80000000;\n\n        }\n\n    }\n\n\n\n    ram_offset = qemu_ram_alloc(ram_size);\n\n    \/* ??? RAM should repeat to fill physical memory space.  *\/\n\n    \/* SDRAM at address zero.  *\/\n\n    cpu_register_physical_memory(0, ram_size, ram_offset | IO_MEM_RAM);\n\n\n\n    arm_sysctl_init(0x10000000, 0xc1400400);\n\n\n\n    if (ncpu == 1) {\n\n        \/* ??? The documentation says GIC1 is nFIQ and either GIC2 or GIC3\n\n           is nIRQ (there are inconsistencies).  However Linux 2.6.17 expects\n\n           GIC1 to be nIRQ and ignores all the others, so do that for now.  *\/\n\n        dev = sysbus_create_simple(\"realview_gic\", 0x10040000, cpu_irq[0]);\n\n    } else {\n\n        dev = sysbus_create_varargs(\"realview_mpcore\", -1,\n\n                                    cpu_irq[0], cpu_irq[1], cpu_irq[2],\n\n                                    cpu_irq[3], NULL);\n\n    }\n\n    for (n = 0; n < 64; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x10006000, pic[20]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x10007000, pic[21]);\n\n\n\n    sysbus_create_simple(\"pl011\", 0x10009000, pic[12]);\n\n    sysbus_create_simple(\"pl011\", 0x1000a000, pic[13]);\n\n    sysbus_create_simple(\"pl011\", 0x1000b000, pic[14]);\n\n    sysbus_create_simple(\"pl011\", 0x1000c000, pic[15]);\n\n\n\n    \/* DMA controller is optional, apparently.  *\/\n\n    sysbus_create_simple(\"pl081\", 0x10030000, pic[24]);\n\n\n\n    sysbus_create_simple(\"sp804\", 0x10011000, pic[4]);\n\n    sysbus_create_simple(\"sp804\", 0x10012000, pic[5]);\n\n\n\n    sysbus_create_simple(\"pl110_versatile\", 0x10020000, pic[23]);\n\n\n\n    sysbus_create_varargs(\"pl181\", 0x10005000, pic[17], pic[18], NULL);\n\n\n\n    sysbus_create_simple(\"pl031\", 0x10017000, pic[10]);\n\n\n\n    dev = sysbus_create_varargs(\"realview_pci\", 0x60000000,\n\n                                pic[48], pic[49], pic[50], pic[51], NULL);\n\n    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci\");\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n    n = drive_get_max_bus(IF_SCSI);\n\n    while (n >= 0) {\n\n        pci_create_simple(pci_bus, -1, \"lsi53c895a\");\n\n        n--;\n\n    }\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n\n\n        if ((!nd->model && !done_smc) || strcmp(nd->model, \"smc91c111\") == 0) {\n\n            smc91c111_init(nd, 0x4e000000, pic[28]);\n\n            done_smc = 1;\n\n        } else {\n\n            pci_nic_init(nd, \"rtl8139\", NULL);\n\n        }\n\n    }\n\n\n\n    \/* Memory map for RealView Emulation Baseboard:  *\/\n\n    \/* 0x10000000 System registers.  *\/\n\n    \/*  0x10001000 System controller.  *\/\n\n    \/*  0x10002000 Two-Wire Serial Bus.  *\/\n\n    \/* 0x10003000 Reserved.  *\/\n\n    \/*  0x10004000 AACI.  *\/\n\n    \/*  0x10005000 MCI.  *\/\n\n    \/* 0x10006000 KMI0.  *\/\n\n    \/* 0x10007000 KMI1.  *\/\n\n    \/*  0x10008000 Character LCD.  *\/\n\n    \/* 0x10009000 UART0.  *\/\n\n    \/* 0x1000a000 UART1.  *\/\n\n    \/* 0x1000b000 UART2.  *\/\n\n    \/* 0x1000c000 UART3.  *\/\n\n    \/*  0x1000d000 SSPI.  *\/\n\n    \/*  0x1000e000 SCI.  *\/\n\n    \/* 0x1000f000 Reserved.  *\/\n\n    \/*  0x10010000 Watchdog.  *\/\n\n    \/* 0x10011000 Timer 0+1.  *\/\n\n    \/* 0x10012000 Timer 2+3.  *\/\n\n    \/*  0x10013000 GPIO 0.  *\/\n\n    \/*  0x10014000 GPIO 1.  *\/\n\n    \/*  0x10015000 GPIO 2.  *\/\n\n    \/* 0x10016000 Reserved.  *\/\n\n    \/* 0x10017000 RTC.  *\/\n\n    \/*  0x10018000 DMC.  *\/\n\n    \/*  0x10019000 PCI controller config.  *\/\n\n    \/*  0x10020000 CLCD.  *\/\n\n    \/* 0x10030000 DMA Controller.  *\/\n\n    \/* 0x10040000 GIC1.  *\/\n\n    \/* 0x10050000 GIC2.  *\/\n\n    \/* 0x10060000 GIC3.  *\/\n\n    \/* 0x10070000 GIC4.  *\/\n\n    \/*  0x10080000 SMC.  *\/\n\n    \/*  0x40000000 NOR flash.  *\/\n\n    \/*  0x44000000 DoC flash.  *\/\n\n    \/*  0x48000000 SRAM.  *\/\n\n    \/*  0x4c000000 Configuration flash.  *\/\n\n    \/* 0x4e000000 Ethernet.  *\/\n\n    \/*  0x4f000000 USB.  *\/\n\n    \/*  0x50000000 PISMO.  *\/\n\n    \/*  0x54000000 PISMO.  *\/\n\n    \/*  0x58000000 PISMO.  *\/\n\n    \/*  0x5c000000 PISMO.  *\/\n\n    \/* 0x60000000 PCI.  *\/\n\n    \/* 0x61000000 PCI Self Config.  *\/\n\n    \/* 0x62000000 PCI Config.  *\/\n\n    \/* 0x63000000 PCI IO.  *\/\n\n    \/* 0x64000000 PCI mem 0.  *\/\n\n    \/* 0x68000000 PCI mem 1.  *\/\n\n    \/* 0x6c000000 PCI mem 2.  *\/\n\n\n\n    \/* ??? Hack to map an additional page of ram for the secondary CPU\n\n       startup code.  I guess this works on real hardware because the\n\n       BootROM happens to be in ROM\/flash or in memory that isn't clobbered\n\n       until after Linux boots the secondary CPUs.  *\/\n\n    ram_offset = qemu_ram_alloc(0x1000);\n\n    cpu_register_physical_memory(0x80000000, 0x1000, ram_offset | IO_MEM_RAM);\n\n\n\n    realview_binfo.ram_size = ram_size;\n\n    realview_binfo.kernel_filename = kernel_filename;\n\n    realview_binfo.kernel_cmdline = kernel_cmdline;\n\n    realview_binfo.initrd_filename = initrd_filename;\n\n    realview_binfo.nb_cpus = ncpu;\n\n    arm_load_kernel(first_cpu, &realview_binfo);\n\n}\n"},{"project":"qemu","commit_id":"4500bc98a6aab1734d865afaeade3509eb65b560","target":0,"func":"static void test_acpi_one(const char *params, test_data *data)\n\n{\n\n    char *args;\n\n    uint8_t signature_low;\n\n    uint8_t signature_high;\n\n    uint16_t signature;\n\n    int i;\n\n    const char *device = \"\";\n\n\n\n    if (!g_strcmp0(data->machine, MACHINE_Q35)) {\n\n        device = \",id=hd -device ide-hd,drive=hd\";\n\n    }\n\n\n\n    args = g_strdup_printf(\"-net none -display none %s -drive file=%s%s,\",\n\n                           params ? params : \"\", disk, device);\n\n    qtest_start(args);\n\n\n\n   \/* Wait at most 1 minute *\/\n\n#define TEST_DELAY (1 * G_USEC_PER_SEC \/ 10)\n\n#define TEST_CYCLES MAX((60 * G_USEC_PER_SEC \/ TEST_DELAY), 1)\n\n\n\n    \/* Poll until code has run and modified memory.  Once it has we know BIOS\n\n     * initialization is done.  TODO: check that IP reached the halt\n\n     * instruction.\n\n     *\/\n\n    for (i = 0; i < TEST_CYCLES; ++i) {\n\n        signature_low = readb(BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET);\n\n        signature_high = readb(BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET + 1);\n\n        signature = (signature_high << 8) | signature_low;\n\n        if (signature == SIGNATURE) {\n\n            break;\n\n        }\n\n        g_usleep(TEST_DELAY);\n\n    }\n\n    g_assert_cmphex(signature, ==, SIGNATURE);\n\n\n\n    test_acpi_rsdp_address(data);\n\n    test_acpi_rsdp_table(data);\n\n    test_acpi_rsdt_table(data);\n\n    test_acpi_fadt_table(data);\n\n    test_acpi_facs_table(data);\n\n    test_acpi_dsdt_table(data);\n\n    test_acpi_ssdt_tables(data);\n\n\n\n    if (iasl) {\n\n        test_acpi_asl(data);\n\n    }\n\n\n\n    qtest_quit(global_qtest);\n\n    g_free(args);\n\n}\n"},{"project":"qemu","commit_id":"5820945946b1e221905aa898f2cd97ed825acd47","target":1,"func":"static void shpc_interrupt_update(PCIDevice *d)\n\n{\n\n    SHPCDevice *shpc = d->shpc;\n\n    int slot;\n\n    int level = 0;\n\n    uint32_t serr_int;\n\n    uint32_t int_locator = 0;\n\n\n\n    \/* Update interrupt locator register *\/\n\n    for (slot = 0; slot < shpc->nslots; ++slot) {\n\n        uint8_t event = shpc->config[SHPC_SLOT_EVENT_LATCH(slot)];\n\n        uint8_t disable = shpc->config[SHPC_SLOT_EVENT_SERR_INT_DIS(d, slot)];\n\n        uint32_t mask = 1 << SHPC_IDX_TO_LOGICAL(slot);\n\n        if (event & ~disable) {\n\n            int_locator |= mask;\n\n        }\n\n    }\n\n    serr_int = pci_get_long(shpc->config + SHPC_SERR_INT);\n\n    if ((serr_int & SHPC_CMD_DETECTED) && !(serr_int & SHPC_CMD_INT_DIS)) {\n\n        int_locator |= SHPC_INT_COMMAND;\n\n    }\n\n    pci_set_long(shpc->config + SHPC_INT_LOCATOR, int_locator);\n\n    level = (!(serr_int & SHPC_INT_DIS) && int_locator) ? 1 : 0;\n\n    if (msi_enabled(d) && shpc->msi_requested != level)\n\n        msi_notify(d, 0);\n\n    else\n\n        pci_set_irq(d, level);\n\n    shpc->msi_requested = level;\n\n}\n"},{"project":"qemu","commit_id":"6ffacc5d3ddf2e3227aae2a8cc5c15627265f727","target":1,"func":"static bool ga_open_pidfile(const char *pidfile)\n\n{\n\n    int pidfd;\n\n    char pidstr[32];\n\n\n\n    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);\n\n    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {\n\n        g_critical(\"Cannot lock pid file, %s\", strerror(errno));\n\n        if (pidfd != -1) {\n\n            close(pidfd);\n\n        }\n\n        return false;\n\n    }\n\n\n\n    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {\n\n        g_critical(\"Failed to truncate pid file\");\n\n        goto fail;\n\n    }\n\n    snprintf(pidstr, sizeof(pidstr), \"%d\\n\", getpid());\n\n    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {\n\n        g_critical(\"Failed to write pid file\");\n\n        goto fail;\n\n    }\n\n\n\n    return true;\n\n\n\nfail:\n\n    unlink(pidfile);\n\n    return false;\n\n}\n"},{"project":"qemu","commit_id":"0b8b8753e4d94901627b3e86431230f2319215c4","target":1,"func":"static void fd_coroutine_enter(void *opaque)\n\n{\n\n    FDYieldUntilData *data = opaque;\n\n    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);\n\n    qemu_coroutine_enter(data->co, NULL);\n\n}\n"},{"project":"qemu","commit_id":"7d1b0095bff7157e856d1d0e6c4295641ced2752","target":1,"func":"static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags)\n\n{\n\n    switch (shiftop) {\n\n    case 0: \/* LSL *\/\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, 32 - shift);\n\n            tcg_gen_shli_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 1: \/* LSR *\/\n\n        if (shift == 0) {\n\n            if (flags) {\n\n                tcg_gen_shri_i32(var, var, 31);\n\n                gen_set_CF(var);\n\n            }\n\n            tcg_gen_movi_i32(var, 0);\n\n        } else {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_shri_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 2: \/* ASR *\/\n\n        if (shift == 0)\n\n            shift = 32;\n\n        if (flags)\n\n            shifter_out_im(var, shift - 1);\n\n        if (shift == 32)\n\n          shift = 31;\n\n        tcg_gen_sari_i32(var, var, shift);\n\n        break;\n\n    case 3: \/* ROR\/RRX *\/\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_rotri_i32(var, var, shift); break;\n\n        } else {\n\n            TCGv tmp = load_cpu_field(CF);\n\n            if (flags)\n\n                shifter_out_im(var, 0);\n\n            tcg_gen_shri_i32(var, var, 1);\n\n            tcg_gen_shli_i32(tmp, tmp, 31);\n\n            tcg_gen_or_i32(var, var, tmp);\n\n            dead_tmp(tmp);\n\n        }\n\n    }\n\n};\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"void omap_badwidth_write32(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    OMAP_32B_REG(addr);\n\n    cpu_physical_memory_write(addr, (void *) &value, 4);\n\n}\n"},{"project":"qemu","commit_id":"ce137829e7e58fcdc5ba63b5e256f972e80be438","target":1,"func":"static inline int array_roll(array_t* array,int index_to,int index_from,int count)\n\n{\n\n    char* buf;\n\n    char* from;\n\n    char* to;\n\n    int is;\n\n\n\n    if(!array ||\n\n\t    index_to<0 || index_to>=array->next ||\n\n\t    index_from<0 || index_from>=array->next)\n\n\treturn -1;\n\n\n\n    if(index_to==index_from)\n\n\treturn 0;\n\n\n\n    is=array->item_size;\n\n    from=array->pointer+index_from*is;\n\n    to=array->pointer+index_to*is;\n\n    buf=g_malloc(is*count);\n\n    memcpy(buf,from,is*count);\n\n\n\n    if(index_to<index_from)\n\n\tmemmove(to+is*count,to,from-to);\n\n    else\n\n\tmemmove(from,from+is*count,to-from);\n\n\n\n    memcpy(to,buf,is*count);\n\n\n\n    free(buf);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"bbc01ca7f265f2c5be8aee7c9ce1d10aa26063f5","target":0,"func":"static void init_proc_970MP (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    \/* Time base *\/\n\n    gen_tbl(env);\n\n    \/* Hardware implementation registers *\/\n\n    \/* XXX : not implemented *\/\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_clear,\n\n                 0x60000000);\n\n    \/* XXX : not implemented *\/\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    \/* XXX : not implemented *\/\n\n    spr_register(env, SPR_970_HID5, \"HID5\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 POWERPC970_HID5_INIT);\n\n    \/* XXX : not implemented *\/\n\n    \/* Memory management *\/\n\n    \/* XXX: not correct *\/\n\n    gen_low_BATs(env);\n\n    spr_register(env, SPR_HIOR, \"SPR_HIOR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_hior, &spr_write_hior,\n\n                 0x00000000);\n\n    \/* Logical partitionning *\/\n\n    spr_register_kvm(env, SPR_LPCR, \"LPCR\",\n\n                     SPR_NOACCESS, SPR_NOACCESS,\n\n                     &spr_read_generic, &spr_write_generic,\n\n                     KVM_REG_PPC_LPCR, 0x00000000);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->slb_nr = 32;\n\n#endif\n\n    init_excp_970(env);\n\n    env->dcache_line_size = 128;\n\n    env->icache_line_size = 128;\n\n    \/* Allocate hardware IRQ controller *\/\n\n    ppc970_irq_init(env);\n\n    \/* Can't find information on what this should be on reset.  This\n\n     * value is the one used by 74xx processors. *\/\n\n    vscr_init(env, 0x00010000);\n\n}\n"},{"project":"qemu","commit_id":"7d1b0095bff7157e856d1d0e6c4295641ced2752","target":1,"func":"static void gen_smul_dual(TCGv a, TCGv b)\n\n{\n\n    TCGv tmp1 = new_tmp();\n\n    TCGv tmp2 = new_tmp();\n\n    tcg_gen_ext16s_i32(tmp1, a);\n\n    tcg_gen_ext16s_i32(tmp2, b);\n\n    tcg_gen_mul_i32(tmp1, tmp1, tmp2);\n\n    dead_tmp(tmp2);\n\n    tcg_gen_sari_i32(a, a, 16);\n\n    tcg_gen_sari_i32(b, b, 16);\n\n    tcg_gen_mul_i32(b, b, a);\n\n    tcg_gen_mov_i32(a, tmp1);\n\n    dead_tmp(tmp1);\n\n}\n"},{"project":"qemu","commit_id":"696b55017d90b3237ca9d656aa4904d6b5c46c7a","target":1,"func":"file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)\n\n{\n\n    HostMemoryBackendFile *fb = MEMORY_BACKEND_FILE(backend);\n\n\n\n    if (!backend->size) {\n\n        error_setg(errp, \"can't create backend with size 0\");\n\n        return;\n\n    }\n\n    if (!fb->mem_path) {\n\n        error_setg(errp, \"mem-path property not set\");\n\n        return;\n\n    }\n\n#ifndef CONFIG_LINUX\n\n    error_setg(errp, \"-mem-path not supported on this host\");\n\n#else\n\n    if (!memory_region_size(&backend->mr)) {\n\n        backend->force_prealloc = mem_prealloc;\n\n        memory_region_init_ram_from_file(&backend->mr, OBJECT(backend),\n\n                                 object_get_canonical_path(OBJECT(backend)),\n\n                                 backend->size, fb->share,\n\n                                 fb->mem_path, errp);\n\n    }\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"fe5241bfe3fb61ec3f589ceacd91c1469bfd400f","target":0,"func":"static int dmg_open(BlockDriverState *bs, QDict *options, int flags,\n\n                    Error **errp)\n\n{\n\n    BDRVDMGState *s = bs->opaque;\n\n    DmgHeaderState ds;\n\n    uint64_t rsrc_fork_offset, rsrc_fork_length;\n\n    uint64_t plist_xml_offset, plist_xml_length;\n\n    int64_t offset;\n\n    int ret;\n\n\n\n    bs->file = bdrv_open_child(NULL, options, \"file\", bs, &child_file,\n\n                               false, errp);\n\n    if (!bs->file) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    block_module_load_one(\"dmg-bz2\");\n\n    bs->read_only = true;\n\n\n\n    s->n_chunks = 0;\n\n    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;\n\n    \/* used by dmg_read_mish_block to keep track of the current I\/O position *\/\n\n    ds.data_fork_offset = 0;\n\n    ds.max_compressed_size = 1;\n\n    ds.max_sectors_per_chunk = 1;\n\n\n\n    \/* locate the UDIF trailer *\/\n\n    offset = dmg_find_koly_offset(bs->file, errp);\n\n    if (offset < 0) {\n\n        ret = offset;\n\n        goto fail;\n\n    }\n\n\n\n    \/* offset of data fork (DataForkOffset) *\/\n\n    ret = read_uint64(bs, offset + 0x18, &ds.data_fork_offset);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    } else if (ds.data_fork_offset > offset) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    \/* offset of resource fork (RsrcForkOffset) *\/\n\n    ret = read_uint64(bs, offset + 0x28, &rsrc_fork_offset);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    ret = read_uint64(bs, offset + 0x30, &rsrc_fork_length);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    if (rsrc_fork_offset >= offset ||\n\n        rsrc_fork_length > offset - rsrc_fork_offset) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    \/* offset of property list (XMLOffset) *\/\n\n    ret = read_uint64(bs, offset + 0xd8, &plist_xml_offset);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    ret = read_uint64(bs, offset + 0xe0, &plist_xml_length);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    if (plist_xml_offset >= offset ||\n\n        plist_xml_length > offset - plist_xml_offset) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    ret = read_uint64(bs, offset + 0x1ec, (uint64_t *)&bs->total_sectors);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    if (bs->total_sectors < 0) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (rsrc_fork_length != 0) {\n\n        ret = dmg_read_resource_fork(bs, &ds,\n\n                                     rsrc_fork_offset, rsrc_fork_length);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    } else if (plist_xml_length != 0) {\n\n        ret = dmg_read_plist_xml(bs, &ds, plist_xml_offset, plist_xml_length);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    } else {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    \/* initialize zlib engine *\/\n\n    s->compressed_chunk = qemu_try_blockalign(bs->file->bs,\n\n                                              ds.max_compressed_size + 1);\n\n    s->uncompressed_chunk = qemu_try_blockalign(bs->file->bs,\n\n                                                512 * ds.max_sectors_per_chunk);\n\n    if (s->compressed_chunk == NULL || s->uncompressed_chunk == NULL) {\n\n        ret = -ENOMEM;\n\n        goto fail;\n\n    }\n\n\n\n    if (inflateInit(&s->zstream) != Z_OK) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    s->current_chunk = s->n_chunks;\n\n\n\n    qemu_co_mutex_init(&s->lock);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(s->types);\n\n    g_free(s->offsets);\n\n    g_free(s->lengths);\n\n    g_free(s->sectors);\n\n    g_free(s->sectorcounts);\n\n    qemu_vfree(s->compressed_chunk);\n\n    qemu_vfree(s->uncompressed_chunk);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"bccd9ec5f098668576342c83d90d6d6833d61d33","target":0,"func":"void tlb_fill (target_ulong addr, int is_write, int mmu_idx, void *retaddr)\n\n{\n\n    TranslationBlock *tb;\n\n    CPUState *saved_env;\n\n    unsigned long pc;\n\n    int ret;\n\n\n\n    \/* XXX: hack to restore env in all cases, even if not called from\n\n       generated code *\/\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n\n\n    D_LOG(\"%s pc=%x tpc=%x ra=%x\\n\", __func__, \n\n\t     env->pc, env->debug1, retaddr);\n\n    ret = cpu_cris_handle_mmu_fault(env, addr, is_write, mmu_idx);\n\n    if (unlikely(ret)) {\n\n        if (retaddr) {\n\n            \/* now we have a real cpu fault *\/\n\n            pc = (unsigned long)retaddr;\n\n            tb = tb_find_pc(pc);\n\n            if (tb) {\n\n                \/* the PC is inside the translated code. It means that we have\n\n                   a virtual CPU fault *\/\n\n                cpu_restore_state(tb, env, pc);\n\n\n\n\t\t\/* Evaluate flags after retranslation.  *\/\n\n                helper_top_evaluate_flags();\n\n            }\n\n        }\n\n        cpu_loop_exit(env);\n\n    }\n\n    env = saved_env;\n\n}\n"},{"project":"qemu","commit_id":"c471ad0e9bd46ca5f5c9c796e727230e043a091d","target":0,"func":"static int vhost_verify_ring_mappings(struct vhost_dev *dev,\n\n                                      uint64_t start_addr,\n\n                                      uint64_t size)\n\n{\n\n    int i, j;\n\n    int r = 0;\n\n    const char *part_name[] = {\n\n        \"descriptor table\",\n\n        \"available ring\",\n\n        \"used ring\"\n\n    };\n\n\n\n    for (i = 0; i < dev->nvqs; ++i) {\n\n        struct vhost_virtqueue *vq = dev->vqs + i;\n\n\n\n        j = 0;\n\n        r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys,\n\n                                           vq->desc_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys,\n\n                                           vq->avail_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys,\n\n                                           vq->used_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (r == -ENOMEM) {\n\n        error_report(\"Unable to map %s for ring %d\", part_name[j], i);\n\n    } else if (r == -EBUSY) {\n\n        error_report(\"%s relocated for ring %d\", part_name[j], i);\n\n    }\n\n    return r;\n\n}\n"},{"project":"qemu","commit_id":"60fe637bf0e4d7989e21e50f52526444765c63b4","target":1,"func":"static void put_uint8(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    qemu_put_8s(f, v);\n\n}\n"},{"project":"qemu","commit_id":"5def6b80e1eca696c1fc6099e7f4d36729686402","target":0,"func":"static void raw_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    struct stat st;\n\n\n\n    if (!fstat(s->fd, &st)) {\n\n        if (S_ISBLK(st.st_mode)) {\n\n            int ret = hdev_get_max_transfer_length(s->fd);\n\n            if (ret >= 0) {\n\n                bs->bl.max_transfer_length = ret;\n\n            }\n\n        }\n\n    }\n\n\n\n    raw_probe_alignment(bs, s->fd, errp);\n\n    bs->bl.min_mem_alignment = s->buf_align;\n\n    bs->bl.opt_mem_alignment = MAX(s->buf_align, getpagesize());\n\n}\n"},{"project":"qemu","commit_id":"3df3e0a5872cbc8fcc55a0413416352eec68132e","target":1,"func":"static VFIOGroup *vfio_get_group(int groupid)\n\n{\n\n    VFIOGroup *group;\n\n    char path[32];\n\n    struct vfio_group_status status = { .argsz = sizeof(status) };\n\n\n\n    QLIST_FOREACH(group, &group_list, next) {\n\n        if (group->groupid == groupid) {\n\n            return group;\n\n        }\n\n    }\n\n\n\n    group = g_malloc0(sizeof(*group));\n\n\n\n    snprintf(path, sizeof(path), \"\/dev\/vfio\/%d\", groupid);\n\n    group->fd = qemu_open(path, O_RDWR);\n\n    if (group->fd < 0) {\n\n        error_report(\"vfio: error opening %s: %m\", path);\n\n        goto free_group_exit;\n\n    }\n\n\n\n    if (ioctl(group->fd, VFIO_GROUP_GET_STATUS, &status)) {\n\n        error_report(\"vfio: error getting group status: %m\");\n\n        goto close_fd_exit;\n\n    }\n\n\n\n    if (!(status.flags & VFIO_GROUP_FLAGS_VIABLE)) {\n\n        error_report(\"vfio: error, group %d is not viable, please ensure \"\n\n                     \"all devices within the iommu_group are bound to their \"\n\n                     \"vfio bus driver.\", groupid);\n\n        goto close_fd_exit;\n\n    }\n\n\n\n    group->groupid = groupid;\n\n    QLIST_INIT(&group->device_list);\n\n\n\n    if (vfio_connect_container(group)) {\n\n        error_report(\"vfio: failed to setup container for group %d\", groupid);\n\n        goto close_fd_exit;\n\n    }\n\n\n\n    if (QLIST_EMPTY(&group_list)) {\n\n        qemu_register_reset(vfio_pci_reset_handler, NULL);\n\n    }\n\n\n\n    QLIST_INSERT_HEAD(&group_list, group, next);\n\n\n\n    vfio_kvm_device_add_group(group);\n\n\n\n    return group;\n\n\n\nclose_fd_exit:\n\n    close(group->fd);\n\n\n\nfree_group_exit:\n\n    g_free(group);\n\n\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"fd56e0612b6454a282fa6a953fdb09281a98c589","target":0,"func":"PCIDevice *pci_get_function_0(PCIDevice *pci_dev)\n\n{\n\n    if(pcie_has_upstream_port(pci_dev)) {\n\n        \/* With an upstream PCIe port, we only support 1 device at slot 0 *\/\n\n        return pci_dev->bus->devices[0];\n\n    } else {\n\n        \/* Other bus types might support multiple devices at slots 0-31 *\/\n\n        return pci_dev->bus->devices[PCI_DEVFN(PCI_SLOT(pci_dev->devfn), 0)];\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"97f1c45c6f456572e5b504b8614e4a69e23b8e3a","target":1,"func":"static void vpc_close(BlockDriverState *bs)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    g_free(s->pagetable);\n\n#ifdef CACHE\n\n    g_free(s->pageentry_u8);\n\n#endif\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n"},{"project":"qemu","commit_id":"9d2db3760be9e32414e22889e3e2bffdf4898f32","target":1,"func":"void colo_do_failover(MigrationState *s)\n\n{\n\n    \/* Make sure VM stopped while failover happened. *\/\n\n    if (!colo_runstate_is_stopped()) {\n\n        vm_stop_force_state(RUN_STATE_COLO);\n\n    }\n\n\n\n    if (get_colo_mode() == COLO_MODE_PRIMARY) {\n\n        primary_vm_do_failover();\n\n\n\n    }\n\n}"},{"project":"qemu","commit_id":"d41f3e750d2c06c613cb1b8db7724f0fbc0a2b14","target":0,"func":"build_srat(GArray *table_data, BIOSLinker *linker, MachineState *machine)\n\n{\n\n    AcpiSystemResourceAffinityTable *srat;\n\n    AcpiSratMemoryAffinity *numamem;\n\n\n\n    int i;\n\n    int srat_start, numa_start, slots;\n\n    uint64_t mem_len, mem_base, next_base;\n\n    MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n    const CPUArchIdList *apic_ids = mc->possible_cpu_arch_ids(machine);\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n    ram_addr_t hotplugabble_address_space_size =\n\n        object_property_get_int(OBJECT(pcms), PC_MACHINE_MEMHP_REGION_SIZE,\n\n                                NULL);\n\n\n\n    srat_start = table_data->len;\n\n\n\n    srat = acpi_data_push(table_data, sizeof *srat);\n\n    srat->reserved1 = cpu_to_le32(1);\n\n\n\n    for (i = 0; i < apic_ids->len; i++) {\n\n        int node_id = apic_ids->cpus[i].props.has_node_id ?\n\n            apic_ids->cpus[i].props.node_id : 0;\n\n        uint32_t apic_id = apic_ids->cpus[i].arch_id;\n\n\n\n        if (apic_id < 255) {\n\n            AcpiSratProcessorAffinity *core;\n\n\n\n            core = acpi_data_push(table_data, sizeof *core);\n\n            core->type = ACPI_SRAT_PROCESSOR_APIC;\n\n            core->length = sizeof(*core);\n\n            core->local_apic_id = apic_id;\n\n            core->proximity_lo = node_id;\n\n            memset(core->proximity_hi, 0, 3);\n\n            core->local_sapic_eid = 0;\n\n            core->flags = cpu_to_le32(1);\n\n        } else {\n\n            AcpiSratProcessorX2ApicAffinity *core;\n\n\n\n            core = acpi_data_push(table_data, sizeof *core);\n\n            core->type = ACPI_SRAT_PROCESSOR_x2APIC;\n\n            core->length = sizeof(*core);\n\n            core->x2apic_id = cpu_to_le32(apic_id);\n\n            core->proximity_domain = cpu_to_le32(node_id);\n\n            core->flags = cpu_to_le32(1);\n\n        }\n\n    }\n\n\n\n\n\n    \/* the memory map is a bit tricky, it contains at least one hole\n\n     * from 640k-1M and possibly another one from 3.5G-4G.\n\n     *\/\n\n    next_base = 0;\n\n    numa_start = table_data->len;\n\n\n\n    numamem = acpi_data_push(table_data, sizeof *numamem);\n\n    build_srat_memory(numamem, 0, 640 * 1024, 0, MEM_AFFINITY_ENABLED);\n\n    next_base = 1024 * 1024;\n\n    for (i = 1; i < pcms->numa_nodes + 1; ++i) {\n\n        mem_base = next_base;\n\n        mem_len = pcms->node_mem[i - 1];\n\n        if (i == 1) {\n\n            mem_len -= 1024 * 1024;\n\n        }\n\n        next_base = mem_base + mem_len;\n\n\n\n        \/* Cut out the ACPI_PCI hole *\/\n\n        if (mem_base <= pcms->below_4g_mem_size &&\n\n            next_base > pcms->below_4g_mem_size) {\n\n            mem_len -= next_base - pcms->below_4g_mem_size;\n\n            if (mem_len > 0) {\n\n                numamem = acpi_data_push(table_data, sizeof *numamem);\n\n                build_srat_memory(numamem, mem_base, mem_len, i - 1,\n\n                                  MEM_AFFINITY_ENABLED);\n\n            }\n\n            mem_base = 1ULL << 32;\n\n            mem_len = next_base - pcms->below_4g_mem_size;\n\n            next_base += (1ULL << 32) - pcms->below_4g_mem_size;\n\n        }\n\n        numamem = acpi_data_push(table_data, sizeof *numamem);\n\n        build_srat_memory(numamem, mem_base, mem_len, i - 1,\n\n                          MEM_AFFINITY_ENABLED);\n\n    }\n\n    slots = (table_data->len - numa_start) \/ sizeof *numamem;\n\n    for (; slots < pcms->numa_nodes + 2; slots++) {\n\n        numamem = acpi_data_push(table_data, sizeof *numamem);\n\n        build_srat_memory(numamem, 0, 0, 0, MEM_AFFINITY_NOFLAGS);\n\n    }\n\n\n\n    \/*\n\n     * Entry is required for Windows to enable memory hotplug in OS\n\n     * and for Linux to enable SWIOTLB when booted with less than\n\n     * 4G of RAM. Windows works better if the entry sets proximity\n\n     * to the highest NUMA node in the machine.\n\n     * Memory devices may override proximity set by this entry,\n\n     * providing _PXM method if necessary.\n\n     *\/\n\n    if (hotplugabble_address_space_size) {\n\n        numamem = acpi_data_push(table_data, sizeof *numamem);\n\n        build_srat_memory(numamem, pcms->hotplug_memory.base,\n\n                          hotplugabble_address_space_size, pcms->numa_nodes - 1,\n\n                          MEM_AFFINITY_HOTPLUGGABLE | MEM_AFFINITY_ENABLED);\n\n    }\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + srat_start),\n\n                 \"SRAT\",\n\n                 table_data->len - srat_start, 1, NULL, NULL);\n\n}\n"},{"project":"qemu","commit_id":"0e9b9edae7bebfd31fdbead4ccbbce03876a7edd","target":0,"func":"build_fadt(GArray *table_data, GArray *linker, unsigned dsdt)\n\n{\n\n    AcpiFadtDescriptorRev5_1 *fadt = acpi_data_push(table_data, sizeof(*fadt));\n\n\n\n    \/* Hardware Reduced = 1 and use PSCI 0.2+ and with HVC *\/\n\n    fadt->flags = cpu_to_le32(1 << ACPI_FADT_F_HW_REDUCED_ACPI);\n\n    fadt->arm_boot_flags = cpu_to_le16((1 << ACPI_FADT_ARM_USE_PSCI_G_0_2) |\n\n                                       (1 << ACPI_FADT_ARM_PSCI_USE_HVC));\n\n\n\n    \/* ACPI v5.1 (fadt->revision.fadt->minor_revision) *\/\n\n    fadt->minor_revision = 0x1;\n\n\n\n    fadt->dsdt = cpu_to_le32(dsdt);\n\n    \/* DSDT address to be filled by Guest linker *\/\n\n    bios_linker_loader_add_pointer(linker, ACPI_BUILD_TABLE_FILE,\n\n                                   ACPI_BUILD_TABLE_FILE,\n\n                                   table_data, &fadt->dsdt,\n\n                                   sizeof fadt->dsdt);\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)fadt, \"FACP\", sizeof(*fadt), 5, NULL, NULL);\n\n}\n"},{"project":"qemu","commit_id":"fa879d62eb51253d00b6920ce1d1d9d261370a49","target":0,"func":"int bdrv_attach(BlockDriverState *bs, DeviceState *qdev)\n\n{\n\n    if (bs->peer) {\n\n        return -EBUSY;\n\n    }\n\n    bs->peer = qdev;\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"e92f0e1910f0655a0edd8d87c5a7262d36517a89","target":1,"func":"static BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset, int bytes,\n\n                                QEMUIOVector *qiov, CoroutineEntry co_entry,\n\n                                BdrvRequestFlags flags,\n\n                                BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    BlkAioEmAIOCB *acb;\n\n    Coroutine *co;\n\n\n\n    bdrv_inc_in_flight(blk_bs(blk));\n\n    acb = blk_aio_get(&blk_aio_em_aiocb_info, blk, cb, opaque);\n\n    acb->rwco = (BlkRwCo) {\n\n        .blk    = blk,\n\n        .offset = offset,\n\n        .qiov   = qiov,\n\n        .flags  = flags,\n\n        .ret    = NOT_DONE,\n\n    };\n\n    acb->bytes = bytes;\n\n    acb->has_returned = false;\n\n\n\n    co = qemu_coroutine_create(co_entry, acb);\n\n    qemu_coroutine_enter(co);\n\n\n\n    acb->has_returned = true;\n\n    if (acb->rwco.ret != NOT_DONE) {\n\n        aio_bh_schedule_oneshot(blk_get_aio_context(blk),\n\n                                blk_aio_complete_bh, acb);\n\n    }\n\n\n\n    return &acb->common;\n\n}\n"},{"project":"qemu","commit_id":"b35278f75450e57c134a153e6da9744c1db8382f","target":1,"func":"static int qcow2_open(BlockDriverState *bs, int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int len, i, ret = 0;\n\n    QCowHeader header;\n\n    uint64_t ext_end;\n\n\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    be32_to_cpus(&header.magic);\n\n    be32_to_cpus(&header.version);\n\n    be64_to_cpus(&header.backing_file_offset);\n\n    be32_to_cpus(&header.backing_file_size);\n\n    be64_to_cpus(&header.size);\n\n    be32_to_cpus(&header.cluster_bits);\n\n    be32_to_cpus(&header.crypt_method);\n\n    be64_to_cpus(&header.l1_table_offset);\n\n    be32_to_cpus(&header.l1_size);\n\n    be64_to_cpus(&header.refcount_table_offset);\n\n    be32_to_cpus(&header.refcount_table_clusters);\n\n    be64_to_cpus(&header.snapshots_offset);\n\n    be32_to_cpus(&header.nb_snapshots);\n\n\n\n    if (header.magic != QCOW_MAGIC) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.version < 2 || header.version > 3) {\n\n        report_unsupported(bs, \"QCOW version %d\", header.version);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    s->qcow_version = header.version;\n\n\n\n    \/* Initialise version 3 header fields *\/\n\n    if (header.version == 2) {\n\n        header.incompatible_features    = 0;\n\n        header.compatible_features      = 0;\n\n        header.autoclear_features       = 0;\n\n        header.refcount_order           = 4;\n\n        header.header_length            = 72;\n\n    } else {\n\n        be64_to_cpus(&header.incompatible_features);\n\n        be64_to_cpus(&header.compatible_features);\n\n        be64_to_cpus(&header.autoclear_features);\n\n        be32_to_cpus(&header.refcount_order);\n\n        be32_to_cpus(&header.header_length);\n\n    }\n\n\n\n    if (header.header_length > sizeof(header)) {\n\n        s->unknown_header_fields_size = header.header_length - sizeof(header);\n\n        s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);\n\n        ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,\n\n                         s->unknown_header_fields_size);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    if (header.backing_file_offset) {\n\n        ext_end = header.backing_file_offset;\n\n    } else {\n\n        ext_end = 1 << header.cluster_bits;\n\n    }\n\n\n\n    \/* Handle feature bits *\/\n\n    s->incompatible_features    = header.incompatible_features;\n\n    s->compatible_features      = header.compatible_features;\n\n    s->autoclear_features       = header.autoclear_features;\n\n\n\n    if (s->incompatible_features != 0) {\n\n        void *feature_table = NULL;\n\n        qcow2_read_extensions(bs, header.header_length, ext_end,\n\n                              &feature_table);\n\n        report_unsupported_feature(bs, feature_table,\n\n                                   s->incompatible_features);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    \/* Check support for various header values *\/\n\n    if (header.refcount_order != 4) {\n\n        report_unsupported(bs, \"%d bit reference counts\",\n\n                           1 << header.refcount_order);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    if (header.cluster_bits < MIN_CLUSTER_BITS ||\n\n        header.cluster_bits > MAX_CLUSTER_BITS) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->crypt_method_header = header.crypt_method;\n\n    if (s->crypt_method_header) {\n\n        bs->encrypted = 1;\n\n    }\n\n    s->cluster_bits = header.cluster_bits;\n\n    s->cluster_size = 1 << s->cluster_bits;\n\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    s->l2_bits = s->cluster_bits - 3; \/* L2 is always one cluster *\/\n\n    s->l2_size = 1 << s->l2_bits;\n\n    bs->total_sectors = header.size \/ 512;\n\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n    s->refcount_table_offset = header.refcount_table_offset;\n\n    s->refcount_table_size =\n\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n\n\n    s->snapshots_offset = header.snapshots_offset;\n\n    s->nb_snapshots = header.nb_snapshots;\n\n\n\n    \/* read the level 1 table *\/\n\n    s->l1_size = header.l1_size;\n\n    s->l1_vm_state_index = size_to_l1(s, header.size);\n\n    \/* the L1 table must contain at least enough entries to put\n\n       header.size bytes *\/\n\n    if (s->l1_size < s->l1_vm_state_index) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    s->l1_table_offset = header.l1_table_offset;\n\n    if (s->l1_size > 0) {\n\n        s->l1_table = g_malloc0(\n\n            align_offset(s->l1_size * sizeof(uint64_t), 512));\n\n        ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n\n                         s->l1_size * sizeof(uint64_t));\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        for(i = 0;i < s->l1_size; i++) {\n\n            be64_to_cpus(&s->l1_table[i]);\n\n        }\n\n    }\n\n\n\n    \/* alloc L2 table\/refcount block cache *\/\n\n    s->l2_table_cache = qcow2_cache_create(bs, L2_CACHE_SIZE);\n\n    s->refcount_block_cache = qcow2_cache_create(bs, REFCOUNT_CACHE_SIZE);\n\n\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n\n    \/* one more sector for decompressed data alignment *\/\n\n    s->cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size\n\n                                  + 512);\n\n    s->cluster_cache_offset = -1;\n\n    s->flags = flags;\n\n\n\n    ret = qcow2_refcount_init(bs);\n\n    if (ret != 0) {\n\n        goto fail;\n\n    }\n\n\n\n    QLIST_INIT(&s->cluster_allocs);\n\n\n\n    \/* read qcow2 extensions *\/\n\n    if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL)) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    \/* read the backing file name *\/\n\n    if (header.backing_file_offset != 0) {\n\n        len = header.backing_file_size;\n\n        if (len > 1023) {\n\n            len = 1023;\n\n        }\n\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n\n                         bs->backing_file, len);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        bs->backing_file[len] = '\\0';\n\n    }\n\n\n\n    ret = qcow2_read_snapshots(bs);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    \/* Clear unknown autoclear feature bits *\/\n\n    if (!bs->read_only && s->autoclear_features != 0) {\n\n        s->autoclear_features = 0;\n\n        ret = qcow2_update_header(bs);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    \/* Initialise locks *\/\n\n    qemu_co_mutex_init(&s->lock);\n\n\n\n#ifdef DEBUG_ALLOC\n\n    {\n\n        BdrvCheckResult result = {0};\n\n        qcow2_check_refcounts(bs, &result);\n\n    }\n\n#endif\n\n    return ret;\n\n\n\n fail:\n\n    g_free(s->unknown_header_fields);\n\n    cleanup_unknown_header_ext(bs);\n\n    qcow2_free_snapshots(bs);\n\n    qcow2_refcount_close(bs);\n\n    g_free(s->l1_table);\n\n    if (s->l2_table_cache) {\n\n        qcow2_cache_destroy(bs, s->l2_table_cache);\n\n    }\n\n    g_free(s->cluster_cache);\n\n    qemu_vfree(s->cluster_data);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"6f321e93abb27b4e7ceb228b4204aa304e95daad","target":1,"func":"static void qed_aio_write_alloc(QEDAIOCB *acb, size_t len)\n\n{\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n\n\n    \/* Freeze this request if another allocating write is in progress *\/\n\n    if (acb != QSIMPLEQ_FIRST(&s->allocating_write_reqs)) {\n\n        QSIMPLEQ_INSERT_TAIL(&s->allocating_write_reqs, acb, next);\n\n    }\n\n    if (acb != QSIMPLEQ_FIRST(&s->allocating_write_reqs)) {\n\n        return; \/* wait for existing request to finish *\/\n\n    }\n\n\n\n    acb->cur_nclusters = qed_bytes_to_clusters(s,\n\n            qed_offset_into_cluster(s, acb->cur_pos) + len);\n\n    acb->cur_cluster = qed_alloc_clusters(s, acb->cur_nclusters);\n\n    qemu_iovec_copy(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    if (qed_should_set_need_check(s)) {\n\n        s->header.features |= QED_F_NEED_CHECK;\n\n        qed_write_header(s, qed_aio_write_prefill, acb);\n\n    } else {\n\n        qed_aio_write_prefill(acb, 0);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"ac4b0d0c4feb291643c0e8a07a92e449e13881b5","target":0,"func":"static void bt_submit_hci(struct HCIInfo *info,\n\n                const uint8_t *data, int length)\n\n{\n\n    struct bt_hci_s *hci = hci_from_info(info);\n\n    uint16_t cmd;\n\n    int paramlen, i;\n\n\n\n    if (length < HCI_COMMAND_HDR_SIZE)\n\n        goto short_hci;\n\n\n\n    memcpy(&hci->last_cmd, data, 2);\n\n\n\n    cmd = (data[1] << 8) | data[0];\n\n    paramlen = data[2];\n\n    if (cmd_opcode_ogf(cmd) == 0 || cmd_opcode_ocf(cmd) == 0)\t\/* NOP *\/\n\n        return;\n\n\n\n    data += HCI_COMMAND_HDR_SIZE;\n\n    length -= HCI_COMMAND_HDR_SIZE;\n\n\n\n    if (paramlen > length)\n\n        return;\n\n\n\n#define PARAM(cmd, param)\t(((cmd##_cp *) data)->param)\n\n#define PARAM16(cmd, param)\tle16_to_cpup(&PARAM(cmd, param))\n\n#define PARAMHANDLE(cmd)\tHNDL(PARAM(cmd, handle))\n\n#define LENGTH_CHECK(cmd)\tif (length < sizeof(cmd##_cp)) goto short_hci\n\n    \/* Note: the supported commands bitmask in bt_hci_read_local_commands_rp\n\n     * needs to be updated every time a command is implemented here!  *\/\n\n    switch (cmd) {\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY):\n\n        LENGTH_CHECK(inquiry);\n\n\n\n        if (PARAM(inquiry, length) < 1) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 0;\n\n        hci->lm.responses_left = PARAM(inquiry, num_rsp) ?: INT_MAX;\n\n        hci->lm.responses = 0;\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY_CANCEL):\n\n        if (!hci->lm.inquire || hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_PERIODIC_INQUIRY):\n\n        LENGTH_CHECK(periodic_inquiry);\n\n\n\n        if (!(PARAM(periodic_inquiry, length) <\n\n                                PARAM16(periodic_inquiry, min_period) &&\n\n                                PARAM16(periodic_inquiry, min_period) <\n\n                                PARAM16(periodic_inquiry, max_period)) ||\n\n                        PARAM(periodic_inquiry, length) < 1 ||\n\n                        PARAM16(periodic_inquiry, min_period) < 2 ||\n\n                        PARAM16(periodic_inquiry, max_period) < 3) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 1;\n\n        hci->lm.responses_left = PARAM(periodic_inquiry, num_rsp);\n\n        hci->lm.responses = 0;\n\n        hci->lm.inquiry_period = PARAM16(periodic_inquiry, max_period);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(periodic_inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_EXIT_PERIODIC_INQUIRY):\n\n        if (!hci->lm.inquire || !hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        qemu_del_timer(hci->lm.inquiry_next);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN):\n\n        LENGTH_CHECK(create_conn);\n\n\n\n        if (hci->lm.connecting >= HCI_HANDLES_MAX) {\n\n            bt_hci_event_status(hci, HCI_REJECTED_LIMITED_RESOURCES);\n\n            break;\n\n        }\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n\n\n        if (bt_hci_connect(hci, &PARAM(create_conn, bdaddr)))\n\n            bt_hci_connection_reject_event(hci, &PARAM(create_conn, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_DISCONNECT):\n\n        LENGTH_CHECK(disconnect);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(disconnect))) {\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_disconnect(hci, PARAMHANDLE(disconnect),\n\n                        PARAM(disconnect, reason));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN_CANCEL):\n\n        LENGTH_CHECK(create_conn_cancel);\n\n\n\n        if (bt_hci_lmp_connection_ready(hci,\n\n                                &PARAM(create_conn_cancel, bdaddr))) {\n\n            for (i = 0; i < HCI_HANDLES_MAX; i ++)\n\n                if (bt_hci_role_master(hci, i) && hci->lm.handle[i].link &&\n\n                                !bacmp(&hci->lm.handle[i].link->slave->bd_addr,\n\n                                        &PARAM(create_conn_cancel, bdaddr)))\n\n                   break;\n\n\n\n            bt_hci_event_complete_conn_cancel(hci, i < HCI_HANDLES_MAX ?\n\n                            HCI_ACL_CONNECTION_EXISTS : HCI_NO_CONNECTION,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        } else\n\n            bt_hci_event_complete_conn_cancel(hci, HCI_SUCCESS,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_ACCEPT_CONN_REQ):\n\n        LENGTH_CHECK(accept_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(accept_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_accept(hci, hci->conn_req_host);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REJECT_CONN_REQ):\n\n        LENGTH_CHECK(reject_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(reject_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_reject(hci, hci->conn_req_host,\n\n                        PARAM(reject_conn_req, reason));\n\n        bt_hci_connection_reject_event(hci, &hci->conn_req_host->bd_addr);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_AUTH_REQUESTED):\n\n        LENGTH_CHECK(auth_requested);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(auth_requested)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_auth_complete(hci, PARAMHANDLE(auth_requested));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT):\n\n        LENGTH_CHECK(set_conn_encrypt);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(set_conn_encrypt)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_encrypt_change(hci,\n\n                            PARAMHANDLE(set_conn_encrypt),\n\n                            PARAM(set_conn_encrypt, encrypt));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ):\n\n        LENGTH_CHECK(remote_name_req);\n\n\n\n        if (bt_hci_name_req(hci, &PARAM(remote_name_req, bdaddr)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ_CANCEL):\n\n        LENGTH_CHECK(remote_name_req_cancel);\n\n\n\n        bt_hci_event_complete_name_cancel(hci,\n\n                        &PARAM(remote_name_req_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_FEATURES):\n\n        LENGTH_CHECK(read_remote_features);\n\n\n\n        if (bt_hci_features_req(hci, PARAMHANDLE(read_remote_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_EXT_FEATURES):\n\n        LENGTH_CHECK(read_remote_ext_features);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(read_remote_ext_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_read_remote_ext_features(hci,\n\n                            PARAMHANDLE(read_remote_ext_features));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_VERSION):\n\n        LENGTH_CHECK(read_remote_version);\n\n\n\n        if (bt_hci_version_req(hci, PARAMHANDLE(read_remote_version)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_CLOCK_OFFSET):\n\n        LENGTH_CHECK(read_clock_offset);\n\n\n\n        if (bt_hci_clkoffset_req(hci, PARAMHANDLE(read_clock_offset)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_LMP_HANDLE):\n\n        LENGTH_CHECK(read_lmp_handle);\n\n\n\n        \/* TODO: *\/\n\n        bt_hci_event_complete_lmp_handle(hci, PARAMHANDLE(read_lmp_handle));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_HOLD_MODE):\n\n        LENGTH_CHECK(hold_mode);\n\n\n\n        if (PARAM16(hold_mode, min_interval) >\n\n                        PARAM16(hold_mode, max_interval) ||\n\n                        PARAM16(hold_mode, min_interval) < 0x0002 ||\n\n                        PARAM16(hold_mode, max_interval) > 0xff00 ||\n\n                        (PARAM16(hold_mode, min_interval) & 1) ||\n\n                        (PARAM16(hold_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(hold_mode),\n\n                                PARAM16(hold_mode, max_interval),\n\n                                acl_hold))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_PARK_MODE):\n\n        LENGTH_CHECK(park_mode);\n\n\n\n        if (PARAM16(park_mode, min_interval) >\n\n                        PARAM16(park_mode, max_interval) ||\n\n                        PARAM16(park_mode, min_interval) < 0x000e ||\n\n                        (PARAM16(park_mode, min_interval) & 1) ||\n\n                        (PARAM16(park_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(park_mode),\n\n                                PARAM16(park_mode, max_interval),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_EXIT_PARK_MODE):\n\n        LENGTH_CHECK(exit_park_mode);\n\n\n\n        if (bt_hci_mode_cancel(hci, PARAMHANDLE(exit_park_mode),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_ROLE_DISCOVERY):\n\n        LENGTH_CHECK(role_discovery);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(role_discovery)))\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(role_discovery), 0);\n\n        else\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(role_discovery),\n\n                            bt_hci_role_master(hci,\n\n                                    PARAMHANDLE(role_discovery)));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_MASK):\n\n        LENGTH_CHECK(set_event_mask);\n\n\n\n        memcpy(hci->event_mask, PARAM(set_event_mask, mask), 8);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_RESET):\n\n        bt_hci_reset(hci);\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_FLT):\n\n        if (length >= 1 && PARAM(set_event_flt, flt_type) == FLT_CLEAR_ALL)\n\n            \/* No length check *\/;\n\n        else\n\n            LENGTH_CHECK(set_event_flt);\n\n\n\n        \/* Filters are not implemented *\/\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_FLUSH):\n\n        LENGTH_CHECK(flush);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(flush)))\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(flush));\n\n        else {\n\n            \/* TODO: ordering? *\/\n\n            bt_hci_event(hci, EVT_FLUSH_OCCURRED,\n\n                            &PARAM(flush, handle),\n\n                            EVT_FLUSH_OCCURRED_SIZE);\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(flush));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_CHANGE_LOCAL_NAME):\n\n        LENGTH_CHECK(change_local_name);\n\n\n\n        if (hci->device.lmp_name)\n\n            free((void *) hci->device.lmp_name);\n\n        hci->device.lmp_name = strndup(PARAM(change_local_name, name),\n\n                        sizeof(PARAM(change_local_name, name)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_LOCAL_NAME):\n\n        bt_hci_event_complete_read_local_name(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CONN_ACCEPT_TIMEOUT):\n\n        bt_hci_event_complete_read_conn_accept_timeout(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CONN_ACCEPT_TIMEOUT):\n\n        \/* TODO *\/\n\n        LENGTH_CHECK(write_conn_accept_timeout);\n\n\n\n        if (PARAM16(write_conn_accept_timeout, timeout) < 0x0001 ||\n\n                        PARAM16(write_conn_accept_timeout, timeout) > 0xb540) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->conn_accept_tout = PARAM16(write_conn_accept_timeout, timeout);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_SCAN_ENABLE):\n\n        bt_hci_event_complete_read_scan_enable(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_SCAN_ENABLE):\n\n        LENGTH_CHECK(write_scan_enable);\n\n\n\n        \/* TODO: check that the remaining bits are all 0 *\/\n\n        hci->device.inquiry_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_INQUIRY);\n\n        hci->device.page_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_PAGE);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CLASS_OF_DEV):\n\n        bt_hci_event_complete_read_local_class(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CLASS_OF_DEV):\n\n        LENGTH_CHECK(write_class_of_dev);\n\n\n\n        memcpy(hci->device.class, PARAM(write_class_of_dev, dev_class),\n\n                        sizeof(PARAM(write_class_of_dev, dev_class)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_VOICE_SETTING):\n\n        bt_hci_event_complete_voice_setting(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_VOICE_SETTING):\n\n        LENGTH_CHECK(write_voice_setting);\n\n\n\n        hci->voice_setting = PARAM(write_voice_setting, voice_setting);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_HOST_NUMBER_OF_COMPLETED_PACKETS):\n\n        if (length < data[0] * 2 + 1)\n\n            goto short_hci;\n\n\n\n        for (i = 0; i < data[0]; i ++)\n\n            if (bt_hci_handle_bad(hci,\n\n                                    data[i * 2 + 1] | (data[i * 2 + 2] << 8)))\n\n                bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_INQUIRY_MODE):\n\n        \/* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x40)\n\n         * else\n\n         *     goto unknown_command *\/\n\n        bt_hci_event_complete_read_inquiry_mode(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_INQUIRY_MODE):\n\n        \/* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x80)\n\n         * else\n\n         *     goto unknown_command *\/\n\n        LENGTH_CHECK(write_inquiry_mode);\n\n\n\n        if (PARAM(write_inquiry_mode, mode) > 0x01) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquiry_mode = PARAM(write_inquiry_mode, mode);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_VERSION):\n\n        bt_hci_read_local_version_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_COMMANDS):\n\n        bt_hci_read_local_commands_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_FEATURES):\n\n        bt_hci_read_local_features_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_EXT_FEATURES):\n\n        LENGTH_CHECK(read_local_ext_features);\n\n\n\n        bt_hci_read_local_ext_features_rp(hci,\n\n                        PARAM(read_local_ext_features, page_num));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BUFFER_SIZE):\n\n        bt_hci_read_buffer_size_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_COUNTRY_CODE):\n\n        bt_hci_read_country_code_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BD_ADDR):\n\n        bt_hci_read_bd_addr_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_STATUS_PARAM, OCF_READ_LINK_QUALITY):\n\n        LENGTH_CHECK(read_link_quality);\n\n\n\n        bt_hci_link_quality_rp(hci, PARAMHANDLE(read_link_quality));\n\n        break;\n\n\n\n    default:\n\n        bt_hci_event_status(hci, HCI_UNKNOWN_COMMAND);\n\n        break;\n\n\n\n    short_hci:\n\n        fprintf(stderr, \"%s: HCI packet too short (%iB)\\n\",\n\n                        __FUNCTION__, length);\n\n        bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"b1b1dad31f3a092e046b09795f4476705c4e564e","target":1,"func":"static int aio_write_f(int argc, char **argv)\n\n{\n\n    int nr_iov, c;\n\n    int pattern = 0xcd;\n\n    struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n\n    BlockDriverAIOCB *acb;\n\n\n\n    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            ctx->Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            ctx->qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n\n                return 0;\n\n            }\n\n            break;\n\n        default:\n\n\n            return command_usage(&aio_write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n\n        return command_usage(&aio_write_cmd);\n\n    }\n\n\n\n    ctx->offset = cvtnum(argv[optind]);\n\n    if (ctx->offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (ctx->offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               ctx->offset);\n\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    ctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, pattern);\n\n\n\n    gettimeofday(&ctx->t1, NULL);\n\n    acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n                          ctx->qiov.size >> 9, aio_write_done, ctx);\n\n    if (!acb) {\n\n        free(ctx->buf);\n\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}"},{"project":"qemu","commit_id":"afed5a5a7030a074a181d2a0ce8202de71a6ada4","target":1,"func":"CpuInfoList *qmp_query_cpus(Error **errp)\n\n{\n\n    MachineState *ms = MACHINE(qdev_get_machine());\n\n    MachineClass *mc = MACHINE_GET_CLASS(ms);\n\n    CpuInfoList *head = NULL, *cur_item = NULL;\n\n    CPUState *cpu;\n\n\n\n    CPU_FOREACH(cpu) {\n\n        CpuInfoList *info;\n\n#if defined(TARGET_I386)\n\n        X86CPU *x86_cpu = X86_CPU(cpu);\n\n        CPUX86State *env = &x86_cpu->env;\n\n#elif defined(TARGET_PPC)\n\n        PowerPCCPU *ppc_cpu = POWERPC_CPU(cpu);\n\n        CPUPPCState *env = &ppc_cpu->env;\n\n#elif defined(TARGET_SPARC)\n\n        SPARCCPU *sparc_cpu = SPARC_CPU(cpu);\n\n        CPUSPARCState *env = &sparc_cpu->env;\n\n#elif defined(TARGET_MIPS)\n\n        MIPSCPU *mips_cpu = MIPS_CPU(cpu);\n\n        CPUMIPSState *env = &mips_cpu->env;\n\n#elif defined(TARGET_TRICORE)\n\n        TriCoreCPU *tricore_cpu = TRICORE_CPU(cpu);\n\n        CPUTriCoreState *env = &tricore_cpu->env;\n\n#endif\n\n\n\n        cpu_synchronize_state(cpu);\n\n\n\n        info = g_malloc0(sizeof(*info));\n\n        info->value = g_malloc0(sizeof(*info->value));\n\n        info->value->CPU = cpu->cpu_index;\n\n        info->value->current = (cpu == first_cpu);\n\n        info->value->halted = cpu->halted;\n\n        info->value->qom_path = object_get_canonical_path(OBJECT(cpu));\n\n        info->value->thread_id = cpu->thread_id;\n\n#if defined(TARGET_I386)\n\n        info->value->arch = CPU_INFO_ARCH_X86;\n\n        info->value->u.x86.pc = env->eip + env->segs[R_CS].base;\n\n#elif defined(TARGET_PPC)\n\n        info->value->arch = CPU_INFO_ARCH_PPC;\n\n        info->value->u.ppc.nip = env->nip;\n\n#elif defined(TARGET_SPARC)\n\n        info->value->arch = CPU_INFO_ARCH_SPARC;\n\n        info->value->u.q_sparc.pc = env->pc;\n\n        info->value->u.q_sparc.npc = env->npc;\n\n#elif defined(TARGET_MIPS)\n\n        info->value->arch = CPU_INFO_ARCH_MIPS;\n\n        info->value->u.q_mips.PC = env->active_tc.PC;\n\n#elif defined(TARGET_TRICORE)\n\n        info->value->arch = CPU_INFO_ARCH_TRICORE;\n\n        info->value->u.tricore.PC = env->PC;\n\n#else\n\n        info->value->arch = CPU_INFO_ARCH_OTHER;\n\n#endif\n\n\n\n\n\n\n\n\n\n\n        \/* XXX: waiting for the qapi to support GSList *\/\n\n        if (!cur_item) {\n\n            head = cur_item = info;\n\n        } else {\n\n            cur_item->next = info;\n\n            cur_item = info;\n\n\n\n\n\n    return head;\n"},{"project":"qemu","commit_id":"a35faa94c8e8d851a1d07e17c98f4ab2202b8a38","target":0,"func":"static int pl061_init(SysBusDevice *dev, const unsigned char *id)\n\n{\n\n    int iomemtype;\n\n    pl061_state *s = FROM_SYSBUS(pl061_state, dev);\n\n    s->id = id;\n\n    iomemtype = cpu_register_io_memory(pl061_readfn,\n\n                                       pl061_writefn, s,\n\n                                       DEVICE_NATIVE_ENDIAN);\n\n    sysbus_init_mmio(dev, 0x1000, iomemtype);\n\n    sysbus_init_irq(dev, &s->irq);\n\n    qdev_init_gpio_in(&dev->qdev, pl061_set_irq, 8);\n\n    qdev_init_gpio_out(&dev->qdev, s->out, 8);\n\n    pl061_reset(s);\n\n    register_savevm(&dev->qdev, \"pl061_gpio\", -1, 1, pl061_save, pl061_load, s);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"e01b444523e2b0c663b42b3e8f44ef48a6153051","target":0,"func":"static int hash32_bat_601_prot(CPUPPCState *env,\n\n                               target_ulong batu, target_ulong batl)\n\n{\n\n    int key, pp;\n\n\n\n    pp = batu & BATU32_601_PP;\n\n    if (msr_pr == 0) {\n\n        key = !!(batu & BATU32_601_KS);\n\n    } else {\n\n        key = !!(batu & BATU32_601_KP);\n\n    }\n\n    return ppc_hash32_pp_check(key, pp, 0);\n\n}\n"},{"project":"qemu","commit_id":"61007b316cd71ee7333ff7a0a749a8949527575f","target":0,"func":"int bdrv_aio_multiwrite(BlockDriverState *bs, BlockRequest *reqs, int num_reqs)\n\n{\n\n    MultiwriteCB *mcb;\n\n    int i;\n\n\n\n    \/* don't submit writes if we don't have a medium *\/\n\n    if (bs->drv == NULL) {\n\n        for (i = 0; i < num_reqs; i++) {\n\n            reqs[i].error = -ENOMEDIUM;\n\n        }\n\n        return -1;\n\n    }\n\n\n\n    if (num_reqs == 0) {\n\n        return 0;\n\n    }\n\n\n\n    \/\/ Create MultiwriteCB structure\n\n    mcb = g_malloc0(sizeof(*mcb) + num_reqs * sizeof(*mcb->callbacks));\n\n    mcb->num_requests = 0;\n\n    mcb->num_callbacks = num_reqs;\n\n\n\n    for (i = 0; i < num_reqs; i++) {\n\n        mcb->callbacks[i].cb = reqs[i].cb;\n\n        mcb->callbacks[i].opaque = reqs[i].opaque;\n\n    }\n\n\n\n    \/\/ Check for mergable requests\n\n    num_reqs = multiwrite_merge(bs, reqs, num_reqs, mcb);\n\n\n\n    trace_bdrv_aio_multiwrite(mcb, mcb->num_callbacks, num_reqs);\n\n\n\n    \/* Run the aio requests. *\/\n\n    mcb->num_requests = num_reqs;\n\n    for (i = 0; i < num_reqs; i++) {\n\n        bdrv_co_aio_rw_vector(bs, reqs[i].sector, reqs[i].qiov,\n\n                              reqs[i].nb_sectors, reqs[i].flags,\n\n                              multiwrite_cb, mcb,\n\n                              true);\n\n    }\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"cdd346371e09709be8e46398bb097dc690a746f2","target":1,"func":"static uint16_t nvme_set_feature(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)\n\n{\n\n    uint32_t dw10 = le32_to_cpu(cmd->cdw10);\n\n    uint32_t dw11 = le32_to_cpu(cmd->cdw11);\n\n\n\n    switch (dw10) {\n\n    case NVME_VOLATILE_WRITE_CACHE:\n\n        blk_set_enable_write_cache(n->conf.blk, dw11 & 1);\n\n        break;\n\n    case NVME_NUMBER_OF_QUEUES:\n\n        req->cqe.result =\n\n            cpu_to_le32((n->num_queues - 1) | ((n->num_queues - 1) << 16));\n\n        break;\n\n    default:\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    return NVME_SUCCESS;\n\n}\n"},{"project":"qemu","commit_id":"e4533c7a8cdcc79ccdf695f0aaa2e23a5b926ed0","target":0,"func":"int cpu_x86_signal_handler(int host_signum, struct siginfo *info, \n\n                           void *puc)\n\n{\n\n    uint32_t *regs = (uint32_t *)(info + 1);\n\n    void *sigmask = (regs + 20);\n\n    unsigned long pc;\n\n    int is_write;\n\n    uint32_t insn;\n\n    \n\n    \/* XXX: is there a standard glibc define ? *\/\n\n    pc = regs[1];\n\n    \/* XXX: need kernel patch to get write flag faster *\/\n\n    is_write = 0;\n\n    insn = *(uint32_t *)pc;\n\n    if ((insn >> 30) == 3) {\n\n      switch((insn >> 19) & 0x3f) {\n\n      case 0x05: \/\/ stb\n\n      case 0x06: \/\/ sth\n\n      case 0x04: \/\/ st\n\n      case 0x07: \/\/ std\n\n      case 0x24: \/\/ stf\n\n      case 0x27: \/\/ stdf\n\n      case 0x25: \/\/ stfsr\n\n\tis_write = 1;\n\n\tbreak;\n\n      }\n\n    }\n\n    return handle_cpu_signal(pc, (unsigned long)info->si_addr, \n\n                             is_write, sigmask);\n\n}\n"},{"project":"qemu","commit_id":"1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3","target":0,"func":"static int do_sigframe_return_v2(CPUARMState *env, target_ulong frame_addr,\n\n                                 struct target_ucontext_v2 *uc)\n\n{\n\n    sigset_t host_set;\n\n    abi_ulong *regspace;\n\n\n\n    target_to_host_sigset(&host_set, &uc->tuc_sigmask);\n\n    sigprocmask(SIG_SETMASK, &host_set, NULL);\n\n\n\n    if (restore_sigcontext(env, &uc->tuc_mcontext))\n\n        return 1;\n\n\n\n    \/* Restore coprocessor signal frame *\/\n\n    regspace = uc->tuc_regspace;\n\n    if (arm_feature(env, ARM_FEATURE_VFP)) {\n\n        regspace = restore_sigframe_v2_vfp(env, regspace);\n\n        if (!regspace) {\n\n            return 1;\n\n        }\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_IWMMXT)) {\n\n        regspace = restore_sigframe_v2_iwmmxt(env, regspace);\n\n        if (!regspace) {\n\n            return 1;\n\n        }\n\n    }\n\n\n\n    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)\n\n        return 1;\n\n\n\n#if 0\n\n    \/* Send SIGTRAP if we're single-stepping *\/\n\n    if (ptrace_cancel_bpt(current))\n\n            send_sig(SIGTRAP, current, 1);\n\n#endif\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"2d9907a3332888e43bc73fe9b98a32f8de662526","target":0,"func":"void pmac_format_nvram_partition (MacIONVRAMState *nvr, int len)\n\n{\n\n    unsigned int i;\n\n    uint32_t start = 0, end;\n\n    struct OpenBIOS_nvpart_v1 *part_header;\n\n\n\n    \/\/ OpenBIOS nvram variables\n\n    \/\/ Variable partition\n\n    part_header = (struct OpenBIOS_nvpart_v1 *)nvr->data;\n\n    part_header->signature = OPENBIOS_PART_SYSTEM;\n\n    pstrcpy(part_header->name, sizeof(part_header->name), \"system\");\n\n\n\n    end = start + sizeof(struct OpenBIOS_nvpart_v1);\n\n    for (i = 0; i < nb_prom_envs; i++)\n\n        end = OpenBIOS_set_var(nvr->data, end, prom_envs[i]);\n\n\n\n    \/\/ End marker\n\n    nvr->data[end++] = '\\0';\n\n\n\n    end = start + ((end - start + 15) & ~15);\n\n    \/* XXX: OpenBIOS is not able to grow up a partition. Leave some space for\n\n       new variables. *\/\n\n    if (end < DEF_SYSTEM_SIZE)\n\n        end = DEF_SYSTEM_SIZE;\n\n    OpenBIOS_finish_partition(part_header, end - start);\n\n\n\n    \/\/ free partition\n\n    start = end;\n\n    part_header = (struct OpenBIOS_nvpart_v1 *)&nvr->data[start];\n\n    part_header->signature = OPENBIOS_PART_FREE;\n\n    pstrcpy(part_header->name, sizeof(part_header->name), \"free\");\n\n\n\n    end = len;\n\n    OpenBIOS_finish_partition(part_header, end - start);\n\n}\n"},{"project":"qemu","commit_id":"60fe637bf0e4d7989e21e50f52526444765c63b4","target":1,"func":"static ssize_t qsb_grow(QEMUSizedBuffer *qsb, size_t new_size)\n\n{\n\n    size_t needed_chunks, i;\n\n\n\n    if (qsb->size < new_size) {\n\n        struct iovec *new_iov;\n\n        size_t size_diff = new_size - qsb->size;\n\n        size_t chunk_size = (size_diff > QSB_MAX_CHUNK_SIZE)\n\n                             ? QSB_MAX_CHUNK_SIZE : QSB_CHUNK_SIZE;\n\n\n\n        needed_chunks = DIV_ROUND_UP(size_diff, chunk_size);\n\n\n\n        new_iov = g_try_new(struct iovec, qsb->n_iov + needed_chunks);\n\n        if (new_iov == NULL) {\n\n            return -ENOMEM;\n\n        }\n\n\n\n        \/* Allocate new chunks as needed into new_iov *\/\n\n        for (i = qsb->n_iov; i < qsb->n_iov + needed_chunks; i++) {\n\n            new_iov[i].iov_base = g_try_malloc0(chunk_size);\n\n            new_iov[i].iov_len = chunk_size;\n\n            if (!new_iov[i].iov_base) {\n\n                size_t j;\n\n\n\n                \/* Free previously allocated new chunks *\/\n\n                for (j = qsb->n_iov; j < i; j++) {\n\n                    g_free(new_iov[j].iov_base);\n\n                }\n\n                g_free(new_iov);\n\n\n\n                return -ENOMEM;\n\n            }\n\n        }\n\n\n\n        \/*\n\n         * Now we can't get any allocation errors, copy over to new iov\n\n         * and switch.\n\n         *\/\n\n        for (i = 0; i < qsb->n_iov; i++) {\n\n            new_iov[i] = qsb->iov[i];\n\n        }\n\n\n\n        qsb->n_iov += needed_chunks;\n\n        g_free(qsb->iov);\n\n        qsb->iov = new_iov;\n\n        qsb->size += (needed_chunks * chunk_size);\n\n    }\n\n\n\n    return qsb->size;\n\n}\n"},{"project":"qemu","commit_id":"a46667ea29218565473e430ceae62e2838f6ce3f","target":1,"func":"static int net_socket_listen_init(VLANState *vlan,\n\n                                  const char *model,\n\n                                  const char *name,\n\n                                  const char *host_str)\n\n{\n\n    NetSocketListenState *s;\n\n    int fd, val, ret;\n\n    struct sockaddr_in saddr;\n\n\n\n    if (parse_host_port(&saddr, host_str) < 0)\n\n        return -1;\n\n\n\n    s = g_malloc0(sizeof(NetSocketListenState));\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        g_free(s);\n\n        return -1;\n\n    }\n\n    socket_set_nonblock(fd);\n\n\n\n    \/* allow fast reuse *\/\n\n    val = 1;\n\n    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (const char *)&val, sizeof(val));\n\n\n\n    ret = bind(fd, (struct sockaddr *)&saddr, sizeof(saddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n        g_free(s);\n\n\n        return -1;\n\n    }\n\n    ret = listen(fd, 0);\n\n    if (ret < 0) {\n\n        perror(\"listen\");\n\n        g_free(s);\n\n\n        return -1;\n\n    }\n\n    s->vlan = vlan;\n\n    s->model = g_strdup(model);\n\n    s->name = name ? g_strdup(name) : NULL;\n\n    s->fd = fd;\n\n    qemu_set_fd_handler(fd, net_socket_accept, NULL, s);\n\n    return 0;\n\n}"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void hb_regs_write(void *opaque, target_phys_addr_t offset,\n\n                          uint64_t value, unsigned size)\n\n{\n\n    uint32_t *regs = opaque;\n\n\n\n    if (offset == 0xf00) {\n\n        if (value == 1 || value == 2) {\n\n            qemu_system_reset_request();\n\n        } else if (value == 3) {\n\n            qemu_system_shutdown_request();\n\n        }\n\n    }\n\n\n\n    regs[offset\/4] = value;\n\n}\n"},{"project":"qemu","commit_id":"259342d34dbdfb304374f569feec26317edd97c9","target":1,"func":"static AHCIQState *ahci_boot(void)\n\n{\n\n    AHCIQState *s;\n\n    const char *cli;\n\n\n\n    s = g_malloc0(sizeof(AHCIQState));\n\n\n\n    cli = \"-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s\"\n\n        \",format=raw\"\n\n        \" -M q35 \"\n\n        \"-device ide-hd,drive=drive0 \"\n\n        \"-global ide-hd.ver=%s\";\n\n    s->parent = qtest_pc_boot(cli, tmp_path, \"testdisk\", \"version\");\n\n\n\n\n    \/* Verify that we have an AHCI device present. *\/\n\n    s->dev = get_ahci_device(&s->fingerprint);\n\n\n\n    return s;\n\n}"},{"project":"qemu","commit_id":"cf29a570a7aa7abab66bf256fdf9540873590811","target":1,"func":"static void quorum_aio_cb(void *opaque, int ret)\n\n{\n\n    QuorumChildRequest *sacb = opaque;\n\n    QuorumAIOCB *acb = sacb->parent;\n\n    BDRVQuorumState *s = acb->common.bs->opaque;\n\n\n\n    sacb->ret = ret;\n\n    acb->count++;\n\n    if (ret == 0) {\n\n        acb->success_count++;\n\n    } else {\n\n        quorum_report_bad(acb, sacb->aiocb->bs->node_name, ret);\n\n    }\n\n    assert(acb->count <= s->num_children);\n\n    assert(acb->success_count <= s->num_children);\n\n    if (acb->count < s->num_children) {\n\n        return;\n\n    }\n\n\n\n    \/* Do the vote on read *\/\n\n    if (acb->is_read) {\n\n        quorum_vote(acb);\n\n    } else {\n\n        quorum_has_too_much_io_failed(acb);\n\n    }\n\n\n\n    quorum_aio_finalize(acb);\n\n}\n"},{"project":"qemu","commit_id":"f21126df5f81797486eb3bd628da8e2ad5fae12e","target":1,"func":"static void pl181_fifo_run(pl181_state *s)\n\n{\n\n    uint32_t bits;\n\n    uint32_t value;\n\n    int n;\n\n    int is_read;\n\n\n\n    is_read = (s->datactrl & PL181_DATA_DIRECTION) != 0;\n\n    if (s->datacnt != 0 && (!is_read || sd_data_ready(s->card))\n\n            && !s->linux_hack) {\n\n        if (is_read) {\n\n            n = 0;\n\n            value = 0;\n\n            while (s->datacnt && s->fifo_len < PL181_FIFO_LEN) {\n\n                value |= (uint32_t)sd_read_data(s->card) << (n * 8);\n\n                s->datacnt--;\n\n                n++;\n\n                if (n == 4) {\n\n                    pl181_fifo_push(s, value);\n\n                    n = 0;\n\n                    value = 0;\n\n                }\n\n            }\n\n            if (n != 0) {\n\n                pl181_fifo_push(s, value);\n\n            }\n\n        } else { \/* write *\/\n\n            n = 0;\n\n            while (s->datacnt > 0 && (s->fifo_len > 0 || n > 0)) {\n\n                if (n == 0) {\n\n                    value = pl181_fifo_pop(s);\n\n                    n = 4;\n\n                }\n\n                n--;\n\n                s->datacnt--;\n\n                sd_write_data(s->card, value & 0xff);\n\n                value >>= 8;\n\n            }\n\n        }\n\n    }\n\n    s->status &= ~(PL181_STATUS_RX_FIFO | PL181_STATUS_TX_FIFO);\n\n    if (s->datacnt == 0) {\n\n        s->status |= PL181_STATUS_DATAEND;\n\n        \/* HACK: *\/\n\n        s->status |= PL181_STATUS_DATABLOCKEND;\n\n        DPRINTF(\"Transfer Complete\\n\");\n\n    }\n\n    if (s->datacnt == 0 && s->fifo_len == 0) {\n\n        s->datactrl &= ~PL181_DATA_ENABLE;\n\n        DPRINTF(\"Data engine idle\\n\");\n\n    } else {\n\n        \/* Update FIFO bits.  *\/\n\n        bits = PL181_STATUS_TXACTIVE | PL181_STATUS_RXACTIVE;\n\n        if (s->fifo_len == 0) {\n\n            bits |= PL181_STATUS_TXFIFOEMPTY;\n\n            bits |= PL181_STATUS_RXFIFOEMPTY;\n\n        } else {\n\n            bits |= PL181_STATUS_TXDATAAVLBL;\n\n            bits |= PL181_STATUS_RXDATAAVLBL;\n\n        }\n\n        if (s->fifo_len == 16) {\n\n            bits |= PL181_STATUS_TXFIFOFULL;\n\n            bits |= PL181_STATUS_RXFIFOFULL;\n\n        }\n\n        if (s->fifo_len <= 8) {\n\n            bits |= PL181_STATUS_TXFIFOHALFEMPTY;\n\n        }\n\n        if (s->fifo_len >= 8) {\n\n            bits |= PL181_STATUS_RXFIFOHALFFULL;\n\n        }\n\n        if (s->datactrl & PL181_DATA_DIRECTION) {\n\n            bits &= PL181_STATUS_RX_FIFO;\n\n        } else {\n\n            bits &= PL181_STATUS_TX_FIFO;\n\n        }\n\n        s->status |= bits;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"364031f17932814484657e5551ba12957d993d7e","target":0,"func":"static int v9fs_synth_truncate(FsContext *ctx, V9fsPath *path, off_t offset)\n\n{\n\n    errno = ENOSYS;\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"08844473820c93541fc47bdfeae0f2cc88cfab59","target":0,"func":"void bdrv_setup_io_funcs(BlockDriver *bdrv)\n\n{\n\n    \/* Block drivers without coroutine functions need emulation *\/\n\n    if (!bdrv->bdrv_co_readv) {\n\n        bdrv->bdrv_co_readv = bdrv_co_readv_em;\n\n        bdrv->bdrv_co_writev = bdrv_co_writev_em;\n\n\n\n        \/* bdrv_co_readv_em()\/brdv_co_writev_em() work in terms of aio, so if\n\n         * the block driver lacks aio we need to emulate that too.\n\n         *\/\n\n        if (!bdrv->bdrv_aio_readv) {\n\n            \/* add AIO emulation layer *\/\n\n            bdrv->bdrv_aio_readv = bdrv_aio_readv_em;\n\n            bdrv->bdrv_aio_writev = bdrv_aio_writev_em;\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static uint32_t  ahci_port_read(AHCIState *s, int port, int offset)\n\n{\n\n    uint32_t val;\n\n    AHCIPortRegs *pr;\n\n    pr = &s->dev[port].port_regs;\n\n\n\n    switch (offset) {\n\n    case PORT_LST_ADDR:\n\n        val = pr->lst_addr;\n\n        break;\n\n    case PORT_LST_ADDR_HI:\n\n        val = pr->lst_addr_hi;\n\n        break;\n\n    case PORT_FIS_ADDR:\n\n        val = pr->fis_addr;\n\n        break;\n\n    case PORT_FIS_ADDR_HI:\n\n        val = pr->fis_addr_hi;\n\n        break;\n\n    case PORT_IRQ_STAT:\n\n        val = pr->irq_stat;\n\n        break;\n\n    case PORT_IRQ_MASK:\n\n        val = pr->irq_mask;\n\n        break;\n\n    case PORT_CMD:\n\n        val = pr->cmd;\n\n        break;\n\n    case PORT_TFDATA:\n\n        val = pr->tfdata;\n\n        break;\n\n    case PORT_SIG:\n\n        val = pr->sig;\n\n        break;\n\n    case PORT_SCR_STAT:\n\n        if (s->dev[port].port.ifs[0].bs) {\n\n            val = SATA_SCR_SSTATUS_DET_DEV_PRESENT_PHY_UP |\n\n                  SATA_SCR_SSTATUS_SPD_GEN1 | SATA_SCR_SSTATUS_IPM_ACTIVE;\n\n        } else {\n\n            val = SATA_SCR_SSTATUS_DET_NODEV;\n\n        }\n\n        break;\n\n    case PORT_SCR_CTL:\n\n        val = pr->scr_ctl;\n\n        break;\n\n    case PORT_SCR_ERR:\n\n        val = pr->scr_err;\n\n        break;\n\n    case PORT_SCR_ACT:\n\n        pr->scr_act &= ~s->dev[port].finished;\n\n        s->dev[port].finished = 0;\n\n        val = pr->scr_act;\n\n        break;\n\n    case PORT_CMD_ISSUE:\n\n        val = pr->cmd_issue;\n\n        break;\n\n    case PORT_RESERVED:\n\n    default:\n\n        val = 0;\n\n    }\n\n    DPRINTF(port, \"offset: 0x%x val: 0x%x\\n\", offset, val);\n\n    return val;\n\n\n\n}\n"},{"project":"qemu","commit_id":"21a0b6ed1dd9f1d8e3d953954847776c8697bd99","target":0,"func":"target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)\n\n{\n\n    uint32_t tlbncfg;\n\n    int tlbn = booke206_tlbm_to_tlbn(env, tlb);\n\n    int tlbm_size;\n\n\n\n    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];\n\n\n\n    if (tlbncfg & TLBnCFG_AVAIL) {\n\n        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;\n\n    } else {\n\n        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;\n\n        tlbm_size <<= 1;\n\n    }\n\n\n\n    return 1024ULL << tlbm_size;\n\n}\n"},{"project":"qemu","commit_id":"6860710cc3864382a898c847d722f950b5e01a6e","target":1,"func":"static inline abi_long host_to_target_sockaddr(abi_ulong target_addr,\n\n                                               struct sockaddr *addr,\n\n                                               socklen_t len)\n\n{\n\n    struct target_sockaddr *target_saddr;\n\n\n\n    if (len == 0) {\n\n        return 0;\n\n    }\n\n\n\n\n    target_saddr = lock_user(VERIFY_WRITE, target_addr, len, 0);\n\n    if (!target_saddr)\n\n        return -TARGET_EFAULT;\n\n    memcpy(target_saddr, addr, len);\n\n    if (len >= offsetof(struct target_sockaddr, sa_family) +\n\n        sizeof(target_saddr->sa_family)) {\n\n        target_saddr->sa_family = tswap16(addr->sa_family);\n\n    }\n\n    if (addr->sa_family == AF_NETLINK && len >= sizeof(struct sockaddr_nl)) {\n\n        struct sockaddr_nl *target_nl = (struct sockaddr_nl *)target_saddr;\n\n        target_nl->nl_pid = tswap32(target_nl->nl_pid);\n\n        target_nl->nl_groups = tswap32(target_nl->nl_groups);\n\n    } else if (addr->sa_family == AF_PACKET) {\n\n        struct sockaddr_ll *target_ll = (struct sockaddr_ll *)target_saddr;\n\n        target_ll->sll_ifindex = tswap32(target_ll->sll_ifindex);\n\n        target_ll->sll_hatype = tswap16(target_ll->sll_hatype);\n\n    } else if (addr->sa_family == AF_INET6 &&\n\n               len >= sizeof(struct target_sockaddr_in6)) {\n\n        struct target_sockaddr_in6 *target_in6 =\n\n               (struct target_sockaddr_in6 *)target_saddr;\n\n        target_in6->sin6_scope_id = tswap16(target_in6->sin6_scope_id);\n\n    }\n\n    unlock_user(target_saddr, target_addr, len);\n\n\n\n    return 0;\n\n}"},{"project":"qemu","commit_id":"6d0ceb80ffe18ad4b28aab7356f440636c0be7be","target":1,"func":"static int coroutine_fn blkreplay_co_flush(BlockDriverState *bs)\n\n{\n\n    uint64_t reqid = request_id++;\n\n    int ret = bdrv_co_flush(bs->file->bs);\n\n    block_request_create(reqid, bs, qemu_coroutine_self());\n\n    qemu_coroutine_yield();\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"fdad35ef6c5839d50dfc14073364ac893afebc30","target":1,"func":"static int nbd_negotiate_options(NBDClient *client, uint16_t myflags,\n                                 Error **errp)\n{\n    uint32_t flags;\n    bool fixedNewstyle = false;\n    bool no_zeroes = false;\n    \/* Client sends:\n        [ 0 ..   3]   client flags\n       Then we loop until NBD_OPT_EXPORT_NAME or NBD_OPT_GO:\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n        [ 8 ..  11]   NBD option\n        [12 ..  15]   Data length\n        ...           Rest of request\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n        [ 8 ..  11]   Second NBD option\n        [12 ..  15]   Data length\n        ...           Rest of request\n    *\/\n    if (nbd_read(client->ioc, &flags, sizeof(flags), errp) < 0) {\n        error_prepend(errp, \"read failed: \");\n        return -EIO;\n    be32_to_cpus(&flags);\n    trace_nbd_negotiate_options_flags(flags);\n    if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) {\n        fixedNewstyle = true;\n        flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE;\n    if (flags & NBD_FLAG_C_NO_ZEROES) {\n        no_zeroes = true;\n        flags &= ~NBD_FLAG_C_NO_ZEROES;\n    if (flags != 0) {\n        error_setg(errp, \"Unknown client flags 0x%\" PRIx32 \" received\", flags);\n    while (1) {\n        int ret;\n        uint32_t option, length;\n        uint64_t magic;\n        if (nbd_read(client->ioc, &magic, sizeof(magic), errp) < 0) {\n            error_prepend(errp, \"read failed: \");\n        magic = be64_to_cpu(magic);\n        trace_nbd_negotiate_options_check_magic(magic);\n        if (magic != NBD_OPTS_MAGIC) {\n            error_setg(errp, \"Bad magic received\");\n        if (nbd_read(client->ioc, &option,\n                     sizeof(option), errp) < 0) {\n            error_prepend(errp, \"read failed: \");\n        option = be32_to_cpu(option);\n        if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) {\n            error_prepend(errp, \"read failed: \");\n        length = be32_to_cpu(length);\n        trace_nbd_negotiate_options_check_option(option,\n                                                 nbd_opt_lookup(option));\n        if (client->tlscreds &&\n            client->ioc == (QIOChannel *)client->sioc) {\n            QIOChannel *tioc;\n            if (!fixedNewstyle) {\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n            switch (option) {\n            case NBD_OPT_STARTTLS:\n                if (length) {\n                    \/* Unconditionally drop the connection if the client\n                     * can't start a TLS negotiation correctly *\/\n                    return nbd_reject_length(client, length, option, true,\n                                             errp);\n                tioc = nbd_negotiate_handle_starttls(client, errp);\n                if (!tioc) {\n                    return -EIO;\n                ret = 0;\n                object_unref(OBJECT(client->ioc));\n                client->ioc = QIO_CHANNEL(tioc);\n                break;\n            case NBD_OPT_EXPORT_NAME:\n                \/* No way to return an error to client, so drop connection *\/\n                error_setg(errp, \"Option 0x%x not permitted before TLS\",\n                           option);\n            default:\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n                    return -EIO;\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n                                                 NBD_REP_ERR_TLS_REQD,\n                                                 option, errp,\n                                                 \"Option 0x%\" PRIx32\n                                                 \"not permitted before TLS\",\n                                                 option);\n                \/* Let the client keep trying, unless they asked to\n                 * quit. In this mode, we've already sent an error, so\n                 * we can't ack the abort.  *\/\n                if (option == NBD_OPT_ABORT) {\n                    return 1;\n                break;\n        } else if (fixedNewstyle) {\n            switch (option) {\n            case NBD_OPT_LIST:\n                if (length) {\n                    ret = nbd_reject_length(client, length, option, false,\n                                            errp);\n                } else {\n                    ret = nbd_negotiate_handle_list(client, errp);\n                break;\n            case NBD_OPT_ABORT:\n                \/* NBD spec says we must try to reply before\n                 * disconnecting, but that we must also tolerate\n                 * guests that don't wait for our reply. *\/\n                nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL);\n                return 1;\n            case NBD_OPT_EXPORT_NAME:\n                return nbd_negotiate_handle_export_name(client, length,\n                                                        myflags, no_zeroes,\n                                                        errp);\n            case NBD_OPT_INFO:\n            case NBD_OPT_GO:\n                ret = nbd_negotiate_handle_info(client, length, option,\n                                                myflags, errp);\n                if (ret == 1) {\n                    assert(option == NBD_OPT_GO);\n                    return 0;\n                break;\n            case NBD_OPT_STARTTLS:\n                if (length) {\n                    ret = nbd_reject_length(client, length, option, false,\n                                            errp);\n                } else if (client->tlscreds) {\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n                                                     NBD_REP_ERR_INVALID,\n                                                     option, errp,\n                                                     \"TLS already enabled\");\n                } else {\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n                                                     NBD_REP_ERR_POLICY,\n                                                     option, errp,\n                                                     \"TLS not configured\");\n                break;\n            case NBD_OPT_STRUCTURED_REPLY:\n                if (length) {\n                    ret = nbd_reject_length(client, length, option, false,\n                                            errp);\n                } else if (client->structured_reply) {\n                    ret = nbd_negotiate_send_rep_err(\n                        client->ioc, NBD_REP_ERR_INVALID, option, errp,\n                        \"structured reply already negotiated\");\n                } else {\n                    ret = nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK,\n                                                 option, errp);\n                    client->structured_reply = true;\n                    myflags |= NBD_FLAG_SEND_DF;\n                break;\n            default:\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n                    return -EIO;\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n                                                 NBD_REP_ERR_UNSUP,\n                                                 option, errp,\n                                                 \"Unsupported option 0x%\"\n                                                 PRIx32 \" (%s)\", option,\n                                                 nbd_opt_lookup(option));\n                break;\n        } else {\n            \/*\n             * If broken new-style we should drop the connection\n             * for anything except NBD_OPT_EXPORT_NAME\n             *\/\n            switch (option) {\n            case NBD_OPT_EXPORT_NAME:\n                return nbd_negotiate_handle_export_name(client, length,\n                                                        myflags, no_zeroes,\n                                                        errp);\n            default:\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32 \" (%s)\",\n                           option, nbd_opt_lookup(option));\n        if (ret < 0) {\n            return ret;"},{"project":"qemu","commit_id":"9e472e101f37233f4e32d181d2fee29014c1cf2f","target":1,"func":"int qemu_signalfd(const sigset_t *mask)\n\n{\n\n#if defined(CONFIG_signalfd)\n\n    int ret;\n\n\n\n    ret = syscall(SYS_signalfd, -1, mask, _NSIG \/ 8);\n\n    if (ret != -1)\n\n        return ret;\n\n#endif\n\n\n\n    return qemu_signalfd_compat(mask);\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    BlockConf *conf = &s->conf.conf;\n\n    struct virtio_blk_config blkcfg;\n\n    uint64_t capacity;\n\n    int blk_size = conf->logical_block_size;\n\n\n\n    bdrv_get_geometry(s->bs, &capacity);\n\n    memset(&blkcfg, 0, sizeof(blkcfg));\n\n    virtio_stq_p(vdev, &blkcfg.capacity, capacity);\n\n    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);\n\n    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);\n\n    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size \/ blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size \/ blk_size);\n\n    blkcfg.heads = conf->heads;\n\n    \/*\n\n     * We must ensure that the block device capacity is a multiple of\n\n     * the logical block size. If that is not the case, let's use\n\n     * sector_mask to adopt the geometry to have a correct picture.\n\n     * For those devices where the capacity is ok for the given geometry\n\n     * we don't touch the sector value of the geometry, since some devices\n\n     * (like s390 dasd) need a specific value. Here the capacity is already\n\n     * cyls*heads*secs*blk_size and the sector value is not block size\n\n     * divided by 512 - instead it is the amount of blk_size blocks\n\n     * per track (cylinder).\n\n     *\/\n\n    if (bdrv_getlength(s->bs) \/  conf->heads \/ conf->secs % blk_size) {\n\n        blkcfg.sectors = conf->secs & ~s->sector_mask;\n\n    } else {\n\n        blkcfg.sectors = conf->secs;\n\n    }\n\n    blkcfg.size_max = 0;\n\n    blkcfg.physical_block_exp = get_physical_block_exp(conf);\n\n    blkcfg.alignment_offset = 0;\n\n    blkcfg.wce = bdrv_enable_write_cache(s->bs);\n\n    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));\n\n}\n"},{"project":"qemu","commit_id":"698feb5e13a2d763369909ce33f2bd7a7c1c11c0","target":0,"func":"static void vfio_listener_region_add(MemoryListener *listener,\n\n                                     MemoryRegionSection *section)\n\n{\n\n    VFIOContainer *container = container_of(listener, VFIOContainer, listener);\n\n    hwaddr iova, end;\n\n    Int128 llend, llsize;\n\n    void *vaddr;\n\n    int ret;\n\n    VFIOHostDMAWindow *hostwin;\n\n    bool hostwin_found;\n\n\n\n    if (vfio_listener_skipped_section(section)) {\n\n        trace_vfio_listener_region_add_skip(\n\n                section->offset_within_address_space,\n\n                section->offset_within_address_space +\n\n                int128_get64(int128_sub(section->size, int128_one())));\n\n        return;\n\n    }\n\n\n\n    if (unlikely((section->offset_within_address_space & ~TARGET_PAGE_MASK) !=\n\n                 (section->offset_within_region & ~TARGET_PAGE_MASK))) {\n\n        error_report(\"%s received unaligned region\", __func__);\n\n        return;\n\n    }\n\n\n\n    iova = TARGET_PAGE_ALIGN(section->offset_within_address_space);\n\n    llend = int128_make64(section->offset_within_address_space);\n\n    llend = int128_add(llend, section->size);\n\n    llend = int128_and(llend, int128_exts64(TARGET_PAGE_MASK));\n\n\n\n    if (int128_ge(int128_make64(iova), llend)) {\n\n        return;\n\n    }\n\n    end = int128_get64(int128_sub(llend, int128_one()));\n\n\n\n    if (container->iommu_type == VFIO_SPAPR_TCE_v2_IOMMU) {\n\n        VFIOHostDMAWindow *hostwin;\n\n        hwaddr pgsize = 0;\n\n\n\n        \/* For now intersections are not allowed, we may relax this later *\/\n\n        QLIST_FOREACH(hostwin, &container->hostwin_list, hostwin_next) {\n\n            if (ranges_overlap(hostwin->min_iova,\n\n                               hostwin->max_iova - hostwin->min_iova + 1,\n\n                               section->offset_within_address_space,\n\n                               int128_get64(section->size))) {\n\n                ret = -1;\n\n                goto fail;\n\n            }\n\n        }\n\n\n\n        ret = vfio_spapr_create_window(container, section, &pgsize);\n\n        if (ret) {\n\n            goto fail;\n\n        }\n\n\n\n        vfio_host_win_add(container, section->offset_within_address_space,\n\n                          section->offset_within_address_space +\n\n                          int128_get64(section->size) - 1, pgsize);\n\n    }\n\n\n\n    hostwin_found = false;\n\n    QLIST_FOREACH(hostwin, &container->hostwin_list, hostwin_next) {\n\n        if (hostwin->min_iova <= iova && end <= hostwin->max_iova) {\n\n            hostwin_found = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (!hostwin_found) {\n\n        error_report(\"vfio: IOMMU container %p can't map guest IOVA region\"\n\n                     \" 0x%\"HWADDR_PRIx\"..0x%\"HWADDR_PRIx,\n\n                     container, iova, end);\n\n        ret = -EFAULT;\n\n        goto fail;\n\n    }\n\n\n\n    memory_region_ref(section->mr);\n\n\n\n    if (memory_region_is_iommu(section->mr)) {\n\n        VFIOGuestIOMMU *giommu;\n\n\n\n        trace_vfio_listener_region_add_iommu(iova, end);\n\n        \/*\n\n         * FIXME: For VFIO iommu types which have KVM acceleration to\n\n         * avoid bouncing all map\/unmaps through qemu this way, this\n\n         * would be the right place to wire that up (tell the KVM\n\n         * device emulation the VFIO iommu handles to use).\n\n         *\/\n\n        giommu = g_malloc0(sizeof(*giommu));\n\n        giommu->iommu = section->mr;\n\n        giommu->iommu_offset = section->offset_within_address_space -\n\n                               section->offset_within_region;\n\n        giommu->container = container;\n\n        giommu->n.notify = vfio_iommu_map_notify;\n\n        giommu->n.notifier_flags = IOMMU_NOTIFIER_ALL;\n\n        QLIST_INSERT_HEAD(&container->giommu_list, giommu, giommu_next);\n\n\n\n        memory_region_register_iommu_notifier(giommu->iommu, &giommu->n);\n\n        memory_region_iommu_replay(giommu->iommu, &giommu->n, false);\n\n\n\n        return;\n\n    }\n\n\n\n    \/* Here we assume that memory_region_is_ram(section->mr)==true *\/\n\n\n\n    vaddr = memory_region_get_ram_ptr(section->mr) +\n\n            section->offset_within_region +\n\n            (iova - section->offset_within_address_space);\n\n\n\n    trace_vfio_listener_region_add_ram(iova, end, vaddr);\n\n\n\n    llsize = int128_sub(llend, int128_make64(iova));\n\n\n\n    ret = vfio_dma_map(container, iova, int128_get64(llsize),\n\n                       vaddr, section->readonly);\n\n    if (ret) {\n\n        error_report(\"vfio_dma_map(%p, 0x%\"HWADDR_PRIx\", \"\n\n                     \"0x%\"HWADDR_PRIx\", %p) = %d (%m)\",\n\n                     container, iova, int128_get64(llsize), vaddr, ret);\n\n        goto fail;\n\n    }\n\n\n\n    return;\n\n\n\nfail:\n\n    \/*\n\n     * On the initfn path, store the first error in the container so we\n\n     * can gracefully fail.  Runtime, there's not much we can do other\n\n     * than throw a hardware error.\n\n     *\/\n\n    if (!container->initialized) {\n\n        if (!container->error) {\n\n            container->error = ret;\n\n        }\n\n    } else {\n\n        hw_error(\"vfio: DMA mapping failed, unable to continue\");\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a307d59434ba78b97544b42b8cfd24a1b62e39a6","target":0,"func":"static ssize_t spapr_vlan_receive(NetClientState *nc, const uint8_t *buf,\n\n                                  size_t size)\n\n{\n\n    VIOsPAPRDevice *sdev = DO_UPCAST(NICState, nc, nc)->opaque;\n\n    VIOsPAPRVLANDevice *dev = (VIOsPAPRVLANDevice *)sdev;\n\n    vlan_bd_t rxq_bd = vio_ldq(sdev, dev->buf_list + VLAN_RXQ_BD_OFF);\n\n    vlan_bd_t bd;\n\n    int buf_ptr = dev->use_buf_ptr;\n\n    uint64_t handle;\n\n    uint8_t control;\n\n\n\n    dprintf(\"spapr_vlan_receive() [%s] rx_bufs=%d\\n\", sdev->qdev.id,\n\n            dev->rx_bufs);\n\n\n\n    if (!dev->isopen) {\n\n        return -1;\n\n    }\n\n\n\n    if (!dev->rx_bufs) {\n\n        return -1;\n\n    }\n\n\n\n    do {\n\n        buf_ptr += 8;\n\n        if (buf_ptr >= SPAPR_TCE_PAGE_SIZE) {\n\n            buf_ptr = VLAN_RX_BDS_OFF;\n\n        }\n\n\n\n        bd = vio_ldq(sdev, dev->buf_list + buf_ptr);\n\n        dprintf(\"use_buf_ptr=%d bd=0x%016llx\\n\",\n\n                buf_ptr, (unsigned long long)bd);\n\n    } while ((!(bd & VLAN_BD_VALID) || (VLAN_BD_LEN(bd) < (size + 8)))\n\n             && (buf_ptr != dev->use_buf_ptr));\n\n\n\n    if (!(bd & VLAN_BD_VALID) || (VLAN_BD_LEN(bd) < (size + 8))) {\n\n        \/* Failed to find a suitable buffer *\/\n\n        return -1;\n\n    }\n\n\n\n    \/* Remove the buffer from the pool *\/\n\n    dev->rx_bufs--;\n\n    dev->use_buf_ptr = buf_ptr;\n\n    vio_stq(sdev, dev->buf_list + dev->use_buf_ptr, 0);\n\n\n\n    dprintf(\"Found buffer: ptr=%d num=%d\\n\", dev->use_buf_ptr, dev->rx_bufs);\n\n\n\n    \/* Transfer the packet data *\/\n\n    if (spapr_vio_dma_write(sdev, VLAN_BD_ADDR(bd) + 8, buf, size) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    dprintf(\"spapr_vlan_receive: DMA write completed\\n\");\n\n\n\n    \/* Update the receive queue *\/\n\n    control = VLAN_RXQC_TOGGLE | VLAN_RXQC_VALID;\n\n    if (rxq_bd & VLAN_BD_TOGGLE) {\n\n        control ^= VLAN_RXQC_TOGGLE;\n\n    }\n\n\n\n    handle = vio_ldq(sdev, VLAN_BD_ADDR(bd));\n\n    vio_stq(sdev, VLAN_BD_ADDR(rxq_bd) + dev->rxq_ptr + 8, handle);\n\n    vio_stl(sdev, VLAN_BD_ADDR(rxq_bd) + dev->rxq_ptr + 4, size);\n\n    vio_sth(sdev, VLAN_BD_ADDR(rxq_bd) + dev->rxq_ptr + 2, 8);\n\n    vio_stb(sdev, VLAN_BD_ADDR(rxq_bd) + dev->rxq_ptr, control);\n\n\n\n    dprintf(\"wrote rxq entry (ptr=0x%llx): 0x%016llx 0x%016llx\\n\",\n\n            (unsigned long long)dev->rxq_ptr,\n\n            (unsigned long long)vio_ldq(sdev, VLAN_BD_ADDR(rxq_bd) +\n\n                                        dev->rxq_ptr),\n\n            (unsigned long long)vio_ldq(sdev, VLAN_BD_ADDR(rxq_bd) +\n\n                                        dev->rxq_ptr + 8));\n\n\n\n    dev->rxq_ptr += 16;\n\n    if (dev->rxq_ptr >= VLAN_BD_LEN(rxq_bd)) {\n\n        dev->rxq_ptr = 0;\n\n        vio_stq(sdev, dev->buf_list + VLAN_RXQ_BD_OFF, rxq_bd ^ VLAN_BD_TOGGLE);\n\n    }\n\n\n\n    if (sdev->signal_state & 1) {\n\n        qemu_irq_pulse(sdev->qirq);\n\n    }\n\n\n\n    return size;\n\n}\n"},{"project":"qemu","commit_id":"a0ceb640d083ab583d115fbd2ded14c089044ae8","target":0,"func":"static void pc_cpu_pre_plug(HotplugHandler *hotplug_dev,\n\n                            DeviceState *dev, Error **errp)\n\n{\n\n    int idx;\n\n    int node_id;\n\n    CPUState *cs;\n\n    CPUArchId *cpu_slot;\n\n    X86CPUTopoInfo topo;\n\n    X86CPU *cpu = X86_CPU(dev);\n\n    PCMachineState *pcms = PC_MACHINE(hotplug_dev);\n\n\n\n    \/* if APIC ID is not set, set it based on socket\/core\/thread properties *\/\n\n    if (cpu->apic_id == UNASSIGNED_APIC_ID) {\n\n        int max_socket = (max_cpus - 1) \/ smp_threads \/ smp_cores;\n\n\n\n        if (cpu->socket_id < 0) {\n\n            error_setg(errp, \"CPU socket-id is not set\");\n\n            return;\n\n        } else if (cpu->socket_id > max_socket) {\n\n            error_setg(errp, \"Invalid CPU socket-id: %u must be in range 0:%u\",\n\n                       cpu->socket_id, max_socket);\n\n            return;\n\n        }\n\n        if (cpu->core_id < 0) {\n\n            error_setg(errp, \"CPU core-id is not set\");\n\n            return;\n\n        } else if (cpu->core_id > (smp_cores - 1)) {\n\n            error_setg(errp, \"Invalid CPU core-id: %u must be in range 0:%u\",\n\n                       cpu->core_id, smp_cores - 1);\n\n            return;\n\n        }\n\n        if (cpu->thread_id < 0) {\n\n            error_setg(errp, \"CPU thread-id is not set\");\n\n            return;\n\n        } else if (cpu->thread_id > (smp_threads - 1)) {\n\n            error_setg(errp, \"Invalid CPU thread-id: %u must be in range 0:%u\",\n\n                       cpu->thread_id, smp_threads - 1);\n\n            return;\n\n        }\n\n\n\n        topo.pkg_id = cpu->socket_id;\n\n        topo.core_id = cpu->core_id;\n\n        topo.smt_id = cpu->thread_id;\n\n        cpu->apic_id = apicid_from_topo_ids(smp_cores, smp_threads, &topo);\n\n    }\n\n\n\n    cpu_slot = pc_find_cpu_slot(MACHINE(pcms), cpu->apic_id, &idx);\n\n    if (!cpu_slot) {\n\n        MachineState *ms = MACHINE(pcms);\n\n\n\n        x86_topo_ids_from_apicid(cpu->apic_id, smp_cores, smp_threads, &topo);\n\n        error_setg(errp, \"Invalid CPU [socket: %u, core: %u, thread: %u] with\"\n\n                  \" APIC ID %\" PRIu32 \", valid index range 0:%d\",\n\n                   topo.pkg_id, topo.core_id, topo.smt_id, cpu->apic_id,\n\n                   ms->possible_cpus->len - 1);\n\n        return;\n\n    }\n\n\n\n    if (cpu_slot->cpu) {\n\n        error_setg(errp, \"CPU[%d] with APIC ID %\" PRIu32 \" exists\",\n\n                   idx, cpu->apic_id);\n\n        return;\n\n    }\n\n\n\n    \/* if 'address' properties socket-id\/core-id\/thread-id are not set, set them\n\n     * so that machine_query_hotpluggable_cpus would show correct values\n\n     *\/\n\n    \/* TODO: move socket_id\/core_id\/thread_id checks into x86_cpu_realizefn()\n\n     * once -smp refactoring is complete and there will be CPU private\n\n     * CPUState::nr_cores and CPUState::nr_threads fields instead of globals *\/\n\n    x86_topo_ids_from_apicid(cpu->apic_id, smp_cores, smp_threads, &topo);\n\n    if (cpu->socket_id != -1 && cpu->socket_id != topo.pkg_id) {\n\n        error_setg(errp, \"property socket-id: %u doesn't match set apic-id:\"\n\n            \" 0x%x (socket-id: %u)\", cpu->socket_id, cpu->apic_id, topo.pkg_id);\n\n        return;\n\n    }\n\n    cpu->socket_id = topo.pkg_id;\n\n\n\n    if (cpu->core_id != -1 && cpu->core_id != topo.core_id) {\n\n        error_setg(errp, \"property core-id: %u doesn't match set apic-id:\"\n\n            \" 0x%x (core-id: %u)\", cpu->core_id, cpu->apic_id, topo.core_id);\n\n        return;\n\n    }\n\n    cpu->core_id = topo.core_id;\n\n\n\n    if (cpu->thread_id != -1 && cpu->thread_id != topo.smt_id) {\n\n        error_setg(errp, \"property thread-id: %u doesn't match set apic-id:\"\n\n            \" 0x%x (thread-id: %u)\", cpu->thread_id, cpu->apic_id, topo.smt_id);\n\n        return;\n\n    }\n\n    cpu->thread_id = topo.smt_id;\n\n\n\n    cs = CPU(cpu);\n\n    cs->cpu_index = idx;\n\n\n\n    node_id = cpu_slot->props.node_id;\n\n    if (!cpu_slot->props.has_node_id) {\n\n        \/* by default CPUState::numa_node was 0 if it's not set via CLI\n\n         * keep it this way for now but in future we probably should\n\n         * refuse to start up with incomplete numa mapping *\/\n\n        node_id = 0;\n\n    }\n\n    if (cs->numa_node == CPU_UNSET_NUMA_NODE_ID) {\n\n        cs->numa_node = node_id;\n\n    } else if (cs->numa_node != node_id) {\n\n            error_setg(errp, \"node-id %d must match numa node specified\"\n\n                \"with -numa option for cpu-index %d\",\n\n                cs->numa_node, cs->cpu_index);\n\n            return;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"7d5e199ade76c53ec316ab6779800581bb47c50a","target":0,"func":"static void dump_json_image_check(ImageCheck *check, bool quiet)\n\n{\n\n    QString *str;\n\n    QObject *obj;\n\n    Visitor *v = qmp_output_visitor_new(&obj);\n\n\n\n    visit_type_ImageCheck(v, NULL, &check, &error_abort);\n\n    visit_complete(v, &obj);\n\n    str = qobject_to_json_pretty(obj);\n\n    assert(str != NULL);\n\n    qprintf(quiet, \"%s\\n\", qstring_get_str(str));\n\n    qobject_decref(obj);\n\n    visit_free(v);\n\n    QDECREF(str);\n\n}\n"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static unsigned int event_status_media(IDEState *s,\n\n                                       uint8_t *buf)\n\n{\n\n    uint8_t event_code, media_status;\n\n\n\n    media_status = 0;\n\n    if (s->tray_open) {\n\n        media_status = MS_TRAY_OPEN;\n\n    } else if (bdrv_is_inserted(s->bs)) {\n\n        media_status = MS_MEDIA_PRESENT;\n\n    }\n\n\n\n    \/* Event notification descriptor *\/\n\n    event_code = MEC_NO_CHANGE;\n\n    if (media_status != MS_TRAY_OPEN) {\n\n        if (s->events.new_media) {\n\n            event_code = MEC_NEW_MEDIA;\n\n            s->events.new_media = false;\n\n        } else if (s->events.eject_request) {\n\n            event_code = MEC_EJECT_REQUESTED;\n\n            s->events.eject_request = false;\n\n        }\n\n    }\n\n\n\n    buf[4] = event_code;\n\n    buf[5] = media_status;\n\n\n\n    \/* These fields are reserved, just clear them. *\/\n\n    buf[6] = 0;\n\n    buf[7] = 0;\n\n\n\n    return 8; \/* We wrote to 4 extra bytes from the header *\/\n\n}\n"},{"project":"qemu","commit_id":"d3392718e1fcf0859fb7c0774a8e946bacb8419c","target":1,"func":"static void v7m_exception_taken(ARMCPU *cpu, uint32_t lr)\n\n{\n\n    \/* Do the \"take the exception\" parts of exception entry,\n\n     * but not the pushing of state to the stack. This is\n\n     * similar to the pseudocode ExceptionTaken() function.\n\n     *\/\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t addr;\n\n\n\n    armv7m_nvic_acknowledge_irq(env->nvic);\n\n    write_v7m_control_spsel(env, 0);\n\n    arm_clear_exclusive(env);\n\n    \/* Clear IT bits *\/\n\n    env->condexec_bits = 0;\n\n    env->regs[14] = lr;\n\n    addr = arm_v7m_load_vector(cpu);\n\n    env->regs[15] = addr & 0xfffffffe;\n\n    env->thumb = addr & 1;\n\n}\n"},{"project":"qemu","commit_id":"ac531cb6e542b1e61d668604adf9dc5306a948c0","target":0,"func":"START_TEST(qdict_get_try_int_test)\n\n{\n\n    int ret;\n\n    const int value = 100;\n\n    const char *key = \"int\";\n\n\n\n    qdict_put(tests_dict, key, qint_from_int(value));\n\n\n\n    ret = qdict_get_try_int(tests_dict, key, 0);\n\n    fail_unless(ret == value);\n\n}\n"},{"project":"qemu","commit_id":"2b584959ed300ddff4acba0d7554becad5f274fd","target":0,"func":"void bdrv_get_geometry_hint(BlockDriverState *bs,\n\n                            int *pcyls, int *pheads, int *psecs)\n\n{\n\n    *pcyls = bs->cyls;\n\n    *pheads = bs->heads;\n\n    *psecs = bs->secs;\n\n}\n"},{"project":"qemu","commit_id":"5923f85fb82df7c8c60a89458a5ae856045e5ab1","target":1,"func":"static void qobject_output_type_uint64(Visitor *v, const char *name,\n\n                                       uint64_t *obj, Error **errp)\n\n{\n\n    \/* FIXME values larger than INT64_MAX become negative *\/\n\n    QObjectOutputVisitor *qov = to_qov(v);\n\n    qobject_output_add(qov, name, qnum_from_int(*obj));\n\n}\n"},{"project":"qemu","commit_id":"debaaa114a8877a939533ba846e64168fb287b7b","target":0,"func":"static void test_flush(void)\n\n{\n\n    AHCIQState *ahci;\n\n\n\n    ahci = ahci_boot_and_enable();\n\n    ahci_test_flush(ahci);\n\n    ahci_shutdown(ahci);\n\n}\n"},{"project":"qemu","commit_id":"5f9099d9cee0e9ed377aee705ca9f4db75e8948d","target":1,"func":"static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,\n                                 struct target_ucontext_v2 *uc)\n{\n    sigset_t host_set;\n    abi_ulong *regspace;\n    target_to_host_sigset(&host_set, &uc->tuc_sigmask);\n    sigprocmask(SIG_SETMASK, &host_set, NULL);\n    if (restore_sigcontext(env, &uc->tuc_mcontext))\n    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)\n#if 0\n    \/* Send SIGTRAP if we're single-stepping *\/\n    if (ptrace_cancel_bpt(current))\n            send_sig(SIGTRAP, current, 1);\n#endif\n    return 0;"},{"project":"qemu","commit_id":"9586fefefe383a9aa25ad99bde9a6b240309ca33","target":1,"func":"static int vga_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VGAState *s = opaque;\n\n    int is_vbe, i, ret;\n\n\n\n    if (version_id > 2)\n\n        return -EINVAL;\n\n\n\n    if (s->pci_dev && version_id >= 2) {\n\n        ret = pci_device_load(s->pci_dev, f);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    qemu_get_be32s(f, &s->latch);\n\n    qemu_get_8s(f, &s->sr_index);\n\n    qemu_get_buffer(f, s->sr, 8);\n\n    qemu_get_8s(f, &s->gr_index);\n\n    qemu_get_buffer(f, s->gr, 16);\n\n    qemu_get_8s(f, &s->ar_index);\n\n    qemu_get_buffer(f, s->ar, 21);\n\n    s->ar_flip_flop=qemu_get_be32(f);\n\n    qemu_get_8s(f, &s->cr_index);\n\n    qemu_get_buffer(f, s->cr, 256);\n\n    qemu_get_8s(f, &s->msr);\n\n    qemu_get_8s(f, &s->fcr);\n\n    qemu_get_8s(f, &s->st00);\n\n    qemu_get_8s(f, &s->st01);\n\n\n\n    qemu_get_8s(f, &s->dac_state);\n\n    qemu_get_8s(f, &s->dac_sub_index);\n\n    qemu_get_8s(f, &s->dac_read_index);\n\n    qemu_get_8s(f, &s->dac_write_index);\n\n    qemu_get_buffer(f, s->dac_cache, 3);\n\n    qemu_get_buffer(f, s->palette, 768);\n\n\n\n    s->bank_offset=qemu_get_be32(f);\n\n    is_vbe = qemu_get_byte(f);\n\n#ifdef CONFIG_BOCHS_VBE\n\n    if (!is_vbe)\n\n        return -EINVAL;\n\n    qemu_get_be16s(f, &s->vbe_index);\n\n    for(i = 0; i < VBE_DISPI_INDEX_NB; i++)\n\n        qemu_get_be16s(f, &s->vbe_regs[i]);\n\n    qemu_get_be32s(f, &s->vbe_start_addr);\n\n    qemu_get_be32s(f, &s->vbe_line_offset);\n\n    qemu_get_be32s(f, &s->vbe_bank_mask);\n\n#else\n\n    if (is_vbe)\n\n        return -EINVAL;\n\n#endif\n\n\n\n    \/* force refresh *\/\n\n    s->graphic_mode = -1;\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static uint64_t ecc_diag_mem_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    ECCState *s = opaque;\n\n    uint32_t ret = s->diag[(int)addr];\n\n\n\n    trace_ecc_diag_mem_readb(addr, ret);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"b7bad50ae81efeb180609eeecdb086ebc7536ed7","target":0,"func":"static void cryptodev_builtin_cleanup(\n\n             CryptoDevBackend *backend,\n\n             Error **errp)\n\n{\n\n    CryptoDevBackendBuiltin *builtin =\n\n                      CRYPTODEV_BACKEND_BUILTIN(backend);\n\n    size_t i;\n\n    int queues = backend->conf.peers.queues;\n\n    CryptoDevBackendClient *cc;\n\n\n\n    for (i = 0; i < MAX_NUM_SESSIONS; i++) {\n\n        if (builtin->sessions[i] != NULL) {\n\n            cryptodev_builtin_sym_close_session(\n\n                    backend, i, 0, errp);\n\n        }\n\n    }\n\n\n\n    assert(queues == 1);\n\n\n\n    for (i = 0; i < queues; i++) {\n\n        cc = backend->conf.peers.ccs[i];\n\n        if (cc) {\n\n            cryptodev_backend_free_client(cc);\n\n            backend->conf.peers.ccs[i] = NULL;\n\n        }\n\n    }\n\n\n\n    cryptodev_backend_set_ready(backend, false);\n\n}\n"},{"project":"qemu","commit_id":"e95205e1f9cd2c4262b7a7b1c992a94512c86d0e","target":1,"func":"static void continue_after_map_failure(void *opaque)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n\n\n    dbs->bh = qemu_bh_new(reschedule_dma, dbs);\n\n    qemu_bh_schedule(dbs->bh);\n\n}\n"},{"project":"qemu","commit_id":"786a4ea82ec9c87e3a895cf41081029b285a5fe5","target":0,"func":"static void acpi_pcihp_eject_slot(AcpiPciHpState *s, unsigned bsel, unsigned slots)\n\n{\n\n    BusChild *kid, *next;\n\n    int slot = ffs(slots) - 1;\n\n    PCIBus *bus = acpi_pcihp_find_hotplug_bus(s, bsel);\n\n\n\n    if (!bus) {\n\n        return;\n\n    }\n\n\n\n    \/* Mark request as complete *\/\n\n    s->acpi_pcihp_pci_status[bsel].down &= ~(1U << slot);\n\n    s->acpi_pcihp_pci_status[bsel].up &= ~(1U << slot);\n\n\n\n    QTAILQ_FOREACH_SAFE(kid, &bus->qbus.children, sibling, next) {\n\n        DeviceState *qdev = kid->child;\n\n        PCIDevice *dev = PCI_DEVICE(qdev);\n\n        if (PCI_SLOT(dev->devfn) == slot) {\n\n            if (!acpi_pcihp_pc_no_hotplug(s, dev)) {\n\n                object_unparent(OBJECT(qdev));\n\n            }\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"12848bfc5d719bad536c5448205a3226be1fda47","target":1,"func":"static int local_post_create_passthrough(FsContext *fs_ctx, const char *path,\n\n        FsCred *credp)\n\n{\n\n    if (chmod(rpath(fs_ctx, path), credp->fc_mode & 07777) < 0) {\n\n        return -1;\n\n    }\n\n    if (chown(rpath(fs_ctx, path), credp->fc_uid, credp->fc_gid) < 0) {\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"bb00021de0b5908bc2c3ca467ad9a2b0c9c36459","target":1,"func":"void qmp_block_commit(const char *device,\n\n                      bool has_base, const char *base,\n\n                      bool has_top, const char *top,\n\n                      bool has_backing_file, const char *backing_file,\n\n                      bool has_speed, int64_t speed,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs, *top_bs;\n\n    AioContext *aio_context;\n\n    Error *local_err = NULL;\n\n    \/* This will be part of the QMP command, if\/when the\n\n     * BlockdevOnError change for blkmirror makes it in\n\n     *\/\n\n    BlockdevOnError on_error = BLOCKDEV_ON_ERROR_REPORT;\n\n\n\n    if (!has_speed) {\n\n        speed = 0;\n\n    }\n\n\n\n    \/* Important Note:\n\n     *  libvirt relies on the DeviceNotFound error class in order to probe for\n\n     *  live commit feature versions; for this to work, we must make sure to\n\n     *  perform the device lookup before any generic errors that may occur in a\n\n     *  scenario in which all optional arguments are omitted. *\/\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    \/* drain all i\/o before commits *\/\n\n    bdrv_drain_all();\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_COMMIT, errp)) {\n\n        goto out;\n\n    }\n\n\n\n    \/* default top_bs is the active layer *\/\n\n    top_bs = bs;\n\n\n\n    if (has_top && top) {\n\n        if (strcmp(bs->filename, top) != 0) {\n\n            top_bs = bdrv_find_backing_image(bs, top);\n\n        }\n\n    }\n\n\n\n    if (top_bs == NULL) {\n\n        error_setg(errp, \"Top image file %s not found\", top ? top : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    assert(bdrv_get_aio_context(top_bs) == aio_context);\n\n\n\n    if (has_base && base) {\n\n        base_bs = bdrv_find_backing_image(top_bs, base);\n\n    } else {\n\n        base_bs = bdrv_find_base(top_bs);\n\n    }\n\n\n\n    if (base_bs == NULL) {\n\n        error_set(errp, QERR_BASE_NOT_FOUND, base ? base : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    assert(bdrv_get_aio_context(base_bs) == aio_context);\n\n\n\n    \/* Do not allow attempts to commit an image into itself *\/\n\n    if (top_bs == base_bs) {\n\n        error_setg(errp, \"cannot commit an image into itself\");\n\n        goto out;\n\n    }\n\n\n\n    if (top_bs == bs) {\n\n        if (has_backing_file) {\n\n            error_setg(errp, \"'backing-file' specified,\"\n\n                             \" but 'top' is the active layer\");\n\n            goto out;\n\n        }\n\n        commit_active_start(bs, base_bs, speed, on_error, block_job_cb,\n\n                            bs, &local_err);\n\n    } else {\n\n        commit_start(bs, base_bs, top_bs, speed, on_error, block_job_cb, bs,\n\n                     has_backing_file ? backing_file : NULL, &local_err);\n\n    }\n\n    if (local_err != NULL) {\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    aio_context_release(aio_context);\n\n}\n"},{"project":"qemu","commit_id":"9121d02cb33c96b444a3973579f5edc119597e81","target":0,"func":"static void uart_rx_reset(UartState *s)\n\n{\n\n    s->rx_wpos = 0;\n\n    s->rx_count = 0;\n\n    qemu_chr_accept_input(s->chr);\n\n\n\n    s->r[R_SR] |= UART_SR_INTR_REMPTY;\n\n    s->r[R_SR] &= ~UART_SR_INTR_RFUL;\n\n}\n"},{"project":"qemu","commit_id":"21ef45d71221b4577330fe3aacfb06afad91ad46","target":1,"func":"static int vnc_display_disable_login(DisplayState *ds)\n\n{\n\n    VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n\n\n\n    if (!vs) {\n\n        return -1;\n\n    }\n\n\n\n    if (vs->password) {\n\n        g_free(vs->password);\n\n    }\n\n\n\n    vs->password = NULL;\n\n    if (vs->auth == VNC_AUTH_NONE) {\n\n        vs->auth = VNC_AUTH_VNC;\n\n    }\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1","target":0,"func":"static void term_forward_char(void)\n\n{\n\n    if (term_cmd_buf_index < term_cmd_buf_size) {\n\n        term_cmd_buf_index++;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"68a9398261ca38979bbc2b7c89ed5bb044ccc9e6","target":1,"func":"static void qemu_thread_set_name(QemuThread *thread, const char *name)\n\n{\n\n#ifdef CONFIG_PTHREAD_SETNAME_NP\n\n    pthread_setname_np(thread->thread, name);\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"134d42d614768b2803e551621f6654dab1fdc2d2","target":0,"func":"static unsigned acpi_data_len(GArray *table)\n\n{\n\n#if GLIB_CHECK_VERSION(2, 14, 0)\n\n    assert(g_array_get_element_size(table) == 1);\n\n#endif\n\n    return table->len;\n\n}\n"},{"project":"qemu","commit_id":"a818a4b69d47ca3826dee36878074395aeac2083","target":0,"func":"static void scsi_device_destroy(SCSIDevice *s)\n\n{\n\n    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);\n\n    if (sc->destroy) {\n\n        sc->destroy(s);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"5c843af22604edecda10d4bb89d4eede9e1bd3d0","target":1,"func":"void hmp_hostfwd_add(Monitor *mon, const QDict *qdict)\n\n{\n\n    const char *redir_str;\n\n    SlirpState *s;\n\n    const char *arg1 = qdict_get_str(qdict, \"arg1\");\n\n    const char *arg2 = qdict_get_try_str(qdict, \"arg2\");\n\n    const char *arg3 = qdict_get_try_str(qdict, \"arg3\");\n\n\n\n    if (arg2) {\n\n        s = slirp_lookup(mon, arg1, arg2);\n\n        redir_str = arg3;\n\n    } else {\n\n        s = slirp_lookup(mon, NULL, NULL);\n\n        redir_str = arg1;\n\n    }\n\n    if (s) {\n\n        slirp_hostfwd(s, redir_str, 0);\n\n    }\n\n\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void apb_config_writel (void *opaque, target_phys_addr_t addr,\n\n                               uint64_t val, unsigned size)\n\n{\n\n    APBState *s = opaque;\n\n\n\n    APB_DPRINTF(\"%s: addr \" TARGET_FMT_lx \" val %\" PRIx64 \"\\n\", __func__, addr, val);\n\n\n\n    switch (addr & 0xffff) {\n\n    case 0x30 ... 0x4f: \/* DMA error registers *\/\n\n        \/* XXX: not implemented yet *\/\n\n        break;\n\n    case 0x200 ... 0x20b: \/* IOMMU *\/\n\n        s->iommu[(addr & 0xf) >> 2] = val;\n\n        break;\n\n    case 0x20c ... 0x3ff: \/* IOMMU flush *\/\n\n        break;\n\n    case 0xc00 ... 0xc3f: \/* PCI interrupt control *\/\n\n        if (addr & 4) {\n\n            s->pci_irq_map[(addr & 0x3f) >> 3] &= PBM_PCI_IMR_MASK;\n\n            s->pci_irq_map[(addr & 0x3f) >> 3] |= val & ~PBM_PCI_IMR_MASK;\n\n        }\n\n        break;\n\n    case 0x1000 ... 0x1080: \/* OBIO interrupt control *\/\n\n        if (addr & 4) {\n\n            s->obio_irq_map[(addr & 0xff) >> 3] &= PBM_PCI_IMR_MASK;\n\n            s->obio_irq_map[(addr & 0xff) >> 3] |= val & ~PBM_PCI_IMR_MASK;\n\n        }\n\n        break;\n\n    case 0x1400 ... 0x143f: \/* PCI interrupt clear *\/\n\n        if (addr & 4) {\n\n            pci_apb_set_irq(s, (addr & 0x3f) >> 3, 0);\n\n        }\n\n        break;\n\n    case 0x1800 ... 0x1860: \/* OBIO interrupt clear *\/\n\n        if (addr & 4) {\n\n            pci_apb_set_irq(s, 0x20 | ((addr & 0xff) >> 3), 0);\n\n        }\n\n        break;\n\n    case 0x2000 ... 0x202f: \/* PCI control *\/\n\n        s->pci_control[(addr & 0x3f) >> 2] = val;\n\n        break;\n\n    case 0xf020 ... 0xf027: \/* Reset control *\/\n\n        if (addr & 4) {\n\n            val &= RESET_MASK;\n\n            s->reset_control &= ~(val & RESET_WCMASK);\n\n            s->reset_control |= val & RESET_WMASK;\n\n            if (val & SOFT_POR) {\n\n                s->nr_resets = 0;\n\n                qemu_system_reset_request();\n\n            } else if (val & SOFT_XIR) {\n\n                qemu_system_reset_request();\n\n            }\n\n        }\n\n        break;\n\n    case 0x5000 ... 0x51cf: \/* PIO\/DMA diagnostics *\/\n\n    case 0xa400 ... 0xa67f: \/* IOMMU diagnostics *\/\n\n    case 0xa800 ... 0xa80f: \/* Interrupt diagnostics *\/\n\n    case 0xf000 ... 0xf01f: \/* FFB config, memory control *\/\n\n        \/* we don't care *\/\n\n    default:\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"b14ef7c9ab41ea824c3ccadb070ad95567cca84e","target":1,"func":"static uint32_t unassigned_mem_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem read \" TARGET_FMT_plx \"\\n\", addr);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 0, 0, 0, 1);\n\n#endif\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"3ff2f67a7c24183fcbcfe1332e5223ac6f96438c","target":1,"func":"BlockDriverState *bdrv_new(void)\n{\n    BlockDriverState *bs;\n    int i;\n    bs = g_new0(BlockDriverState, 1);\n    QLIST_INIT(&bs->dirty_bitmaps);\n    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {\n        QLIST_INIT(&bs->op_blockers[i]);\n    }\n    notifier_with_return_list_init(&bs->before_write_notifiers);\n    bs->refcnt = 1;\n    bs->aio_context = qemu_get_aio_context();\n    QTAILQ_INSERT_TAIL(&all_bdrv_states, bs, bs_list);\n    return bs;\n}"},{"project":"qemu","commit_id":"0284b03ba3f47da53b6b46293a3d586c08829f7e","target":0,"func":"restore_sigcontext(CPUX86State *env, struct target_sigcontext *sc, int *peax)\n\n{\n\n    unsigned int err = 0;\n\n    abi_ulong fpstate_addr;\n\n    unsigned int tmpflags;\n\n\n\n    cpu_x86_load_seg(env, R_GS, tswap16(sc->gs));\n\n    cpu_x86_load_seg(env, R_FS, tswap16(sc->fs));\n\n    cpu_x86_load_seg(env, R_ES, tswap16(sc->es));\n\n    cpu_x86_load_seg(env, R_DS, tswap16(sc->ds));\n\n\n\n    env->regs[R_EDI] = tswapl(sc->edi);\n\n    env->regs[R_ESI] = tswapl(sc->esi);\n\n    env->regs[R_EBP] = tswapl(sc->ebp);\n\n    env->regs[R_ESP] = tswapl(sc->esp);\n\n    env->regs[R_EBX] = tswapl(sc->ebx);\n\n    env->regs[R_EDX] = tswapl(sc->edx);\n\n    env->regs[R_ECX] = tswapl(sc->ecx);\n\n    env->eip = tswapl(sc->eip);\n\n\n\n    cpu_x86_load_seg(env, R_CS, lduw_p(&sc->cs) | 3);\n\n    cpu_x86_load_seg(env, R_SS, lduw_p(&sc->ss) | 3);\n\n\n\n    tmpflags = tswapl(sc->eflags);\n\n    env->eflags = (env->eflags & ~0x40DD5) | (tmpflags & 0x40DD5);\n\n    \/\/\t\tregs->orig_eax = -1;\t\t\/* disable syscall checks *\/\n\n\n\n    fpstate_addr = tswapl(sc->fpstate);\n\n    if (fpstate_addr != 0) {\n\n        if (!access_ok(VERIFY_READ, fpstate_addr,\n\n                       sizeof(struct target_fpstate)))\n\n            goto badframe;\n\n        cpu_x86_frstor(env, fpstate_addr, 1);\n\n    }\n\n\n\n    *peax = tswapl(sc->eax);\n\n    return err;\n\nbadframe:\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"6f3c90af3c50d4f839849c8ba9b6ba4e9a548c28","target":0,"func":"static int map_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    int64_t offset;\n\n    int64_t nb_sectors, total_sectors;\n\n    char s1[64];\n\n    int64_t num;\n\n    int ret;\n\n    const char *retstr;\n\n\n\n    offset = 0;\n\n    total_sectors = blk_nb_sectors(blk);\n\n    if (total_sectors < 0) {\n\n        error_report(\"Failed to query image length: %s\",\n\n                     strerror(-total_sectors));\n\n        return 0;\n\n    }\n\n\n\n    nb_sectors = total_sectors;\n\n\n\n    do {\n\n        ret = map_is_allocated(blk_bs(blk), offset, nb_sectors, &num);\n\n        if (ret < 0) {\n\n            error_report(\"Failed to get allocation status: %s\", strerror(-ret));\n\n            return 0;\n\n        } else if (!num) {\n\n            error_report(\"Unexpected end of image\");\n\n            return 0;\n\n        }\n\n\n\n        retstr = ret ? \"    allocated\" : \"not allocated\";\n\n        cvtstr(offset << 9ULL, s1, sizeof(s1));\n\n        printf(\"[% 24\" PRId64 \"] % 8\" PRId64 \"\/% 8\" PRId64 \" sectors %s \"\n\n               \"at offset %s (%d)\\n\",\n\n               offset << 9ULL, num, nb_sectors, retstr, s1, ret);\n\n\n\n        offset += num;\n\n        nb_sectors -= num;\n\n    } while (offset < total_sectors);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"e4a3507e86a1ef1453d603031bca27d5ac4cff3c","target":0,"func":"static ssize_t block_crypto_write_func(QCryptoBlock *block,\n\n                                       void *opaque,\n\n                                       size_t offset,\n\n                                       const uint8_t *buf,\n\n                                       size_t buflen,\n\n                                       Error **errp)\n\n{\n\n    struct BlockCryptoCreateData *data = opaque;\n\n    ssize_t ret;\n\n\n\n    ret = blk_pwrite(data->blk, offset, buf, buflen, 0);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not write encryption header\");\n\n        return ret;\n\n    }\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"3c529d935923a70519557d420db1d5a09a65086a","target":0,"func":"static void raw_aio_cancel(BlockDriverAIOCB *blockacb)\n\n{\n\n    int ret;\n\n    RawAIOCB *acb = (RawAIOCB *)blockacb;\n\n    RawAIOCB **pacb;\n\n\n\n    ret = aio_cancel(acb->aiocb.aio_fildes, &acb->aiocb);\n\n    if (ret == AIO_NOTCANCELED) {\n\n        \/* fail safe: if the aio could not be canceled, we wait for\n\n           it *\/\n\n        while (aio_error(&acb->aiocb) == EINPROGRESS);\n\n    }\n\n\n\n    \/* remove the callback from the queue *\/\n\n    pacb = &posix_aio_state->first_aio;\n\n    for(;;) {\n\n        if (*pacb == NULL) {\n\n            break;\n\n        } else if (*pacb == acb) {\n\n            *pacb = acb->next;\n\n            raw_fd_pool_put(acb);\n\n            qemu_aio_release(acb);\n\n            break;\n\n        }\n\n        pacb = &acb->next;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"920557971b60e53c2f3f22e5d6c620ab1ed411fd","target":0,"func":"void ich9_lpc_pm_init(PCIDevice *lpc_pci, bool smm_enabled)\n\n{\n\n    ICH9LPCState *lpc = ICH9_LPC_DEVICE(lpc_pci);\n\n    qemu_irq sci_irq;\n\n\n\n    sci_irq = qemu_allocate_irq(ich9_set_sci, lpc, 0);\n\n    ich9_pm_init(lpc_pci, &lpc->pm, smm_enabled, sci_irq);\n\n    ich9_lpc_reset(&lpc->d.qdev);\n\n}\n"},{"project":"qemu","commit_id":"2c6942fa7b332a95286071b92d233853e1000948","target":0,"func":"int64_t bdrv_getlength(BlockDriverState *bs)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n\n\n    if (bs->growable || bs->removable) {\n\n        if (drv->bdrv_getlength) {\n\n            return drv->bdrv_getlength(bs);\n\n        }\n\n    }\n\n    return bs->total_sectors * BDRV_SECTOR_SIZE;\n\n}\n"},{"project":"qemu","commit_id":"340065e5a11a515382c8b1112424c97e86ad2a3f","target":1,"func":"static void pc_machine_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n    PCMachineClass *pcmc = PC_MACHINE_CLASS(oc);\n\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);\n\n\n\n    pcmc->inter_dimm_gap = true;\n\n    pcmc->get_hotplug_handler = mc->get_hotplug_handler;\n\n    mc->get_hotplug_handler = pc_get_hotpug_handler;\n\n    mc->cpu_index_to_socket_id = pc_cpu_index_to_socket_id;\n\n    mc->default_boot_order = \"cad\";\n\n    mc->hot_add_cpu = pc_hot_add_cpu;\n\n    mc->max_cpus = 255;\n\n    mc->reset = pc_machine_reset;\n\n    hc->plug = pc_machine_device_plug_cb;\n\n    hc->unplug_request = pc_machine_device_unplug_request_cb;\n\n    hc->unplug = pc_machine_device_unplug_cb;\n\n}\n"},{"project":"qemu","commit_id":"3e3553905cfc814d59de6d1a634c3a991b2a9257","target":0,"func":"int qcow2_check_metadata_overlap(BlockDriverState *bs, int ign, int64_t offset,\n\n                                 int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int chk = QCOW2_OL_DEFAULT & ~ign;\n\n    int i, j;\n\n\n\n    if (!size) {\n\n        return 0;\n\n    }\n\n\n\n    if (chk & QCOW2_OL_MAIN_HEADER) {\n\n        if (offset < s->cluster_size) {\n\n            return QCOW2_OL_MAIN_HEADER;\n\n        }\n\n    }\n\n\n\n    \/* align range to test to cluster boundaries *\/\n\n    size = align_offset(offset_into_cluster(s, offset) + size, s->cluster_size);\n\n    offset = start_of_cluster(s, offset);\n\n\n\n    if ((chk & QCOW2_OL_ACTIVE_L1) && s->l1_size) {\n\n        if (overlaps_with(s->l1_table_offset, s->l1_size * sizeof(uint64_t))) {\n\n            return QCOW2_OL_ACTIVE_L1;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_REFCOUNT_TABLE) && s->refcount_table_size) {\n\n        if (overlaps_with(s->refcount_table_offset,\n\n            s->refcount_table_size * sizeof(uint64_t))) {\n\n            return QCOW2_OL_REFCOUNT_TABLE;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_SNAPSHOT_TABLE) && s->snapshots_size) {\n\n        if (overlaps_with(s->snapshots_offset, s->snapshots_size)) {\n\n            return QCOW2_OL_SNAPSHOT_TABLE;\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_INACTIVE_L1) && s->snapshots) {\n\n        for (i = 0; i < s->nb_snapshots; i++) {\n\n            if (s->snapshots[i].l1_size &&\n\n                overlaps_with(s->snapshots[i].l1_table_offset,\n\n                s->snapshots[i].l1_size * sizeof(uint64_t))) {\n\n                return QCOW2_OL_INACTIVE_L1;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_ACTIVE_L2) && s->l1_table) {\n\n        for (i = 0; i < s->l1_size; i++) {\n\n            if ((s->l1_table[i] & L1E_OFFSET_MASK) &&\n\n                overlaps_with(s->l1_table[i] & L1E_OFFSET_MASK,\n\n                s->cluster_size)) {\n\n                return QCOW2_OL_ACTIVE_L2;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_REFCOUNT_BLOCK) && s->refcount_table) {\n\n        for (i = 0; i < s->refcount_table_size; i++) {\n\n            if ((s->refcount_table[i] & REFT_OFFSET_MASK) &&\n\n                overlaps_with(s->refcount_table[i] & REFT_OFFSET_MASK,\n\n                s->cluster_size)) {\n\n                return QCOW2_OL_REFCOUNT_BLOCK;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((chk & QCOW2_OL_INACTIVE_L2) && s->snapshots) {\n\n        for (i = 0; i < s->nb_snapshots; i++) {\n\n            uint64_t l1_ofs = s->snapshots[i].l1_table_offset;\n\n            uint32_t l1_sz  = s->snapshots[i].l1_size;\n\n            uint64_t l1_sz2 = l1_sz * sizeof(uint64_t);\n\n            uint64_t *l1 = g_malloc(l1_sz2);\n\n            int ret;\n\n\n\n            ret = bdrv_pread(bs->file, l1_ofs, l1, l1_sz2);\n\n            if (ret < 0) {\n\n                g_free(l1);\n\n                return ret;\n\n            }\n\n\n\n            for (j = 0; j < l1_sz; j++) {\n\n                uint64_t l2_ofs = be64_to_cpu(l1[j]) & L1E_OFFSET_MASK;\n\n                if (l2_ofs && overlaps_with(l2_ofs, s->cluster_size)) {\n\n                    g_free(l1);\n\n                    return QCOW2_OL_INACTIVE_L2;\n\n                }\n\n            }\n\n\n\n            g_free(l1);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"007ac6faed12abdd4113e2460ba4464aacb7f4dd","target":0,"func":"static void gen_flt3_ldst (DisasContext *ctx, uint32_t opc,\n\n                           int fd, int fs, int base, int index)\n\n{\n\n    const char *opn = \"extended float load\/store\";\n\n    int store = 0;\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    if (base == 0) {\n\n        gen_load_gpr(t0, index);\n\n    } else if (index == 0) {\n\n        gen_load_gpr(t0, base);\n\n    } else {\n\n        gen_load_gpr(t0, index);\n\n        gen_op_addr_add(ctx, t0, cpu_gpr[base]);\n\n    }\n\n    \/* Don't do NOP if destination is zero: we must perform the actual\n\n       memory access. *\/\n\n    save_cpu_state(ctx, 0);\n\n    switch (opc) {\n\n    case OPC_LWXC1:\n\n        check_cop1x(ctx);\n\n        {\n\n            TCGv_i32 fp0 = tcg_temp_new_i32();\n\n\n\n            tcg_gen_qemu_ld32s(t0, t0, ctx->mem_idx);\n\n            tcg_gen_trunc_tl_i32(fp0, t0);\n\n            gen_store_fpr32(fp0, fd);\n\n            tcg_temp_free_i32(fp0);\n\n        }\n\n        opn = \"lwxc1\";\n\n        break;\n\n    case OPC_LDXC1:\n\n        check_cop1x(ctx);\n\n        check_cp1_registers(ctx, fd);\n\n        {\n\n            TCGv_i64 fp0 = tcg_temp_new_i64();\n\n\n\n            tcg_gen_qemu_ld64(fp0, t0, ctx->mem_idx);\n\n            gen_store_fpr64(ctx, fp0, fd);\n\n            tcg_temp_free_i64(fp0);\n\n        }\n\n        opn = \"ldxc1\";\n\n        break;\n\n    case OPC_LUXC1:\n\n        check_cp1_64bitmode(ctx);\n\n        tcg_gen_andi_tl(t0, t0, ~0x7);\n\n        {\n\n            TCGv_i64 fp0 = tcg_temp_new_i64();\n\n\n\n            tcg_gen_qemu_ld64(fp0, t0, ctx->mem_idx);\n\n            gen_store_fpr64(ctx, fp0, fd);\n\n            tcg_temp_free_i64(fp0);\n\n        }\n\n        opn = \"luxc1\";\n\n        break;\n\n    case OPC_SWXC1:\n\n        check_cop1x(ctx);\n\n        {\n\n            TCGv_i32 fp0 = tcg_temp_new_i32();\n\n            TCGv t1 = tcg_temp_new();\n\n\n\n            gen_load_fpr32(fp0, fs);\n\n            tcg_gen_extu_i32_tl(t1, fp0);\n\n            tcg_gen_qemu_st32(t1, t0, ctx->mem_idx);\n\n            tcg_temp_free_i32(fp0);\n\n            tcg_temp_free_i32(t1);\n\n        }\n\n        opn = \"swxc1\";\n\n        store = 1;\n\n        break;\n\n    case OPC_SDXC1:\n\n        check_cop1x(ctx);\n\n        check_cp1_registers(ctx, fs);\n\n        {\n\n            TCGv_i64 fp0 = tcg_temp_new_i64();\n\n\n\n            gen_load_fpr64(ctx, fp0, fs);\n\n            tcg_gen_qemu_st64(fp0, t0, ctx->mem_idx);\n\n            tcg_temp_free_i64(fp0);\n\n        }\n\n        opn = \"sdxc1\";\n\n        store = 1;\n\n        break;\n\n    case OPC_SUXC1:\n\n        check_cp1_64bitmode(ctx);\n\n        tcg_gen_andi_tl(t0, t0, ~0x7);\n\n        {\n\n            TCGv_i64 fp0 = tcg_temp_new_i64();\n\n\n\n            gen_load_fpr64(ctx, fp0, fs);\n\n            tcg_gen_qemu_st64(fp0, t0, ctx->mem_idx);\n\n            tcg_temp_free_i64(fp0);\n\n        }\n\n        opn = \"suxc1\";\n\n        store = 1;\n\n        break;\n\n    }\n\n    tcg_temp_free(t0);\n\n    MIPS_DEBUG(\"%s %s, %s(%s)\", opn, fregnames[store ? fs : fd],\n\n               regnames[index], regnames[base]);\n\n}\n"},{"project":"qemu","commit_id":"caffdac363801cd2cf2bf01ad013a8c1e1e43800","target":1,"func":"static int virtio_blk_pci_init(VirtIOPCIProxy *vpci_dev)\n\n{\n\n    VirtIOBlkPCI *dev = VIRTIO_BLK_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n    virtio_blk_set_conf(vdev, &(dev->blk));\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"12de9a396acbc95e25c5d60ed097cc55777eaaed","target":1,"func":"static inline target_phys_addr_t get_pgaddr (target_phys_addr_t sdr1,\n\n                                             int sdr_sh,\n\n                                             target_phys_addr_t hash,\n\n                                             target_phys_addr_t mask)\n\n{\n\n    return (sdr1 & ((target_ulong)(-1ULL) << sdr_sh)) | (hash & mask);\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"minimac2_write(void *opaque, target_phys_addr_t addr, uint64_t value,\n\n               unsigned size)\n\n{\n\n    MilkymistMinimac2State *s = opaque;\n\n\n\n    trace_milkymist_minimac2_memory_read(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_MDIO:\n\n    {\n\n        \/* MDIO_DI is read only *\/\n\n        int mdio_di = (s->regs[R_MDIO] & MDIO_DI);\n\n        s->regs[R_MDIO] = value;\n\n        if (mdio_di) {\n\n            s->regs[R_MDIO] |= mdio_di;\n\n        } else {\n\n            s->regs[R_MDIO] &= ~mdio_di;\n\n        }\n\n\n\n        minimac2_update_mdio(s);\n\n    } break;\n\n    case R_TXCOUNT:\n\n        s->regs[addr] = value;\n\n        if (value > 0) {\n\n            minimac2_tx(s);\n\n        }\n\n        break;\n\n    case R_STATE0:\n\n    case R_STATE1:\n\n        s->regs[addr] = value;\n\n        update_rx_interrupt(s);\n\n        break;\n\n    case R_SETUP:\n\n    case R_COUNT0:\n\n    case R_COUNT1:\n\n        s->regs[addr] = value;\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_minimac2: write access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void cirrus_linear_write(void *opaque, target_phys_addr_t addr,\n\n                                uint64_t val, unsigned size)\n\n{\n\n    CirrusVGAState *s = opaque;\n\n    unsigned mode;\n\n\n\n    addr &= s->cirrus_addr_mask;\n\n\n\n    if (((s->vga.sr[0x17] & 0x44) == 0x44) &&\n\n        ((addr & s->linear_mmio_mask) ==  s->linear_mmio_mask)) {\n\n\t\/* memory-mapped I\/O *\/\n\n\tcirrus_mmio_blt_write(s, addr & 0xff, val);\n\n    } else if (s->cirrus_srcptr != s->cirrus_srcptr_end) {\n\n\t\/* bitblt *\/\n\n\t*s->cirrus_srcptr++ = (uint8_t) val;\n\n\tif (s->cirrus_srcptr >= s->cirrus_srcptr_end) {\n\n\t    cirrus_bitblt_cputovideo_next(s);\n\n\t}\n\n    } else {\n\n\t\/* video memory *\/\n\n\tif ((s->vga.gr[0x0B] & 0x14) == 0x14) {\n\n\t    addr <<= 4;\n\n\t} else if (s->vga.gr[0x0B] & 0x02) {\n\n\t    addr <<= 3;\n\n\t}\n\n\taddr &= s->cirrus_addr_mask;\n\n\n\n\tmode = s->vga.gr[0x05] & 0x7;\n\n\tif (mode < 4 || mode > 5 || ((s->vga.gr[0x0B] & 0x4) == 0)) {\n\n\t    *(s->vga.vram_ptr + addr) = (uint8_t) val;\n\n            memory_region_set_dirty(&s->vga.vram, addr, 1);\n\n\t} else {\n\n\t    if ((s->vga.gr[0x0B] & 0x14) != 0x14) {\n\n\t\tcirrus_mem_writeb_mode4and5_8bpp(s, mode, addr, val);\n\n\t    } else {\n\n\t\tcirrus_mem_writeb_mode4and5_16bpp(s, mode, addr, val);\n\n\t    }\n\n\t}\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"026aeffcb4752054830ba203020ed6eb05bcaba8","target":0,"func":"static int cirrus_bitblt_common_patterncopy(CirrusVGAState *s, bool videosrc)\n\n{\n\n    uint32_t patternsize;\n\n    uint8_t *dst;\n\n    uint8_t *src;\n\n\n\n    dst = s->vga.vram_ptr + s->cirrus_blt_dstaddr;\n\n\n\n    if (videosrc) {\n\n        switch (s->vga.get_bpp(&s->vga)) {\n\n        case 8:\n\n            patternsize = 64;\n\n            break;\n\n        case 15:\n\n        case 16:\n\n            patternsize = 128;\n\n            break;\n\n        case 24:\n\n        case 32:\n\n        default:\n\n            patternsize = 256;\n\n            break;\n\n        }\n\n        s->cirrus_blt_srcaddr &= ~(patternsize - 1);\n\n        if (s->cirrus_blt_srcaddr + patternsize > s->vga.vram_size) {\n\n            return 0;\n\n        }\n\n        src = s->vga.vram_ptr + s->cirrus_blt_srcaddr;\n\n    } else {\n\n        src = s->cirrus_bltbuf;\n\n    }\n\n\n\n    if (blit_is_unsafe(s, true)) {\n\n        return 0;\n\n    }\n\n\n\n    (*s->cirrus_rop) (s, dst, src,\n\n                      s->cirrus_blt_dstpitch, 0,\n\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n                             s->cirrus_blt_height);\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"b3ceef24f4fee8d5ed96b8c4a5d3e80c0a651f0b","target":0,"func":"static void tcx_update_display(void *opaque)\n\n{\n\n    TCXState *ts = opaque;\n\n    ram_addr_t page, page_min, page_max;\n\n    int y, y_start, dd, ds;\n\n    uint8_t *d, *s;\n\n    void (*f)(TCXState *s1, uint8_t *d, const uint8_t *s, int width);\n\n\n\n    if (ts->ds->depth == 0)\n\n\treturn;\n\n    page = ts->vram_offset;\n\n    y_start = -1;\n\n    page_min = 0xffffffff;\n\n    page_max = 0;\n\n    d = ts->ds->data;\n\n    s = ts->vram;\n\n    dd = ts->ds->linesize;\n\n    ds = 1024;\n\n\n\n    switch (ts->ds->depth) {\n\n    case 32:\n\n\tf = tcx_draw_line32;\n\n\tbreak;\n\n    case 15:\n\n    case 16:\n\n\tf = tcx_draw_line16;\n\n\tbreak;\n\n    default:\n\n    case 8:\n\n\tf = tcx_draw_line8;\n\n\tbreak;\n\n    case 0:\n\n\treturn;\n\n    }\n\n    \n\n    for(y = 0; y < ts->height; y += 4, page += TARGET_PAGE_SIZE) {\n\n\tif (cpu_physical_memory_get_dirty(page, VGA_DIRTY_FLAG)) {\n\n\t    if (y_start < 0)\n\n                y_start = y;\n\n            if (page < page_min)\n\n                page_min = page;\n\n            if (page > page_max)\n\n                page_max = page;\n\n\t    f(ts, d, s, ts->width);\n\n\t    d += dd;\n\n\t    s += ds;\n\n\t    f(ts, d, s, ts->width);\n\n\t    d += dd;\n\n\t    s += ds;\n\n\t    f(ts, d, s, ts->width);\n\n\t    d += dd;\n\n\t    s += ds;\n\n\t    f(ts, d, s, ts->width);\n\n\t    d += dd;\n\n\t    s += ds;\n\n\t} else {\n\n            if (y_start >= 0) {\n\n                \/* flush to display *\/\n\n                dpy_update(ts->ds, 0, y_start, \n\n                           ts->width, y - y_start);\n\n                y_start = -1;\n\n            }\n\n\t    d += dd * 4;\n\n\t    s += ds * 4;\n\n\t}\n\n    }\n\n    if (y_start >= 0) {\n\n\t\/* flush to display *\/\n\n\tdpy_update(ts->ds, 0, y_start, \n\n\t\t   ts->width, y - y_start);\n\n    }\n\n    \/* reset modified pages *\/\n\n    if (page_min <= page_max) {\n\n        cpu_physical_memory_reset_dirty(page_min, page_max + TARGET_PAGE_SIZE,\n\n                                        VGA_DIRTY_FLAG);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"80624c938d2d9d2b2cca56326876f213c31e1202","target":0,"func":"static void scsi_dma_complete(void *opaque, int ret)\n\n{\n\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    bdrv_acct_done(s->qdev.conf.bs, &r->acct);\n\n\n\n    if (ret) {\n\n        if (scsi_handle_rw_error(r, -ret)) {\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    r->sector += r->sector_count;\n\n    r->sector_count = 0;\n\n    scsi_req_complete(&r->req, GOOD);\n\n\n\ndone:\n\n    if (!r->req.io_canceled) {\n\n        scsi_req_unref(&r->req);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"88266f5aa70fa71fd5cc20aa4dbeb7a7bd8d2e92","target":0,"func":"void bdrv_io_limits_enable(BlockDriverState *bs)\n\n{\n\n    qemu_co_queue_init(&bs->throttled_reqs);\n\n    bs->block_timer = qemu_new_timer_ns(vm_clock, bdrv_block_timer, bs);\n\n    bs->io_limits_enabled = true;\n\n}\n"},{"project":"qemu","commit_id":"079019f2e319bd1279681b6c1d7dde785d09e69e","target":0,"func":"static void spapr_machine_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_CLASS(oc);\n\n    FWPathProviderClass *fwc = FW_PATH_PROVIDER_CLASS(oc);\n\n    NMIClass *nc = NMI_CLASS(oc);\n\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);\n\n\n\n    mc->desc = \"pSeries Logical Partition (PAPR compliant)\";\n\n\n\n    \/*\n\n     * We set up the default \/ latest behaviour here.  The class_init\n\n     * functions for the specific versioned machine types can override\n\n     * these details for backwards compatibility\n\n     *\/\n\n    mc->init = ppc_spapr_init;\n\n    mc->reset = ppc_spapr_reset;\n\n    mc->block_default_type = IF_SCSI;\n\n    mc->max_cpus = MAX_CPUMASK_BITS;\n\n    mc->no_parallel = 1;\n\n    mc->default_boot_order = \"\";\n\n    mc->default_ram_size = 512 * M_BYTE;\n\n    mc->kvm_type = spapr_kvm_type;\n\n    mc->has_dynamic_sysbus = true;\n\n    mc->pci_allow_0_address = true;\n\n    mc->get_hotplug_handler = spapr_get_hotplug_handler;\n\n    hc->pre_plug = spapr_machine_device_pre_plug;\n\n    hc->plug = spapr_machine_device_plug;\n\n    hc->unplug = spapr_machine_device_unplug;\n\n    mc->cpu_index_to_socket_id = spapr_cpu_index_to_socket_id;\n\n\n\n    smc->dr_lmb_enabled = true;\n\n    smc->tcg_default_cpu = \"POWER8\";\n\n    mc->query_hotpluggable_cpus = spapr_query_hotpluggable_cpus;\n\n    fwc->get_dev_path = spapr_get_fw_dev_path;\n\n    nc->nmi_monitor_handler = spapr_nmi;\n\n    smc->phb_placement = spapr_phb_placement;\n\n}\n"},{"project":"qemu","commit_id":"a942d8fa01f65279cdc135f4294db611bbc088ef","target":1,"func":"static void json_message_process_token(JSONLexer *lexer, GString *input,\n\n                                       JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    JSONToken *token;\n\n\n\n    switch (type) {\n\n    case JSON_LCURLY:\n\n        parser->brace_count++;\n\n        break;\n\n    case JSON_RCURLY:\n\n        parser->brace_count--;\n\n        break;\n\n    case JSON_LSQUARE:\n\n        parser->bracket_count++;\n\n        break;\n\n    case JSON_RSQUARE:\n\n        parser->bracket_count--;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    token = g_malloc(sizeof(JSONToken) + input->len + 1);\n\n    token->type = type;\n\n    memcpy(token->str, input->str, input->len);\n\n    token->str[input->len] = 0;\n\n    token->x = x;\n\n    token->y = y;\n\n\n\n    parser->token_size += input->len;\n\n\n\n    g_queue_push_tail(parser->tokens, token);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               g_queue_get_length(parser->tokens) > MAX_TOKEN_COUNT ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        \/* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         *\/\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    \/*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     *\/\n\n    json_message_free_tokens(parser);\n\nout_emit:\n\n    \/* send current list of tokens to parser and reset tokenizer *\/\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    \/* parser->emit takes ownership of parser->tokens.  *\/\n\n    parser->emit(parser, parser->tokens);\n\n    parser->tokens = g_queue_new();\n\n    parser->token_size = 0;\n\n}\n"},{"project":"qemu","commit_id":"2db59a76c421cdd1039d10e32a9798952d3ff5ba","target":1,"func":"static void gen_advance_ccount_cond(DisasContext *dc)\n\n{\n\n    if (dc->ccount_delta > 0) {\n\n        TCGv_i32 tmp = tcg_const_i32(dc->ccount_delta);\n\n        gen_helper_advance_ccount(cpu_env, tmp);\n\n        tcg_temp_free(tmp);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"c2b38b277a7882a592f4f2ec955084b2b756daaa","target":0,"func":"static void glib_pollfds_fill(int64_t *cur_timeout)\n\n{\n\n    GMainContext *context = g_main_context_default();\n\n    int timeout = 0;\n\n    int64_t timeout_ns;\n\n    int n;\n\n\n\n    g_main_context_prepare(context, &max_priority);\n\n\n\n    glib_pollfds_idx = gpollfds->len;\n\n    n = glib_n_poll_fds;\n\n    do {\n\n        GPollFD *pfds;\n\n        glib_n_poll_fds = n;\n\n        g_array_set_size(gpollfds, glib_pollfds_idx + glib_n_poll_fds);\n\n        pfds = &g_array_index(gpollfds, GPollFD, glib_pollfds_idx);\n\n        n = g_main_context_query(context, max_priority, &timeout, pfds,\n\n                                 glib_n_poll_fds);\n\n    } while (n != glib_n_poll_fds);\n\n\n\n    if (timeout < 0) {\n\n        timeout_ns = -1;\n\n    } else {\n\n        timeout_ns = (int64_t)timeout * (int64_t)SCALE_MS;\n\n    }\n\n\n\n    *cur_timeout = qemu_soonest_timeout(timeout_ns, *cur_timeout);\n\n}\n"},{"project":"qemu","commit_id":"f9749f28b78be36471d3d0f5d4b6eed030f8942e","target":0,"func":"static int coroutine_fn is_allocated_base(BlockDriverState *top,\n\n                                          BlockDriverState *base,\n\n                                          int64_t sector_num,\n\n                                          int nb_sectors, int *pnum)\n\n{\n\n    BlockDriverState *intermediate;\n\n    int ret, n;\n\n\n\n    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);\n\n    if (ret) {\n\n        *pnum = n;\n\n        return ret;\n\n    }\n\n\n\n    \/*\n\n     * Is the unallocated chunk [sector_num, n] also\n\n     * unallocated between base and top?\n\n     *\/\n\n    intermediate = top->backing_hd;\n\n\n\n    while (intermediate != base) {\n\n        int pnum_inter;\n\n\n\n        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,\n\n                                   &pnum_inter);\n\n        if (ret < 0) {\n\n            return ret;\n\n        } else if (ret) {\n\n            *pnum = pnum_inter;\n\n            return 0;\n\n        }\n\n\n\n        \/*\n\n         * [sector_num, nb_sectors] is unallocated on top but intermediate\n\n         * might have\n\n         *\n\n         * [sector_num+x, nr_sectors] allocated.\n\n         *\/\n\n        if (n > pnum_inter) {\n\n            n = pnum_inter;\n\n        }\n\n\n\n        intermediate = intermediate->backing_hd;\n\n    }\n\n\n\n    *pnum = n;\n\n    return 1;\n\n}\n"},{"project":"qemu","commit_id":"d5bfda334adf9af62df5709cdac38f523f815f47","target":0,"func":"void cpu_x86_inject_mce(Monitor *mon, CPUState *cenv, int bank,\n\n                        uint64_t status, uint64_t mcg_status, uint64_t addr,\n\n                        uint64_t misc, int flags)\n\n{\n\n    unsigned bank_num = cenv->mcg_cap & 0xff;\n\n    CPUState *env;\n\n    int flag = 0;\n\n\n\n    if (!cenv->mcg_cap) {\n\n        monitor_printf(mon, \"MCE injection not supported\\n\");\n\n        return;\n\n    }\n\n    if (bank >= bank_num) {\n\n        monitor_printf(mon, \"Invalid MCE bank number\\n\");\n\n        return;\n\n    }\n\n    if (!(status & MCI_STATUS_VAL)) {\n\n        monitor_printf(mon, \"Invalid MCE status code\\n\");\n\n        return;\n\n    }\n\n    if ((flags & MCE_INJECT_BROADCAST)\n\n        && !cpu_x86_support_mca_broadcast(cenv)) {\n\n        monitor_printf(mon, \"Guest CPU does not support MCA broadcast\\n\");\n\n        return;\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        if (flags & MCE_INJECT_BROADCAST) {\n\n            flag |= MCE_BROADCAST;\n\n        }\n\n\n\n        kvm_inject_x86_mce(cenv, bank, status, mcg_status, addr, misc, flag);\n\n    } else {\n\n        qemu_inject_x86_mce(mon, cenv, bank, status, mcg_status, addr, misc,\n\n                            flags);\n\n        if (flags & MCE_INJECT_BROADCAST) {\n\n            for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n                if (cenv == env) {\n\n                    continue;\n\n                }\n\n                qemu_inject_x86_mce(mon, env, 1,\n\n                                    MCI_STATUS_VAL | MCI_STATUS_UC,\n\n                                    MCG_STATUS_MCIP | MCG_STATUS_RIPV, 0, 0,\n\n                                    flags);\n\n            }\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"805b5d98c649d26fc44d2d7755a97f18e62b438a","target":1,"func":"static void v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n    if (!err) {\n        err = offset;\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    v9fs_string_free(&name);\n    pdu_complete(pdu, err);"},{"project":"qemu","commit_id":"7d553f27fce284805d7f94603932045ee3bbb979","target":0,"func":"static int usb_qdev_init(DeviceState *qdev)\n\n{\n\n    USBDevice *dev = USB_DEVICE(qdev);\n\n    int rc;\n\n\n\n    pstrcpy(dev->product_desc, sizeof(dev->product_desc),\n\n            usb_device_get_product_desc(dev));\n\n    dev->auto_attach = 1;\n\n    QLIST_INIT(&dev->strings);\n\n    usb_ep_init(dev);\n\n    rc = usb_claim_port(dev);\n\n    if (rc != 0) {\n\n        return rc;\n\n    }\n\n    rc = usb_device_init(dev);\n\n    if (rc != 0) {\n\n        usb_release_port(dev);\n\n        return rc;\n\n    }\n\n    if (dev->auto_attach) {\n\n        rc = usb_device_attach(dev);\n\n        if (rc != 0) {\n\n            usb_qdev_exit(qdev);\n\n            return rc;\n\n        }\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"95ed56939eb2eaa4e2f349fe6dcd13ca4edfd8fb","target":0,"func":"static int ohci_service_ed_list(OHCIState *ohci, uint32_t head, int completion)\n\n{\n\n    struct ohci_ed ed;\n\n    uint32_t next_ed;\n\n    uint32_t cur;\n\n    int active;\n\n\n\n    active = 0;\n\n\n\n    if (head == 0)\n\n        return 0;\n\n\n\n    for (cur = head; cur; cur = next_ed) {\n\n        if (ohci_read_ed(ohci, cur, &ed)) {\n\n            trace_usb_ohci_ed_read_error(cur);\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n\n\n        next_ed = ed.next & OHCI_DPTR_MASK;\n\n\n\n        if ((ed.head & OHCI_ED_H) || (ed.flags & OHCI_ED_K)) {\n\n            uint32_t addr;\n\n            \/* Cancel pending packets for ED that have been paused.  *\/\n\n            addr = ed.head & OHCI_DPTR_MASK;\n\n            if (ohci->async_td && addr == ohci->async_td) {\n\n                usb_cancel_packet(&ohci->usb_packet);\n\n                ohci->async_td = 0;\n\n                usb_device_ep_stopped(ohci->usb_packet.ep->dev,\n\n                                      ohci->usb_packet.ep);\n\n            }\n\n            continue;\n\n        }\n\n\n\n        while ((ed.head & OHCI_DPTR_MASK) != ed.tail) {\n\n            trace_usb_ohci_ed_pkt(cur, (ed.head & OHCI_ED_H) != 0,\n\n                    (ed.head & OHCI_ED_C) != 0, ed.head & OHCI_DPTR_MASK,\n\n                    ed.tail & OHCI_DPTR_MASK, ed.next & OHCI_DPTR_MASK);\n\n            trace_usb_ohci_ed_pkt_flags(\n\n                    OHCI_BM(ed.flags, ED_FA), OHCI_BM(ed.flags, ED_EN),\n\n                    OHCI_BM(ed.flags, ED_D), (ed.flags & OHCI_ED_S)!= 0,\n\n                    (ed.flags & OHCI_ED_K) != 0, (ed.flags & OHCI_ED_F) != 0,\n\n                    OHCI_BM(ed.flags, ED_MPS));\n\n\n\n            active = 1;\n\n\n\n            if ((ed.flags & OHCI_ED_F) == 0) {\n\n                if (ohci_service_td(ohci, &ed))\n\n                    break;\n\n            } else {\n\n                \/* Handle isochronous endpoints *\/\n\n                if (ohci_service_iso_td(ohci, &ed, completion))\n\n                    break;\n\n            }\n\n        }\n\n\n\n        if (ohci_put_ed(ohci, cur, &ed)) {\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return active;\n\n}\n"},{"project":"qemu","commit_id":"d70724cec84ff99ffc7f70dd567466acf228b389","target":1,"func":"static void dump_op_count(void)\n\n{\n\n    int i;\n\n    FILE *f;\n\n    f = fopen(\"\/tmp\/op.log\", \"w\");\n\n    for(i = INDEX_op_end; i < NB_OPS; i++) {\n\n        fprintf(f, \"%s %\" PRId64 \"\\n\", tcg_op_defs[i].name, tcg_table_op_count[i]);\n\n    }\n\n    fclose(f);\n\n}\n"},{"project":"qemu","commit_id":"9b2fadda3e0196ffd485adde4fe9cdd6fae35300","target":1,"func":"static void gen_rac(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n    gen_helper_rac(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n#endif\n\n}\n"},{"project":"qemu","commit_id":"3c85e74fbf9e5a39d8d13ef91a5f3dd91f0bc8a8","target":1,"func":"int kvm_arch_init(KVMState *s)\n\n{\n\n    uint64_t identity_base = 0xfffbc000;\n\n    int ret;\n\n    struct utsname utsname;\n\n\n\n    ret = kvm_get_supported_msrs(s);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    uname(&utsname);\n\n    lm_capable_kernel = strcmp(utsname.machine, \"x86_64\") == 0;\n\n\n\n    \/*\n\n     * On older Intel CPUs, KVM uses vm86 mode to emulate 16-bit code directly.\n\n     * In order to use vm86 mode, an EPT identity map and a TSS  are needed.\n\n     * Since these must be part of guest physical memory, we need to allocate\n\n     * them, both by setting their start addresses in the kernel and by\n\n     * creating a corresponding e820 entry. We need 4 pages before the BIOS.\n\n     *\n\n     * Older KVM versions may not support setting the identity map base. In\n\n     * that case we need to stick with the default, i.e. a 256K maximum BIOS\n\n     * size.\n\n     *\/\n\n#ifdef KVM_CAP_SET_IDENTITY_MAP_ADDR\n\n    if (kvm_check_extension(s, KVM_CAP_SET_IDENTITY_MAP_ADDR)) {\n\n        \/* Allows up to 16M BIOSes. *\/\n\n        identity_base = 0xfeffc000;\n\n\n\n        ret = kvm_vm_ioctl(s, KVM_SET_IDENTITY_MAP_ADDR, &identity_base);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n#endif\n\n    \/* Set TSS base one page after EPT identity map. *\/\n\n    ret = kvm_vm_ioctl(s, KVM_SET_TSS_ADDR, identity_base + 0x1000);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* Tell fw_cfg to notify the BIOS to reserve the range. *\/\n\n    ret = e820_add_entry(identity_base, 0x4000, E820_RESERVED);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"e820_add_entry() table is full\\n\");\n\n        return ret;\n\n    }\n\n\n\n\n    return 0;\n\n}"},{"project":"qemu","commit_id":"2d26512b45b5236fa521c4492608fe9fb5bedf46","target":0,"func":"int cksum(struct mbuf *m, int len)\n\n{\n\n\tregister uint16_t *w;\n\n\tregister int sum = 0;\n\n\tregister int mlen = 0;\n\n\tint byte_swapped = 0;\n\n\n\n\tunion {\n\n\t\tuint8_t  c[2];\n\n\t\tuint16_t s;\n\n\t} s_util;\n\n\tunion {\n\n\t\tuint16_t s[2];\n\n\t\tuint32_t l;\n\n\t} l_util;\n\n\n\n\tif (m->m_len == 0)\n\n\t   goto cont;\n\n\tw = mtod(m, uint16_t *);\n\n\n\n\tmlen = m->m_len;\n\n\n\n\tif (len < mlen)\n\n\t   mlen = len;\n\n#ifdef DEBUG\n\n\tlen -= mlen;\n\n#endif\n\n\t\/*\n\n\t * Force to even boundary.\n\n\t *\/\n\n\tif ((1 & (long) w) && (mlen > 0)) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\ts_util.c[0] = *(uint8_t *)w;\n\n\t\tw = (uint16_t *)((int8_t *)w + 1);\n\n\t\tmlen--;\n\n\t\tbyte_swapped = 1;\n\n\t}\n\n\t\/*\n\n\t * Unroll the loop to make overhead from\n\n\t * branches &c small.\n\n\t *\/\n\n\twhile ((mlen -= 32) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tsum += w[4]; sum += w[5]; sum += w[6]; sum += w[7];\n\n\t\tsum += w[8]; sum += w[9]; sum += w[10]; sum += w[11];\n\n\t\tsum += w[12]; sum += w[13]; sum += w[14]; sum += w[15];\n\n\t\tw += 16;\n\n\t}\n\n\tmlen += 32;\n\n\twhile ((mlen -= 8) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tw += 4;\n\n\t}\n\n\tmlen += 8;\n\n\tif (mlen == 0 && byte_swapped == 0)\n\n\t   goto cont;\n\n\tREDUCE;\n\n\twhile ((mlen -= 2) >= 0) {\n\n\t\tsum += *w++;\n\n\t}\n\n\n\n\tif (byte_swapped) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\tif (mlen == -1) {\n\n\t\t\ts_util.c[1] = *(uint8_t *)w;\n\n\t\t\tsum += s_util.s;\n\n\t\t\tmlen = 0;\n\n\t\t} else\n\n\n\n\t\t   mlen = -1;\n\n\t} else if (mlen == -1)\n\n\t   s_util.c[0] = *(uint8_t *)w;\n\n\n\ncont:\n\n#ifdef DEBUG\n\n\tif (len) {\n\n\t\tDEBUG_ERROR((dfd, \"cksum: out of data\\n\"));\n\n\t\tDEBUG_ERROR((dfd, \" len = %d\\n\", len));\n\n\t}\n\n#endif\n\n\tif (mlen == -1) {\n\n\t\t\/* The last mbuf has odd # of bytes. Follow the\n\n\t\t standard (the odd byte may be shifted left by 8 bits\n\n\t\t\t   or not as determined by endian-ness of the machine) *\/\n\n\t\ts_util.c[1] = 0;\n\n\t\tsum += s_util.s;\n\n\t}\n\n\tREDUCE;\n\n\treturn (~sum & 0xffff);\n\n}\n"},{"project":"qemu","commit_id":"e1cf5582644ef63528993fb2b88dd3b43b9914c6","target":1,"func":"void qemu_iovec_init(QEMUIOVector *qiov, int alloc_hint)\n\n{\n\n    qiov->iov = g_malloc(alloc_hint * sizeof(struct iovec));\n\n    qiov->niov = 0;\n\n    qiov->nalloc = alloc_hint;\n\n    qiov->size = 0;\n\n}\n"},{"project":"qemu","commit_id":"e23a1b33b53d25510320b26d9f154e19c6c99725","target":1,"func":"void pci_cmd646_ide_init(PCIBus *bus, DriveInfo **hd_table,\n\n                         int secondary_ide_enabled)\n\n{\n\n    PCIDevice *dev;\n\n\n\n    dev = pci_create(bus, -1, \"CMD646 IDE\");\n\n    qdev_prop_set_uint32(&dev->qdev, \"secondary\", secondary_ide_enabled);\n\n    qdev_init(&dev->qdev);\n\n\n\n    pci_ide_create_devs(dev, hd_table);\n\n}\n"},{"project":"qemu","commit_id":"4295f879becfbbb9f4330489311586b96915d920","target":1,"func":"static int check_strtox_error(const char *p, char *endptr, const char **next,\n\n                              int err)\n\n{\n\n    \/* If no conversion was performed, prefer BSD behavior over glibc\n\n     * behavior.\n\n     *\/\n\n    if (err == 0 && endptr == p) {\n\n        err = EINVAL;\n\n    }\n\n    if (!next && *endptr) {\n\n        return -EINVAL;\n\n    }\n\n    if (next) {\n\n        *next = endptr;\n\n    }\n\n    return -err;\n\n}\n"},{"project":"qemu","commit_id":"02ce232c5051854bf49e6d2816c65e00f6d7e036","target":1,"func":"static void qemu_clock_init(QEMUClockType type)\n{\n    QEMUClock *clock = qemu_clock_ptr(type);\n    clock->type = type;\n    clock->enabled = true;\n    clock->last = INT64_MIN;\n    QLIST_INIT(&clock->timerlists);\n    notifier_list_init(&clock->reset_notifiers);\n    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);\n}"},{"project":"qemu","commit_id":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0,"func":"static void virtio_blk_device_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOBlock *s = VIRTIO_BLK(dev);\n\n    VirtIOBlkConf *conf = &s->conf;\n\n    Error *err = NULL;\n\n    static int virtio_blk_id;\n\n\n\n    if (!conf->conf.bs) {\n\n        error_setg(errp, \"drive property not set\");\n\n        return;\n\n    }\n\n    if (!bdrv_is_inserted(conf->conf.bs)) {\n\n        error_setg(errp, \"Device needs media, but drive is empty\");\n\n        return;\n\n    }\n\n\n\n    blkconf_serial(&conf->conf, &conf->serial);\n\n    s->original_wce = bdrv_enable_write_cache(conf->conf.bs);\n\n    blkconf_geometry(&conf->conf, NULL, 65535, 255, 255, &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    virtio_init(vdev, \"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                sizeof(struct virtio_blk_config));\n\n\n\n    s->bs = conf->conf.bs;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf.conf.logical_block_size \/ BDRV_SECTOR_SIZE) - 1;\n\n\n\n    s->vq = virtio_add_queue(vdev, 128, virtio_blk_handle_output);\n\n    s->complete_request = virtio_blk_complete_request;\n\n    virtio_blk_data_plane_create(vdev, conf, &s->dataplane, &err);\n\n    if (err != NULL) {\n\n        error_propagate(errp, err);\n\n        virtio_cleanup(vdev);\n\n        return;\n\n    }\n\n    s->migration_state_notifier.notify = virtio_blk_migration_state_changed;\n\n    add_migration_state_change_notifier(&s->migration_state_notifier);\n\n\n\n    s->change = qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_guest_block_size(s->bs, s->conf.conf.logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n}\n"},{"project":"qemu","commit_id":"42e5f39378c6e7a0ada563779bbb6f470f7c03ff","target":1,"func":"int main(int argc, char **argv, char **envp)\n    int i;\n    int snapshot, linux_boot;\n    const char *initrd_filename;\n    const char *kernel_filename, *kernel_cmdline;\n    const char *boot_order = NULL;\n    const char *boot_once = NULL;\n    DisplayState *ds;\n    int cyls, heads, secs, translation;\n    QemuOpts *opts, *machine_opts;\n    QemuOpts *hda_opts = NULL, *icount_opts = NULL, *accel_opts = NULL;\n    QemuOptsList *olist;\n    int optind;\n    const char *optarg;\n    const char *loadvm = NULL;\n    MachineClass *machine_class;\n    const char *cpu_model;\n    const char *vga_model = NULL;\n    const char *qtest_chrdev = NULL;\n    const char *qtest_log = NULL;\n    const char *pid_file = NULL;\n    const char *incoming = NULL;\n    bool defconfig = true;\n    bool userconfig = true;\n    bool nographic = false;\n    DisplayType display_type = DT_DEFAULT;\n    int display_remote = 0;\n    const char *log_mask = NULL;\n    const char *log_file = NULL;\n    char *trace_file = NULL;\n    ram_addr_t maxram_size;\n    uint64_t ram_slots = 0;\n    FILE *vmstate_dump_file = NULL;\n    Error *main_loop_err = NULL;\n    Error *err = NULL;\n    bool list_data_dirs = false;\n    typedef struct BlockdevOptions_queue {\n        BlockdevOptions *bdo;\n        Location loc;\n        QSIMPLEQ_ENTRY(BlockdevOptions_queue) entry;\n    } BlockdevOptions_queue;\n    QSIMPLEQ_HEAD(, BlockdevOptions_queue) bdo_queue\n        = QSIMPLEQ_HEAD_INITIALIZER(bdo_queue);\n    module_call_init(MODULE_INIT_TRACE);\n    qemu_init_cpu_list();\n    qemu_init_cpu_loop();\n    qemu_mutex_lock_iothread();\n    atexit(qemu_run_exit_notifiers);\n    error_set_progname(argv[0]);\n    qemu_init_exec_dir(argv[0]);\n    module_call_init(MODULE_INIT_QOM);\n    monitor_init_qmp_commands();\n    qemu_add_opts(&qemu_drive_opts);\n    qemu_add_drive_opts(&qemu_legacy_drive_opts);\n    qemu_add_drive_opts(&qemu_common_drive_opts);\n    qemu_add_drive_opts(&qemu_drive_opts);\n    qemu_add_drive_opts(&bdrv_runtime_opts);\n    qemu_add_opts(&qemu_chardev_opts);\n    qemu_add_opts(&qemu_device_opts);\n    qemu_add_opts(&qemu_netdev_opts);\n    qemu_add_opts(&qemu_net_opts);\n    qemu_add_opts(&qemu_rtc_opts);\n    qemu_add_opts(&qemu_global_opts);\n    qemu_add_opts(&qemu_mon_opts);\n    qemu_add_opts(&qemu_trace_opts);\n    qemu_add_opts(&qemu_option_rom_opts);\n    qemu_add_opts(&qemu_machine_opts);\n    qemu_add_opts(&qemu_accel_opts);\n    qemu_add_opts(&qemu_mem_opts);\n    qemu_add_opts(&qemu_smp_opts);\n    qemu_add_opts(&qemu_boot_opts);\n    qemu_add_opts(&qemu_sandbox_opts);\n    qemu_add_opts(&qemu_add_fd_opts);\n    qemu_add_opts(&qemu_object_opts);\n    qemu_add_opts(&qemu_tpmdev_opts);\n    qemu_add_opts(&qemu_realtime_opts);\n    qemu_add_opts(&qemu_msg_opts);\n    qemu_add_opts(&qemu_name_opts);\n    qemu_add_opts(&qemu_numa_opts);\n    qemu_add_opts(&qemu_icount_opts);\n    qemu_add_opts(&qemu_semihosting_config_opts);\n    qemu_add_opts(&qemu_fw_cfg_opts);\n    module_call_init(MODULE_INIT_OPTS);\n    runstate_init();\n    if (qcrypto_init(&err) < 0) {\n        error_reportf_err(err, \"cannot initialize crypto: \");\n    rtc_clock = QEMU_CLOCK_HOST;\n    QLIST_INIT (&vm_change_state_head);\n    os_setup_early_signal_handling();\n    cpu_model = NULL;\n    snapshot = 0;\n    cyls = heads = secs = 0;\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n    nb_nics = 0;\n    bdrv_init_with_whitelist();\n    autostart = 1;\n    \/* first pass of option parsing *\/\n    optind = 1;\n    while (optind < argc) {\n        if (argv[optind][0] != '-') {\n            \/* disk image *\/\n            optind++;\n        } else {\n            const QEMUOption *popt;\n            popt = lookup_opt(argc, argv, &optarg, &optind);\n            switch (popt->index) {\n            case QEMU_OPTION_nodefconfig:\n                defconfig = false;\n            case QEMU_OPTION_nouserconfig:\n                userconfig = false;\n    if (defconfig && userconfig) {\n        if (qemu_read_default_config_file() < 0) {\n    \/* second pass of option parsing *\/\n    optind = 1;\n    for(;;) {\n        if (optind >= argc)\n        if (argv[optind][0] != '-') {\n            hda_opts = drive_add(IF_DEFAULT, 0, argv[optind++], HD_OPTS);\n        } else {\n            const QEMUOption *popt;\n            popt = lookup_opt(argc, argv, &optarg, &optind);\n            if (!(popt->arch_mask & arch_type)) {\n                error_report(\"Option not supported for this target\");\n            switch(popt->index) {\n            case QEMU_OPTION_no_kvm_irqchip: {\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"kernel_irqchip=off\", false);\n            case QEMU_OPTION_cpu:\n                \/* hw initialization will check this *\/\n                cpu_model = optarg;\n            case QEMU_OPTION_hda:\n                    char buf[256];\n                    if (cyls == 0)\n                        snprintf(buf, sizeof(buf), \"%s\", HD_OPTS);\n                    else\n                        snprintf(buf, sizeof(buf),\n                                 \"%s,cyls=%d,heads=%d,secs=%d%s\",\n                                 HD_OPTS , cyls, heads, secs,\n                                 translation == BIOS_ATA_TRANSLATION_LBA ?\n                                 \",trans=lba\" :\n                                 translation == BIOS_ATA_TRANSLATION_NONE ?\n                                 \",trans=none\" : \"\");\n                    drive_add(IF_DEFAULT, 0, optarg, buf);\n            case QEMU_OPTION_hdb:\n            case QEMU_OPTION_hdc:\n            case QEMU_OPTION_hdd:\n                drive_add(IF_DEFAULT, popt->index - QEMU_OPTION_hda, optarg,\n                          HD_OPTS);\n            case QEMU_OPTION_drive:\n                if (drive_def(optarg) == NULL) {\n            case QEMU_OPTION_set:\n                if (qemu_set_option(optarg) != 0)\n            case QEMU_OPTION_global:\n                if (qemu_global_option(optarg) != 0)\n            case QEMU_OPTION_mtdblock:\n                drive_add(IF_MTD, -1, optarg, MTD_OPTS);\n            case QEMU_OPTION_sd:\n                drive_add(IF_SD, -1, optarg, SD_OPTS);\n            case QEMU_OPTION_pflash:\n                drive_add(IF_PFLASH, -1, optarg, PFLASH_OPTS);\n            case QEMU_OPTION_snapshot:\n                snapshot = 1;\n            case QEMU_OPTION_hdachs:\n                    const char *p;\n                    p = optarg;\n                    cyls = strtol(p, (char **)&p, 0);\n                    if (cyls < 1 || cyls > 16383)\n                        goto chs_fail;\n                    if (*p != ',')\n                        goto chs_fail;\n                    p++;\n                    heads = strtol(p, (char **)&p, 0);\n                    if (heads < 1 || heads > 16)\n                        goto chs_fail;\n                    if (*p != ',')\n                        goto chs_fail;\n                    p++;\n                    secs = strtol(p, (char **)&p, 0);\n                    if (secs < 1 || secs > 63)\n                        goto chs_fail;\n                    if (*p == ',') {\n                        p++;\n                        if (!strcmp(p, \"large\")) {\n                            translation = BIOS_ATA_TRANSLATION_LARGE;\n                        } else if (!strcmp(p, \"rechs\")) {\n                            translation = BIOS_ATA_TRANSLATION_RECHS;\n                        } else if (!strcmp(p, \"none\")) {\n                            translation = BIOS_ATA_TRANSLATION_NONE;\n                        } else if (!strcmp(p, \"lba\")) {\n                            translation = BIOS_ATA_TRANSLATION_LBA;\n                        } else if (!strcmp(p, \"auto\")) {\n                            translation = BIOS_ATA_TRANSLATION_AUTO;\n                        } else {\n                            goto chs_fail;\n                    } else if (*p != '\\0') {\n                    chs_fail:\n                        error_report(\"invalid physical CHS format\");\n                    if (hda_opts != NULL) {\n                        qemu_opt_set_number(hda_opts, \"cyls\", cyls,\n                                            &error_abort);\n                        qemu_opt_set_number(hda_opts, \"heads\", heads,\n                                            &error_abort);\n                        qemu_opt_set_number(hda_opts, \"secs\", secs,\n                                            &error_abort);\n                        if (translation == BIOS_ATA_TRANSLATION_LARGE) {\n                            qemu_opt_set(hda_opts, \"trans\", \"large\",\n                                         &error_abort);\n                        } else if (translation == BIOS_ATA_TRANSLATION_RECHS) {\n                            qemu_opt_set(hda_opts, \"trans\", \"rechs\",\n                                         &error_abort);\n                        } else if (translation == BIOS_ATA_TRANSLATION_LBA) {\n                            qemu_opt_set(hda_opts, \"trans\", \"lba\",\n                                         &error_abort);\n                        } else if (translation == BIOS_ATA_TRANSLATION_NONE) {\n                            qemu_opt_set(hda_opts, \"trans\", \"none\",\n                                         &error_abort);\n            case QEMU_OPTION_numa:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"numa\"),\n                                               optarg, true);\n                if (!opts) {\n            case QEMU_OPTION_display:\n                display_type = select_display(optarg);\n            case QEMU_OPTION_nographic:\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"graphics=off\", false);\n                nographic = true;\n                display_type = DT_NONE;\n            case QEMU_OPTION_curses:\n#ifdef CONFIG_CURSES\n                display_type = DT_CURSES;\n#else\n                error_report(\"curses support is disabled\");\n#endif\n            case QEMU_OPTION_portrait:\n                graphic_rotate = 90;\n            case QEMU_OPTION_rotate:\n                graphic_rotate = strtol(optarg, (char **) &optarg, 10);\n                if (graphic_rotate != 0 && graphic_rotate != 90 &&\n                    graphic_rotate != 180 && graphic_rotate != 270) {\n                    error_report(\"only 90, 180, 270 deg rotation is available\");\n            case QEMU_OPTION_kernel:\n                qemu_opts_set(qemu_find_opts(\"machine\"), 0, \"kernel\", optarg,\n                              &error_abort);\n            case QEMU_OPTION_initrd:\n                qemu_opts_set(qemu_find_opts(\"machine\"), 0, \"initrd\", optarg,\n                              &error_abort);\n            case QEMU_OPTION_append:\n                qemu_opts_set(qemu_find_opts(\"machine\"), 0, \"append\", optarg,\n                              &error_abort);\n            case QEMU_OPTION_dtb:\n                qemu_opts_set(qemu_find_opts(\"machine\"), 0, \"dtb\", optarg,\n                              &error_abort);\n            case QEMU_OPTION_cdrom:\n                drive_add(IF_DEFAULT, 2, optarg, CDROM_OPTS);\n            case QEMU_OPTION_boot:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"boot-opts\"),\n                                               optarg, true);\n                if (!opts) {\n            case QEMU_OPTION_fda:\n            case QEMU_OPTION_fdb:\n                drive_add(IF_FLOPPY, popt->index - QEMU_OPTION_fda,\n                          optarg, FD_OPTS);\n            case QEMU_OPTION_no_fd_bootchk:\n                fd_bootchk = 0;\n            case QEMU_OPTION_netdev:\n                default_net = 0;\n                if (net_client_parse(qemu_find_opts(\"netdev\"), optarg) == -1) {\n            case QEMU_OPTION_net:\n                default_net = 0;\n                if (net_client_parse(qemu_find_opts(\"net\"), optarg) == -1) {\n#ifdef CONFIG_LIBISCSI\n            case QEMU_OPTION_iscsi:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"iscsi\"),\n                                               optarg, false);\n                if (!opts) {\n#endif\n#ifdef CONFIG_SLIRP\n            case QEMU_OPTION_tftp:\n                error_report(\"The -tftp option is deprecated. \"\n                             \"Please use '-netdev user,tftp=...' instead.\");\n                legacy_tftp_prefix = optarg;\n            case QEMU_OPTION_bootp:\n                error_report(\"The -bootp option is deprecated. \"\n                             \"Please use '-netdev user,bootfile=...' instead.\");\n                legacy_bootp_filename = optarg;\n            case QEMU_OPTION_redir:\n                error_report(\"The -redir option is deprecated. \"\n                             \"Please use '-netdev user,hostfwd=...' instead.\");\n                if (net_slirp_redir(optarg) < 0)\n#endif\n            case QEMU_OPTION_bt:\n                add_device_config(DEV_BT, optarg);\n            case QEMU_OPTION_audio_help:\n                AUD_help ();\n                exit (0);\n            case QEMU_OPTION_soundhw:\n                select_soundhw (optarg);\n            case QEMU_OPTION_h:\n                help(0);\n            case QEMU_OPTION_version:\n                version();\n                exit(0);\n            case QEMU_OPTION_m:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"memory\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(EXIT_FAILURE);\n#ifdef CONFIG_TPM\n            case QEMU_OPTION_tpmdev:\n                if (tpm_config_parse(qemu_find_opts(\"tpmdev\"), optarg) < 0) {\n#endif\n            case QEMU_OPTION_mempath:\n                mem_path = optarg;\n            case QEMU_OPTION_mem_prealloc:\n                mem_prealloc = 1;\n            case QEMU_OPTION_d:\n                log_mask = optarg;\n            case QEMU_OPTION_D:\n                log_file = optarg;\n            case QEMU_OPTION_DFILTER:\n                qemu_set_dfilter_ranges(optarg, &error_fatal);\n            case QEMU_OPTION_s:\n                add_device_config(DEV_GDB, \"tcp::\" DEFAULT_GDBSTUB_PORT);\n            case QEMU_OPTION_gdb:\n                add_device_config(DEV_GDB, optarg);\n            case QEMU_OPTION_L:\n                if (is_help_option(optarg)) {\n                    list_data_dirs = true;\n                } else if (data_dir_idx < ARRAY_SIZE(data_dir)) {\n                    data_dir[data_dir_idx++] = optarg;\n            case QEMU_OPTION_bios:\n                qemu_opts_set(qemu_find_opts(\"machine\"), 0, \"firmware\", optarg,\n                              &error_abort);\n            case QEMU_OPTION_singlestep:\n                singlestep = 1;\n            case QEMU_OPTION_S:\n                autostart = 0;\n            case QEMU_OPTION_k:\n                keyboard_layout = optarg;\n            case QEMU_OPTION_localtime:\n                rtc_utc = 0;\n            case QEMU_OPTION_vga:\n                vga_model = optarg;\n                default_vga = 0;\n            case QEMU_OPTION_g:\n                    const char *p;\n                    int w, h, depth;\n                    p = optarg;\n                    w = strtol(p, (char **)&p, 10);\n                    if (w <= 0) {\n                    graphic_error:\n                        error_report(\"invalid resolution or depth\");\n                    if (*p != 'x')\n                        goto graphic_error;\n                    p++;\n                    h = strtol(p, (char **)&p, 10);\n                    if (h <= 0)\n                        goto graphic_error;\n                    if (*p == 'x') {\n                        p++;\n                        depth = strtol(p, (char **)&p, 10);\n                        if (depth != 8 && depth != 15 && depth != 16 &&\n                            depth != 24 && depth != 32)\n                            goto graphic_error;\n                    } else if (*p == '\\0') {\n                        depth = graphic_depth;\n                    } else {\n                        goto graphic_error;\n                    graphic_width = w;\n                    graphic_height = h;\n                    graphic_depth = depth;\n            case QEMU_OPTION_echr:\n                    char *r;\n                    term_escape_char = strtol(optarg, &r, 0);\n                    if (r == optarg)\n                        printf(\"Bad argument to echr\\n\");\n            case QEMU_OPTION_monitor:\n                default_monitor = 0;\n                if (strncmp(optarg, \"none\", 4)) {\n                    monitor_parse(optarg, \"readline\", false);\n            case QEMU_OPTION_qmp:\n                monitor_parse(optarg, \"control\", false);\n                default_monitor = 0;\n            case QEMU_OPTION_qmp_pretty:\n                monitor_parse(optarg, \"control\", true);\n                default_monitor = 0;\n            case QEMU_OPTION_mon:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"mon\"), optarg,\n                                               true);\n                if (!opts) {\n                default_monitor = 0;\n            case QEMU_OPTION_chardev:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"chardev\"),\n                                               optarg, true);\n                if (!opts) {\n            case QEMU_OPTION_fsdev:\n                olist = qemu_find_opts(\"fsdev\");\n                if (!olist) {\n                    error_report(\"fsdev support is disabled\");\n                opts = qemu_opts_parse_noisily(olist, optarg, true);\n                if (!opts) {\n            case QEMU_OPTION_virtfs: {\n                QemuOpts *fsdev;\n                QemuOpts *device;\n                const char *writeout, *sock_fd, *socket;\n                olist = qemu_find_opts(\"virtfs\");\n                if (!olist) {\n                    error_report(\"virtfs support is disabled\");\n                opts = qemu_opts_parse_noisily(olist, optarg, true);\n                if (!opts) {\n                if (qemu_opt_get(opts, \"fsdriver\") == NULL ||\n                    qemu_opt_get(opts, \"mount_tag\") == NULL) {\n                    error_report(\"Usage: -virtfs fsdriver,mount_tag=tag\");\n                fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n                                         qemu_opt_get(opts, \"mount_tag\"),\n                                         1, NULL);\n                if (!fsdev) {\n                    error_report(\"duplicate fsdev id: %s\",\n                                 qemu_opt_get(opts, \"mount_tag\"));\n                writeout = qemu_opt_get(opts, \"writeout\");\n                if (writeout) {\n#ifdef CONFIG_SYNC_FILE_RANGE\n                    qemu_opt_set(fsdev, \"writeout\", writeout, &error_abort);\n#else\n                    error_report(\"writeout=immediate not supported \"\n                                 \"on this platform\");\n#endif\n                qemu_opt_set(fsdev, \"fsdriver\",\n                             qemu_opt_get(opts, \"fsdriver\"), &error_abort);\n                qemu_opt_set(fsdev, \"path\", qemu_opt_get(opts, \"path\"),\n                             &error_abort);\n                qemu_opt_set(fsdev, \"security_model\",\n                             qemu_opt_get(opts, \"security_model\"),\n                             &error_abort);\n                socket = qemu_opt_get(opts, \"socket\");\n                if (socket) {\n                    qemu_opt_set(fsdev, \"socket\", socket, &error_abort);\n                sock_fd = qemu_opt_get(opts, \"sock_fd\");\n                if (sock_fd) {\n                    qemu_opt_set(fsdev, \"sock_fd\", sock_fd, &error_abort);\n                qemu_opt_set_bool(fsdev, \"readonly\",\n                                  qemu_opt_get_bool(opts, \"readonly\", 0),\n                                  &error_abort);\n                device = qemu_opts_create(qemu_find_opts(\"device\"), NULL, 0,\n                                          &error_abort);\n                qemu_opt_set(device, \"driver\", \"virtio-9p-pci\", &error_abort);\n                qemu_opt_set(device, \"fsdev\",\n                             qemu_opt_get(opts, \"mount_tag\"), &error_abort);\n                qemu_opt_set(device, \"mount_tag\",\n                             qemu_opt_get(opts, \"mount_tag\"), &error_abort);\n            case QEMU_OPTION_virtfs_synth: {\n                QemuOpts *fsdev;\n                QemuOpts *device;\n                fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"), \"v_synth\",\n                                         1, NULL);\n                if (!fsdev) {\n                    error_report(\"duplicate option: %s\", \"virtfs_synth\");\n                qemu_opt_set(fsdev, \"fsdriver\", \"synth\", &error_abort);\n                device = qemu_opts_create(qemu_find_opts(\"device\"), NULL, 0,\n                                          &error_abort);\n                qemu_opt_set(device, \"driver\", \"virtio-9p-pci\", &error_abort);\n                qemu_opt_set(device, \"fsdev\", \"v_synth\", &error_abort);\n                qemu_opt_set(device, \"mount_tag\", \"v_synth\", &error_abort);\n            case QEMU_OPTION_serial:\n                add_device_config(DEV_SERIAL, optarg);\n                default_serial = 0;\n                if (strncmp(optarg, \"mon:\", 4) == 0) {\n                    default_monitor = 0;\n            case QEMU_OPTION_watchdog:\n                if (watchdog) {\n                    error_report(\"only one watchdog option may be given\");\n                    return 1;\n                watchdog = optarg;\n            case QEMU_OPTION_watchdog_action:\n                if (select_watchdog_action(optarg) == -1) {\n                    error_report(\"unknown -watchdog-action parameter\");\n            case QEMU_OPTION_virtiocon:\n                add_device_config(DEV_VIRTCON, optarg);\n                default_virtcon = 0;\n                if (strncmp(optarg, \"mon:\", 4) == 0) {\n                    default_monitor = 0;\n            case QEMU_OPTION_parallel:\n                add_device_config(DEV_PARALLEL, optarg);\n                default_parallel = 0;\n                if (strncmp(optarg, \"mon:\", 4) == 0) {\n                    default_monitor = 0;\n            case QEMU_OPTION_debugcon:\n                add_device_config(DEV_DEBUGCON, optarg);\n            case QEMU_OPTION_loadvm:\n                loadvm = optarg;\n            case QEMU_OPTION_full_screen:\n                full_screen = 1;\n            case QEMU_OPTION_no_frame:\n                no_frame = 1;\n            case QEMU_OPTION_alt_grab:\n                alt_grab = 1;\n            case QEMU_OPTION_ctrl_grab:\n                ctrl_grab = 1;\n            case QEMU_OPTION_no_quit:\n                no_quit = 1;\n            case QEMU_OPTION_sdl:\n#ifdef CONFIG_SDL\n                display_type = DT_SDL;\n#else\n                error_report(\"SDL support is disabled\");\n#endif\n            case QEMU_OPTION_pidfile:\n                pid_file = optarg;\n            case QEMU_OPTION_win2k_hack:\n                win2k_install_hack = 1;\n            case QEMU_OPTION_rtc_td_hack: {\n                static GlobalProperty slew_lost_ticks = {\n                    .driver   = \"mc146818rtc\",\n                    .property = \"lost_tick_policy\",\n                    .value    = \"slew\",\n                };\n                qdev_prop_register_global(&slew_lost_ticks);\n            case QEMU_OPTION_acpitable:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"acpi\"),\n                                               optarg, true);\n                if (!opts) {\n                acpi_table_add(opts, &error_fatal);\n            case QEMU_OPTION_smbios:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"smbios\"),\n                                               optarg, false);\n                if (!opts) {\n                smbios_entry_add(opts, &error_fatal);\n            case QEMU_OPTION_fwcfg:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"fw_cfg\"),\n                                               optarg, true);\n                if (opts == NULL) {\n            case QEMU_OPTION_enable_kvm:\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"accel=kvm\", false);\n            case QEMU_OPTION_enable_hax:\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"accel=hax\", false);\n            case QEMU_OPTION_M:\n            case QEMU_OPTION_machine:\n                olist = qemu_find_opts(\"machine\");\n                opts = qemu_opts_parse_noisily(olist, optarg, true);\n                if (!opts) {\n             case QEMU_OPTION_no_kvm:\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"accel=tcg\", false);\n            case QEMU_OPTION_no_kvm_pit: {\n                error_report(\"warning: ignoring deprecated option\");\n            case QEMU_OPTION_no_kvm_pit_reinjection: {\n                static GlobalProperty kvm_pit_lost_tick_policy = {\n                    .driver   = \"kvm-pit\",\n                    .property = \"lost_tick_policy\",\n                    .value    = \"discard\",\n                };\n                error_report(\"warning: deprecated, replaced by \"\n                             \"-global kvm-pit.lost_tick_policy=discard\");\n                qdev_prop_register_global(&kvm_pit_lost_tick_policy);\n            case QEMU_OPTION_accel:\n                accel_opts = qemu_opts_parse_noisily(qemu_find_opts(\"accel\"),\n                                                     optarg, true);\n                optarg = qemu_opt_get(accel_opts, \"accel\");\n                olist = qemu_find_opts(\"machine\");\n                if (strcmp(\"kvm\", optarg) == 0) {\n                    qemu_opts_parse_noisily(olist, \"accel=kvm\", false);\n                } else if (strcmp(\"xen\", optarg) == 0) {\n                    qemu_opts_parse_noisily(olist, \"accel=xen\", false);\n                } else if (strcmp(\"tcg\", optarg) == 0) {\n                    qemu_opts_parse_noisily(olist, \"accel=tcg\", false);\n                } else {\n                    if (!is_help_option(optarg)) {\n                        error_printf(\"Unknown accelerator: %s\", optarg);\n                    error_printf(\"Supported accelerators: kvm, xen, tcg\\n\");\n            case QEMU_OPTION_usb:\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"usb=on\", false);\n            case QEMU_OPTION_usbdevice:\n                olist = qemu_find_opts(\"machine\");\n                qemu_opts_parse_noisily(olist, \"usb=on\", false);\n                add_device_config(DEV_USB, optarg);\n            case QEMU_OPTION_device:\n                if (!qemu_opts_parse_noisily(qemu_find_opts(\"device\"),\n                                             optarg, true)) {\n            case QEMU_OPTION_smp:\n                if (!qemu_opts_parse_noisily(qemu_find_opts(\"smp-opts\"),\n                                             optarg, true)) {\n            case QEMU_OPTION_vnc:\n                vnc_parse(optarg, &error_fatal);\n            case QEMU_OPTION_no_acpi:\n                acpi_enabled = 0;\n            case QEMU_OPTION_no_hpet:\n                no_hpet = 1;\n            case QEMU_OPTION_balloon:\n                if (balloon_parse(optarg) < 0) {\n                    error_report(\"unknown -balloon argument %s\", optarg);\n            case QEMU_OPTION_no_reboot:\n                no_reboot = 1;\n            case QEMU_OPTION_no_shutdown:\n                no_shutdown = 1;\n            case QEMU_OPTION_show_cursor:\n                cursor_hide = 0;\n            case QEMU_OPTION_uuid:\n                if (qemu_uuid_parse(optarg, &qemu_uuid) < 0) {\n                    error_report(\"failed to parse UUID string: wrong format\");\n                qemu_uuid_set = true;\n            case QEMU_OPTION_option_rom:\n                if (nb_option_roms >= MAX_OPTION_ROMS) {\n                    error_report(\"too many option ROMs\");\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"option-rom\"),\n                                               optarg, true);\n                if (!opts) {\n                option_rom[nb_option_roms].name = qemu_opt_get(opts, \"romfile\");\n                option_rom[nb_option_roms].bootindex =\n                    qemu_opt_get_number(opts, \"bootindex\", -1);\n                if (!option_rom[nb_option_roms].name) {\n                    error_report(\"Option ROM file is not specified\");\n                nb_option_roms++;\n            case QEMU_OPTION_semihosting:\n                semihosting.enabled = true;\n                semihosting.target = SEMIHOSTING_TARGET_AUTO;\n            case QEMU_OPTION_semihosting_config:\n                semihosting.enabled = true;\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"semihosting-config\"),\n                                               optarg, false);\n                if (opts != NULL) {\n                    semihosting.enabled = qemu_opt_get_bool(opts, \"enable\",\n                                                            true);\n                    const char *target = qemu_opt_get(opts, \"target\");\n                    if (target != NULL) {\n                        if (strcmp(\"native\", target) == 0) {\n                            semihosting.target = SEMIHOSTING_TARGET_NATIVE;\n                        } else if (strcmp(\"gdb\", target) == 0) {\n                            semihosting.target = SEMIHOSTING_TARGET_GDB;\n                        } else  if (strcmp(\"auto\", target) == 0) {\n                            semihosting.target = SEMIHOSTING_TARGET_AUTO;\n                        } else {\n                            error_report(\"unsupported semihosting-config %s\",\n                                         optarg);\n                    } else {\n                        semihosting.target = SEMIHOSTING_TARGET_AUTO;\n                    \/* Set semihosting argument count and vector *\/\n                    qemu_opt_foreach(opts, add_semihosting_arg,\n                                     &semihosting, NULL);\n                } else {\n                    error_report(\"unsupported semihosting-config %s\", optarg);\n            case QEMU_OPTION_tdf:\n                error_report(\"warning: ignoring deprecated option\");\n            case QEMU_OPTION_name:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"name\"),\n                                               optarg, true);\n                if (!opts) {\n            case QEMU_OPTION_prom_env:\n                if (nb_prom_envs >= MAX_PROM_ENVS) {\n                    error_report(\"too many prom variables\");\n                prom_envs[nb_prom_envs] = optarg;\n                nb_prom_envs++;\n            case QEMU_OPTION_old_param:\n                old_param = 1;\n            case QEMU_OPTION_clock:\n                \/* Clock options no longer exist.  Keep this option for\n                 * backward compatibility.\n                 *\/\n            case QEMU_OPTION_startdate:\n                configure_rtc_date_offset(optarg, 1);\n            case QEMU_OPTION_rtc:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"rtc\"), optarg,\n                                               false);\n                if (!opts) {\n                configure_rtc(opts);\n            case QEMU_OPTION_tb_size:\n                tcg_tb_size = strtol(optarg, NULL, 0);\n                if (tcg_tb_size < 0) {\n                    tcg_tb_size = 0;\n            case QEMU_OPTION_icount:\n                icount_opts = qemu_opts_parse_noisily(qemu_find_opts(\"icount\"),\n                                                      optarg, true);\n                if (!icount_opts) {\n            case QEMU_OPTION_incoming:\n                if (!incoming) {\n                    runstate_set(RUN_STATE_INMIGRATE);\n                incoming = optarg;\n            case QEMU_OPTION_only_migratable:\n                only_migratable = 1;\n            case QEMU_OPTION_nodefaults:\n                has_defaults = 0;\n            case QEMU_OPTION_xen_domid:\n                if (!(xen_available())) {\n                    error_report(\"Option not supported for this target\");\n                xen_domid = atoi(optarg);\n            case QEMU_OPTION_xen_create:\n                if (!(xen_available())) {\n                    error_report(\"Option not supported for this target\");\n                xen_mode = XEN_CREATE;\n            case QEMU_OPTION_xen_attach:\n                if (!(xen_available())) {\n                    error_report(\"Option not supported for this target\");\n                xen_mode = XEN_ATTACH;\n            case QEMU_OPTION_trace:\n                g_free(trace_file);\n                trace_file = trace_opt_parse(optarg);\n            case QEMU_OPTION_readconfig:\n                    int ret = qemu_read_config_file(optarg);\n                    if (ret < 0) {\n                        error_report(\"read config %s: %s\", optarg,\n                                     strerror(-ret));\n            case QEMU_OPTION_spice:\n                olist = qemu_find_opts(\"spice\");\n                if (!olist) {\n                    error_report(\"spice support is disabled\");\n                opts = qemu_opts_parse_noisily(olist, optarg, false);\n                if (!opts) {\n                display_remote++;\n            case QEMU_OPTION_writeconfig:\n                    FILE *fp;\n                    if (strcmp(optarg, \"-\") == 0) {\n                        fp = stdout;\n                    } else {\n                        fp = fopen(optarg, \"w\");\n                        if (fp == NULL) {\n                            error_report(\"open %s: %s\", optarg,\n                                         strerror(errno));\n                    qemu_config_write(fp);\n                    if (fp != stdout) {\n                        fclose(fp);\n            case QEMU_OPTION_qtest:\n                qtest_chrdev = optarg;\n            case QEMU_OPTION_qtest_log:\n                qtest_log = optarg;\n            case QEMU_OPTION_sandbox:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"sandbox\"),\n                                               optarg, true);\n                if (!opts) {\n            case QEMU_OPTION_add_fd:\n#ifndef _WIN32\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"add-fd\"),\n                                               optarg, false);\n                if (!opts) {\n#else\n                error_report(\"File descriptor passing is disabled on this \"\n                             \"platform\");\n#endif\n            case QEMU_OPTION_object:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"object\"),\n                                               optarg, true);\n                if (!opts) {\n            case QEMU_OPTION_realtime:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"realtime\"),\n                                               optarg, false);\n                if (!opts) {\n                enable_mlock = qemu_opt_get_bool(opts, \"mlock\", true);\n            case QEMU_OPTION_msg:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"msg\"), optarg,\n                                               false);\n                if (!opts) {\n                configure_msg(opts);\n            case QEMU_OPTION_dump_vmstate:\n                if (vmstate_dump_file) {\n                    error_report(\"only one '-dump-vmstate' \"\n                                 \"option may be given\");\n                vmstate_dump_file = fopen(optarg, \"w\");\n                if (vmstate_dump_file == NULL) {\n                    error_report(\"open %s: %s\", optarg, strerror(errno));\n            default:\n                os_parse_cmd_args(popt->index, optarg);\n    \/*\n     * Clear error location left behind by the loop.\n     * Best done right after the loop.  Do not insert code here!\n     *\/\n    loc_set_none();\n    replay_configure(icount_opts);\n    qemu_tcg_configure(accel_opts, &error_fatal);\n    machine_class = select_machine();\n    set_memory_options(&ram_slots, &maxram_size, machine_class);\n    os_daemonize();\n    if (pid_file && qemu_create_pidfile(pid_file) != 0) {\n        error_report(\"could not acquire pid file: %s\", strerror(errno));\n    if (qemu_init_main_loop(&main_loop_err)) {\n        error_report_err(main_loop_err);\n    if (qemu_opts_foreach(qemu_find_opts(\"sandbox\"),\n                          parse_sandbox, NULL, NULL)) {\n    if (qemu_opts_foreach(qemu_find_opts(\"name\"),\n                          parse_name, NULL, NULL)) {\n#ifndef _WIN32\n    if (qemu_opts_foreach(qemu_find_opts(\"add-fd\"),\n                          parse_add_fd, NULL, NULL)) {\n    if (qemu_opts_foreach(qemu_find_opts(\"add-fd\"),\n                          cleanup_add_fd, NULL, NULL)) {\n#endif\n    current_machine = MACHINE(object_new(object_class_get_name(\n                          OBJECT_CLASS(machine_class))));\n    if (machine_help_func(qemu_get_machine_opts(), current_machine)) {\n        exit(0);\n    object_property_add_child(object_get_root(), \"machine\",\n                              OBJECT(current_machine), &error_abort);\n    if (machine_class->minimum_page_bits) {\n        if (!set_preferred_target_page_bits(machine_class->minimum_page_bits)) {\n            \/* This would be a board error: specifying a minimum smaller than\n             * a target's compile-time fixed setting.\n             *\/\n            g_assert_not_reached();\n    cpu_exec_init_all();\n    if (machine_class->hw_version) {\n        qemu_set_hw_version(machine_class->hw_version);\n    if (cpu_model && is_help_option(cpu_model)) {\n        list_cpus(stdout, &fprintf, cpu_model);\n        exit(0);\n    if (!trace_init_backends()) {\n    trace_init_file(trace_file);\n    \/* Open the logfile at this point and set the log mask if necessary.\n     *\/\n    if (log_file) {\n        qemu_set_log_filename(log_file, &error_fatal);\n    if (log_mask) {\n        int mask;\n        mask = qemu_str_to_log_mask(log_mask);\n        if (!mask) {\n            qemu_print_log_usage(stdout);\n        qemu_set_log(mask);\n    } else {\n        qemu_set_log(0);\n    \/* If no data_dir is specified then try to find it relative to the\n       executable path.  *\/\n    if (data_dir_idx < ARRAY_SIZE(data_dir)) {\n        data_dir[data_dir_idx] = os_find_datadir();\n        if (data_dir[data_dir_idx] != NULL) {\n            data_dir_idx++;\n    \/* If all else fails use the install path specified when building. *\/\n    if (data_dir_idx < ARRAY_SIZE(data_dir)) {\n        data_dir[data_dir_idx++] = CONFIG_QEMU_DATADIR;\n    \/* -L help lists the data directories and exits. *\/\n    if (list_data_dirs) {\n        for (i = 0; i < data_dir_idx; i++) {\n            printf(\"%s\\n\", data_dir[i]);\n        exit(0);\n    smp_parse(qemu_opts_find(qemu_find_opts(\"smp-opts\"), NULL));\n    machine_class->max_cpus = machine_class->max_cpus ?: 1; \/* Default to UP *\/\n    if (max_cpus > machine_class->max_cpus) {\n        error_report(\"Number of SMP CPUs requested (%d) exceeds max CPUs \"\n                     \"supported by machine '%s' (%d)\", max_cpus,\n                     machine_class->name, machine_class->max_cpus);\n    \/*\n     * Get the default machine options from the machine if it is not already\n     * specified either by the configuration file or by the command line.\n     *\/\n    if (machine_class->default_machine_opts) {\n        qemu_opts_set_defaults(qemu_find_opts(\"machine\"),\n                               machine_class->default_machine_opts, 0);\n    qemu_opts_foreach(qemu_find_opts(\"device\"),\n                      default_driver_check, NULL, NULL);\n    qemu_opts_foreach(qemu_find_opts(\"global\"),\n                      default_driver_check, NULL, NULL);\n    if (!vga_model && !default_vga) {\n        vga_interface_type = VGA_DEVICE;\n    if (!has_defaults || machine_class->no_serial) {\n        default_serial = 0;\n    if (!has_defaults || machine_class->no_parallel) {\n        default_parallel = 0;\n    if (!has_defaults || !machine_class->use_virtcon) {\n        default_virtcon = 0;\n    if (!has_defaults || !machine_class->use_sclp) {\n        default_sclp = 0;\n    if (!has_defaults || machine_class->no_floppy) {\n        default_floppy = 0;\n    if (!has_defaults || machine_class->no_cdrom) {\n        default_cdrom = 0;\n    if (!has_defaults || machine_class->no_sdcard) {\n        default_sdcard = 0;\n    if (!has_defaults) {\n        default_monitor = 0;\n        default_net = 0;\n        default_vga = 0;\n    if (is_daemonized()) {\n        \/* According to documentation and historically, -nographic redirects\n         * serial port, parallel port and monitor to stdio, which does not work\n         * with -daemonize.  We can redirect these to null instead, but since\n         * -nographic is legacy, let's just error out.\n         * We disallow -nographic only if all other ports are not redirected\n         * explicitly, to not break existing legacy setups which uses\n         * -nographic _and_ redirects all ports explicitly - this is valid\n         * usage, -nographic is just a no-op in this case.\n         *\/\n        if (nographic\n            && (default_parallel || default_serial\n                || default_monitor || default_virtcon)) {\n            error_report(\"-nographic cannot be used with -daemonize\");\n#ifdef CONFIG_CURSES\n        if (display_type == DT_CURSES) {\n            error_report(\"curses display cannot be used with -daemonize\");\n#endif\n    if (nographic) {\n        if (default_parallel)\n            add_device_config(DEV_PARALLEL, \"null\");\n        if (default_serial && default_monitor) {\n            add_device_config(DEV_SERIAL, \"mon:stdio\");\n        } else if (default_virtcon && default_monitor) {\n            add_device_config(DEV_VIRTCON, \"mon:stdio\");\n        } else if (default_sclp && default_monitor) {\n            add_device_config(DEV_SCLP, \"mon:stdio\");\n        } else {\n            if (default_serial)\n                add_device_config(DEV_SERIAL, \"stdio\");\n            if (default_virtcon)\n                add_device_config(DEV_VIRTCON, \"stdio\");\n            if (default_sclp) {\n                add_device_config(DEV_SCLP, \"stdio\");\n            if (default_monitor)\n                monitor_parse(\"stdio\", \"readline\", false);\n    } else {\n        if (default_serial)\n            add_device_config(DEV_SERIAL, \"vc:80Cx24C\");\n        if (default_parallel)\n            add_device_config(DEV_PARALLEL, \"vc:80Cx24C\");\n        if (default_monitor)\n            monitor_parse(\"vc:80Cx24C\", \"readline\", false);\n        if (default_virtcon)\n            add_device_config(DEV_VIRTCON, \"vc:80Cx24C\");\n        if (default_sclp) {\n            add_device_config(DEV_SCLP, \"vc:80Cx24C\");\n#if defined(CONFIG_VNC)\n    if (!QTAILQ_EMPTY(&(qemu_find_opts(\"vnc\")->head))) {\n        display_remote++;\n#endif\n    if (display_type == DT_DEFAULT && !display_remote) {\n#if defined(CONFIG_GTK)\n        display_type = DT_GTK;\n#elif defined(CONFIG_SDL)\n        display_type = DT_SDL;\n#elif defined(CONFIG_COCOA)\n        display_type = DT_COCOA;\n#elif defined(CONFIG_VNC)\n        vnc_parse(\"localhost:0,to=99,id=default\", &error_abort);\n#else\n        display_type = DT_NONE;\n#endif\n    if ((no_frame || alt_grab || ctrl_grab) && display_type != DT_SDL) {\n        error_report(\"-no-frame, -alt-grab and -ctrl-grab are only valid \"\n                     \"for SDL, ignoring option\");\n    if (no_quit && (display_type != DT_GTK && display_type != DT_SDL)) {\n        error_report(\"-no-quit is only valid for GTK and SDL, \"\n                     \"ignoring option\");\n    if (display_type == DT_GTK) {\n        early_gtk_display_init(request_opengl);\n    if (display_type == DT_SDL) {\n        sdl_display_early_init(request_opengl);\n    qemu_console_early_init();\n    if (request_opengl == 1 && display_opengl == 0) {\n#if defined(CONFIG_OPENGL)\n        error_report(\"OpenGL is not supported by the display\");\n#else\n        error_report(\"OpenGL support is disabled\");\n#endif\n    page_size_init();\n    socket_init();\n    if (qemu_opts_foreach(qemu_find_opts(\"object\"),\n                          user_creatable_add_opts_foreach,\n                          object_create_initial, NULL)) {\n    if (qemu_opts_foreach(qemu_find_opts(\"chardev\"),\n                          chardev_init_func, NULL, NULL)) {\n#ifdef CONFIG_VIRTFS\n    if (qemu_opts_foreach(qemu_find_opts(\"fsdev\"),\n                          fsdev_init_func, NULL, NULL)) {\n#endif\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"),\n                          device_help_func, NULL, NULL)) {\n        exit(0);\n    machine_opts = qemu_get_machine_opts();\n    if (qemu_opt_foreach(machine_opts, machine_set_property, current_machine,\n                         NULL)) {\n        object_unref(OBJECT(current_machine));\n    configure_accelerator(current_machine);\n    if (qtest_chrdev) {\n        qtest_init(qtest_chrdev, qtest_log, &error_fatal);\n    machine_opts = qemu_get_machine_opts();\n    kernel_filename = qemu_opt_get(machine_opts, \"kernel\");\n    initrd_filename = qemu_opt_get(machine_opts, \"initrd\");\n    kernel_cmdline = qemu_opt_get(machine_opts, \"append\");\n    bios_name = qemu_opt_get(machine_opts, \"firmware\");\n    opts = qemu_opts_find(qemu_find_opts(\"boot-opts\"), NULL);\n    if (opts) {\n        boot_order = qemu_opt_get(opts, \"order\");\n        if (boot_order) {\n            validate_bootdevices(boot_order, &error_fatal);\n        boot_once = qemu_opt_get(opts, \"once\");\n        if (boot_once) {\n            validate_bootdevices(boot_once, &error_fatal);\n        boot_menu = qemu_opt_get_bool(opts, \"menu\", boot_menu);\n        boot_strict = qemu_opt_get_bool(opts, \"strict\", false);\n    if (!boot_order) {\n        boot_order = machine_class->default_boot_order;\n    if (!kernel_cmdline) {\n        kernel_cmdline = \"\";\n        current_machine->kernel_cmdline = (char *)kernel_cmdline;\n    linux_boot = (kernel_filename != NULL);\n    if (!linux_boot && *kernel_cmdline != '\\0') {\n        error_report(\"-append only allowed with -kernel option\");\n    if (!linux_boot && initrd_filename != NULL) {\n        error_report(\"-initrd only allowed with -kernel option\");\n    if (semihosting_enabled() && !semihosting_get_argc() && kernel_filename) {\n        \/* fall back to the -kernel\/-append *\/\n        semihosting_arg_fallback(kernel_filename, kernel_cmdline);\n    os_set_line_buffering();\n    \/* spice needs the timers to be initialized by this point *\/\n    qemu_spice_init();\n    cpu_ticks_init();\n    if (icount_opts) {\n        if (!tcg_enabled()) {\n            error_report(\"-icount is not allowed with hardware virtualization\");\n        } else if (qemu_tcg_mttcg_enabled()) {\n            error_report(\"-icount does not currently work with MTTCG\");\n        configure_icount(icount_opts, &error_abort);\n        qemu_opts_del(icount_opts);\n    if (default_net) {\n        QemuOptsList *net = qemu_find_opts(\"net\");\n        qemu_opts_set(net, NULL, \"type\", \"nic\", &error_abort);\n#ifdef CONFIG_SLIRP\n        qemu_opts_set(net, NULL, \"type\", \"user\", &error_abort);\n#endif\n    colo_info_init();\n    if (net_init_clients() < 0) {\n    if (qemu_opts_foreach(qemu_find_opts(\"object\"),\n                          user_creatable_add_opts_foreach,\n                          object_create_delayed, NULL)) {\n#ifdef CONFIG_TPM\n    if (tpm_init() < 0) {\n#endif\n    \/* init the bluetooth world *\/\n    if (foreach_device_config(DEV_BT, bt_parse))\n    if (!xen_enabled()) {\n        \/* On 32-bit hosts, QEMU is limited by virtual address space *\/\n        if (ram_size > (2047 << 20) && HOST_LONG_BITS == 32) {\n            error_report(\"at most 2047 MB RAM can be simulated\");\n    blk_mig_init();\n    ram_mig_init();\n    \/* If the currently selected machine wishes to override the units-per-bus\n     * property of its default HBA interface type, do so now. *\/\n    if (machine_class->units_per_default_bus) {\n        override_max_devs(machine_class->block_default_type,\n                          machine_class->units_per_default_bus);\n    \/* open the virtual block devices *\/\n    while (!QSIMPLEQ_EMPTY(&bdo_queue)) {\n        BlockdevOptions_queue *bdo = QSIMPLEQ_FIRST(&bdo_queue);\n        QSIMPLEQ_REMOVE_HEAD(&bdo_queue, entry);\n        loc_push_restore(&bdo->loc);\n        qmp_blockdev_add(bdo->bdo, &error_fatal);\n        loc_pop(&bdo->loc);\n        qapi_free_BlockdevOptions(bdo->bdo);\n        g_free(bdo);\n    if (snapshot || replay_mode != REPLAY_MODE_NONE) {\n        qemu_opts_foreach(qemu_find_opts(\"drive\"), drive_enable_snapshot,\n                          NULL, NULL);\n    if (qemu_opts_foreach(qemu_find_opts(\"drive\"), drive_init_func,\n                          &machine_class->block_default_type, NULL)) {\n    default_drive(default_cdrom, snapshot, machine_class->block_default_type, 2,\n                  CDROM_OPTS);\n    default_drive(default_floppy, snapshot, IF_FLOPPY, 0, FD_OPTS);\n    default_drive(default_sdcard, snapshot, IF_SD, 0, SD_OPTS);\n    parse_numa_opts(machine_class);\n    if (qemu_opts_foreach(qemu_find_opts(\"mon\"),\n                          mon_init_func, NULL, NULL)) {\n    if (foreach_device_config(DEV_SERIAL, serial_parse) < 0)\n    if (foreach_device_config(DEV_PARALLEL, parallel_parse) < 0)\n    if (foreach_device_config(DEV_VIRTCON, virtcon_parse) < 0)\n    if (foreach_device_config(DEV_SCLP, sclp_parse) < 0) {\n    if (foreach_device_config(DEV_DEBUGCON, debugcon_parse) < 0)\n    \/* If no default VGA is requested, the default is \"none\".  *\/\n    if (default_vga) {\n        if (machine_class->default_display) {\n            vga_model = machine_class->default_display;\n        } else if (vga_interface_available(VGA_CIRRUS)) {\n            vga_model = \"cirrus\";\n        } else if (vga_interface_available(VGA_STD)) {\n            vga_model = \"std\";\n    if (vga_model) {\n        select_vgahw(vga_model);\n    if (watchdog) {\n        i = select_watchdog(watchdog);\n        if (i > 0)\n            exit (i == 1 ? 1 : 0);\n    machine_register_compat_props(current_machine);\n    qemu_opts_foreach(qemu_find_opts(\"global\"),\n                      global_init_func, NULL, NULL);\n    \/* This checkpoint is required by replay to separate prior clock\n       reading from the other reads, because timer polling functions query\n       clock values from the log. *\/\n    replay_checkpoint(CHECKPOINT_INIT);\n    qdev_machine_init();\n    current_machine->ram_size = ram_size;\n    current_machine->maxram_size = maxram_size;\n    current_machine->ram_slots = ram_slots;\n    current_machine->boot_order = boot_order;\n    current_machine->cpu_model = cpu_model;\n    machine_class->init(current_machine);\n    realtime_init();\n    audio_init();\n    if (hax_enabled()) {\n        hax_sync_vcpus();\n    if (qemu_opts_foreach(qemu_find_opts(\"fw_cfg\"),\n                          parse_fw_cfg, fw_cfg_find(), NULL) != 0) {\n    \/* init USB devices *\/\n    if (machine_usb(current_machine)) {\n        if (foreach_device_config(DEV_USB, usb_parse) < 0)\n    \/* Check if IGD GFX passthrough. *\/\n    igd_gfx_passthru();\n    \/* init generic devices *\/\n    rom_set_order_override(FW_CFG_ORDER_OVERRIDE_DEVICE);\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"),\n                          device_init_func, NULL, NULL)) {\n    cpu_synchronize_all_post_init();\n    numa_post_machine_init();\n    rom_reset_order_override();\n    \/*\n     * Create frontends for -drive if=scsi leftovers.\n     * Normally, frontends for -drive get created by machine\n     * initialization for onboard SCSI HBAs.  However, we create a few\n     * more ever since SCSI qdevification, but this is pretty much an\n     * implementation accident, and deprecated.\n     *\/\n    scsi_legacy_handle_cmdline();\n    \/* Did we create any drives that we failed to create a device for? *\/\n    drive_check_orphaned();\n    \/* Don't warn about the default network setup that you get if\n     * no command line -net or -netdev options are specified. There\n     * are two cases that we would otherwise complain about:\n     * (1) board doesn't support a NIC but the implicit \"-net nic\"\n     * requested one\n     * (2) CONFIG_SLIRP not set, in which case the implicit \"-net nic\"\n     * sets up a nic that isn't connected to anything.\n     *\/\n    if (!default_net) {\n        net_check_clients();\n    if (boot_once) {\n        qemu_boot_set(boot_once, &error_fatal);\n        qemu_register_reset(restore_boot_order, g_strdup(boot_order));\n    ds = init_displaystate();\n    \/* init local displays *\/\n    switch (display_type) {\n    case DT_CURSES:\n        curses_display_init(ds, full_screen);\n    case DT_SDL:\n        sdl_display_init(ds, full_screen, no_frame);\n    case DT_COCOA:\n        cocoa_display_init(ds, full_screen);\n    case DT_GTK:\n        gtk_display_init(ds, full_screen, grab_on_hover);\n    default:\n    \/* must be after terminal init, SDL library changes signal handlers *\/\n    os_setup_signal_handling();\n    \/* init remote displays *\/\n#ifdef CONFIG_VNC\n    qemu_opts_foreach(qemu_find_opts(\"vnc\"),\n                      vnc_init_func, NULL, NULL);\n#endif\n    if (using_spice) {\n        qemu_spice_display_init();\n    if (foreach_device_config(DEV_GDB, gdbserver_start) < 0) {\n    qdev_machine_creation_done();\n    \/* TODO: once all bus devices are qdevified, this should be done\n     * when bus is created by qdev.c *\/\n    qemu_register_reset(qbus_reset_all_fn, sysbus_get_default());\n    qemu_run_machine_init_done_notifiers();\n    if (rom_check_and_register_reset() != 0) {\n        error_report(\"rom check and register reset failed\");\n    replay_start();\n    \/* This checkpoint is required by replay to separate prior clock\n       reading from the other reads, because timer polling functions query\n       clock values from the log. *\/\n    replay_checkpoint(CHECKPOINT_RESET);\n    qemu_system_reset(VMRESET_SILENT);\n    register_global_state();\n    if (replay_mode != REPLAY_MODE_NONE) {\n        replay_vmstate_init();\n    } else if (loadvm) {\n        if (load_vmstate(loadvm) < 0) {\n            autostart = 0;\n    qdev_prop_check_globals();\n    if (vmstate_dump_file) {\n        \/* dump and exit *\/\n        dump_vmstate_json_to_file(vmstate_dump_file);\n        return 0;\n    if (incoming) {\n        Error *local_err = NULL;\n        qemu_start_incoming_migration(incoming, &local_err);\n        if (local_err) {\n            error_reportf_err(local_err, \"-incoming %s: \", incoming);\n    } else if (autostart) {\n        vm_start();\n    os_setup_post();\n    main_loop();\n    replay_disable_events();\n    iothread_stop_all();\n    bdrv_close_all();\n    pause_all_vcpus();\n    res_free();\n    \/* vhost-user must be cleaned up before chardevs.  *\/\n    net_cleanup();\n    audio_cleanup();\n    monitor_cleanup();\n    qemu_chr_cleanup();\n    return 0;"},{"project":"qemu","commit_id":"58892b447f0ffcd0967bc6f1bcb40df288ebeebc","target":1,"func":"static void vfio_platform_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VFIOPlatformDevice *vdev = VFIO_PLATFORM_DEVICE(dev);\n\n    SysBusDevice *sbdev = SYS_BUS_DEVICE(dev);\n\n    VFIODevice *vbasedev = &vdev->vbasedev;\n\n    VFIOINTp *intp;\n\n    int i, ret;\n\n\n\n    vbasedev->type = VFIO_DEVICE_TYPE_PLATFORM;\n\n    vbasedev->ops = &vfio_platform_ops;\n\n\n\n    trace_vfio_platform_realize(vbasedev->name, vdev->compat);\n\n\n\n    ret = vfio_base_device_init(vbasedev);\n\n    if (ret) {\n\n        error_setg(errp, \"vfio: vfio_base_device_init failed for %s\",\n\n                   vbasedev->name);\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < vbasedev->num_regions; i++) {\n\n        vfio_map_region(vdev, i);\n\n        sysbus_init_mmio(sbdev, &vdev->regions[i]->mem);\n\n    }\n\n\n\n    QLIST_FOREACH(intp, &vdev->intp_list, next) {\n\n        vfio_start_eventfd_injection(intp);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"e68c35cfb8088a11300371751e3987f67cac15b1","target":0,"func":"static int nbd_negotiate_handle_list(NBDClient *client, uint32_t length,\n\n                                     Error **errp)\n\n{\n\n    NBDExport *exp;\n\n\n\n    if (length) {\n\n        if (nbd_drop(client->ioc, length, errp) < 0) {\n\n            return -EIO;\n\n        }\n\n        return nbd_negotiate_send_rep_err(client->ioc,\n\n                                          NBD_REP_ERR_INVALID, NBD_OPT_LIST,\n\n                                          errp,\n\n                                          \"OPT_LIST should not have length\");\n\n    }\n\n\n\n    \/* For each export, send a NBD_REP_SERVER reply. *\/\n\n    QTAILQ_FOREACH(exp, &exports, next) {\n\n        if (nbd_negotiate_send_rep_list(client->ioc, exp, errp)) {\n\n            return -EINVAL;\n\n        }\n\n    }\n\n    \/* Finish with a NBD_REP_ACK. *\/\n\n    return nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, NBD_OPT_LIST, errp);\n\n}\n"},{"project":"qemu","commit_id":"e23a1b33b53d25510320b26d9f154e19c6c99725","target":1,"func":"m48t59_t *m48t59_init_isa(uint32_t io_base, uint16_t size, int type)\n\n{\n\n    M48t59ISAState *d;\n\n    ISADevice *dev;\n\n    m48t59_t *s;\n\n\n\n    dev = isa_create(\"m48t59_isa\");\n\n    qdev_prop_set_uint32(&dev->qdev, \"type\", type);\n\n    qdev_prop_set_uint32(&dev->qdev, \"size\", size);\n\n    qdev_prop_set_uint32(&dev->qdev, \"io_base\", io_base);\n\n    qdev_init(&dev->qdev);\n\n    d = DO_UPCAST(M48t59ISAState, busdev, dev);\n\n    s = &d->state;\n\n\n\n    if (io_base != 0) {\n\n        register_ioport_read(io_base, 0x04, 1, NVRAM_readb, s);\n\n        register_ioport_write(io_base, 0x04, 1, NVRAM_writeb, s);\n\n    }\n\n\n\n    return s;\n\n}\n"},{"project":"qemu","commit_id":"260fecf13b0d30621dc88da03dc1b502b7358c6b","target":0,"func":"void bdrv_set_backing_hd(BlockDriverState *bs, BlockDriverState *backing_hd)\n\n{\n\n    if (backing_hd) {\n\n        bdrv_ref(backing_hd);\n\n    }\n\n\n\n    if (bs->backing) {\n\n        assert(bs->backing_blocker);\n\n        bdrv_op_unblock_all(bs->backing->bs, bs->backing_blocker);\n\n        bdrv_unref_child(bs, bs->backing);\n\n    } else if (backing_hd) {\n\n        error_setg(&bs->backing_blocker,\n\n                   \"node is used as backing hd of '%s'\",\n\n                   bdrv_get_device_or_node_name(bs));\n\n    }\n\n\n\n    if (!backing_hd) {\n\n        error_free(bs->backing_blocker);\n\n        bs->backing_blocker = NULL;\n\n        bs->backing = NULL;\n\n        goto out;\n\n    }\n\n    bs->backing = bdrv_attach_child(bs, backing_hd, &child_backing);\n\n    bs->open_flags &= ~BDRV_O_NO_BACKING;\n\n    pstrcpy(bs->backing_file, sizeof(bs->backing_file), backing_hd->filename);\n\n    pstrcpy(bs->backing_format, sizeof(bs->backing_format),\n\n            backing_hd->drv ? backing_hd->drv->format_name : \"\");\n\n\n\n    bdrv_op_block_all(backing_hd, bs->backing_blocker);\n\n    \/* Otherwise we won't be able to commit due to check in bdrv_commit *\/\n\n    bdrv_op_unblock(backing_hd, BLOCK_OP_TYPE_COMMIT_TARGET,\n\n                    bs->backing_blocker);\n\nout:\n\n    bdrv_refresh_limits(bs, NULL);\n\n}\n"},{"project":"qemu","commit_id":"47e8dd8fe9d83e8b51d40c2b87d7983bd0a78206","target":1,"func":"char **breakline(char *input, int *count)\n\n{\n\n    int c = 0;\n\n    char *p;\n\n    char **rval = calloc(sizeof(char *), 1);\n\n\n\n    while (rval && (p = qemu_strsep(&input, \" \")) != NULL) {\n\n        if (!*p) {\n\n            continue;\n\n        }\n\n        c++;\n\n        rval = realloc(rval, sizeof(*rval) * (c + 1));\n\n        if (!rval) {\n\n            c = 0;\n\n            break;\n\n        }\n\n        rval[c - 1] = p;\n\n        rval[c] = NULL;\n\n    }\n\n    *count = c;\n\n    return rval;\n\n}\n"},{"project":"qemu","commit_id":"c24a8a0b6dad5a33d84f5fb846edb28c43312c71","target":1,"func":"static inline uint64_t inline_cvttq(CPUAlphaState *env, uint64_t a,\n\n                                    int roundmode, int VI)\n\n{\n\n    uint64_t frac, ret = 0;\n\n    uint32_t exp, sign, exc = 0;\n\n    int shift;\n\n\n\n    sign = (a >> 63);\n\n    exp = (uint32_t)(a >> 52) & 0x7ff;\n\n    frac = a & 0xfffffffffffffull;\n\n\n\n    if (exp == 0) {\n\n        if (unlikely(frac != 0)) {\n\n            goto do_underflow;\n\n        }\n\n    } else if (exp == 0x7ff) {\n\n        exc = (frac ? FPCR_INV : VI ? FPCR_OVF : 0);\n\n    } else {\n\n        \/* Restore implicit bit.  *\/\n\n        frac |= 0x10000000000000ull;\n\n\n\n        shift = exp - 1023 - 52;\n\n        if (shift >= 0) {\n\n            \/* In this case the number is so large that we must shift\n\n               the fraction left.  There is no rounding to do.  *\/\n\n            if (shift < 63) {\n\n                ret = frac << shift;\n\n                if (VI && (ret >> shift) != frac) {\n\n                    exc = FPCR_OVF;\n\n                }\n\n            }\n\n        } else {\n\n            uint64_t round;\n\n\n\n            \/* In this case the number is smaller than the fraction as\n\n               represented by the 52 bit number.  Here we must think\n\n               about rounding the result.  Handle this by shifting the\n\n               fractional part of the number into the high bits of ROUND.\n\n               This will let us efficiently handle round-to-nearest.  *\/\n\n            shift = -shift;\n\n            if (shift < 63) {\n\n                ret = frac >> shift;\n\n                round = frac << (64 - shift);\n\n            } else {\n\n                \/* The exponent is so small we shift out everything.\n\n                   Leave a sticky bit for proper rounding below.  *\/\n\n            do_underflow:\n\n                round = 1;\n\n            }\n\n\n\n            if (round) {\n\n                exc = (VI ? FPCR_INE : 0);\n\n                switch (roundmode) {\n\n                case float_round_nearest_even:\n\n                    if (round == (1ull << 63)) {\n\n                        \/* Fraction is exactly 0.5; round to even.  *\/\n\n                        ret += (ret & 1);\n\n                    } else if (round > (1ull << 63)) {\n\n                        ret += 1;\n\n                    }\n\n                    break;\n\n                case float_round_to_zero:\n\n                    break;\n\n                case float_round_up:\n\n                    ret += 1 - sign;\n\n                    break;\n\n                case float_round_down:\n\n                    ret += sign;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (sign) {\n\n            ret = -ret;\n\n        }\n\n    }\n\n    env->error_code = exc;\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a","target":1,"func":"static void ivshmem_check_memdev_is_busy(Object *obj, const char *name,\n\n                                         Object *val, Error **errp)\n\n{\n\n    if (host_memory_backend_is_mapped(MEMORY_BACKEND(val))) {\n\n        char *path = object_get_canonical_path_component(val);\n\n        error_setg(errp, \"can't use already busy memdev: %s\", path);\n\n        g_free(path);\n\n    } else {\n\n        qdev_prop_allow_set_link_before_realize(obj, name, val, errp);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void lsi_ram_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t val, unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n    uint32_t newval;\n\n    uint32_t mask;\n\n    int shift;\n\n\n\n    newval = s->script_ram[addr >> 2];\n\n    shift = (addr & 3) * 8;\n\n    mask = ((uint64_t)1 << (size * 8)) - 1;\n\n    newval &= ~(mask << shift);\n\n    newval |= val << shift;\n\n    s->script_ram[addr >> 2] = newval;\n\n}\n"},{"project":"qemu","commit_id":"0cbad81f70546b58f08de3225f1eca7a8b869b09","target":1,"func":"static void kvmppc_host_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    uint32_t vmx = kvmppc_get_vmx();\n\n    uint32_t dfp = kvmppc_get_dfp();\n\n\n\n\n\n    \/* Now fix up the class with information we can query from the host *\/\n\n\n\n    if (vmx != -1) {\n\n        \/* Only override when we know what the host supports *\/\n\n        alter_insns(&pcc->insns_flags, PPC_ALTIVEC, vmx > 0);\n\n        alter_insns(&pcc->insns_flags2, PPC2_VSX, vmx > 1);\n\n    }\n\n    if (dfp != -1) {\n\n        \/* Only override when we know what the host supports *\/\n\n        alter_insns(&pcc->insns_flags2, PPC2_DFP, dfp);\n\n    }\n\n\n\n    if (dcache_size != -1) {\n\n        pcc->l1_dcache_size = dcache_size;\n\n    }\n\n\n\n    if (icache_size != -1) {\n\n        pcc->l1_icache_size = icache_size;\n\n    }\n\n}"},{"project":"qemu","commit_id":"381b634c275ca1a2806e97392527bbfc01bcb333","target":1,"func":"static void scsi_cmd_xfer_mode(SCSICommand *cmd)\n\n{\n\n    if (!cmd->xfer) {\n\n        cmd->mode = SCSI_XFER_NONE;\n\n        return;\n\n    }\n\n    switch (cmd->buf[0]) {\n\n    case WRITE_6:\n\n    case WRITE_10:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n    case COPY:\n\n    case COPY_VERIFY:\n\n    case COMPARE:\n\n    case CHANGE_DEFINITION:\n\n    case LOG_SELECT:\n\n    case MODE_SELECT:\n\n    case MODE_SELECT_10:\n\n    case SEND_DIAGNOSTIC:\n\n    case WRITE_BUFFER:\n\n    case FORMAT_UNIT:\n\n    case REASSIGN_BLOCKS:\n\n    case SEARCH_EQUAL:\n\n    case SEARCH_HIGH:\n\n    case SEARCH_LOW:\n\n    case UPDATE_BLOCK:\n\n    case WRITE_LONG_10:\n\n    case WRITE_SAME_10:\n\n    case WRITE_SAME_16:\n\n    case UNMAP:\n\n    case SEARCH_HIGH_12:\n\n    case SEARCH_EQUAL_12:\n\n    case SEARCH_LOW_12:\n\n    case MEDIUM_SCAN:\n\n    case SEND_VOLUME_TAG:\n\n    case SEND_CUE_SHEET:\n\n    case SEND_DVD_STRUCTURE:\n\n    case PERSISTENT_RESERVE_OUT:\n\n    case MAINTENANCE_OUT:\n\n\n        cmd->mode = SCSI_XFER_TO_DEV;\n\n        break;\n\n    default:\n\n        cmd->mode = SCSI_XFER_FROM_DEV;\n\n        break;\n\n    }\n\n}"},{"project":"qemu","commit_id":"e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f","target":1,"func":"static bool aux_bus_is_bridge(AUXBus *bus, DeviceState *dev)\n\n{\n\n    return (dev == DEVICE(bus->bridge));\n\n}\n"},{"project":"qemu","commit_id":"4eb938102b3d533e142de23e255e46da1326fc5a","target":0,"func":"static void qemu_fflush(QEMUFile *f)\n\n{\n\n    int ret = 0;\n\n\n\n    if (!f->ops->put_buffer) {\n\n        return;\n\n    }\n\n    if (f->is_write && f->buf_index > 0) {\n\n        ret = f->ops->put_buffer(f->opaque, f->buf, f->buf_offset, f->buf_index);\n\n        if (ret >= 0) {\n\n            f->buf_offset += f->buf_index;\n\n        }\n\n        f->buf_index = 0;\n\n    }\n\n    if (ret < 0) {\n\n        qemu_file_set_error(f, ret);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"eb5d4f5329df83ea15244b47f7fbca21adaae41b","target":0,"func":"static void slirp_state_save(QEMUFile *f, void *opaque)\n\n{\n\n    Slirp *slirp = opaque;\n\n    struct ex_list *ex_ptr;\n\n\n\n    for (ex_ptr = slirp->exec_list; ex_ptr; ex_ptr = ex_ptr->ex_next)\n\n        if (ex_ptr->ex_pty == 3) {\n\n            struct socket *so;\n\n            so = slirp_find_ctl_socket(slirp, ex_ptr->ex_addr,\n\n                                       ntohs(ex_ptr->ex_fport));\n\n            if (!so)\n\n                continue;\n\n\n\n            qemu_put_byte(f, 42);\n\n            vmstate_save_state(f, &vmstate_slirp_socket, so, NULL);\n\n        }\n\n    qemu_put_byte(f, 0);\n\n\n\n    qemu_put_be16(f, slirp->ip_id);\n\n\n\n    slirp_bootp_save(f, slirp);\n\n}\n"},{"project":"qemu","commit_id":"6cabe1f303b9d76458c00f00df7f477449a13b2f","target":0,"func":"static void qemu_wait_io_event(CPUState *env)\n\n{\n\n    while (!tcg_has_work())\n\n        qemu_cond_timedwait(env->halt_cond, &qemu_global_mutex, 1000);\n\n\n\n    qemu_mutex_unlock(&qemu_global_mutex);\n\n\n\n    \/*\n\n     * Users of qemu_global_mutex can be starved, having no chance\n\n     * to acquire it since this path will get to it first.\n\n     * So use another lock to provide fairness.\n\n     *\/\n\n    qemu_mutex_lock(&qemu_fair_mutex);\n\n    qemu_mutex_unlock(&qemu_fair_mutex);\n\n\n\n    qemu_mutex_lock(&qemu_global_mutex);\n\n    qemu_wait_io_event_common(env);\n\n}\n"},{"project":"qemu","commit_id":"e23a1b33b53d25510320b26d9f154e19c6c99725","target":1,"func":"static void *iommu_init(target_phys_addr_t addr, uint32_t version, qemu_irq irq)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"iommu\");\n\n    qdev_prop_set_uint32(dev, \"version\", version);\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, addr);\n\n\n\n    return s;\n\n}\n"},{"project":"qemu","commit_id":"cbf82fa01e6fd4ecb234b235b10ffce548154a95","target":1,"func":"static void ehci_detach(USBPort *port)\n\n{\n\n    EHCIState *s = port->opaque;\n\n    uint32_t *portsc = &s->portsc[port->index];\n\n    const char *owner = (*portsc & PORTSC_POWNER) ? \"comp\" : \"ehci\";\n\n\n\n    trace_usb_ehci_port_detach(port->index, owner);\n\n\n\n    if (*portsc & PORTSC_POWNER) {\n\n        USBPort *companion = s->companion_ports[port->index];\n\n        companion->ops->detach(companion);\n\n        companion->dev = NULL;\n\n        \/*\n\n         * EHCI spec 4.2.2: \"When a disconnect occurs... On the event,\n\n         * the port ownership is returned immediately to the EHCI controller.\"\n\n         *\/\n\n        *portsc &= ~PORTSC_POWNER;\n\n        return;\n\n    }\n\n\n\n    ehci_queues_rip_device(s, port->dev, 0);\n\n    ehci_queues_rip_device(s, port->dev, 1);\n\n\n\n    *portsc &= ~(PORTSC_CONNECT|PORTSC_PED);\n\n    *portsc |= PORTSC_CSC;\n\n\n\n    ehci_raise_irq(s, USBSTS_PCD);\n\n}\n"},{"project":"qemu","commit_id":"5f3e31012e334f3410e04abae7f88565df17c91a","target":1,"func":"void cpu_disable_ticks(void)\n\n{\n\n    \/* Here, the really thing protected by seqlock is cpu_clock_offset. *\/\n\n    seqlock_write_lock(&timers_state.vm_clock_seqlock);\n\n    if (timers_state.cpu_ticks_enabled) {\n\n        timers_state.cpu_ticks_offset = cpu_get_ticks();\n\n        timers_state.cpu_clock_offset = cpu_get_clock_locked();\n\n        timers_state.cpu_ticks_enabled = 0;\n\n    }\n\n    seqlock_write_unlock(&timers_state.vm_clock_seqlock);\n\n}\n"},{"project":"qemu","commit_id":"19494f811a43c6bc226aa272d86300d9229224fe","target":0,"func":"static void create_cps(MaltaState *s, const char *cpu_model,\n\n                       qemu_irq *cbus_irq, qemu_irq *i8259_irq)\n\n{\n\n    Error *err = NULL;\n\n    s->cps = g_new0(MIPSCPSState, 1);\n\n\n\n    object_initialize(s->cps, sizeof(MIPSCPSState), TYPE_MIPS_CPS);\n\n    qdev_set_parent_bus(DEVICE(s->cps), sysbus_get_default());\n\n\n\n    object_property_set_str(OBJECT(s->cps), cpu_model, \"cpu-model\", &err);\n\n    object_property_set_int(OBJECT(s->cps), smp_cpus, \"num-vp\", &err);\n\n    object_property_set_bool(OBJECT(s->cps), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        error_report(\"%s\", error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    sysbus_mmio_map_overlap(SYS_BUS_DEVICE(s->cps), 0, 0, 1);\n\n\n\n    \/* FIXME: When GIC is present then we should use GIC's IRQ 3.\n\n       Until then CPS exposes CPU's IRQs thus use the default IRQ 2. *\/\n\n    *i8259_irq = get_cps_irq(s->cps, 2);\n\n    *cbus_irq = NULL;\n\n}\n"},{"project":"qemu","commit_id":"fdfab37dfeffefbd4533b4158055c9b82d7c3e69","target":0,"func":"static int count_cow_clusters(BDRVQcow2State *s, int nb_clusters,\n\n    uint64_t *l2_table, int l2_index)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t l2_entry = be64_to_cpu(l2_table[l2_index + i]);\n\n        QCow2ClusterType cluster_type = qcow2_get_cluster_type(l2_entry);\n\n\n\n        switch(cluster_type) {\n\n        case QCOW2_CLUSTER_NORMAL:\n\n            if (l2_entry & QCOW_OFLAG_COPIED) {\n\n                goto out;\n\n            }\n\n            break;\n\n        case QCOW2_CLUSTER_UNALLOCATED:\n\n        case QCOW2_CLUSTER_COMPRESSED:\n\n        case QCOW2_CLUSTER_ZERO:\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\nout:\n\n    assert(i <= nb_clusters);\n\n    return i;\n\n}\n"},{"project":"qemu","commit_id":"60fe637bf0e4d7989e21e50f52526444765c63b4","target":1,"func":"int64_t qmp_query_migrate_cache_size(Error **errp)\n\n{\n\n    return migrate_xbzrle_cache_size();\n\n}\n"},{"project":"qemu","commit_id":"21d58b575e79c5d0739b695b272ea89bb052a7bf","target":1,"func":"static void virtio_console_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    vdev = virtio_console_init(&pci_dev->qdev);\n\n    virtio_init_pci(proxy, vdev,\n\n                    PCI_VENDOR_ID_REDHAT_QUMRANET,\n\n                    PCI_DEVICE_ID_VIRTIO_CONSOLE,\n\n                    PCI_CLASS_DISPLAY_OTHER,\n\n                    0x00);\n\n}\n"},{"project":"qemu","commit_id":"33876dfad64bc481f59c5e9ccf60db78624c4b93","target":1,"func":"static struct XenDevice *xen_be_get_xendev(const char *type, int dom, int dev,\n\n                                           struct XenDevOps *ops)\n\n{\n\n    struct XenDevice *xendev;\n\n    char *dom0;\n\n\n\n    xendev = xen_be_find_xendev(type, dom, dev);\n\n    if (xendev) {\n\n        return xendev;\n\n    }\n\n\n\n    \/* init new xendev *\/\n\n    xendev = g_malloc0(ops->size);\n\n    xendev->type  = type;\n\n    xendev->dom   = dom;\n\n    xendev->dev   = dev;\n\n    xendev->ops   = ops;\n\n\n\n    dom0 = xs_get_domain_path(xenstore, 0);\n\n    snprintf(xendev->be, sizeof(xendev->be), \"%s\/backend\/%s\/%d\/%d\",\n\n             dom0, xendev->type, xendev->dom, xendev->dev);\n\n    snprintf(xendev->name, sizeof(xendev->name), \"%s-%d\",\n\n             xendev->type, xendev->dev);\n\n    free(dom0);\n\n\n\n    xendev->debug      = debug;\n\n    xendev->local_port = -1;\n\n\n\n    xendev->evtchndev = xen_xc_evtchn_open(NULL, 0);\n\n    if (xendev->evtchndev == XC_HANDLER_INITIAL_VALUE) {\n\n        xen_be_printf(NULL, 0, \"can't open evtchn device\\n\");\n\n        g_free(xendev);\n\n        return NULL;\n\n    }\n\n    fcntl(xc_evtchn_fd(xendev->evtchndev), F_SETFD, FD_CLOEXEC);\n\n\n\n    if (ops->flags & DEVOPS_FLAG_NEED_GNTDEV) {\n\n        xendev->gnttabdev = xen_xc_gnttab_open(NULL, 0);\n\n        if (xendev->gnttabdev == XC_HANDLER_INITIAL_VALUE) {\n\n            xen_be_printf(NULL, 0, \"can't open gnttab device\\n\");\n\n            xc_evtchn_close(xendev->evtchndev);\n\n            g_free(xendev);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        xendev->gnttabdev = XC_HANDLER_INITIAL_VALUE;\n\n    }\n\n\n\n    QTAILQ_INSERT_TAIL(&xendevs, xendev, next);\n\n\n\n    if (xendev->ops->alloc) {\n\n        xendev->ops->alloc(xendev);\n\n    }\n\n\n\n    return xendev;\n\n}\n"},{"project":"qemu","commit_id":"7df953bd456da45f761064974820ab5c3fd7b2aa","target":0,"func":"static void vtd_context_device_invalidate(IntelIOMMUState *s,\n\n                                          uint16_t source_id,\n\n                                          uint16_t func_mask)\n\n{\n\n    uint16_t mask;\n\n    VTDAddressSpace **pvtd_as;\n\n    VTDAddressSpace *vtd_as;\n\n    uint16_t devfn;\n\n    uint16_t devfn_it;\n\n\n\n    switch (func_mask & 3) {\n\n    case 0:\n\n        mask = 0;   \/* No bits in the SID field masked *\/\n\n        break;\n\n    case 1:\n\n        mask = 4;   \/* Mask bit 2 in the SID field *\/\n\n        break;\n\n    case 2:\n\n        mask = 6;   \/* Mask bit 2:1 in the SID field *\/\n\n        break;\n\n    case 3:\n\n        mask = 7;   \/* Mask bit 2:0 in the SID field *\/\n\n        break;\n\n    }\n\n    VTD_DPRINTF(INV, \"device-selective invalidation source 0x%\"PRIx16\n\n                    \" mask %\"PRIu16, source_id, mask);\n\n    pvtd_as = s->address_spaces[VTD_SID_TO_BUS(source_id)];\n\n    if (pvtd_as) {\n\n        devfn = VTD_SID_TO_DEVFN(source_id);\n\n        for (devfn_it = 0; devfn_it < VTD_PCI_DEVFN_MAX; ++devfn_it) {\n\n            vtd_as = pvtd_as[devfn_it];\n\n            if (vtd_as && ((devfn_it & mask) == (devfn & mask))) {\n\n                VTD_DPRINTF(INV, \"invalidate context-cahce of devfn 0x%\"PRIx16,\n\n                            devfn_it);\n\n                vtd_as->context_cache_entry.context_cache_gen = 0;\n\n            }\n\n        }\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"6a91cf04a1177f47a18d3c25873513a1ebfc2fcb","target":0,"func":"void pc_cpus_init(PCMachineState *pcms)\n\n{\n\n    int i;\n\n    CPUClass *cc;\n\n    ObjectClass *oc;\n\n    const char *typename;\n\n    gchar **model_pieces;\n\n    X86CPU *cpu = NULL;\n\n    MachineState *machine = MACHINE(pcms);\n\n\n\n    \/* init CPUs *\/\n\n    if (machine->cpu_model == NULL) {\n\n#ifdef TARGET_X86_64\n\n        machine->cpu_model = \"qemu64\";\n\n#else\n\n        machine->cpu_model = \"qemu32\";\n\n#endif\n\n    }\n\n\n\n    model_pieces = g_strsplit(machine->cpu_model, \",\", 2);\n\n    if (!model_pieces[0]) {\n\n        error_report(\"Invalid\/empty CPU model name\");\n\n        exit(1);\n\n    }\n\n\n\n    oc = cpu_class_by_name(TYPE_X86_CPU, model_pieces[0]);\n\n    if (oc == NULL) {\n\n        error_report(\"Unable to find CPU definition: %s\", model_pieces[0]);\n\n        exit(1);\n\n    }\n\n    typename = object_class_get_name(oc);\n\n    cc = CPU_CLASS(oc);\n\n    cc->parse_features(typename, model_pieces[1], &error_fatal);\n\n    g_strfreev(model_pieces);\n\n\n\n    \/* Calculates the limit to CPU APIC ID values\n\n     *\n\n     * Limit for the APIC ID value, so that all\n\n     * CPU APIC IDs are < pcms->apic_id_limit.\n\n     *\n\n     * This is used for FW_CFG_MAX_CPUS. See comments on bochs_bios_init().\n\n     *\/\n\n    pcms->apic_id_limit = x86_cpu_apic_id_from_index(max_cpus - 1) + 1;\n\n    if (pcms->apic_id_limit > ACPI_CPU_HOTPLUG_ID_LIMIT) {\n\n        error_report(\"max_cpus is too large. APIC ID of last CPU is %u\",\n\n                     pcms->apic_id_limit - 1);\n\n        exit(1);\n\n    }\n\n\n\n    pcms->possible_cpus = g_malloc0(sizeof(CPUArchIdList) +\n\n                                    sizeof(CPUArchId) * max_cpus);\n\n    for (i = 0; i < max_cpus; i++) {\n\n        pcms->possible_cpus->cpus[i].arch_id = x86_cpu_apic_id_from_index(i);\n\n        pcms->possible_cpus->len++;\n\n        if (i < smp_cpus) {\n\n            cpu = pc_new_cpu(typename, x86_cpu_apic_id_from_index(i),\n\n                             &error_fatal);\n\n            object_unref(OBJECT(cpu));\n\n        }\n\n    }\n\n\n\n    \/* tell smbios about cpuid version and features *\/\n\n    smbios_set_cpuid(cpu->env.cpuid_version, cpu->env.features[FEAT_1_EDX]);\n\n}\n"},{"project":"qemu","commit_id":"8be7e7e4c72c048b90e3482557954a24bba43ba7","target":1,"func":"QemuOpts *qemu_opts_create(QemuOptsList *list, const char *id, int fail_if_exists)\n\n{\n\n    QemuOpts *opts = NULL;\n\n\n\n    if (id) {\n\n        if (!id_wellformed(id)) {\n\n            qerror_report(QERR_INVALID_PARAMETER_VALUE, \"id\", \"an identifier\");\n\n            error_printf_unless_qmp(\"Identifiers consist of letters, digits, '-', '.', '_', starting with a letter.\\n\");\n\n            return NULL;\n\n        }\n\n        opts = qemu_opts_find(list, id);\n\n        if (opts != NULL) {\n\n            if (fail_if_exists && !list->merge_lists) {\n\n                qerror_report(QERR_DUPLICATE_ID, id, list->name);\n\n                return NULL;\n\n            } else {\n\n                return opts;\n\n            }\n\n        }\n\n    } else if (list->merge_lists) {\n\n        opts = qemu_opts_find(list, NULL);\n\n        if (opts) {\n\n            return opts;\n\n        }\n\n    }\n\n    opts = g_malloc0(sizeof(*opts));\n\n    if (id) {\n\n        opts->id = g_strdup(id);\n\n    }\n\n    opts->list = list;\n\n    loc_save(&opts->loc);\n\n    QTAILQ_INIT(&opts->head);\n\n    QTAILQ_INSERT_TAIL(&list->head, opts, next);\n\n    return opts;\n\n}\n"},{"project":"qemu","commit_id":"1b7f01d966f97b7820f3cdd471461cf0799a93cc","target":1,"func":"void qemu_co_rwlock_rdlock(CoRwlock *lock)\n{\n    while (lock->writer) {\n        qemu_co_queue_wait(&lock->queue);\n    }\n    lock->reader++;\n}"},{"project":"qemu","commit_id":"0ba1f53191221b541b938df86a39eeccfb87f996","target":0,"func":"void virtio_scsi_common_realize(DeviceState *dev, Error **errp,\n\n                                HandleOutput ctrl, HandleOutput evt,\n\n                                HandleOutput cmd)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOSCSICommon *s = VIRTIO_SCSI_COMMON(dev);\n\n    int i;\n\n\n\n    virtio_init(vdev, \"virtio-scsi\", VIRTIO_ID_SCSI,\n\n                sizeof(VirtIOSCSIConfig));\n\n\n\n    if (s->conf.num_queues <= 0 || s->conf.num_queues > VIRTIO_PCI_QUEUE_MAX) {\n\n        error_setg(errp, \"Invalid number of queues (= %\" PRId32 \"), \"\n\n                         \"must be a positive integer less than %d.\",\n\n                   s->conf.num_queues, VIRTIO_PCI_QUEUE_MAX);\n\n        virtio_cleanup(vdev);\n\n        return;\n\n    }\n\n    s->cmd_vqs = g_malloc0(s->conf.num_queues * sizeof(VirtQueue *));\n\n    s->sense_size = VIRTIO_SCSI_SENSE_SIZE;\n\n    s->cdb_size = VIRTIO_SCSI_CDB_SIZE;\n\n\n\n    s->ctrl_vq = virtio_add_queue(vdev, VIRTIO_SCSI_VQ_SIZE,\n\n                                  ctrl);\n\n    s->event_vq = virtio_add_queue(vdev, VIRTIO_SCSI_VQ_SIZE,\n\n                                   evt);\n\n    for (i = 0; i < s->conf.num_queues; i++) {\n\n        s->cmd_vqs[i] = virtio_add_queue(vdev, VIRTIO_SCSI_VQ_SIZE,\n\n                                         cmd);\n\n    }\n\n\n\n    if (s->conf.iothread) {\n\n        virtio_scsi_set_iothread(VIRTIO_SCSI(s), s->conf.iothread);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"5b956f415a356449a4171d5e0c7d9a25bbc84b5a","target":0,"func":"static void scsi_do_read(SCSIDiskReq *r, int ret)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    SCSIDiskClass *sdc = (SCSIDiskClass *) object_get_class(OBJECT(s));\n\n\n\n    assert (r->req.aiocb == NULL);\n\n\n\n    if (r->req.io_canceled) {\n\n        scsi_req_cancel_complete(&r->req);\n\n        goto done;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        if (scsi_handle_rw_error(r, -ret, false)) {\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    \/* The request is used as the AIO opaque value, so add a ref.  *\/\n\n    scsi_req_ref(&r->req);\n\n\n\n    if (r->req.sg) {\n\n        dma_acct_start(s->qdev.conf.blk, &r->acct, r->req.sg, BLOCK_ACCT_READ);\n\n        r->req.resid -= r->req.sg->size;\n\n        r->req.aiocb = dma_blk_io(blk_get_aio_context(s->qdev.conf.blk),\n\n                                  r->req.sg, r->sector << BDRV_SECTOR_BITS,\n\n                                  sdc->dma_readv, r, scsi_dma_complete, r,\n\n                                  DMA_DIRECTION_FROM_DEVICE);\n\n    } else {\n\n        scsi_init_iovec(r, SCSI_DMA_BUF_SIZE);\n\n        block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,\n\n                         r->qiov.size, BLOCK_ACCT_READ);\n\n        r->req.aiocb = sdc->dma_readv(r->sector, &r->qiov,\n\n                                      scsi_read_complete, r, r);\n\n    }\n\n\n\ndone:\n\n    scsi_req_unref(&r->req);\n\n}\n"},{"project":"qemu","commit_id":"b4ba67d9a702507793c2724e56f98e9b0f7be02b","target":1,"func":"bool qpci_msix_masked(QPCIDevice *dev, uint16_t entry)\n\n{\n\n    uint8_t addr;\n\n    uint16_t val;\n\n    void *vector_addr = dev->msix_table + (entry * PCI_MSIX_ENTRY_SIZE);\n\n\n\n    g_assert(dev->msix_enabled);\n\n    addr = qpci_find_capability(dev, PCI_CAP_ID_MSIX);\n\n    g_assert_cmphex(addr, !=, 0);\n\n    val = qpci_config_readw(dev, addr + PCI_MSIX_FLAGS);\n\n\n\n    if (val & PCI_MSIX_FLAGS_MASKALL) {\n\n        return true;\n\n    } else {\n\n        return (qpci_io_readl(dev, vector_addr + PCI_MSIX_ENTRY_VECTOR_CTRL)\n\n                                            & PCI_MSIX_ENTRY_CTRL_MASKBIT) != 0;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"cfaf6d36ae761da1033159d85d670706ffb24fb9","target":0,"func":"static void fd_accept_incoming_migration(void *opaque)\n\n{\n\n    QEMUFile *f = opaque;\n\n    int ret;\n\n\n\n    ret = qemu_loadvm_state(f);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"load of migration failed\\n\");\n\n        goto err;\n\n    }\n\n    qemu_announce_self();\n\n    DPRINTF(\"successfully loaded vm state\\n\");\n\n    \/* we've successfully migrated, close the fd *\/\n\n    qemu_set_fd_handler2(qemu_stdio_fd(f), NULL, NULL, NULL, NULL);\n\n    if (autostart)\n\n        vm_start();\n\n\n\nerr:\n\n    qemu_fclose(f);\n\n}\n"},{"project":"qemu","commit_id":"17a71e58238138c3f02be7e9f5dc8de5d72a9a9d","target":0,"func":"static int do_alloc_cluster_offset(BlockDriverState *bs, uint64_t guest_offset,\n\n    uint64_t *host_offset, unsigned int *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret;\n\n\n\n    trace_qcow2_do_alloc_clusters_offset(qemu_coroutine_self(), guest_offset,\n\n                                         *host_offset, *nb_clusters);\n\n\n\n    ret = handle_dependencies(bs, guest_offset, nb_clusters);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* Allocate new clusters *\/\n\n    trace_qcow2_cluster_alloc_phys(qemu_coroutine_self());\n\n    if (*host_offset == 0) {\n\n        int64_t cluster_offset =\n\n            qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);\n\n        if (cluster_offset < 0) {\n\n            return cluster_offset;\n\n        }\n\n        *host_offset = cluster_offset;\n\n        return 0;\n\n    } else {\n\n        ret = qcow2_alloc_clusters_at(bs, *host_offset, *nb_clusters);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        *nb_clusters = ret;\n\n        return 0;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"de9e9d9f17a36ff76c1a02a5348835e5e0a081b0","target":0,"func":"static inline void gen_op_multiply(TCGv dst, TCGv src1, TCGv src2, int sign_ext)\n\n{\n\n    TCGv_i32 r_src1, r_src2;\n\n    TCGv_i64 r_temp, r_temp2;\n\n\n\n    r_src1 = tcg_temp_new_i32();\n\n    r_src2 = tcg_temp_new_i32();\n\n\n\n    tcg_gen_trunc_tl_i32(r_src1, src1);\n\n    tcg_gen_trunc_tl_i32(r_src2, src2);\n\n\n\n    r_temp = tcg_temp_new_i64();\n\n    r_temp2 = tcg_temp_new_i64();\n\n\n\n    if (sign_ext) {\n\n        tcg_gen_ext_i32_i64(r_temp, r_src2);\n\n        tcg_gen_ext_i32_i64(r_temp2, r_src1);\n\n    } else {\n\n        tcg_gen_extu_i32_i64(r_temp, r_src2);\n\n        tcg_gen_extu_i32_i64(r_temp2, r_src1);\n\n    }\n\n\n\n    tcg_gen_mul_i64(r_temp2, r_temp, r_temp2);\n\n\n\n    tcg_gen_shri_i64(r_temp, r_temp2, 32);\n\n    tcg_gen_trunc_i64_tl(cpu_tmp0, r_temp);\n\n    tcg_temp_free_i64(r_temp);\n\n    tcg_gen_andi_tl(cpu_y, cpu_tmp0, 0xffffffff);\n\n\n\n    tcg_gen_trunc_i64_tl(dst, r_temp2);\n\n\n\n    tcg_temp_free_i64(r_temp2);\n\n\n\n    tcg_temp_free_i32(r_src1);\n\n    tcg_temp_free_i32(r_src2);\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void omap_tcmi_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_write32(opaque, addr, value);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t\/* IMIF_PRIO *\/\n\n    case 0x04:\t\/* EMIFS_PRIO *\/\n\n    case 0x08:\t\/* EMIFF_PRIO *\/\n\n    case 0x10:\t\/* EMIFS_CS0_CONFIG *\/\n\n    case 0x14:\t\/* EMIFS_CS1_CONFIG *\/\n\n    case 0x18:\t\/* EMIFS_CS2_CONFIG *\/\n\n    case 0x1c:\t\/* EMIFS_CS3_CONFIG *\/\n\n    case 0x20:\t\/* EMIFF_SDRAM_CONFIG *\/\n\n    case 0x24:\t\/* EMIFF_MRS *\/\n\n    case 0x28:\t\/* TIMEOUT1 *\/\n\n    case 0x2c:\t\/* TIMEOUT2 *\/\n\n    case 0x30:\t\/* TIMEOUT3 *\/\n\n    case 0x3c:\t\/* EMIFF_SDRAM_CONFIG_2 *\/\n\n    case 0x40:\t\/* EMIFS_CFG_DYN_WAIT *\/\n\n        s->tcmi_regs[addr >> 2] = value;\n\n        break;\n\n    case 0x0c:\t\/* EMIFS_CONFIG *\/\n\n        s->tcmi_regs[addr >> 2] = (value & 0xf) | (1 << 4);\n\n        break;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static uint64_t lan9118_16bit_mode_read(void *opaque, target_phys_addr_t offset,\n\n                                        unsigned size)\n\n{\n\n    switch (size) {\n\n    case 2:\n\n        return lan9118_readw(opaque, offset);\n\n    case 4:\n\n        return lan9118_readl(opaque, offset, size);\n\n    }\n\n\n\n    hw_error(\"lan9118_read: Bad size 0x%x\\n\", size);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"0188fadb7fe460d8c4c743372b1f7b25773e183e","target":1,"func":"static void setup_frame(int sig, struct target_sigaction *ka,\n\n                        target_sigset_t *set, CPUM68KState *env)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    abi_ulong retcode_addr;\n\n    abi_ulong sc_addr;\n\n    int err = 0;\n\n    int i;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof *frame);\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n\n\tgoto give_sigsegv;\n\n\n\n    __put_user(sig, &frame->sig);\n\n\n\n    sc_addr = frame_addr + offsetof(struct target_sigframe, sc);\n\n    __put_user(sc_addr, &frame->psc);\n\n\n\n    setup_sigcontext(&frame->sc, env, set->sig[0]);\n\n\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        if (__put_user(set->sig[i], &frame->extramask[i - 1]))\n\n            goto give_sigsegv;\n\n    }\n\n\n\n    \/* Set up to return from userspace.  *\/\n\n\n\n    retcode_addr = frame_addr + offsetof(struct target_sigframe, retcode);\n\n    __put_user(retcode_addr, &frame->pretcode);\n\n\n\n    \/* moveq #,d0; trap #0 *\/\n\n\n\n    __put_user(0x70004e40 + (TARGET_NR_sigreturn << 16),\n\n                      (long *)(frame->retcode));\n\n\n\n    if (err)\n\n        goto give_sigsegv;\n\n\n\n    \/* Set up to return from userspace *\/\n\n\n\n    env->aregs[7] = frame_addr;\n\n    env->pc = ka->_sa_handler;\n\n\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    return;\n\n\n\ngive_sigsegv:\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n"},{"project":"qemu","commit_id":"805017b7791200f1b72deef17dc98fd272b941eb","target":0,"func":"int main(int argc, char **argv)\n\n{\n\n    TestInputVisitorData testdata;\n\n\n\n    g_test_init(&argc, &argv, NULL);\n\n\n\n    validate_test_add(\"\/visitor\/input-strict\/pass\/struct\",\n\n                       &testdata, test_validate_struct);\n\n    validate_test_add(\"\/visitor\/input-strict\/pass\/struct-nested\",\n\n                       &testdata, test_validate_struct_nested);\n\n    validate_test_add(\"\/visitor\/input-strict\/pass\/list\",\n\n                       &testdata, test_validate_list);\n\n    validate_test_add(\"\/visitor\/input-strict\/pass\/union\",\n\n                       &testdata, test_validate_union);\n\n    validate_test_add(\"\/visitor\/input-strict\/pass\/union-flat\",\n\n                       &testdata, test_validate_union_flat);\n\n    validate_test_add(\"\/visitor\/input-strict\/pass\/union-anon\",\n\n                       &testdata, test_validate_union_anon);\n\n    validate_test_add(\"\/visitor\/input-strict\/fail\/struct\",\n\n                       &testdata, test_validate_fail_struct);\n\n    validate_test_add(\"\/visitor\/input-strict\/fail\/struct-nested\",\n\n                       &testdata, test_validate_fail_struct_nested);\n\n    validate_test_add(\"\/visitor\/input-strict\/fail\/list\",\n\n                       &testdata, test_validate_fail_list);\n\n    validate_test_add(\"\/visitor\/input-strict\/fail\/union\",\n\n                       &testdata, test_validate_fail_union);\n\n    validate_test_add(\"\/visitor\/input-strict\/fail\/union-flat\",\n\n                       &testdata, test_validate_fail_union_flat);\n\n    validate_test_add(\"\/visitor\/input-strict\/fail\/union-flat-no-discriminator\",\n\n                       &testdata, test_validate_fail_union_flat_no_discrim);\n\n    validate_test_add(\"\/visitor\/input-strict\/fail\/union-anon\",\n\n                       &testdata, test_validate_fail_union_anon);\n\n\n\n    g_test_run();\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"e6eef7c221634c942e9f586df84aae623aa06cd5","target":0,"func":"int kvm_arch_put_registers(CPUState *cs, int level)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    CPUS390XState *env = &cpu->env;\n\n    struct kvm_sregs sregs;\n\n    struct kvm_regs regs;\n\n    struct kvm_fpu fpu;\n\n    int r;\n\n    int i;\n\n\n\n    \/* always save the PSW  and the GPRS*\/\n\n    cs->kvm_run->psw_addr = env->psw.addr;\n\n    cs->kvm_run->psw_mask = env->psw.mask;\n\n\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            cs->kvm_run->s.regs.gprs[i] = env->regs[i];\n\n            cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_GPRS;\n\n        }\n\n    } else {\n\n        for (i = 0; i < 16; i++) {\n\n            regs.gprs[i] = env->regs[i];\n\n        }\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_REGS, &regs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    \/* Floating point *\/\n\n    for (i = 0; i < 16; i++) {\n\n        fpu.fprs[i] = env->fregs[i].ll;\n\n    }\n\n    fpu.fpc = env->fpc;\n\n\n\n    r = kvm_vcpu_ioctl(cs, KVM_SET_FPU, &fpu);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    \/* Do we need to save more than that? *\/\n\n    if (level == KVM_PUT_RUNTIME_STATE) {\n\n        return 0;\n\n    }\n\n\n\n    \/*\n\n     * These ONE_REGS are not protected by a capability. As they are only\n\n     * necessary for migration we just trace a possible error, but don't\n\n     * return with an error return code.\n\n     *\/\n\n    kvm_set_one_reg(cs, KVM_REG_S390_CPU_TIMER, &env->cputm);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_CLOCK_COMP, &env->ckc);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_TODPR, &env->todpr);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_GBEA, &env->gbea);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_PP, &env->pp);\n\n\n\n    if (cap_async_pf) {\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFTOKEN, &env->pfault_token);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFCOMPARE, &env->pfault_compare);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFSELECT, &env->pfault_select);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    if (cap_sync_regs &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            cs->kvm_run->s.regs.acrs[i] = env->aregs[i];\n\n            cs->kvm_run->s.regs.crs[i] = env->cregs[i];\n\n        }\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_ACRS;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_CRS;\n\n    } else {\n\n        for (i = 0; i < 16; i++) {\n\n            sregs.acrs[i] = env->aregs[i];\n\n            sregs.crs[i] = env->cregs[i];\n\n        }\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_SREGS, &sregs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    \/* Finally the prefix *\/\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) {\n\n        cs->kvm_run->s.regs.prefix = env->psa;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_PREFIX;\n\n    } else {\n\n        \/* prefix is only supported via sync regs *\/\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"30f6da6656c94964ba8677928588592d9667007e","target":0,"func":"static int qxl_post_load(void *opaque, int version)\n\n{\n\n    PCIQXLDevice* d = opaque;\n\n    uint8_t *ram_start = d->vga.vram_ptr;\n\n    QXLCommandExt *cmds;\n\n    int in, out, i, newmode;\n\n\n\n    dprint(d, 1, \"%s: start\\n\", __FUNCTION__);\n\n\n\n    assert(d->last_release_offset < d->vga.vram_size);\n\n    if (d->last_release_offset == 0) {\n\n        d->last_release = NULL;\n\n    } else {\n\n        d->last_release = (QXLReleaseInfo *)(ram_start + d->last_release_offset);\n\n    }\n\n\n\n    d->modes = (QXLModes*)((uint8_t*)d->rom + d->rom->modes_offset);\n\n\n\n    dprint(d, 1, \"%s: restore mode (%s)\\n\", __FUNCTION__,\n\n        qxl_mode_to_string(d->mode));\n\n    newmode = d->mode;\n\n    d->mode = QXL_MODE_UNDEFINED;\n\n    switch (newmode) {\n\n    case QXL_MODE_UNDEFINED:\n\n        break;\n\n    case QXL_MODE_VGA:\n\n        qxl_enter_vga_mode(d);\n\n        break;\n\n    case QXL_MODE_NATIVE:\n\n        for (i = 0; i < NUM_MEMSLOTS; i++) {\n\n            if (!d->guest_slots[i].active) {\n\n                continue;\n\n            }\n\n            qxl_add_memslot(d, i, 0, QXL_SYNC);\n\n        }\n\n        qxl_create_guest_primary(d, 1, QXL_SYNC);\n\n\n\n        \/* replay surface-create and cursor-set commands *\/\n\n        cmds = g_malloc0(sizeof(QXLCommandExt) * (NUM_SURFACES + 1));\n\n        for (in = 0, out = 0; in < NUM_SURFACES; in++) {\n\n            if (d->guest_surfaces.cmds[in] == 0) {\n\n                continue;\n\n            }\n\n            cmds[out].cmd.data = d->guest_surfaces.cmds[in];\n\n            cmds[out].cmd.type = QXL_CMD_SURFACE;\n\n            cmds[out].group_id = MEMSLOT_GROUP_GUEST;\n\n            out++;\n\n        }\n\n        cmds[out].cmd.data = d->guest_cursor;\n\n        cmds[out].cmd.type = QXL_CMD_CURSOR;\n\n        cmds[out].group_id = MEMSLOT_GROUP_GUEST;\n\n        out++;\n\n        qxl_spice_loadvm_commands(d, cmds, out);\n\n        g_free(cmds);\n\n\n\n        break;\n\n    case QXL_MODE_COMPAT:\n\n        qxl_set_mode(d, d->shadow_rom.mode, 1);\n\n        break;\n\n    }\n\n    dprint(d, 1, \"%s: done\\n\", __FUNCTION__);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"9be385980d37e8f4fd33f605f5fb1c3d144170a8","target":0,"func":"static uint32_t vbe_ioport_read_index(void *opaque, uint32_t addr)\n\n{\n\n    VGACommonState *s = opaque;\n\n    uint32_t val;\n\n    val = s->vbe_index;\n\n    return val;\n\n}\n"},{"project":"qemu","commit_id":"cfc87e00c22ab4ea0262c9771c803ed03d754001","target":1,"func":"static int64_t alloc_block(BlockDriverState* bs, int64_t offset)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    int64_t bat_offset;\n\n    uint32_t index, bat_value;\n\n    int ret;\n\n    uint8_t bitmap[s->bitmap_size];\n\n\n\n    \/* Check if sector_num is valid *\/\n\n    if ((offset < 0) || (offset > bs->total_sectors * BDRV_SECTOR_SIZE)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    \/* Write entry into in-memory BAT *\/\n\n    index = offset \/ s->block_size;\n\n    assert(s->pagetable[index] == 0xFFFFFFFF);\n\n    s->pagetable[index] = s->free_data_block_offset \/ 512;\n\n\n\n    \/* Initialize the block's bitmap *\/\n\n    memset(bitmap, 0xff, s->bitmap_size);\n\n    ret = bdrv_pwrite_sync(bs->file, s->free_data_block_offset, bitmap,\n\n        s->bitmap_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* Write new footer (the old one will be overwritten) *\/\n\n    s->free_data_block_offset += s->block_size + s->bitmap_size;\n\n    ret = rewrite_footer(bs);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    \/* Write BAT entry to disk *\/\n\n    bat_offset = s->bat_offset + (4 * index);\n\n    bat_value = cpu_to_be32(s->pagetable[index]);\n\n    ret = bdrv_pwrite_sync(bs->file, bat_offset, &bat_value, 4);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    return get_image_offset(bs, offset, false);\n\n\n\nfail:\n\n    s->free_data_block_offset -= (s->block_size + s->bitmap_size);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"04088adbe0c5adca66adb6022723362ad90ed0fc","target":0,"func":"static void bamboo_init(ram_addr_t ram_size,\n\n                        const char *boot_device,\n\n                        const char *kernel_filename,\n\n                        const char *kernel_cmdline,\n\n                        const char *initrd_filename,\n\n                        const char *cpu_model)\n\n{\n\n    unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 };\n\n    PCIBus *pcibus;\n\n    CPUState *env;\n\n    uint64_t elf_entry;\n\n    uint64_t elf_lowaddr;\n\n    target_phys_addr_t entry = 0;\n\n    target_phys_addr_t loadaddr = 0;\n\n    target_long kernel_size = 0;\n\n    target_ulong initrd_base = 0;\n\n    target_long initrd_size = 0;\n\n    target_ulong dt_base = 0;\n\n    void *fdt;\n\n    int i;\n\n\n\n    \/* Setup CPU. *\/\n\n    env = ppc440ep_init(&ram_size, &pcibus, pci_irq_nrs, 1, cpu_model);\n\n\n\n    if (pcibus) {\n\n        \/* Register network interfaces. *\/\n\n        for (i = 0; i < nb_nics; i++) {\n\n            \/* There are no PCI NICs on the Bamboo board, but there are\n\n             * PCI slots, so we can pick whatever default model we want. *\/\n\n            pci_nic_init_nofail(&nd_table[i], \"e1000\", NULL);\n\n        }\n\n    }\n\n\n\n    \/* Load kernel. *\/\n\n    if (kernel_filename) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, &loadaddr, NULL);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(kernel_filename, 0, &elf_entry, &elf_lowaddr,\n\n                                   NULL, 1, ELF_MACHINE, 0);\n\n            entry = elf_entry;\n\n            loadaddr = elf_lowaddr;\n\n        }\n\n        \/* XXX try again as binary *\/\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    \/* Load initrd. *\/\n\n    if (initrd_filename) {\n\n        initrd_base = kernel_size + loadaddr;\n\n        initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                          ram_size - initrd_base);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    \/* If we're loading a kernel directly, we must load the device tree too. *\/\n\n    if (kernel_filename) {\n\n        if (initrd_base)\n\n            dt_base = initrd_base + initrd_size;\n\n        else\n\n            dt_base = kernel_size + loadaddr;\n\n\n\n        fdt = bamboo_load_device_tree(dt_base, ram_size,\n\n                                      initrd_base, initrd_size, kernel_cmdline);\n\n        if (fdt == NULL) {\n\n            fprintf(stderr, \"couldn't load device tree\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        cpu_synchronize_state(env);\n\n\n\n        \/* Set initial guest state. *\/\n\n        env->gpr[1] = (16<<20) - 8;\n\n        env->gpr[3] = dt_base;\n\n        env->nip = entry;\n\n        \/* XXX we currently depend on KVM to create some initial TLB entries. *\/\n\n    }\n\n\n\n    if (kvm_enabled())\n\n        kvmppc_init();\n\n}\n"},{"project":"qemu","commit_id":"2aaa1940684a3bf2b381fd2a8ff26c287a05109d","target":1,"func":"static uint32_t cc_calc_abs_32(int32_t dst)\n\n{\n\n    if ((uint32_t)dst == 0x80000000UL) {\n\n        return 3;\n\n    } else if (dst) {\n\n        return 1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"96d7073fb058e6f05257cd9041ffbbd736f6ccec","target":0,"func":"static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {\n\n            goto std_case;\n\n        } else {\n\n            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);\n\n            tcg_gen_ext8u_tl(t0, t0);\n\n        }\n\n        break;\n\n    default:\n\n    std_case:\n\n        tcg_gen_mov_tl(t0, cpu_regs[reg]);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"1c7242da851cc65a2cc93fbc6defa964084a2826","target":0,"func":"target_ulong helper_yield(target_ulong arg1)\n\n{\n\n    if (arg1 < 0) {\n\n        \/* No scheduling policy implemented. *\/\n\n        if (arg1 != -2) {\n\n            if (env->CP0_VPEControl & (1 << CP0VPECo_YSI) &&\n\n                env->active_tc.CP0_TCStatus & (1 << CP0TCSt_DT)) {\n\n                env->CP0_VPEControl &= ~(0x7 << CP0VPECo_EXCPT);\n\n                env->CP0_VPEControl |= 4 << CP0VPECo_EXCPT;\n\n                helper_raise_exception(EXCP_THREAD);\n\n            }\n\n        }\n\n    } else if (arg1 == 0) {\n\n        if (0 \/* TODO: TC underflow *\/) {\n\n            env->CP0_VPEControl &= ~(0x7 << CP0VPECo_EXCPT);\n\n            helper_raise_exception(EXCP_THREAD);\n\n        } else {\n\n            \/\/ TODO: Deallocate TC\n\n        }\n\n    } else if (arg1 > 0) {\n\n        \/* Yield qualifier inputs not implemented. *\/\n\n        env->CP0_VPEControl &= ~(0x7 << CP0VPECo_EXCPT);\n\n        env->CP0_VPEControl |= 2 << CP0VPECo_EXCPT;\n\n        helper_raise_exception(EXCP_THREAD);\n\n    }\n\n    return env->CP0_YQMask;\n\n}\n"},{"project":"qemu","commit_id":"49cffbc6079c27432b4635d5d03ce14a249d86e2","target":1,"func":"void virtio_blk_submit_multireq(BlockBackend *blk, MultiReqBuffer *mrb)\n\n{\n\n    int i = 0, start = 0, num_reqs = 0, niov = 0, nb_sectors = 0;\n\n    int max_xfer_len = 0;\n\n    int64_t sector_num = 0;\n\n\n\n    if (mrb->num_reqs == 1) {\n\n        submit_requests(blk, mrb, 0, 1, -1);\n\n        mrb->num_reqs = 0;\n\n        return;\n\n    }\n\n\n\n    max_xfer_len = blk_get_max_transfer_length(mrb->reqs[0]->dev->blk);\n\n    max_xfer_len = MIN_NON_ZERO(max_xfer_len, BDRV_REQUEST_MAX_SECTORS);\n\n\n\n    qsort(mrb->reqs, mrb->num_reqs, sizeof(*mrb->reqs),\n\n          &multireq_compare);\n\n\n\n    for (i = 0; i < mrb->num_reqs; i++) {\n\n        VirtIOBlockReq *req = mrb->reqs[i];\n\n        if (num_reqs > 0) {\n\n            bool merge = true;\n\n\n\n            \/* merge would exceed maximum number of IOVs *\/\n\n            if (niov + req->qiov.niov > IOV_MAX) {\n\n                merge = false;\n\n            }\n\n\n\n            \/* merge would exceed maximum transfer length of backend device *\/\n\n            if (req->qiov.size \/ BDRV_SECTOR_SIZE + nb_sectors > max_xfer_len) {\n\n                merge = false;\n\n            }\n\n\n\n            \/* requests are not sequential *\/\n\n            if (sector_num + nb_sectors != req->sector_num) {\n\n                merge = false;\n\n            }\n\n\n\n            if (!merge) {\n\n                submit_requests(blk, mrb, start, num_reqs, niov);\n\n                num_reqs = 0;\n\n            }\n\n        }\n\n\n\n        if (num_reqs == 0) {\n\n            sector_num = req->sector_num;\n\n            nb_sectors = niov = 0;\n\n            start = i;\n\n        }\n\n\n\n        nb_sectors += req->qiov.size \/ BDRV_SECTOR_SIZE;\n\n        niov += req->qiov.niov;\n\n        num_reqs++;\n\n    }\n\n\n\n    submit_requests(blk, mrb, start, num_reqs, niov);\n\n    mrb->num_reqs = 0;\n\n}\n"},{"project":"qemu","commit_id":"5839e53bbc0fec56021d758aab7610df421ed8c8","target":1,"func":"static int64_t archipelago_volume_info(BDRVArchipelagoState *s)\n\n{\n\n    uint64_t size;\n\n    int ret, targetlen;\n\n    struct xseg_request *req;\n\n    struct xseg_reply_info *xinfo;\n\n    AIORequestData *reqdata = g_malloc(sizeof(AIORequestData));\n\n\n\n    const char *volname = s->volname;\n\n    targetlen = strlen(volname);\n\n    req = xseg_get_request(s->xseg, s->srcport, s->mportno, X_ALLOC);\n\n    if (!req) {\n\n        archipelagolog(\"Cannot get XSEG request\\n\");\n\n        goto err_exit2;\n\n    }\n\n    ret = xseg_prep_request(s->xseg, req, targetlen,\n\n                            sizeof(struct xseg_reply_info));\n\n    if (ret < 0) {\n\n        archipelagolog(\"Cannot prepare XSEG request\\n\");\n\n        goto err_exit;\n\n    }\n\n    char *target = xseg_get_target(s->xseg, req);\n\n    if (!target) {\n\n        archipelagolog(\"Cannot get XSEG target\\n\");\n\n        goto err_exit;\n\n    }\n\n    memcpy(target, volname, targetlen);\n\n    req->size = req->datalen;\n\n    req->offset = 0;\n\n    req->op = X_INFO;\n\n\n\n    reqdata->op = ARCHIP_OP_VOLINFO;\n\n    reqdata->volname = volname;\n\n    xseg_set_req_data(s->xseg, req, reqdata);\n\n\n\n    xport p = xseg_submit(s->xseg, req, s->srcport, X_ALLOC);\n\n    if (p == NoPort) {\n\n        archipelagolog(\"Cannot submit XSEG request\\n\");\n\n        goto err_exit;\n\n    }\n\n    xseg_signal(s->xseg, p);\n\n    qemu_mutex_lock(&s->archip_mutex);\n\n    while (!s->is_signaled) {\n\n        qemu_cond_wait(&s->archip_cond, &s->archip_mutex);\n\n    }\n\n    s->is_signaled = false;\n\n    qemu_mutex_unlock(&s->archip_mutex);\n\n\n\n    xinfo = (struct xseg_reply_info *) xseg_get_data(s->xseg, req);\n\n    size = xinfo->size;\n\n    xseg_put_request(s->xseg, req, s->srcport);\n\n    g_free(reqdata);\n\n    s->size = size;\n\n    return size;\n\n\n\nerr_exit:\n\n    xseg_put_request(s->xseg, req, s->srcport);\n\nerr_exit2:\n\n    g_free(reqdata);\n\n    return -EIO;\n\n}\n"},{"project":"qemu","commit_id":"e864cabdc0a38bb598ddcf88b264896dc6f3e3b2","target":1,"func":"PPC_OP(clear_xer_cr)\n\n{\n\n    xer_so = 0;\n\n    xer_ov = 0;\n\n    xer_ca = 0;\n\n    RETURN();\n\n}\n"},{"project":"qemu","commit_id":"44b6789299a8acca3f25331bc411055cafc7bb06","target":1,"func":"static void blkverify_aio_bh(void *opaque)\n\n{\n\n    BlkverifyAIOCB *acb = opaque;\n\n\n\n    if (acb->buf) {\n\n        qemu_iovec_destroy(&acb->raw_qiov);\n\n        qemu_vfree(acb->buf);\n\n    }\n\n    acb->common.cb(acb->common.opaque, acb->ret);\n\n    qemu_aio_unref(acb);\n\n}\n"},{"project":"qemu","commit_id":"0188fadb7fe460d8c4c743372b1f7b25773e183e","target":1,"func":"static void setup_frame(int sig, struct target_sigaction *ka,\n\n                        target_sigset_t *set, CPUCRISState *env)\n\n{\n\n\tstruct target_signal_frame *frame;\n\n\tabi_ulong frame_addr;\n\n\tint err = 0;\n\n\tint i;\n\n\n\n\tframe_addr = get_sigframe(env, sizeof *frame);\n\n\tif (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n\n\t\tgoto badframe;\n\n\n\n\t\/*\n\n\t * The CRIS signal return trampoline. A real linux\/CRIS kernel doesn't\n\n\t * use this trampoline anymore but it sets it up for GDB.\n\n\t * In QEMU, using the trampoline simplifies things a bit so we use it.\n\n\t *\n\n\t * This is movu.w __NR_sigreturn, r9; break 13;\n\n\t *\/\n\n    __put_user(0x9c5f, frame->retcode+0);\n\n    __put_user(TARGET_NR_sigreturn,\n\n               frame->retcode + 1);\n\n    __put_user(0xe93d, frame->retcode + 2);\n\n\n\n\t\/* Save the mask.  *\/\n\n    __put_user(set->sig[0], &frame->sc.oldmask);\n\n\tif (err)\n\n\t\tgoto badframe;\n\n\n\n\tfor(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n\t\tif (__put_user(set->sig[i], &frame->extramask[i - 1]))\n\n\t\t\tgoto badframe;\n\n\t}\n\n\n\n\tsetup_sigcontext(&frame->sc, env);\n\n\n\n\t\/* Move the stack and setup the arguments for the handler.  *\/\n\n\tenv->regs[R_SP] = frame_addr;\n\n\tenv->regs[10] = sig;\n\n\tenv->pc = (unsigned long) ka->_sa_handler;\n\n\t\/* Link SRP so the guest returns through the trampoline.  *\/\n\n\tenv->pregs[PR_SRP] = frame_addr + offsetof(typeof(*frame), retcode);\n\n\n\n\tunlock_user_struct(frame, frame_addr, 1);\n\n\treturn;\n\n  badframe:\n\n\tunlock_user_struct(frame, frame_addr, 1);\n\n\tforce_sig(TARGET_SIGSEGV);\n\n}\n"},{"project":"qemu","commit_id":"bdfce20df113522f389b4483ffd9d5b336e3c774","target":1,"func":"static void xhci_port_write(void *ptr, hwaddr reg,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    XHCIPort *port = ptr;\n\n    uint32_t portsc;\n\n\n\n    trace_usb_xhci_port_write(port->portnr, reg, val);\n\n\n\n    switch (reg) {\n\n    case 0x00: \/* PORTSC *\/\n\n        portsc = port->portsc;\n\n        \/* write-1-to-clear bits*\/\n\n        portsc &= ~(val & (PORTSC_CSC|PORTSC_PEC|PORTSC_WRC|PORTSC_OCC|\n\n                           PORTSC_PRC|PORTSC_PLC|PORTSC_CEC));\n\n        if (val & PORTSC_LWS) {\n\n            \/* overwrite PLS only when LWS=1 *\/\n\n            uint32_t pls = get_field(val, PORTSC_PLS);\n\n            set_field(&portsc, pls, PORTSC_PLS);\n\n            trace_usb_xhci_port_link(port->portnr, pls);\n\n        }\n\n        \/* read\/write bits *\/\n\n        portsc &= ~(PORTSC_PP|PORTSC_WCE|PORTSC_WDE|PORTSC_WOE);\n\n        portsc |= (val & (PORTSC_PP|PORTSC_WCE|PORTSC_WDE|PORTSC_WOE));\n\n        port->portsc = portsc;\n\n        \/* write-1-to-start bits *\/\n\n        if (val & PORTSC_PR) {\n\n            xhci_port_reset(port);\n\n        }\n\n        break;\n\n    case 0x04: \/* PORTPMSC *\/\n\n    case 0x08: \/* PORTLI *\/\n\n    default:\n\n        trace_usb_xhci_unimplemented(\"port write\", reg);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"3786cff5eb384d058395a2729af627fa3253d056","target":1,"func":"static int virtio_net_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIONet *n = VIRTIO_NET(qdev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);\n\n    int i;\n\n\n\n    \/* This will stop vhost backend if appropriate. *\/\n\n    virtio_net_set_status(vdev, 0);\n\n\n\n    unregister_savevm(qdev, \"virtio-net\", n);\n\n\n\n    if (n->netclient_name) {\n\n        g_free(n->netclient_name);\n\n        n->netclient_name = NULL;\n\n    }\n\n    if (n->netclient_type) {\n\n        g_free(n->netclient_type);\n\n        n->netclient_type = NULL;\n\n    }\n\n\n\n    g_free(n->mac_table.macs);\n\n    g_free(n->vlans);\n\n\n\n    for (i = 0; i < n->max_queues; i++) {\n\n        VirtIONetQueue *q = &n->vqs[i];\n\n        NetClientState *nc = qemu_get_subqueue(n->nic, i);\n\n\n\n        qemu_purge_queued_packets(nc);\n\n\n\n        if (q->tx_timer) {\n\n            timer_del(q->tx_timer);\n\n            timer_free(q->tx_timer);\n\n        } else if (q->tx_bh) {\n\n            qemu_bh_delete(q->tx_bh);\n\n        }\n\n    }\n\n\n\n    g_free(n->vqs);\n\n    qemu_del_nic(n->nic);\n\n    virtio_cleanup(vdev);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"b7079df4100069959f4e9d90d5cb5ba7d4ebbf1a","target":0,"func":"static int curl_find_buf(BDRVCURLState *s, size_t start, size_t len,\n\n                         CURLAIOCB *acb)\n\n{\n\n    int i;\n\n    size_t end = start + len;\n\n\n\n    for (i=0; i<CURL_NUM_STATES; i++) {\n\n        CURLState *state = &s->states[i];\n\n        size_t buf_end = (state->buf_start + state->buf_off);\n\n        size_t buf_fend = (state->buf_start + state->buf_len);\n\n\n\n        if (!state->orig_buf)\n\n            continue;\n\n        if (!state->buf_off)\n\n            continue;\n\n\n\n        \/\/ Does the existing buffer cover our section?\n\n        if ((start >= state->buf_start) &&\n\n            (start <= buf_end) &&\n\n            (end >= state->buf_start) &&\n\n            (end <= buf_end))\n\n        {\n\n            char *buf = state->orig_buf + (start - state->buf_start);\n\n\n\n            qemu_iovec_from_buf(acb->qiov, 0, buf, len);\n\n            acb->common.cb(acb->common.opaque, 0);\n\n\n\n            return FIND_RET_OK;\n\n        }\n\n\n\n        \/\/ Wait for unfinished chunks\n\n        if ((start >= state->buf_start) &&\n\n            (start <= buf_fend) &&\n\n            (end >= state->buf_start) &&\n\n            (end <= buf_fend))\n\n        {\n\n            int j;\n\n\n\n            acb->start = start - state->buf_start;\n\n            acb->end = acb->start + len;\n\n\n\n            for (j=0; j<CURL_NUM_ACB; j++) {\n\n                if (!state->acb[j]) {\n\n                    state->acb[j] = acb;\n\n                    return FIND_RET_WAIT;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    return FIND_RET_NONE;\n\n}\n"},{"project":"qemu","commit_id":"35f754620615138aaae0ef72602f84c88fd8de0f","target":1,"func":"struct vhost_net *vhost_net_init(VLANClientState *backend, int devfd,\n\n                                 bool force)\n\n{\n\n\n    return NULL;\n\n}"},{"project":"qemu","commit_id":"61007b316cd71ee7333ff7a0a749a8949527575f","target":0,"func":"int coroutine_fn bdrv_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n    int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    trace_bdrv_co_writev(bs, sector_num, nb_sectors);\n\n\n\n    return bdrv_co_do_writev(bs, sector_num, nb_sectors, qiov, 0);\n\n}\n"},{"project":"qemu","commit_id":"bd79255d2571a3c68820117caf94ea9afe1d527e","target":0,"func":"static inline void gen_outs(DisasContext *s, TCGMemOp ot)\n\n{\n\n    if (use_icount)\n\n        gen_io_start();\n\n    gen_string_movl_A0_ESI(s);\n\n    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);\n\n\n\n    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);\n\n    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n\n    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);\n\n    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n\n\n    gen_op_movl_T0_Dshift(ot);\n\n    gen_op_add_reg_T0(s->aflag, R_ESI);\n\n    if (use_icount)\n\n        gen_io_end();\n\n}\n"},{"project":"qemu","commit_id":"e7d336959b7c01699702dcda4b54a822972d74a8","target":0,"func":"int chsc_sei_nt2_get_event(void *res)\n\n{\n\n    ChscSeiNt2Res *nt2_res = (ChscSeiNt2Res *)res;\n\n    PciCcdfAvail *accdf;\n\n    PciCcdfErr *eccdf;\n\n    int rc = 1;\n\n    SeiContainer *sei_cont;\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(\n\n        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));\n\n\n\n    if (!s) {\n\n        return rc;\n\n    }\n\n\n\n    sei_cont = QTAILQ_FIRST(&s->pending_sei);\n\n    if (sei_cont) {\n\n        QTAILQ_REMOVE(&s->pending_sei, sei_cont, link);\n\n        nt2_res->nt = 2;\n\n        nt2_res->cc = sei_cont->cc;\n\n        nt2_res->length = cpu_to_be16(sizeof(ChscSeiNt2Res));\n\n        switch (sei_cont->cc) {\n\n        case 1: \/* error event *\/\n\n            eccdf = (PciCcdfErr *)nt2_res->ccdf;\n\n            eccdf->fid = cpu_to_be32(sei_cont->fid);\n\n            eccdf->fh = cpu_to_be32(sei_cont->fh);\n\n            eccdf->e = cpu_to_be32(sei_cont->e);\n\n            eccdf->faddr = cpu_to_be64(sei_cont->faddr);\n\n            eccdf->pec = cpu_to_be16(sei_cont->pec);\n\n            break;\n\n        case 2: \/* availability event *\/\n\n            accdf = (PciCcdfAvail *)nt2_res->ccdf;\n\n            accdf->fid = cpu_to_be32(sei_cont->fid);\n\n            accdf->fh = cpu_to_be32(sei_cont->fh);\n\n            accdf->pec = cpu_to_be16(sei_cont->pec);\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n        g_free(sei_cont);\n\n        rc = 0;\n\n    }\n\n\n\n    return rc;\n\n}\n"},{"project":"qemu","commit_id":"a89f364ae8740dfc31b321eed9ee454e996dc3c1","target":0,"func":"void omap_mpuio_key(struct omap_mpuio_s *s, int row, int col, int down)\n\n{\n\n    if (row >= 5 || row < 0)\n\n        hw_error(\"%s: No key %i-%i\\n\", __FUNCTION__, col, row);\n\n\n\n    if (down)\n\n        s->buttons[row] |= 1 << col;\n\n    else\n\n        s->buttons[row] &= ~(1 << col);\n\n\n\n    omap_mpuio_kbd_update(s);\n\n}\n"},{"project":"qemu","commit_id":"cd7bc87868d534f95e928cad98e2a52df7695771","target":1,"func":"static void usb_uas_unrealize(USBDevice *dev, Error **errp)\n{\n    UASDevice *uas = USB_UAS(dev);\n    qemu_bh_delete(uas->status_bh);\n}"},{"project":"qemu","commit_id":"74f24cb6306d065045d0e2215a7d10533fa59c57","target":1,"func":"static void parse_type_int64(Visitor *v, const char *name, int64_t *obj,\n\n                             Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n\n\n    if (!siv->string) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"integer\");\n\n        return;\n\n    }\n\n\n\n    parse_str(siv, errp);\n\n\n\n    if (!siv->ranges) {\n\n        goto error;\n\n    }\n\n\n\n    if (!siv->cur_range) {\n\n        Range *r;\n\n\n\n        siv->cur_range = g_list_first(siv->ranges);\n\n        if (!siv->cur_range) {\n\n            goto error;\n\n        }\n\n\n\n        r = siv->cur_range->data;\n\n        if (!r) {\n\n            goto error;\n\n        }\n\n\n\n        siv->cur = r->begin;\n\n    }\n\n\n\n    *obj = siv->cur;\n\n    siv->cur++;\n\n    return;\n\n\n\nerror:\n\n    error_setg(errp, QERR_INVALID_PARAMETER_VALUE, name ? name : \"null\",\n\n               \"an int64 value or range\");\n\n}\n"},{"project":"qemu","commit_id":"7848c8d19f8556666df25044bbd5d8b29439c368","target":0,"func":"void helper_vmrun(CPUX86State *env, int aflag, int next_eip_addend)\n\n{\n\n    CPUState *cs = CPU(x86_env_get_cpu(env));\n\n    target_ulong addr;\n\n    uint32_t event_inj;\n\n    uint32_t int_ctl;\n\n\n\n    cpu_svm_check_intercept_param(env, SVM_EXIT_VMRUN, 0);\n\n\n\n    if (aflag == 2) {\n\n        addr = env->regs[R_EAX];\n\n    } else {\n\n        addr = (uint32_t)env->regs[R_EAX];\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_TB_IN_ASM, \"vmrun! \" TARGET_FMT_lx \"\\n\", addr);\n\n\n\n    env->vm_vmcb = addr;\n\n\n\n    \/* save the current CPU state in the hsave page *\/\n\n    stq_phys(cs->as, env->vm_hsave + offsetof(struct vmcb, save.gdtr.base),\n\n             env->gdt.base);\n\n    stl_phys(cs->as, env->vm_hsave + offsetof(struct vmcb, save.gdtr.limit),\n\n             env->gdt.limit);\n\n\n\n    stq_phys(cs->as, env->vm_hsave + offsetof(struct vmcb, save.idtr.base),\n\n             env->idt.base);\n\n    stl_phys(cs->as, env->vm_hsave + offsetof(struct vmcb, save.idtr.limit),\n\n             env->idt.limit);\n\n\n\n    stq_phys(cs->as,\n\n             env->vm_hsave + offsetof(struct vmcb, save.cr0), env->cr[0]);\n\n    stq_phys(cs->as,\n\n             env->vm_hsave + offsetof(struct vmcb, save.cr2), env->cr[2]);\n\n    stq_phys(cs->as,\n\n             env->vm_hsave + offsetof(struct vmcb, save.cr3), env->cr[3]);\n\n    stq_phys(cs->as,\n\n             env->vm_hsave + offsetof(struct vmcb, save.cr4), env->cr[4]);\n\n    stq_phys(cs->as,\n\n             env->vm_hsave + offsetof(struct vmcb, save.dr6), env->dr[6]);\n\n    stq_phys(cs->as,\n\n             env->vm_hsave + offsetof(struct vmcb, save.dr7), env->dr[7]);\n\n\n\n    stq_phys(cs->as,\n\n             env->vm_hsave + offsetof(struct vmcb, save.efer), env->efer);\n\n    stq_phys(cs->as,\n\n             env->vm_hsave + offsetof(struct vmcb, save.rflags),\n\n             cpu_compute_eflags(env));\n\n\n\n    svm_save_seg(env, env->vm_hsave + offsetof(struct vmcb, save.es),\n\n                 &env->segs[R_ES]);\n\n    svm_save_seg(env, env->vm_hsave + offsetof(struct vmcb, save.cs),\n\n                 &env->segs[R_CS]);\n\n    svm_save_seg(env, env->vm_hsave + offsetof(struct vmcb, save.ss),\n\n                 &env->segs[R_SS]);\n\n    svm_save_seg(env, env->vm_hsave + offsetof(struct vmcb, save.ds),\n\n                 &env->segs[R_DS]);\n\n\n\n    stq_phys(cs->as, env->vm_hsave + offsetof(struct vmcb, save.rip),\n\n             env->eip + next_eip_addend);\n\n    stq_phys(cs->as,\n\n             env->vm_hsave + offsetof(struct vmcb, save.rsp), env->regs[R_ESP]);\n\n    stq_phys(cs->as,\n\n             env->vm_hsave + offsetof(struct vmcb, save.rax), env->regs[R_EAX]);\n\n\n\n    \/* load the interception bitmaps so we do not need to access the\n\n       vmcb in svm mode *\/\n\n    env->intercept = ldq_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,\n\n                                                      control.intercept));\n\n    env->intercept_cr_read = lduw_phys(cs->as, env->vm_vmcb +\n\n                                       offsetof(struct vmcb,\n\n                                                control.intercept_cr_read));\n\n    env->intercept_cr_write = lduw_phys(cs->as, env->vm_vmcb +\n\n                                        offsetof(struct vmcb,\n\n                                                 control.intercept_cr_write));\n\n    env->intercept_dr_read = lduw_phys(cs->as, env->vm_vmcb +\n\n                                       offsetof(struct vmcb,\n\n                                                control.intercept_dr_read));\n\n    env->intercept_dr_write = lduw_phys(cs->as, env->vm_vmcb +\n\n                                        offsetof(struct vmcb,\n\n                                                 control.intercept_dr_write));\n\n    env->intercept_exceptions = ldl_phys(cs->as, env->vm_vmcb +\n\n                                         offsetof(struct vmcb,\n\n                                                  control.intercept_exceptions\n\n                                                  ));\n\n\n\n    \/* enable intercepts *\/\n\n    env->hflags |= HF_SVMI_MASK;\n\n\n\n    env->tsc_offset = ldq_phys(cs->as, env->vm_vmcb +\n\n                               offsetof(struct vmcb, control.tsc_offset));\n\n\n\n    env->gdt.base  = ldq_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,\n\n                                                      save.gdtr.base));\n\n    env->gdt.limit = ldl_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,\n\n                                                      save.gdtr.limit));\n\n\n\n    env->idt.base  = ldq_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,\n\n                                                      save.idtr.base));\n\n    env->idt.limit = ldl_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,\n\n                                                      save.idtr.limit));\n\n\n\n    \/* clear exit_info_2 so we behave like the real hardware *\/\n\n    stq_phys(cs->as,\n\n             env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2), 0);\n\n\n\n    cpu_x86_update_cr0(env, ldq_phys(cs->as,\n\n                                     env->vm_vmcb + offsetof(struct vmcb,\n\n                                                             save.cr0)));\n\n    cpu_x86_update_cr4(env, ldq_phys(cs->as,\n\n                                     env->vm_vmcb + offsetof(struct vmcb,\n\n                                                             save.cr4)));\n\n    cpu_x86_update_cr3(env, ldq_phys(cs->as,\n\n                                     env->vm_vmcb + offsetof(struct vmcb,\n\n                                                             save.cr3)));\n\n    env->cr[2] = ldq_phys(cs->as,\n\n                          env->vm_vmcb + offsetof(struct vmcb, save.cr2));\n\n    int_ctl = ldl_phys(cs->as,\n\n                       env->vm_vmcb + offsetof(struct vmcb, control.int_ctl));\n\n    env->hflags2 &= ~(HF2_HIF_MASK | HF2_VINTR_MASK);\n\n    if (int_ctl & V_INTR_MASKING_MASK) {\n\n        env->v_tpr = int_ctl & V_TPR_MASK;\n\n        env->hflags2 |= HF2_VINTR_MASK;\n\n        if (env->eflags & IF_MASK) {\n\n            env->hflags2 |= HF2_HIF_MASK;\n\n        }\n\n    }\n\n\n\n    cpu_load_efer(env,\n\n                  ldq_phys(cs->as,\n\n                           env->vm_vmcb + offsetof(struct vmcb, save.efer)));\n\n    env->eflags = 0;\n\n    cpu_load_eflags(env, ldq_phys(cs->as,\n\n                                  env->vm_vmcb + offsetof(struct vmcb,\n\n                                                          save.rflags)),\n\n                    ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C | DF_MASK));\n\n    CC_OP = CC_OP_EFLAGS;\n\n\n\n    svm_load_seg_cache(env, env->vm_vmcb + offsetof(struct vmcb, save.es),\n\n                       R_ES);\n\n    svm_load_seg_cache(env, env->vm_vmcb + offsetof(struct vmcb, save.cs),\n\n                       R_CS);\n\n    svm_load_seg_cache(env, env->vm_vmcb + offsetof(struct vmcb, save.ss),\n\n                       R_SS);\n\n    svm_load_seg_cache(env, env->vm_vmcb + offsetof(struct vmcb, save.ds),\n\n                       R_DS);\n\n\n\n    env->eip = ldq_phys(cs->as,\n\n                        env->vm_vmcb + offsetof(struct vmcb, save.rip));\n\n\n\n    env->regs[R_ESP] = ldq_phys(cs->as,\n\n                                env->vm_vmcb + offsetof(struct vmcb, save.rsp));\n\n    env->regs[R_EAX] = ldq_phys(cs->as,\n\n                                env->vm_vmcb + offsetof(struct vmcb, save.rax));\n\n    env->dr[7] = ldq_phys(cs->as,\n\n                          env->vm_vmcb + offsetof(struct vmcb, save.dr7));\n\n    env->dr[6] = ldq_phys(cs->as,\n\n                          env->vm_vmcb + offsetof(struct vmcb, save.dr6));\n\n    cpu_x86_set_cpl(env, ldub_phys(cs->as,\n\n                                   env->vm_vmcb + offsetof(struct vmcb,\n\n                                                           save.cpl)));\n\n\n\n    \/* FIXME: guest state consistency checks *\/\n\n\n\n    switch (ldub_phys(cs->as,\n\n                      env->vm_vmcb + offsetof(struct vmcb, control.tlb_ctl))) {\n\n    case TLB_CONTROL_DO_NOTHING:\n\n        break;\n\n    case TLB_CONTROL_FLUSH_ALL_ASID:\n\n        \/* FIXME: this is not 100% correct but should work for now *\/\n\n        tlb_flush(cs, 1);\n\n        break;\n\n    }\n\n\n\n    env->hflags2 |= HF2_GIF_MASK;\n\n\n\n    if (int_ctl & V_IRQ_MASK) {\n\n        CPUState *cs = CPU(x86_env_get_cpu(env));\n\n\n\n        cs->interrupt_request |= CPU_INTERRUPT_VIRQ;\n\n    }\n\n\n\n    \/* maybe we need to inject an event *\/\n\n    event_inj = ldl_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,\n\n                                                 control.event_inj));\n\n    if (event_inj & SVM_EVTINJ_VALID) {\n\n        uint8_t vector = event_inj & SVM_EVTINJ_VEC_MASK;\n\n        uint16_t valid_err = event_inj & SVM_EVTINJ_VALID_ERR;\n\n        uint32_t event_inj_err = ldl_phys(cs->as, env->vm_vmcb +\n\n                                          offsetof(struct vmcb,\n\n                                                   control.event_inj_err));\n\n\n\n        qemu_log_mask(CPU_LOG_TB_IN_ASM, \"Injecting(%#hx): \", valid_err);\n\n        \/* FIXME: need to implement valid_err *\/\n\n        switch (event_inj & SVM_EVTINJ_TYPE_MASK) {\n\n        case SVM_EVTINJ_TYPE_INTR:\n\n            cs->exception_index = vector;\n\n            env->error_code = event_inj_err;\n\n            env->exception_is_int = 0;\n\n            env->exception_next_eip = -1;\n\n            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"INTR\");\n\n            \/* XXX: is it always correct? *\/\n\n            do_interrupt_x86_hardirq(env, vector, 1);\n\n            break;\n\n        case SVM_EVTINJ_TYPE_NMI:\n\n            cs->exception_index = EXCP02_NMI;\n\n            env->error_code = event_inj_err;\n\n            env->exception_is_int = 0;\n\n            env->exception_next_eip = env->eip;\n\n            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"NMI\");\n\n            cpu_loop_exit(cs);\n\n            break;\n\n        case SVM_EVTINJ_TYPE_EXEPT:\n\n            cs->exception_index = vector;\n\n            env->error_code = event_inj_err;\n\n            env->exception_is_int = 0;\n\n            env->exception_next_eip = -1;\n\n            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"EXEPT\");\n\n            cpu_loop_exit(cs);\n\n            break;\n\n        case SVM_EVTINJ_TYPE_SOFT:\n\n            cs->exception_index = vector;\n\n            env->error_code = event_inj_err;\n\n            env->exception_is_int = 1;\n\n            env->exception_next_eip = env->eip;\n\n            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"SOFT\");\n\n            cpu_loop_exit(cs);\n\n            break;\n\n        }\n\n        qemu_log_mask(CPU_LOG_TB_IN_ASM, \" %#x %#x\\n\", cs->exception_index,\n\n                      env->error_code);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"debaaa114a8877a939533ba846e64168fb287b7b","target":0,"func":"static void test_io_rw_interface(enum AddrMode lba48, enum IOMode dma,\n\n                                 unsigned bufsize, uint64_t sector)\n\n{\n\n    AHCIQState *ahci;\n\n\n\n    ahci = ahci_boot_and_enable();\n\n    ahci_test_io_rw_simple(ahci, bufsize, sector,\n\n                           io_cmds[dma][lba48][IO_READ],\n\n                           io_cmds[dma][lba48][IO_WRITE]);\n\n    ahci_shutdown(ahci);\n\n}\n"},{"project":"qemu","commit_id":"cdbf6e165988ab9d7c01da03b9e27bb8ac0c76aa","target":0,"func":"static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    NetCharDriver *s = chr->opaque;\n\n    gsize bytes_read = 0;\n\n    GIOStatus status;\n\n\n\n    if (s->max_size == 0)\n\n        return FALSE;\n\n    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),\n\n                                     &bytes_read, NULL);\n\n    s->bufcnt = bytes_read;\n\n    s->bufptr = s->bufcnt;\n\n    if (status != G_IO_STATUS_NORMAL) {\n\n        return FALSE;\n\n    }\n\n\n\n    s->bufptr = 0;\n\n    while (s->max_size > 0 && s->bufptr < s->bufcnt) {\n\n        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);\n\n        s->bufptr++;\n\n        s->max_size = qemu_chr_be_can_write(chr);\n\n    }\n\n\n\n    return TRUE;\n\n}\n"},{"project":"qemu","commit_id":"eabb7b91b36b202b4dac2df2d59d698e3aff197a","target":0,"func":"static void tcg_out_qemu_st(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop & MO_SIZE,\n\n                             offsetof(CPUTLBEntry, addr_write));\n\n\n\n    \/* The fast path is exactly one insn.  Thus we can perform the entire\n\n       TLB Hit in the (annulled) delay slot of the branch over TLB Miss.  *\/\n\n    \/* beq,a,pt %[xi]cc, label0 *\/\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    \/* delay slot *\/\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n\n\n    \/* TLB Miss.  *\/\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        \/* Skip the high-part; we'll perform the extract in the trampoline.  *\/\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n    if (!SPARC64 && (memop & MO_SIZE) == MO_64) {\n\n        \/* Skip the high-part; we'll perform the extract in the trampoline.  *\/\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, data);\n\n\n\n    func = qemu_st_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    \/* delay slot *\/\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n#endif \/* CONFIG_SOFTMMU *\/\n\n}\n"},{"project":"qemu","commit_id":"b4ba67d9a702507793c2724e56f98e9b0f7be02b","target":1,"func":"void qpci_io_writew(QPCIDevice *dev, void *data, uint16_t value)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    if (addr < QPCI_PIO_LIMIT) {\n\n        dev->bus->pio_writew(dev->bus, addr, value);\n\n    } else {\n\n        value = cpu_to_le16(value);\n\n        dev->bus->memwrite(dev->bus, addr, &value, sizeof(value));\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"c679e74d2e29fa08ede9121d59aee4e9675611d7","target":0,"func":"int css_do_csch(SubchDev *sch)\n\n{\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    int ret;\n\n\n\n    if (!(p->flags & (PMCW_FLAGS_MASK_DNV | PMCW_FLAGS_MASK_ENA))) {\n\n        ret = -ENODEV;\n\n        goto out;\n\n    }\n\n\n\n    \/* Trigger the clear function. *\/\n\n    s->ctrl &= ~(SCSW_CTRL_MASK_FCTL | SCSW_CTRL_MASK_ACTL);\n\n    s->ctrl |= SCSW_FCTL_CLEAR_FUNC | SCSW_ACTL_CLEAR_PEND;\n\n\n\n    do_subchannel_work(sch, NULL);\n\n    ret = 0;\n\n\n\nout:\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"d251157ac1928191af851d199a9ff255d330bec9","target":0,"func":"pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n\n{\n\n    uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n\n\n\n    if (ready_ptr != mgr->consumed_ptr) {\n\n        uint32_t next_ready_ptr =\n\n            mgr->consumed_ptr++ & mgr->txr_len_mask;\n\n        uint32_t next_ready_page =\n\n            next_ready_ptr \/ PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n\n        uint32_t inpage_idx =\n\n            next_ready_ptr % PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n\n\n\n        return mgr->req_ring_pages_pa[next_ready_page] +\n\n               inpage_idx * sizeof(PVSCSIRingReqDesc);\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"9307c4c1d93939db9b04117b654253af5113dc21","target":0,"func":"static void do_log(int argc, const char **argv)\n\n{\n\n    int mask;\n\n    \n\n    if (argc != 2)\n\n        goto help;\n\n    if (!strcmp(argv[1], \"none\")) {\n\n        mask = 0;\n\n    } else {\n\n        mask = cpu_str_to_log_mask(argv[1]);\n\n        if (!mask) {\n\n        help:\n\n            help_cmd(argv[0]);\n\n            return;\n\n        }\n\n    }\n\n    cpu_set_log(mask);\n\n}\n"},{"project":"qemu","commit_id":"fa1298c2d623522eda7b4f1f721fcb935abb7360","target":1,"func":"static bool ohci_eof_timer_needed(void *opaque)\n\n{\n\n    OHCIState *ohci = opaque;\n\n\n\n    return ohci->eof_timer != NULL;\n\n}\n"},{"project":"qemu","commit_id":"b08d0ea0446aa91f373c9df4254ba3bc4ee84098","target":0,"func":"static SCSIRequest *scsi_block_new_request(SCSIDevice *d, uint32_t tag,\n\n                                           uint32_t lun, uint8_t *buf,\n\n                                           void *hba_private)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n\n\n    switch (buf[0]) {\n\n    case READ_6:\n\n    case READ_10:\n\n    case READ_12:\n\n    case READ_16:\n\n    case VERIFY_10:\n\n    case VERIFY_12:\n\n    case VERIFY_16:\n\n    case WRITE_6:\n\n    case WRITE_10:\n\n    case WRITE_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_VERIFY_16:\n\n        \/* If we are not using O_DIRECT, we might read stale data from the\n\n\t * host cache if writes were made using other commands than these\n\n\t * ones (such as WRITE SAME or EXTENDED COPY, etc.).  So, without\n\n\t * O_DIRECT everything must go through SG_IO.\n\n         *\/\n\n        if (bdrv_get_flags(s->qdev.conf.bs) & BDRV_O_NOCACHE) {\n\n            break;\n\n        }\n\n\n\n        \/* MMC writing cannot be done via pread\/pwrite, because it sometimes\n\n         * involves writing beyond the maximum LBA or to negative LBA (lead-in).\n\n         * And once you do these writes, reading from the block device is\n\n         * unreliable, too.  It is even possible that reads deliver random data\n\n         * from the host page cache (this is probably a Linux bug).\n\n         *\n\n         * We might use scsi_disk_reqops as long as no writing commands are\n\n         * seen, but performance usually isn't paramount on optical media.  So,\n\n         * just make scsi-block operate the same as scsi-generic for them.\n\n         *\/\n\n        if (s->qdev.type == TYPE_ROM) {\n\n            break;\n\n\t}\n\n        return scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun,\n\n                              hba_private);\n\n    }\n\n\n\n    return scsi_req_alloc(&scsi_generic_req_ops, &s->qdev, tag, lun,\n\n                          hba_private);\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static uint32_t isa_mmio_readb (void *opaque, target_phys_addr_t addr)\n\n{\n\n    return cpu_inb(addr & IOPORTS_MASK);\n\n}\n"},{"project":"qemu","commit_id":"f8ed85ac992c48814d916d5df4d44f9a971c5de4","target":1,"func":"static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)\n\n{\n\n    XlnxZynqMPState *s = XLNX_ZYNQMP(dev);\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    uint8_t i;\n\n    const char *boot_cpu = s->boot_cpu ? s->boot_cpu : \"apu-cpu[0]\";\n\n    qemu_irq gic_spi[GIC_NUM_SPI_INTR];\n\n    Error *err = NULL;\n\n\n\n    \/* Create the four OCM banks *\/\n\n    for (i = 0; i < XLNX_ZYNQMP_NUM_OCM_BANKS; i++) {\n\n        char *ocm_name = g_strdup_printf(\"zynqmp.ocm_ram_bank_%d\", i);\n\n\n\n        memory_region_init_ram(&s->ocm_ram[i], NULL, ocm_name,\n\n                               XLNX_ZYNQMP_OCM_RAM_SIZE, &error_abort);\n\n        vmstate_register_ram_global(&s->ocm_ram[i]);\n\n        memory_region_add_subregion(get_system_memory(),\n\n                                    XLNX_ZYNQMP_OCM_RAM_0_ADDRESS +\n\n                                        i * XLNX_ZYNQMP_OCM_RAM_SIZE,\n\n                                    &s->ocm_ram[i]);\n\n\n\n        g_free(ocm_name);\n\n    }\n\n\n\n    qdev_prop_set_uint32(DEVICE(&s->gic), \"num-irq\", GIC_NUM_SPI_INTR + 32);\n\n    qdev_prop_set_uint32(DEVICE(&s->gic), \"revision\", 2);\n\n    qdev_prop_set_uint32(DEVICE(&s->gic), \"num-cpu\", XLNX_ZYNQMP_NUM_APU_CPUS);\n\n    object_property_set_bool(OBJECT(&s->gic), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    assert(ARRAY_SIZE(xlnx_zynqmp_gic_regions) == XLNX_ZYNQMP_GIC_REGIONS);\n\n    for (i = 0; i < XLNX_ZYNQMP_GIC_REGIONS; i++) {\n\n        SysBusDevice *gic = SYS_BUS_DEVICE(&s->gic);\n\n        const XlnxZynqMPGICRegion *r = &xlnx_zynqmp_gic_regions[i];\n\n        MemoryRegion *mr = sysbus_mmio_get_region(gic, r->region_index);\n\n        uint32_t addr = r->address;\n\n        int j;\n\n\n\n        sysbus_mmio_map(gic, r->region_index, addr);\n\n\n\n        for (j = 0; j < XLNX_ZYNQMP_GIC_ALIASES; j++) {\n\n            MemoryRegion *alias = &s->gic_mr[i][j];\n\n\n\n            addr += XLNX_ZYNQMP_GIC_REGION_SIZE;\n\n            memory_region_init_alias(alias, OBJECT(s), \"zynqmp-gic-alias\", mr,\n\n                                     0, XLNX_ZYNQMP_GIC_REGION_SIZE);\n\n            memory_region_add_subregion(system_memory, addr, alias);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < XLNX_ZYNQMP_NUM_APU_CPUS; i++) {\n\n        qemu_irq irq;\n\n        char *name;\n\n\n\n        object_property_set_int(OBJECT(&s->apu_cpu[i]), QEMU_PSCI_CONDUIT_SMC,\n\n                                \"psci-conduit\", &error_abort);\n\n\n\n        name = object_get_canonical_path_component(OBJECT(&s->apu_cpu[i]));\n\n        if (strcmp(name, boot_cpu)) {\n\n            \/* Secondary CPUs start in PSCI powered-down state *\/\n\n            object_property_set_bool(OBJECT(&s->apu_cpu[i]), true,\n\n                                     \"start-powered-off\", &error_abort);\n\n        } else {\n\n            s->boot_cpu_ptr = &s->apu_cpu[i];\n\n        }\n\n        g_free(name);\n\n\n\n        object_property_set_int(OBJECT(&s->apu_cpu[i]), GIC_BASE_ADDR,\n\n                                \"reset-cbar\", &error_abort);\n\n        object_property_set_bool(OBJECT(&s->apu_cpu[i]), true, \"realized\",\n\n                                 &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(&s->gic), i,\n\n                           qdev_get_gpio_in(DEVICE(&s->apu_cpu[i]),\n\n                                            ARM_CPU_IRQ));\n\n        irq = qdev_get_gpio_in(DEVICE(&s->gic),\n\n                               arm_gic_ppi_index(i, ARM_PHYS_TIMER_PPI));\n\n        qdev_connect_gpio_out(DEVICE(&s->apu_cpu[i]), 0, irq);\n\n        irq = qdev_get_gpio_in(DEVICE(&s->gic),\n\n                               arm_gic_ppi_index(i, ARM_VIRT_TIMER_PPI));\n\n        qdev_connect_gpio_out(DEVICE(&s->apu_cpu[i]), 1, irq);\n\n    }\n\n\n\n    for (i = 0; i < XLNX_ZYNQMP_NUM_RPU_CPUS; i++) {\n\n        char *name;\n\n\n\n        name = object_get_canonical_path_component(OBJECT(&s->rpu_cpu[i]));\n\n        if (strcmp(name, boot_cpu)) {\n\n            \/* Secondary CPUs start in PSCI powered-down state *\/\n\n            object_property_set_bool(OBJECT(&s->rpu_cpu[i]), true,\n\n                                     \"start-powered-off\", &error_abort);\n\n        } else {\n\n            s->boot_cpu_ptr = &s->rpu_cpu[i];\n\n        }\n\n        g_free(name);\n\n\n\n        object_property_set_bool(OBJECT(&s->rpu_cpu[i]), true, \"reset-hivecs\",\n\n                                 &error_abort);\n\n        object_property_set_bool(OBJECT(&s->rpu_cpu[i]), true, \"realized\",\n\n                                 &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (!s->boot_cpu_ptr) {\n\n        error_setg(errp, \"ZynqMP Boot cpu %s not found\\n\", boot_cpu);\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < GIC_NUM_SPI_INTR; i++) {\n\n        gic_spi[i] = qdev_get_gpio_in(DEVICE(&s->gic), i);\n\n    }\n\n\n\n    for (i = 0; i < XLNX_ZYNQMP_NUM_GEMS; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (nd->used) {\n\n            qemu_check_nic_model(nd, TYPE_CADENCE_GEM);\n\n            qdev_set_nic_properties(DEVICE(&s->gem[i]), nd);\n\n        }\n\n        object_property_set_bool(OBJECT(&s->gem[i]), true, \"realized\", &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(&s->gem[i]), 0, gem_addr[i]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(&s->gem[i]), 0,\n\n                           gic_spi[gem_intr[i]]);\n\n    }\n\n\n\n    for (i = 0; i < XLNX_ZYNQMP_NUM_UARTS; i++) {\n\n        object_property_set_bool(OBJECT(&s->uart[i]), true, \"realized\", &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(&s->uart[i]), 0, uart_addr[i]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(&s->uart[i]), 0,\n\n                           gic_spi[uart_intr[i]]);\n\n    }\n\n\n\n    object_property_set_int(OBJECT(&s->sata), SATA_NUM_PORTS, \"num-ports\",\n\n                            &error_abort);\n\n    object_property_set_bool(OBJECT(&s->sata), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(&s->sata), 0, SATA_ADDR);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(&s->sata), 0, gic_spi[SATA_INTR]);\n\n}\n"},{"project":"qemu","commit_id":"1ee24514aed34760fb2863d98bea3a1b705d9c9f","target":1,"func":"static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeSQueue *sq;\n\n    NvmeCreateSq *c = (NvmeCreateSq *)cmd;\n\n\n\n    uint16_t cqid = le16_to_cpu(c->cqid);\n\n    uint16_t sqid = le16_to_cpu(c->sqid);\n\n    uint16_t qsize = le16_to_cpu(c->qsize);\n\n    uint16_t qflags = le16_to_cpu(c->sq_flags);\n\n    uint64_t prp1 = le64_to_cpu(c->prp1);\n\n\n\n    if (!cqid || nvme_check_cqid(n, cqid)) {\n\n        return NVME_INVALID_CQID | NVME_DNR;\n\n    }\n\n    if (!sqid || !nvme_check_sqid(n, sqid)) {\n\n        return NVME_INVALID_QID | NVME_DNR;\n\n    }\n\n    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {\n\n        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;\n\n    }\n\n    if (!prp1 || prp1 & (n->page_size - 1)) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    if (!(NVME_SQ_FLAGS_PC(qflags))) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    sq = g_malloc0(sizeof(*sq));\n\n    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);\n\n    return NVME_SUCCESS;\n\n}\n"},{"project":"qemu","commit_id":"b3db211f3c80bb996a704d665fe275619f728bd4","target":0,"func":"static void init_native_list(UserDefNativeListUnion *cvalue)\n\n{\n\n    int i;\n\n    switch (cvalue->type) {\n\n    case USER_DEF_NATIVE_LIST_UNION_KIND_INTEGER: {\n\n        intList **list = &cvalue->u.integer.data;\n\n        for (i = 0; i < 32; i++) {\n\n            *list = g_new0(intList, 1);\n\n            (*list)->value = i;\n\n            (*list)->next = NULL;\n\n            list = &(*list)->next;\n\n        }\n\n        break;\n\n    }\n\n    case USER_DEF_NATIVE_LIST_UNION_KIND_S8: {\n\n        int8List **list = &cvalue->u.s8.data;\n\n        for (i = 0; i < 32; i++) {\n\n            *list = g_new0(int8List, 1);\n\n            (*list)->value = i;\n\n            (*list)->next = NULL;\n\n            list = &(*list)->next;\n\n        }\n\n        break;\n\n    }\n\n    case USER_DEF_NATIVE_LIST_UNION_KIND_S16: {\n\n        int16List **list = &cvalue->u.s16.data;\n\n        for (i = 0; i < 32; i++) {\n\n            *list = g_new0(int16List, 1);\n\n            (*list)->value = i;\n\n            (*list)->next = NULL;\n\n            list = &(*list)->next;\n\n        }\n\n        break;\n\n    }\n\n    case USER_DEF_NATIVE_LIST_UNION_KIND_S32: {\n\n        int32List **list = &cvalue->u.s32.data;\n\n        for (i = 0; i < 32; i++) {\n\n            *list = g_new0(int32List, 1);\n\n            (*list)->value = i;\n\n            (*list)->next = NULL;\n\n            list = &(*list)->next;\n\n        }\n\n        break;\n\n    }\n\n    case USER_DEF_NATIVE_LIST_UNION_KIND_S64: {\n\n        int64List **list = &cvalue->u.s64.data;\n\n        for (i = 0; i < 32; i++) {\n\n            *list = g_new0(int64List, 1);\n\n            (*list)->value = i;\n\n            (*list)->next = NULL;\n\n            list = &(*list)->next;\n\n        }\n\n        break;\n\n    }\n\n    case USER_DEF_NATIVE_LIST_UNION_KIND_U8: {\n\n        uint8List **list = &cvalue->u.u8.data;\n\n        for (i = 0; i < 32; i++) {\n\n            *list = g_new0(uint8List, 1);\n\n            (*list)->value = i;\n\n            (*list)->next = NULL;\n\n            list = &(*list)->next;\n\n        }\n\n        break;\n\n    }\n\n    case USER_DEF_NATIVE_LIST_UNION_KIND_U16: {\n\n        uint16List **list = &cvalue->u.u16.data;\n\n        for (i = 0; i < 32; i++) {\n\n            *list = g_new0(uint16List, 1);\n\n            (*list)->value = i;\n\n            (*list)->next = NULL;\n\n            list = &(*list)->next;\n\n        }\n\n        break;\n\n    }\n\n    case USER_DEF_NATIVE_LIST_UNION_KIND_U32: {\n\n        uint32List **list = &cvalue->u.u32.data;\n\n        for (i = 0; i < 32; i++) {\n\n            *list = g_new0(uint32List, 1);\n\n            (*list)->value = i;\n\n            (*list)->next = NULL;\n\n            list = &(*list)->next;\n\n        }\n\n        break;\n\n    }\n\n    case USER_DEF_NATIVE_LIST_UNION_KIND_U64: {\n\n        uint64List **list = &cvalue->u.u64.data;\n\n        for (i = 0; i < 32; i++) {\n\n            *list = g_new0(uint64List, 1);\n\n            (*list)->value = i;\n\n            (*list)->next = NULL;\n\n            list = &(*list)->next;\n\n        }\n\n        break;\n\n    }\n\n    case USER_DEF_NATIVE_LIST_UNION_KIND_BOOLEAN: {\n\n        boolList **list = &cvalue->u.boolean.data;\n\n        for (i = 0; i < 32; i++) {\n\n            *list = g_new0(boolList, 1);\n\n            (*list)->value = (i % 3 == 0);\n\n            (*list)->next = NULL;\n\n            list = &(*list)->next;\n\n        }\n\n        break;\n\n    }\n\n    case USER_DEF_NATIVE_LIST_UNION_KIND_STRING: {\n\n        strList **list = &cvalue->u.string.data;\n\n        for (i = 0; i < 32; i++) {\n\n            *list = g_new0(strList, 1);\n\n            (*list)->value = g_strdup_printf(\"%d\", i);\n\n            (*list)->next = NULL;\n\n            list = &(*list)->next;\n\n        }\n\n        break;\n\n    }\n\n    case USER_DEF_NATIVE_LIST_UNION_KIND_NUMBER: {\n\n        numberList **list = &cvalue->u.number.data;\n\n        for (i = 0; i < 32; i++) {\n\n            *list = g_new0(numberList, 1);\n\n            (*list)->value = (double)i \/ 3;\n\n            (*list)->next = NULL;\n\n            list = &(*list)->next;\n\n        }\n\n        break;\n\n    }\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"ad96090a01d848df67d70c5259ed8aa321fa8716","target":0,"func":"static void do_smbios_option(const char *optarg)\n\n{\n\n    if (smbios_entry_add(optarg) < 0) {\n\n        fprintf(stderr, \"Wrong smbios provided\\n\");\n\n        exit(1);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884","target":0,"func":"static int vnc_display_connect(VncDisplay *vd,\n\n                               SocketAddressLegacy **saddr,\n\n                               size_t nsaddr,\n\n                               SocketAddressLegacy **wsaddr,\n\n                               size_t nwsaddr,\n\n                               Error **errp)\n\n{\n\n    \/* connect to viewer *\/\n\n    QIOChannelSocket *sioc = NULL;\n\n    if (nwsaddr != 0) {\n\n        error_setg(errp, \"Cannot use websockets in reverse mode\");\n\n        return -1;\n\n    }\n\n    if (nsaddr != 1) {\n\n        error_setg(errp, \"Expected a single address in reverse mode\");\n\n        return -1;\n\n    }\n\n    \/* TODO SOCKET_ADDRESS_LEGACY_KIND_FD when fd has AF_UNIX *\/\n\n    vd->is_unix = saddr[0]->type == SOCKET_ADDRESS_LEGACY_KIND_UNIX;\n\n    sioc = qio_channel_socket_new();\n\n    qio_channel_set_name(QIO_CHANNEL(sioc), \"vnc-reverse\");\n\n    if (qio_channel_socket_connect_sync(sioc, saddr[0], errp) < 0) {\n\n        return -1;\n\n    }\n\n    vnc_connect(vd, sioc, false, false);\n\n    object_unref(OBJECT(sioc));\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"cedf9a6f4549900f857954059284a96814e4c7a3","target":1,"func":"int load_elf(const char *filename, uint64_t (*translate_fn)(void *, uint64_t),\n\n             void *translate_opaque, uint64_t *pentry, uint64_t *lowaddr,\n\n             uint64_t *highaddr, int big_endian, int elf_machine, int clear_lsb)\n\n{\n\n    int fd, data_order, target_data_order, must_swab, ret;\n\n    uint8_t e_ident[EI_NIDENT];\n\n\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (fd < 0) {\n\n        perror(filename);\n\n        return -1;\n\n    }\n\n    if (read(fd, e_ident, sizeof(e_ident)) != sizeof(e_ident))\n\n        goto fail;\n\n    if (e_ident[0] != ELFMAG0 ||\n\n        e_ident[1] != ELFMAG1 ||\n\n        e_ident[2] != ELFMAG2 ||\n\n        e_ident[3] != ELFMAG3)\n\n        goto fail;\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    data_order = ELFDATA2MSB;\n\n#else\n\n    data_order = ELFDATA2LSB;\n\n#endif\n\n    must_swab = data_order != e_ident[EI_DATA];\n\n    if (big_endian) {\n\n        target_data_order = ELFDATA2MSB;\n\n    } else {\n\n        target_data_order = ELFDATA2LSB;\n\n    }\n\n\n\n    if (target_data_order != e_ident[EI_DATA])\n\n        return -1;\n\n\n\n    lseek(fd, 0, SEEK_SET);\n\n    if (e_ident[EI_CLASS] == ELFCLASS64) {\n\n        ret = load_elf64(filename, fd, translate_fn, translate_opaque, must_swab,\n\n                         pentry, lowaddr, highaddr, elf_machine, clear_lsb);\n\n    } else {\n\n        ret = load_elf32(filename, fd, translate_fn, translate_opaque, must_swab,\n\n                         pentry, lowaddr, highaddr, elf_machine, clear_lsb);\n\n    }\n\n\n\n    close(fd);\n\n    return ret;\n\n\n\n fail:\n\n    close(fd);\n\n    return -1;\n\n}\n"},{"project":"qemu","commit_id":"06630554ccbdd25780aa03c3548aaff1eb56dffd","target":0,"func":"static void mptsas_fetch_request(MPTSASState *s)\n\n{\n\n    PCIDevice *pci = (PCIDevice *) s;\n\n    char req[MPTSAS_MAX_REQUEST_SIZE];\n\n    MPIRequestHeader *hdr = (MPIRequestHeader *)req;\n\n    hwaddr addr;\n\n    int size;\n\n\n\n    if (s->state != MPI_IOC_STATE_OPERATIONAL) {\n\n        mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_STATE);\n\n        return;\n\n    }\n\n\n\n    \/* Read the message header from the guest first. *\/\n\n    addr = s->host_mfa_high_addr | MPTSAS_FIFO_GET(s, request_post);\n\n    pci_dma_read(pci, addr, req, sizeof(hdr));\n\n\n\n    if (hdr->Function < ARRAY_SIZE(mpi_request_sizes) &&\n\n        mpi_request_sizes[hdr->Function]) {\n\n        \/* Read the rest of the request based on the type.  Do not\n\n         * reread everything, as that could cause a TOC\/TOU mismatch\n\n         * and leak data from the QEMU stack.\n\n         *\/\n\n        size = mpi_request_sizes[hdr->Function];\n\n        assert(size <= MPTSAS_MAX_REQUEST_SIZE);\n\n        pci_dma_read(pci, addr + sizeof(hdr), &req[sizeof(hdr)],\n\n                     size - sizeof(hdr));\n\n    }\n\n\n\n    if (hdr->Function == MPI_FUNCTION_SCSI_IO_REQUEST) {\n\n        \/* SCSI I\/O requests are separate from mptsas_process_message\n\n         * because they cannot be sent through the doorbell yet.\n\n         *\/\n\n        mptsas_process_scsi_io_request(s, (MPIMsgSCSIIORequest *)req, addr);\n\n    } else {\n\n        mptsas_process_message(s, (MPIRequestHeader *)req);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"210b580b106fa798149e28aa13c66b325a43204e","target":0,"func":"static void rtas_get_xive(sPAPREnvironment *spapr, uint32_t token,\n\n                          uint32_t nargs, target_ulong args,\n\n                          uint32_t nret, target_ulong rets)\n\n{\n\n    struct ics_state *ics = spapr->icp->ics;\n\n    uint32_t nr;\n\n\n\n    if ((nargs != 1) || (nret != 3)) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    nr = rtas_ld(args, 0);\n\n\n\n    if (!ics_valid_irq(ics, nr)) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    rtas_st(rets, 0, 0); \/* Success *\/\n\n    rtas_st(rets, 1, ics->irqs[nr - ics->offset].server);\n\n    rtas_st(rets, 2, ics->irqs[nr - ics->offset].priority);\n\n}\n"},{"project":"qemu","commit_id":"c63807244fb55071675907460a0ecf228c1766c8","target":1,"func":"static int qemu_peek_byte(QEMUFile *f)\n\n{\n\n    if (f->is_write) {\n\n        abort();\n\n    }\n\n\n\n    if (f->buf_index >= f->buf_size) {\n\n        qemu_fill_buffer(f);\n\n        if (f->buf_index >= f->buf_size) {\n\n            return 0;\n\n        }\n\n    }\n\n    return f->buf[f->buf_index];\n\n}\n"},{"project":"qemu","commit_id":"96c05abc904c6f74b60981d956cee531920e4cdf","target":0,"func":"static int qxl_init_common(PCIQXLDevice *qxl)\n\n{\n\n    uint8_t* config = qxl->pci.config;\n\n    uint32_t pci_device_id;\n\n    uint32_t pci_device_rev;\n\n    uint32_t io_size;\n\n\n\n    qxl->mode = QXL_MODE_UNDEFINED;\n\n    qxl->generation = 1;\n\n    qxl->num_memslots = NUM_MEMSLOTS;\n\n    qxl->num_surfaces = NUM_SURFACES;\n\n\n\n    switch (qxl->revision) {\n\n    case 1: \/* spice 0.4 -- qxl-1 *\/\n\n        pci_device_id  = QXL_DEVICE_ID_STABLE;\n\n        pci_device_rev = QXL_REVISION_STABLE_V04;\n\n        break;\n\n    case 2: \/* spice 0.6 -- qxl-2 *\/\n\n        pci_device_id  = QXL_DEVICE_ID_STABLE;\n\n        pci_device_rev = QXL_REVISION_STABLE_V06;\n\n        break;\n\n    default: \/* experimental *\/\n\n        pci_device_id  = QXL_DEVICE_ID_DEVEL;\n\n        pci_device_rev = 1;\n\n        break;\n\n    }\n\n\n\n    pci_config_set_vendor_id(config, REDHAT_PCI_VENDOR_ID);\n\n    pci_config_set_device_id(config, pci_device_id);\n\n    pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev);\n\n    pci_set_byte(&config[PCI_INTERRUPT_PIN], 1);\n\n\n\n    qxl->rom_size = qxl_rom_size();\n\n    qxl->rom_offset = qemu_ram_alloc(&qxl->pci.qdev, \"qxl.vrom\", qxl->rom_size);\n\n    init_qxl_rom(qxl);\n\n    init_qxl_ram(qxl);\n\n\n\n    if (qxl->vram_size < 16 * 1024 * 1024) {\n\n        qxl->vram_size = 16 * 1024 * 1024;\n\n    }\n\n    if (qxl->revision == 1) {\n\n        qxl->vram_size = 4096;\n\n    }\n\n    qxl->vram_size = msb_mask(qxl->vram_size * 2 - 1);\n\n    qxl->vram_offset = qemu_ram_alloc(&qxl->pci.qdev, \"qxl.vram\", qxl->vram_size);\n\n\n\n    io_size = msb_mask(QXL_IO_RANGE_SIZE * 2 - 1);\n\n    if (qxl->revision == 1) {\n\n        io_size = 8;\n\n    }\n\n\n\n    pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX,\n\n                     io_size, PCI_BASE_ADDRESS_SPACE_IO, qxl_map);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX,\n\n                     qxl->rom_size, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     qxl_map);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX,\n\n                     qxl->vga.vram_size, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     qxl_map);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX, qxl->vram_size,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, qxl_map);\n\n\n\n    qxl->ssd.qxl.base.sif = &qxl_interface.base;\n\n    qxl->ssd.qxl.id = qxl->id;\n\n    qemu_spice_add_interface(&qxl->ssd.qxl.base);\n\n    qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl);\n\n\n\n    init_pipe_signaling(qxl);\n\n    qxl_reset_state(qxl);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5","target":0,"func":"struct omap_lcd_panel_s *omap_lcdc_init(MemoryRegion *sysmem,\n\n                                        hwaddr base,\n\n                                        qemu_irq irq,\n\n                                        struct omap_dma_lcd_channel_s *dma,\n\n                                        omap_clk clk)\n\n{\n\n    struct omap_lcd_panel_s *s = (struct omap_lcd_panel_s *)\n\n            g_malloc0(sizeof(struct omap_lcd_panel_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->sysmem = sysmem;\n\n    omap_lcdc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_lcdc_ops, s, \"omap.lcdc\", 0x100);\n\n    memory_region_add_subregion(sysmem, base, &s->iomem);\n\n\n\n    s->con = graphic_console_init(omap_update_display,\n\n                                  omap_invalidate_display,\n\n                                  omap_screen_dump, NULL, s);\n\n\n\n    return s;\n\n}\n"},{"project":"qemu","commit_id":"f53a829bb9ef14be800556cbc02d8b20fc1050a7","target":0,"func":"static void nbd_reply_ready(void *opaque)\n\n{\n\n    NbdClientSession *s = opaque;\n\n    uint64_t i;\n\n    int ret;\n\n\n\n    if (s->reply.handle == 0) {\n\n        \/* No reply already in flight.  Fetch a header.  It is possible\n\n         * that another thread has done the same thing in parallel, so\n\n         * the socket is not readable anymore.\n\n         *\/\n\n        ret = nbd_receive_reply(s->sock, &s->reply);\n\n        if (ret == -EAGAIN) {\n\n            return;\n\n        }\n\n        if (ret < 0) {\n\n            s->reply.handle = 0;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    \/* There's no need for a mutex on the receive side, because the\n\n     * handler acts as a synchronization point and ensures that only\n\n     * one coroutine is called until the reply finishes.  *\/\n\n    i = HANDLE_TO_INDEX(s, s->reply.handle);\n\n    if (i >= MAX_NBD_REQUESTS) {\n\n        goto fail;\n\n    }\n\n\n\n    if (s->recv_coroutine[i]) {\n\n        qemu_coroutine_enter(s->recv_coroutine[i], NULL);\n\n        return;\n\n    }\n\n\n\nfail:\n\n    nbd_teardown_connection(s);\n\n}\n"},{"project":"qemu","commit_id":"e4f4fb1eca795e36f363b4647724221e774523c1","target":1,"func":"static void ohci_sysbus_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = ohci_realize_pxa;\n\n    set_bit(DEVICE_CATEGORY_USB, dc->categories);\n\n    dc->desc = \"OHCI USB Controller\";\n\n    dc->props = ohci_sysbus_properties;\n\n    dc->reset = usb_ohci_reset_sysbus;\n\n\n\n\n\n\n}"},{"project":"qemu","commit_id":"3ebcc707d20643e9fefa24a4396de577b1163755","target":0,"func":"void handle_vm86_fault(CPUX86State *env)\n\n{\n\n    TaskState *ts = env->opaque;\n\n    uint8_t *csp, *pc, *ssp;\n\n    unsigned int ip, sp, newflags, newip, newcs, opcode, intno;\n\n    int data32, pref_done;\n\n\n\n    csp = (uint8_t *)(env->segs[R_CS] << 4);\n\n    ip = env->eip & 0xffff;\n\n    pc = csp + ip;\n\n    \n\n    ssp = (uint8_t *)(env->segs[R_SS] << 4);\n\n    sp = env->regs[R_ESP] & 0xffff;\n\n\n\n#if defined(DEBUG_VM86)\n\n    fprintf(logfile, \"VM86 exception %04x:%08x %02x %02x\\n\",\n\n            env->segs[R_CS], env->eip, pc[0], pc[1]);\n\n#endif\n\n\n\n    data32 = 0;\n\n    pref_done = 0;\n\n    do {\n\n        opcode = csp[ip];\n\n        ADD16(ip, 1);\n\n        switch (opcode) {\n\n        case 0x66:      \/* 32-bit data *\/     data32=1; break;\n\n        case 0x67:      \/* 32-bit address *\/  break;\n\n        case 0x2e:      \/* CS *\/              break;\n\n        case 0x3e:      \/* DS *\/              break;\n\n        case 0x26:      \/* ES *\/              break;\n\n        case 0x36:      \/* SS *\/              break;\n\n        case 0x65:      \/* GS *\/              break;\n\n        case 0x64:      \/* FS *\/              break;\n\n        case 0xf2:      \/* repnz *\/\t      break;\n\n        case 0xf3:      \/* rep *\/             break;\n\n        default: pref_done = 1;\n\n        }\n\n    } while (!pref_done);\n\n\n\n    \/* VM86 mode *\/\n\n    switch(opcode) {\n\n    case 0x9c: \/* pushf *\/\n\n        ADD16(env->eip, 2);\n\n        if (data32) {\n\n            vm_putl(ssp, sp - 4, get_vflags(env));\n\n            ADD16(env->regs[R_ESP], -4);\n\n        } else {\n\n            vm_putw(ssp, sp - 2, get_vflags(env));\n\n            ADD16(env->regs[R_ESP], -2);\n\n        }\n\n        env->eip = ip;\n\n        VM86_FAULT_RETURN;\n\n\n\n    case 0x9d: \/* popf *\/\n\n        if (data32) {\n\n            newflags = vm_getl(ssp, sp);\n\n            ADD16(env->regs[R_ESP], 4);\n\n        } else {\n\n            newflags = vm_getw(ssp, sp);\n\n            ADD16(env->regs[R_ESP], 2);\n\n        }\n\n        env->eip = ip;\n\n        CHECK_IF_IN_TRAP();\n\n        if (data32) {\n\n            if (set_vflags_long(newflags, env))\n\n                return;\n\n        } else {\n\n            if (set_vflags_short(newflags, env))\n\n                return;\n\n        }\n\n        VM86_FAULT_RETURN;\n\n\n\n    case 0xcd: \/* int *\/\n\n        intno = csp[ip];\n\n        ADD16(ip, 1);\n\n        env->eip = ip;\n\n        if (ts->vm86plus.vm86plus.flags & TARGET_vm86dbg_active) {\n\n            if ( (ts->vm86plus.vm86plus.vm86dbg_intxxtab[intno >> 3] >> \n\n                  (intno &7)) & 1) {\n\n                return_to_32bit(env, TARGET_VM86_INTx + (intno << 8));\n\n                return;\n\n            }\n\n        }\n\n        do_int(env, intno);\n\n        break;\n\n\n\n    case 0xcf: \/* iret *\/\n\n        if (data32) {\n\n            newip = vm_getl(ssp, sp) & 0xffff;\n\n            newcs = vm_getl(ssp, sp + 4) & 0xffff;\n\n            newflags = vm_getl(ssp, sp + 8);\n\n            ADD16(env->regs[R_ESP], 12);\n\n        } else {\n\n            newip = vm_getw(ssp, sp);\n\n            newcs = vm_getw(ssp, sp + 2);\n\n            newflags = vm_getw(ssp, sp + 4);\n\n            ADD16(env->regs[R_ESP], 6);\n\n        }\n\n        env->eip = newip;\n\n        cpu_x86_load_seg(env, R_CS, newcs);\n\n        CHECK_IF_IN_TRAP();\n\n        if (data32) {\n\n            if (set_vflags_long(newflags, env))\n\n                return;\n\n        } else {\n\n            if (set_vflags_short(newflags, env))\n\n                return;\n\n        }\n\n        VM86_FAULT_RETURN;\n\n        \n\n    case 0xfa: \/* cli *\/\n\n        env->eip = ip;\n\n        clear_IF(env);\n\n        VM86_FAULT_RETURN;\n\n        \n\n    case 0xfb: \/* sti *\/\n\n        env->eip = ip;\n\n        if (set_IF(env))\n\n            return;\n\n        VM86_FAULT_RETURN;\n\n\n\n    default:\n\n        \/* real VM86 GPF exception *\/\n\n        return_to_32bit(env, TARGET_VM86_UNKNOWN);\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"efec3dd631d94160288392721a5f9c39e50fb2bc","target":1,"func":"static void pl190_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = pl190_init;\n\n    dc->no_user = 1;\n\n    dc->reset = pl190_reset;\n\n    dc->vmsd = &vmstate_pl190;\n\n}\n"},{"project":"qemu","commit_id":"4b635c59b04cae594f49d9aa45d31b3f318def8f","target":1,"func":"void *qxl_phys2virt(PCIQXLDevice *qxl, QXLPHYSICAL pqxl, int group_id)\n\n{\n\n    uint64_t phys   = le64_to_cpu(pqxl);\n\n    uint32_t slot   = (phys >> (64 -  8)) & 0xff;\n\n    uint64_t offset = phys & 0xffffffffffff;\n\n\n\n    switch (group_id) {\n\n    case MEMSLOT_GROUP_HOST:\n\n        return (void *)(intptr_t)offset;\n\n    case MEMSLOT_GROUP_GUEST:\n\n        PANIC_ON(slot >= NUM_MEMSLOTS);\n\n        PANIC_ON(!qxl->guest_slots[slot].active);\n\n        PANIC_ON(offset < qxl->guest_slots[slot].delta);\n\n        offset -= qxl->guest_slots[slot].delta;\n\n        PANIC_ON(offset > qxl->guest_slots[slot].size)\n\n        return qxl->guest_slots[slot].ptr + offset;\n\n    default:\n\n        PANIC_ON(1);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"177b75104da3e3a9af84975c32a44782d903c41f","target":0,"func":"static inline int dmg_read_chunk(BlockDriverState *bs, uint64_t sector_num)\n\n{\n\n    BDRVDMGState *s = bs->opaque;\n\n\n\n    if (!is_sector_in_chunk(s, s->current_chunk, sector_num)) {\n\n        int ret;\n\n        uint32_t chunk = search_chunk(s, sector_num);\n\n#ifdef CONFIG_BZIP2\n\n        uint64_t total_out;\n\n#endif\n\n\n\n        if (chunk >= s->n_chunks) {\n\n            return -1;\n\n        }\n\n\n\n        s->current_chunk = s->n_chunks;\n\n        switch (s->types[chunk]) { \/* block entry type *\/\n\n        case 0x80000005: { \/* zlib compressed *\/\n\n            \/* we need to buffer, because only the chunk as whole can be\n\n             * inflated. *\/\n\n            ret = bdrv_pread(bs->file, s->offsets[chunk],\n\n                             s->compressed_chunk, s->lengths[chunk]);\n\n            if (ret != s->lengths[chunk]) {\n\n                return -1;\n\n            }\n\n\n\n            s->zstream.next_in = s->compressed_chunk;\n\n            s->zstream.avail_in = s->lengths[chunk];\n\n            s->zstream.next_out = s->uncompressed_chunk;\n\n            s->zstream.avail_out = 512 * s->sectorcounts[chunk];\n\n            ret = inflateReset(&s->zstream);\n\n            if (ret != Z_OK) {\n\n                return -1;\n\n            }\n\n            ret = inflate(&s->zstream, Z_FINISH);\n\n            if (ret != Z_STREAM_END ||\n\n                s->zstream.total_out != 512 * s->sectorcounts[chunk]) {\n\n                return -1;\n\n            }\n\n            break; }\n\n#ifdef CONFIG_BZIP2\n\n        case 0x80000006: \/* bzip2 compressed *\/\n\n            \/* we need to buffer, because only the chunk as whole can be\n\n             * inflated. *\/\n\n            ret = bdrv_pread(bs->file, s->offsets[chunk],\n\n                             s->compressed_chunk, s->lengths[chunk]);\n\n            if (ret != s->lengths[chunk]) {\n\n                return -1;\n\n            }\n\n\n\n            ret = BZ2_bzDecompressInit(&s->bzstream, 0, 0);\n\n            if (ret != BZ_OK) {\n\n                return -1;\n\n            }\n\n            s->bzstream.next_in = (char *)s->compressed_chunk;\n\n            s->bzstream.avail_in = (unsigned int) s->lengths[chunk];\n\n            s->bzstream.next_out = (char *)s->uncompressed_chunk;\n\n            s->bzstream.avail_out = (unsigned int) 512 * s->sectorcounts[chunk];\n\n            ret = BZ2_bzDecompress(&s->bzstream);\n\n            total_out = ((uint64_t)s->bzstream.total_out_hi32 << 32) +\n\n                        s->bzstream.total_out_lo32;\n\n            BZ2_bzDecompressEnd(&s->bzstream);\n\n            if (ret != BZ_STREAM_END ||\n\n                total_out != 512 * s->sectorcounts[chunk]) {\n\n                return -1;\n\n            }\n\n            break;\n\n#endif \/* CONFIG_BZIP2 *\/\n\n        case 1: \/* copy *\/\n\n            ret = bdrv_pread(bs->file, s->offsets[chunk],\n\n                             s->uncompressed_chunk, s->lengths[chunk]);\n\n            if (ret != s->lengths[chunk]) {\n\n                return -1;\n\n            }\n\n            break;\n\n        case 2: \/* zero *\/\n\n            memset(s->uncompressed_chunk, 0, 512 * s->sectorcounts[chunk]);\n\n            break;\n\n        }\n\n        s->current_chunk = chunk;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"2ebcebe262e88111ff583f97bc5fe0aae64b8940","target":1,"func":"static int vmsa_ttbcr_raw_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                                uint64_t value)\n\n{\n\n    if (arm_feature(env, ARM_FEATURE_LPAE)) {\n\n        value &= ~((7 << 19) | (3 << 14) | (0xf << 3));\n\n    } else {\n\n        value &= 7;\n\n    }\n\n    \/* Note that we always calculate c2_mask and c2_base_mask, but\n\n     * they are only used for short-descriptor tables (ie if EAE is 0);\n\n     * for long-descriptor tables the TTBCR fields are used differently\n\n     * and the c2_mask and c2_base_mask values are meaningless.\n\n     *\/\n\n    env->cp15.c2_control = value;\n\n    env->cp15.c2_mask = ~(((uint32_t)0xffffffffu) >> value);\n\n    env->cp15.c2_base_mask = ~((uint32_t)0x3fffu >> value);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"ddca7f86ac022289840e0200fd4050b2b58e9176","target":0,"func":"static void v9fs_statfs(void *opaque)\n\n{\n\n    int32_t fid;\n\n    ssize_t retval = 0;\n\n    size_t offset = 7;\n\n    V9fsFidState *fidp;\n\n    struct statfs stbuf;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"d\", &fid);\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        retval = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    retval = v9fs_co_statfs(pdu, &fidp->path, &stbuf);\n\n    if (retval < 0) {\n\n        goto out;\n\n    }\n\n    retval = offset;\n\n    retval += v9fs_fill_statfs(s, pdu, &stbuf);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, retval);\n\n    return;\n\n}\n"},{"project":"qemu","commit_id":"728470bea15b11ba7b3e3db54f0d9939908e0e65","target":1,"func":"static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)\n\n{\n\n    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));\n\n\n\n    if (qemu_file_mode_is_not_valid(mode)) {\n\n        return NULL;\n\n    }\n\n\n\n    r->rdma = rdma;\n\n\n\n    if (mode[0] == 'w') {\n\n        r->file = qemu_fopen_ops(r, &rdma_write_ops);\n\n    } else {\n\n        r->file = qemu_fopen_ops(r, &rdma_read_ops);\n\n    }\n\n\n\n    return r->file;\n\n}\n"},{"project":"qemu","commit_id":"0b8b8753e4d94901627b3e86431230f2319215c4","target":1,"func":"int bdrv_create(BlockDriver *drv, const char* filename,\n\n                QemuOpts *opts, Error **errp)\n\n{\n\n    int ret;\n\n\n\n    Coroutine *co;\n\n    CreateCo cco = {\n\n        .drv = drv,\n\n        .filename = g_strdup(filename),\n\n        .opts = opts,\n\n        .ret = NOT_DONE,\n\n        .err = NULL,\n\n    };\n\n\n\n    if (!drv->bdrv_create) {\n\n        error_setg(errp, \"Driver '%s' does not support image creation\", drv->format_name);\n\n        ret = -ENOTSUP;\n\n        goto out;\n\n    }\n\n\n\n    if (qemu_in_coroutine()) {\n\n        \/* Fast-path if already in coroutine context *\/\n\n        bdrv_create_co_entry(&cco);\n\n    } else {\n\n        co = qemu_coroutine_create(bdrv_create_co_entry);\n\n        qemu_coroutine_enter(co, &cco);\n\n        while (cco.ret == NOT_DONE) {\n\n            aio_poll(qemu_get_aio_context(), true);\n\n        }\n\n    }\n\n\n\n    ret = cco.ret;\n\n    if (ret < 0) {\n\n        if (cco.err) {\n\n            error_propagate(errp, cco.err);\n\n        } else {\n\n            error_setg_errno(errp, -ret, \"Could not create image\");\n\n        }\n\n    }\n\n\n\nout:\n\n    g_free(cco.filename);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"c3203fa5b2c17a1c446e44c87788fef21b4af5f4","target":1,"func":"static int get_current_cpu(void)\n\n{\n\n  return cpu_single_env->cpu_index;\n\n}\n"},{"project":"qemu","commit_id":"0ab07c623c629acfbc792e5a174129c19faefbb7","target":0,"func":"static void flush_queued_work(CPUState *env)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (!env->queued_work_first)\n\n        return;\n\n\n\n    while ((wi = env->queued_work_first)) {\n\n        env->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n    }\n\n    env->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n"},{"project":"qemu","commit_id":"d42cf28837801cd1f835089fe9db2a42a1af55cd","target":0,"func":"static void bdrv_drain_recurse(BlockDriverState *bs)\n\n{\n\n    BdrvChild *child;\n\n\n\n    if (bs->drv && bs->drv->bdrv_drain) {\n\n        bs->drv->bdrv_drain(bs);\n\n    }\n\n    QLIST_FOREACH(child, &bs->children, next) {\n\n        bdrv_drain_recurse(child->bs);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"8e9b0d24fb986d4241ae3b77752eca5dab4cb486","target":0,"func":"static void vnc_listen_read(void *opaque, bool websocket)\n\n{\n\n    VncDisplay *vs = opaque;\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int csock;\n\n\n\n    \/* Catch-up *\/\n\n    graphic_hw_update(vs->dcl.con);\n\n#ifdef CONFIG_VNC_WS\n\n    if (websocket) {\n\n        csock = qemu_accept(vs->lwebsock, (struct sockaddr *)&addr, &addrlen);\n\n    } else\n\n#endif \/* CONFIG_VNC_WS *\/\n\n    {\n\n        csock = qemu_accept(vs->lsock, (struct sockaddr *)&addr, &addrlen);\n\n    }\n\n\n\n    if (csock != -1) {\n\n        socket_set_nodelay(csock);\n\n        vnc_connect(vs, csock, false, websocket);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"10c4c98ab7dc18169b37b76f6ea5e60ebe65222b","target":0,"func":"static void qbus_print(Monitor *mon, BusState *bus, int indent)\n\n{\n\n    struct DeviceState *dev;\n\n\n\n    qdev_printf(\"bus: %s\\n\", bus->name);\n\n    indent += 2;\n\n    qdev_printf(\"type %s\\n\", bus_type_names[bus->type]);\n\n    LIST_FOREACH(dev, &bus->children, sibling) {\n\n        qdev_print(mon, dev, indent);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b","target":1,"func":"QEMUPutLEDEntry *qemu_add_led_event_handler(QEMUPutLEDEvent *func,\n\n                                            void *opaque)\n\n{\n\n    QEMUPutLEDEntry *s;\n\n\n\n    s = g_malloc0(sizeof(QEMUPutLEDEntry));\n\n\n\n    s->put_led = func;\n\n    s->opaque = opaque;\n\n    QTAILQ_INSERT_TAIL(&led_handlers, s, next);\n\n    return s;\n\n}\n"},{"project":"qemu","commit_id":"e6afc87f804abee7d0479be5e8e31c56d885fafb","target":1,"func":"static float64 roundAndPackFloat64( flag zSign, int16 zExp, uint64_t zSig STATUS_PARAM)\n\n{\n\n    int8 roundingMode;\n\n    flag roundNearestEven;\n\n    int16 roundIncrement, roundBits;\n\n    flag isTiny;\n\n\n\n    roundingMode = STATUS(float_rounding_mode);\n\n    roundNearestEven = ( roundingMode == float_round_nearest_even );\n\n    roundIncrement = 0x200;\n\n    if ( ! roundNearestEven ) {\n\n        if ( roundingMode == float_round_to_zero ) {\n\n            roundIncrement = 0;\n\n        }\n\n        else {\n\n            roundIncrement = 0x3FF;\n\n            if ( zSign ) {\n\n                if ( roundingMode == float_round_up ) roundIncrement = 0;\n\n            }\n\n            else {\n\n                if ( roundingMode == float_round_down ) roundIncrement = 0;\n\n            }\n\n        }\n\n    }\n\n    roundBits = zSig & 0x3FF;\n\n    if ( 0x7FD <= (uint16_t) zExp ) {\n\n        if (    ( 0x7FD < zExp )\n\n             || (    ( zExp == 0x7FD )\n\n                  && ( (int64_t) ( zSig + roundIncrement ) < 0 ) )\n\n           ) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat64( zSign, 0x7FF, - ( roundIncrement == 0 ));\n\n        }\n\n        if ( zExp < 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat64( zSign, 0, 0 );\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < -1 )\n\n                || ( zSig + roundIncrement < LIT64( 0x8000000000000000 ) );\n\n            shift64RightJamming( zSig, - zExp, &zSig );\n\n            zExp = 0;\n\n            roundBits = zSig & 0x3FF;\n\n            if ( isTiny && roundBits ) float_raise( float_flag_underflow STATUS_VAR);\n\n        }\n\n    }\n\n    if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    zSig = ( zSig + roundIncrement )>>10;\n\n    zSig &= ~ ( ( ( roundBits ^ 0x200 ) == 0 ) & roundNearestEven );\n\n    if ( zSig == 0 ) zExp = 0;\n\n    return packFloat64( zSign, zExp, zSig );\n\n\n\n}\n"},{"project":"qemu","commit_id":"2e6fc7eb1a4af1b127df5f07b8bb28af891946fa","target":0,"func":"static void raw_reopen_commit(BDRVReopenState *state)\n\n{\n\n    BDRVRawState *new_s = state->opaque;\n\n    BDRVRawState *s = state->bs->opaque;\n\n\n\n    memcpy(s, new_s, sizeof(BDRVRawState));\n\n\n\n    g_free(state->opaque);\n\n    state->opaque = NULL;\n\n}\n"},{"project":"qemu","commit_id":"27af7d6ea5015e5ef1f7985eab94a8a218267a2b","target":1,"func":"static int save_xbzrle_page(QEMUFile *f, uint8_t **current_data,\n\n                            ram_addr_t current_addr, RAMBlock *block,\n\n                            ram_addr_t offset, int cont, bool last_stage)\n\n{\n\n    int encoded_len = 0, bytes_sent = -1;\n\n    uint8_t *prev_cached_page;\n\n\n\n    if (!cache_is_cached(XBZRLE.cache, current_addr)) {\n\n        acct_info.xbzrle_cache_miss++;\n\n        if (!last_stage) {\n\n            if (cache_insert(XBZRLE.cache, current_addr, *current_data) == -1) {\n\n                return -1;\n\n            } else {\n\n                \/* update *current_data when the page has been\n\n                   inserted into cache *\/\n\n                *current_data = get_cached_data(XBZRLE.cache, current_addr);\n\n            }\n\n        }\n\n        return -1;\n\n    }\n\n\n\n    prev_cached_page = get_cached_data(XBZRLE.cache, current_addr);\n\n\n\n    \/* save current buffer into memory *\/\n\n    memcpy(XBZRLE.current_buf, *current_data, TARGET_PAGE_SIZE);\n\n\n\n    \/* XBZRLE encoding (if there is no overflow) *\/\n\n    encoded_len = xbzrle_encode_buffer(prev_cached_page, XBZRLE.current_buf,\n\n                                       TARGET_PAGE_SIZE, XBZRLE.encoded_buf,\n\n                                       TARGET_PAGE_SIZE);\n\n    if (encoded_len == 0) {\n\n        DPRINTF(\"Skipping unmodified page\\n\");\n\n        return 0;\n\n    } else if (encoded_len == -1) {\n\n        DPRINTF(\"Overflow\\n\");\n\n        acct_info.xbzrle_overflows++;\n\n        \/* update data in the cache *\/\n\n        if (!last_stage) {\n\n            memcpy(prev_cached_page, *current_data, TARGET_PAGE_SIZE);\n\n            *current_data = prev_cached_page;\n\n        }\n\n        return -1;\n\n    }\n\n\n\n    \/* we need to update the data in the cache, in order to get the same data *\/\n\n    if (!last_stage) {\n\n        memcpy(prev_cached_page, XBZRLE.current_buf, TARGET_PAGE_SIZE);\n\n    }\n\n\n\n    \/* Send XBZRLE based compressed page *\/\n\n    bytes_sent = save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_XBZRLE);\n\n    qemu_put_byte(f, ENCODING_FLAG_XBZRLE);\n\n    qemu_put_be16(f, encoded_len);\n\n    qemu_put_buffer(f, XBZRLE.encoded_buf, encoded_len);\n\n    bytes_sent += encoded_len + 1 + 2;\n\n    acct_info.xbzrle_pages++;\n\n    acct_info.xbzrle_bytes += bytes_sent;\n\n\n\n    return bytes_sent;\n\n}\n"},{"project":"qemu","commit_id":"47d4be12c3997343e436c6cca89aefbbbeb70863","target":1,"func":"static void test_qemu_strtoull_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n"},{"project":"qemu","commit_id":"db39fcf1f690b02d612e2bfc00980700887abe03","target":0,"func":"static CharDriverState *qemu_chr_open_ringbuf(ChardevRingbuf *opts,\n\n                                              Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    RingBufCharDriver *d;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    d = g_malloc(sizeof(*d));\n\n\n\n    d->size = opts->has_size ? opts->size : 65536;\n\n\n\n    \/* The size must be power of 2 *\/\n\n    if (d->size & (d->size - 1)) {\n\n        error_setg(errp, \"size of ringbuf chardev must be power of two\");\n\n        goto fail;\n\n    }\n\n\n\n    d->prod = 0;\n\n    d->cons = 0;\n\n    d->cbuf = g_malloc0(d->size);\n\n\n\n    chr->opaque = d;\n\n    chr->chr_write = ringbuf_chr_write;\n\n    chr->chr_close = ringbuf_chr_close;\n\n\n\n    return chr;\n\n\n\nfail:\n\n    g_free(d);\n\n    g_free(chr);\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"fd56e0612b6454a282fa6a953fdb09281a98c589","target":0,"func":"static void pxb_register_bus(PCIDevice *dev, PCIBus *pxb_bus, Error **errp)\n\n{\n\n    PCIBus *bus = dev->bus;\n\n    int pxb_bus_num = pci_bus_num(pxb_bus);\n\n\n\n    if (bus->parent_dev) {\n\n        error_setg(errp, \"PXB devices can be attached only to root bus\");\n\n        return;\n\n    }\n\n\n\n    QLIST_FOREACH(bus, &bus->child, sibling) {\n\n        if (pci_bus_num(bus) == pxb_bus_num) {\n\n            error_setg(errp, \"Bus %d is already in use\", pxb_bus_num);\n\n            return;\n\n        }\n\n    }\n\n    QLIST_INSERT_HEAD(&dev->bus->child, pxb_bus, sibling);\n\n}\n"},{"project":"qemu","commit_id":"677ef6230b603571ae05125db469f7b4c8912a77","target":0,"func":"void helper_lock(void)\n\n{\n\n    spin_lock(&global_cpu_lock);\n\n}\n"},{"project":"qemu","commit_id":"ff047453f56713aa627e63aade1a9046ccd3bdfd","target":0,"func":"static void cpu_pre_save(void *opaque)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n\n\n    if (!write_cpustate_to_list(cpu)) {\n\n        \/* This should never fail. *\/\n\n        abort();\n\n    }\n\n\n\n    cpu->cpreg_vmstate_array_len = cpu->cpreg_array_len;\n\n    memcpy(cpu->cpreg_vmstate_indexes, cpu->cpreg_indexes,\n\n           cpu->cpreg_array_len * sizeof(uint64_t));\n\n    memcpy(cpu->cpreg_vmstate_values, cpu->cpreg_values,\n\n           cpu->cpreg_array_len * sizeof(uint64_t));\n\n}\n"},{"project":"qemu","commit_id":"3ddcd2edc8ca708ccd808a78424b9aadebd4f7c4","target":0,"func":"static int hyperv_handle_properties(CPUState *cs)\n\n{\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n\n\n    if (cpu->hyperv_relaxed_timing) {\n\n        env->features[FEAT_HYPERV_EAX] |= HV_X64_MSR_HYPERCALL_AVAILABLE;\n\n    }\n\n    if (cpu->hyperv_vapic) {\n\n        env->features[FEAT_HYPERV_EAX] |= HV_X64_MSR_HYPERCALL_AVAILABLE;\n\n        env->features[FEAT_HYPERV_EAX] |= HV_X64_MSR_APIC_ACCESS_AVAILABLE;\n\n    }\n\n    if (cpu->hyperv_time &&\n\n            kvm_check_extension(cs->kvm_state, KVM_CAP_HYPERV_TIME) > 0) {\n\n        env->features[FEAT_HYPERV_EAX] |= HV_X64_MSR_HYPERCALL_AVAILABLE;\n\n        env->features[FEAT_HYPERV_EAX] |= HV_X64_MSR_TIME_REF_COUNT_AVAILABLE;\n\n        env->features[FEAT_HYPERV_EAX] |= 0x200;\n\n        has_msr_hv_tsc = true;\n\n    }\n\n    if (cpu->hyperv_crash && has_msr_hv_crash) {\n\n        env->features[FEAT_HYPERV_EDX] |= HV_X64_GUEST_CRASH_MSR_AVAILABLE;\n\n    }\n\n    env->features[FEAT_HYPERV_EDX] |= HV_X64_CPU_DYNAMIC_PARTITIONING_AVAILABLE;\n\n    if (cpu->hyperv_reset && has_msr_hv_reset) {\n\n        env->features[FEAT_HYPERV_EAX] |= HV_X64_MSR_RESET_AVAILABLE;\n\n    }\n\n    if (cpu->hyperv_vpindex && has_msr_hv_vpindex) {\n\n        env->features[FEAT_HYPERV_EAX] |= HV_X64_MSR_VP_INDEX_AVAILABLE;\n\n    }\n\n    if (cpu->hyperv_runtime && has_msr_hv_runtime) {\n\n        env->features[FEAT_HYPERV_EAX] |= HV_X64_MSR_VP_RUNTIME_AVAILABLE;\n\n    }\n\n    if (cpu->hyperv_synic) {\n\n        int sint;\n\n\n\n        if (!has_msr_hv_synic ||\n\n            kvm_vcpu_enable_cap(cs, KVM_CAP_HYPERV_SYNIC, 0)) {\n\n            fprintf(stderr, \"Hyper-V SynIC is not supported by kernel\\n\");\n\n            return -ENOSYS;\n\n        }\n\n\n\n        env->features[FEAT_HYPERV_EAX] |= HV_X64_MSR_SYNIC_AVAILABLE;\n\n        env->msr_hv_synic_version = HV_SYNIC_VERSION_1;\n\n        for (sint = 0; sint < ARRAY_SIZE(env->msr_hv_synic_sint); sint++) {\n\n            env->msr_hv_synic_sint[sint] = HV_SYNIC_SINT_MASKED;\n\n        }\n\n    }\n\n    if (cpu->hyperv_stimer) {\n\n        if (!has_msr_hv_stimer) {\n\n            fprintf(stderr, \"Hyper-V timers aren't supported by kernel\\n\");\n\n            return -ENOSYS;\n\n        }\n\n        env->features[FEAT_HYPERV_EAX] |= HV_X64_MSR_SYNTIMER_AVAILABLE;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"b2f95feec5e4d546b932848dd421ec3361e8ef77","target":1,"func":"static int coroutine_fn bdrv_co_do_pwrite_zeroes(BlockDriverState *bs,\n\n    int64_t offset, int count, BdrvRequestFlags flags)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    QEMUIOVector qiov;\n\n    struct iovec iov = {0};\n\n    int ret = 0;\n\n    bool need_flush = false;\n\n    int head = 0;\n\n    int tail = 0;\n\n\n\n    int max_write_zeroes = MIN_NON_ZERO(bs->bl.max_pwrite_zeroes, INT_MAX);\n\n    int alignment = MAX(bs->bl.pwrite_zeroes_alignment,\n\n                        bs->bl.request_alignment);\n\n\n\n    assert(alignment % bs->bl.request_alignment == 0);\n\n    head = offset % alignment;\n\n    tail = (offset + count) % alignment;\n\n    max_write_zeroes = QEMU_ALIGN_DOWN(max_write_zeroes, alignment);\n\n    assert(max_write_zeroes >= bs->bl.request_alignment);\n\n\n\n    while (count > 0 && !ret) {\n\n        int num = count;\n\n\n\n        \/* Align request.  Block drivers can expect the \"bulk\" of the request\n\n         * to be aligned, and that unaligned requests do not cross cluster\n\n         * boundaries.\n\n         *\/\n\n        if (head) {\n\n            \/* Make a small request up to the first aligned sector.  *\/\n\n            num = MIN(count, alignment - head);\n\n            head = 0;\n\n        } else if (tail && num > alignment) {\n\n            \/* Shorten the request to the last aligned sector.  *\/\n\n            num -= tail;\n\n        }\n\n\n\n        \/* limit request size *\/\n\n        if (num > max_write_zeroes) {\n\n            num = max_write_zeroes;\n\n        }\n\n\n\n        ret = -ENOTSUP;\n\n        \/* First try the efficient write zeroes operation *\/\n\n        if (drv->bdrv_co_pwrite_zeroes) {\n\n            ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num,\n\n                                             flags & bs->supported_zero_flags);\n\n            if (ret != -ENOTSUP && (flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_zero_flags & BDRV_REQ_FUA)) {\n\n                need_flush = true;\n\n            }\n\n        } else {\n\n            assert(!bs->supported_zero_flags);\n\n        }\n\n\n\n        if (ret == -ENOTSUP) {\n\n            \/* Fall back to bounce buffer if write zeroes is unsupported *\/\n\n            int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n\n                                            MAX_WRITE_ZEROES_BOUNCE_BUFFER);\n\n            BdrvRequestFlags write_flags = flags & ~BDRV_REQ_ZERO_WRITE;\n\n\n\n            if ((flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n\n                \/* No need for bdrv_driver_pwrite() to do a fallback\n\n                 * flush on each chunk; use just one at the end *\/\n\n                write_flags &= ~BDRV_REQ_FUA;\n\n                need_flush = true;\n\n            }\n\n            num = MIN(num, max_transfer);\n\n            iov.iov_len = num;\n\n            if (iov.iov_base == NULL) {\n\n                iov.iov_base = qemu_try_blockalign(bs, num);\n\n                if (iov.iov_base == NULL) {\n\n                    ret = -ENOMEM;\n\n                    goto fail;\n\n                }\n\n                memset(iov.iov_base, 0, num);\n\n            }\n\n            qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n            ret = bdrv_driver_pwritev(bs, offset, num, &qiov, write_flags);\n\n\n\n            \/* Keep bounce buffer around if it is big enough for all\n\n             * all future requests.\n\n             *\/\n\n            if (num < max_transfer) {\n\n                qemu_vfree(iov.iov_base);\n\n                iov.iov_base = NULL;\n\n            }\n\n        }\n\n\n\n        offset += num;\n\n        count -= num;\n\n    }\n\n\n\nfail:\n\n    if (ret == 0 && need_flush) {\n\n        ret = bdrv_co_flush(bs);\n\n    }\n\n    qemu_vfree(iov.iov_base);\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"c5a49c63fa26e8825ad101dfe86339ae4c216539","target":1,"func":"static void gen_waiti(DisasContext *dc, uint32_t imm4)\n\n{\n\n    TCGv_i32 pc = tcg_const_i32(dc->next_pc);\n\n    TCGv_i32 intlevel = tcg_const_i32(imm4);\n\n\n\n    if (dc->tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_waiti(cpu_env, pc, intlevel);\n\n    if (dc->tb->cflags & CF_USE_ICOUNT) {\n\n        gen_io_end();\n\n    }\n\n    tcg_temp_free(pc);\n\n    tcg_temp_free(intlevel);\n\n    gen_jumpi_check_loop_end(dc, 0);\n\n}\n"},{"project":"qemu","commit_id":"a8f2e5c8fffbaf7fbd4f0efc8efbeebade78008f","target":1,"func":"void virtio_scsi_handle_ctrl_req(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    VirtIODevice *vdev = (VirtIODevice *)s;\n\n    uint32_t type;\n\n    int r = 0;\n\n\n\n    if (iov_to_buf(req->elem.out_sg, req->elem.out_num, 0,\n\n                &type, sizeof(type)) < sizeof(type)) {\n\n        virtio_scsi_bad_req();\n\n        return;\n\n    }\n\n\n\n    virtio_tswap32s(vdev, &type);\n\n    if (type == VIRTIO_SCSI_T_TMF) {\n\n        if (virtio_scsi_parse_req(req, sizeof(VirtIOSCSICtrlTMFReq),\n\n                    sizeof(VirtIOSCSICtrlTMFResp)) < 0) {\n\n            virtio_scsi_bad_req();\n\n        } else {\n\n            r = virtio_scsi_do_tmf(s, req);\n\n        }\n\n\n\n    } else if (type == VIRTIO_SCSI_T_AN_QUERY ||\n\n               type == VIRTIO_SCSI_T_AN_SUBSCRIBE) {\n\n        if (virtio_scsi_parse_req(req, sizeof(VirtIOSCSICtrlANReq),\n\n                    sizeof(VirtIOSCSICtrlANResp)) < 0) {\n\n            virtio_scsi_bad_req();\n\n        } else {\n\n            req->resp.an.event_actual = 0;\n\n            req->resp.an.response = VIRTIO_SCSI_S_OK;\n\n        }\n\n    }\n\n    if (r == 0) {\n\n        virtio_scsi_complete_req(req);\n\n    } else {\n\n        assert(r == -EINPROGRESS);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"ad96090a01d848df67d70c5259ed8aa321fa8716","target":0,"func":"int qemu_uuid_parse(const char *str, uint8_t *uuid)\n\n{\n\n    int ret;\n\n\n\n    if(strlen(str) != 36)\n\n        return -1;\n\n\n\n    ret = sscanf(str, UUID_FMT, &uuid[0], &uuid[1], &uuid[2], &uuid[3],\n\n            &uuid[4], &uuid[5], &uuid[6], &uuid[7], &uuid[8], &uuid[9],\n\n            &uuid[10], &uuid[11], &uuid[12], &uuid[13], &uuid[14], &uuid[15]);\n\n\n\n    if(ret != 16)\n\n        return -1;\n\n\n\n#ifdef TARGET_I386\n\n    smbios_add_field(1, offsetof(struct smbios_type_1, uuid), 16, uuid);\n\n#endif\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"ab902981cf4d46834d82eb095f2b9ab159e017bf","target":1,"func":"static void interface_set_client_capabilities(QXLInstance *sin,\n                                              uint8_t client_present,\n                                              uint8_t caps[58])\n{\n    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);\n    qxl->shadow_rom.client_present = client_present;\n    memcpy(qxl->shadow_rom.client_capabilities, caps, sizeof(caps));\n    qxl->rom->client_present = client_present;\n    memcpy(qxl->rom->client_capabilities, caps, sizeof(caps));\n    qxl_rom_set_dirty(qxl);\n    qxl_send_events(qxl, QXL_INTERRUPT_CLIENT);"},{"project":"qemu","commit_id":"bf55b7afce53718ef96f4e6616da62c0ccac37dd","target":0,"func":"static IOMMUTLBEntry s390_translate_iommu(MemoryRegion *mr, hwaddr addr,\n\n                                          bool is_write)\n\n{\n\n    uint64_t pte;\n\n    uint32_t flags;\n\n    S390PCIIOMMU *iommu = container_of(mr, S390PCIIOMMU, iommu_mr);\n\n    IOMMUTLBEntry ret = {\n\n        .target_as = &address_space_memory,\n\n        .iova = 0,\n\n        .translated_addr = 0,\n\n        .addr_mask = ~(hwaddr)0,\n\n        .perm = IOMMU_NONE,\n\n    };\n\n\n\n    switch (iommu->pbdev->state) {\n\n    case ZPCI_FS_ENABLED:\n\n    case ZPCI_FS_BLOCKED:\n\n        if (!iommu->enabled) {\n\n            return ret;\n\n        }\n\n        break;\n\n    default:\n\n        return ret;\n\n    }\n\n\n\n    DPRINTF(\"iommu trans addr 0x%\" PRIx64 \"\\n\", addr);\n\n\n\n    if (addr < iommu->pba || addr > iommu->pal) {\n\n        return ret;\n\n    }\n\n\n\n    pte = s390_guest_io_table_walk(s390_pci_get_table_origin(iommu->g_iota),\n\n                                   addr);\n\n    if (!pte) {\n\n        return ret;\n\n    }\n\n\n\n    flags = pte & ZPCI_PTE_FLAG_MASK;\n\n    ret.iova = addr;\n\n    ret.translated_addr = pte & ZPCI_PTE_ADDR_MASK;\n\n    ret.addr_mask = 0xfff;\n\n\n\n    if (flags & ZPCI_PTE_INVALID) {\n\n        ret.perm = IOMMU_NONE;\n\n    } else {\n\n        ret.perm = IOMMU_RW;\n\n    }\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"ba21f0cca8165c5b284274edd12dc955cf4fb248","target":0,"func":"static bool is_iso_bc_entry_compatible(IsoBcSection *s)\n\n{\n\n    return true;\n\n}\n"},{"project":"qemu","commit_id":"c2b38b277a7882a592f4f2ec955084b2b756daaa","target":0,"func":"QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)\n\n{\n\n    return timer_list->clock->type;\n\n}\n"},{"project":"qemu","commit_id":"b3db211f3c80bb996a704d665fe275619f728bd4","target":0,"func":"static void test_visitor_in_bool(TestInputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    bool res = false;\n\n    Visitor *v;\n\n\n\n    v = visitor_input_test_init(data, \"true\");\n\n\n\n    visit_type_bool(v, NULL, &res, &error_abort);\n\n    g_assert_cmpint(res, ==, true);\n\n}\n"},{"project":"qemu","commit_id":"70976a7926b42d87e0c575412b85a8f5c1e48fad","target":1,"func":"static int gdb_get_avr_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#ifdef WORDS_BIGENDIAN\n\n        stq_p(mem_buf, env->avr[n].u64[0]);\n\n        stq_p(mem_buf+8, env->avr[n].u64[1]);\n\n#else\n\n        stq_p(mem_buf, env->avr[n].u64[1]);\n\n        stq_p(mem_buf+8, env->avr[n].u64[0]);\n\n#endif\n\n        return 16;\n\n    }\n\n    if (n == 33) {\n\n        stl_p(mem_buf, env->vscr);\n\n        return 4;\n\n    }\n\n    if (n == 34) {\n\n        stl_p(mem_buf, (uint32_t)env->spr[SPR_VRSAVE]);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"f95d7cc7fecbc0e320e83c864ce2d99fee3d9236","target":0,"func":"static int pte_check_hash32(struct mmu_ctx_hash32 *ctx, target_ulong pte0,\n\n                            target_ulong pte1, int h, int rwx)\n\n{\n\n    target_ulong mmask;\n\n    int access, ret, pp;\n\n\n\n    ret = -1;\n\n    \/* Check validity and table match *\/\n\n    if ((pte0 & HPTE32_V_VALID) && (h == !!(pte0 & HPTE32_V_SECONDARY))) {\n\n        \/* Check vsid & api *\/\n\n        mmask = PTE_CHECK_MASK;\n\n        pp = pte1 & HPTE32_R_PP;\n\n        if (HPTE32_V_COMPARE(pte0, ctx->ptem)) {\n\n            if (ctx->raddr != (hwaddr)-1ULL) {\n\n                \/* all matches should have equal RPN, WIMG & PP *\/\n\n                if ((ctx->raddr & mmask) != (pte1 & mmask)) {\n\n                    qemu_log(\"Bad RPN\/WIMG\/PP\\n\");\n\n                    return -3;\n\n                }\n\n            }\n\n            \/* Compute access rights *\/\n\n            access = ppc_hash32_pp_check(ctx->key, pp, ctx->nx);\n\n            \/* Keep the matching PTE informations *\/\n\n            ctx->raddr = pte1;\n\n            ctx->prot = access;\n\n            ret = ppc_hash32_check_prot(ctx->prot, rwx);\n\n            if (ret == 0) {\n\n                \/* Access granted *\/\n\n                LOG_MMU(\"PTE access granted !\\n\");\n\n            } else {\n\n                \/* Access right violation *\/\n\n                LOG_MMU(\"PTE access rejected\\n\");\n\n            }\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"d861b05ea30e6ac177de9b679da96194ebe21afc","target":1,"func":"void lance_init(NICInfo *nd, int irq, uint32_t leaddr, uint32_t ledaddr)\n\n{\n\n    LANCEState *s;\n\n    int lance_io_memory, ledma_io_memory;\n\n\n\n    s = qemu_mallocz(sizeof(LANCEState));\n\n    if (!s)\n\n        return;\n\n\n\n    s->irq = irq;\n\n\n\n    lance_io_memory = cpu_register_io_memory(0, lance_mem_read, lance_mem_write, s);\n\n    cpu_register_physical_memory(leaddr, 4, lance_io_memory);\n\n\n\n    ledma_io_memory = cpu_register_io_memory(0, ledma_mem_read, ledma_mem_write, s);\n\n    cpu_register_physical_memory(ledaddr, 16, ledma_io_memory);\n\n\n\n    memcpy(s->macaddr, nd->macaddr, 6);\n\n\n\n    lance_reset(s);\n\n\n\n    s->vc = qemu_new_vlan_client(nd->vlan, lance_receive, s);\n\n\n\n    snprintf(s->vc->info_str, sizeof(s->vc->info_str),\n\n             \"lance macaddr=%02x:%02x:%02x:%02x:%02x:%02x\",\n\n             s->macaddr[0],\n\n             s->macaddr[1],\n\n             s->macaddr[2],\n\n             s->macaddr[3],\n\n             s->macaddr[4],\n\n             s->macaddr[5]);\n\n\n\n    register_savevm(\"lance\", leaddr, 1, lance_save, lance_load, s);\n\n    qemu_register_reset(lance_reset, s);\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"void macio_nvram_setup_bar(MacIONVRAMState *s, MemoryRegion *bar,\n\n                           target_phys_addr_t mem_base)\n\n{\n\n    memory_region_add_subregion(bar, mem_base, &s->mem);\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static uint64_t mpc8544_guts_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    uint32_t value = 0;\n\n    CPUPPCState *env = cpu_single_env;\n\n\n\n    addr &= MPC8544_GUTS_MMIO_SIZE - 1;\n\n    switch (addr) {\n\n    case MPC8544_GUTS_ADDR_PVR:\n\n        value = env->spr[SPR_PVR];\n\n        break;\n\n    case MPC8544_GUTS_ADDR_SVR:\n\n        value = env->spr[SPR_E500_SVR];\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"guts: Unknown register read: %x\\n\", (int)addr);\n\n        break;\n\n    }\n\n\n\n    return value;\n\n}\n"},{"project":"qemu","commit_id":"4333979e3d8c129953bba36ed87ce543d33cbea1","target":1,"func":"static void bochs_bios_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    static const char shutdown_str[8] = \"Shutdown\";\n\n    static int shutdown_index = 0;\n\n\n\n    switch(addr) {\n\n        \/* Bochs BIOS messages *\/\n\n    case 0x400:\n\n    case 0x401:\n\n        \/* used to be panic, now unused *\/\n\n        break;\n\n    case 0x402:\n\n    case 0x403:\n\n#ifdef DEBUG_BIOS\n\n        fprintf(stderr, \"%c\", val);\n\n#endif\n\n        break;\n\n    case 0x8900:\n\n        \/* same as Bochs power off *\/\n\n        if (val == shutdown_str[shutdown_index]) {\n\n            shutdown_index++;\n\n            if (shutdown_index == 8) {\n\n                shutdown_index = 0;\n\n                qemu_system_shutdown_request();\n\n            }\n\n        } else {\n\n            shutdown_index = 0;\n\n        }\n\n        break;\n\n\n\n        \/* LGPL'ed VGA BIOS messages *\/\n\n    case 0x501:\n\n    case 0x502:\n\n        fprintf(stderr, \"VGA BIOS panic, line %d\\n\", val);\n\n        exit(1);\n\n    case 0x500:\n\n    case 0x503:\n\n#ifdef DEBUG_BIOS\n\n        fprintf(stderr, \"%c\", val);\n\n#endif\n\n        break;\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"e2f0c49ffae8d3a00272c3cbc68850cc5aafbffa","target":1,"func":"static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    int start_track, format, msf, toclen;\n\n    uint64_t nb_sectors;\n\n\n\n    msf = req->cmd.buf[1] & 2;\n\n    format = req->cmd.buf[2] & 0xf;\n\n    start_track = req->cmd.buf[6];\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    DPRINTF(\"Read TOC (track %d format %d msf %d)\\n\", start_track, format, msf >> 1);\n\n    nb_sectors \/= s->qdev.blocksize \/ 512;\n\n    switch (format) {\n\n    case 0:\n\n        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    case 1:\n\n        \/* multi session : only a single session defined *\/\n\n        toclen = 12;\n\n        memset(outbuf, 0, 12);\n\n        outbuf[1] = 0x0a;\n\n        outbuf[2] = 0x01;\n\n        outbuf[3] = 0x01;\n\n        break;\n\n    case 2:\n\n        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    if (toclen > req->cmd.xfer) {\n\n        toclen = req->cmd.xfer;\n\n    }\n\n    return toclen;\n\n}\n"},{"project":"qemu","commit_id":"466787fbca9b25b47365b3d2c09d308df67a61db","target":0,"func":"static void bdrv_replace_child(BdrvChild *child, BlockDriverState *new_bs,\n\n                               bool check_new_perm)\n\n{\n\n    BlockDriverState *old_bs = child->bs;\n\n    uint64_t perm, shared_perm;\n\n\n\n    if (old_bs) {\n\n        \/* Update permissions for old node. This is guaranteed to succeed\n\n         * because we're just taking a parent away, so we're loosening\n\n         * restrictions. *\/\n\n        bdrv_get_cumulative_perm(old_bs, &perm, &shared_perm);\n\n        bdrv_check_perm(old_bs, perm, shared_perm, NULL, &error_abort);\n\n        bdrv_set_perm(old_bs, perm, shared_perm);\n\n    }\n\n\n\n    bdrv_replace_child_noperm(child, new_bs);\n\n\n\n    if (new_bs) {\n\n        bdrv_get_cumulative_perm(new_bs, &perm, &shared_perm);\n\n        if (check_new_perm) {\n\n            bdrv_check_perm(new_bs, perm, shared_perm, NULL, &error_abort);\n\n        }\n\n        bdrv_set_perm(new_bs, perm, shared_perm);\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"d07cc1f12d8e15c167857852c39190d770763824","target":0,"func":"static KVMMSIRoute *kvm_lookup_msi_route(KVMState *s, MSIMessage msg)\n\n{\n\n    unsigned int hash = kvm_hash_msi(msg.data);\n\n    KVMMSIRoute *route;\n\n\n\n    QTAILQ_FOREACH(route, &s->msi_hashtab[hash], entry) {\n\n        if (route->kroute.u.msi.address_lo == (uint32_t)msg.address &&\n\n            route->kroute.u.msi.address_hi == (msg.address >> 32) &&\n\n            route->kroute.u.msi.data == msg.data) {\n\n            return route;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n"},{"project":"qemu","commit_id":"e12c08d3b67c4f4e5a16ee815188fc13632530ce","target":0,"func":"static void test_machine(const void *data)\n\n{\n\n    const testdef_t *test = data;\n\n    char tmpname[] = \"\/tmp\/qtest-boot-serial-XXXXXX\";\n\n    int fd;\n\n\n\n    fd = mkstemp(tmpname);\n\n    g_assert(fd != -1);\n\n\n\n    \/*\n\n     * Make sure that this test uses tcg if available: It is used as a\n\n     * fast-enough smoketest for that.\n\n     *\/\n\n    global_qtest = qtest_startf(\"-M %s,accel=tcg:kvm \"\n\n                                \"-chardev file,id=serial0,path=%s \"\n\n                                \"-no-shutdown -serial chardev:serial0 %s\",\n\n                                test->machine, tmpname, test->extra);\n\n    unlink(tmpname);\n\n\n\n    check_guest_output(test, fd);\n\n    qtest_quit(global_qtest);\n\n\n\n    close(fd);\n\n}\n"},{"project":"qemu","commit_id":"9b938c7262e403f5467110609cb20ef1ae6e9df2","target":1,"func":"static void unix_process_msgfd(CharDriverState *chr, struct msghdr *msg)\n{\n    TCPCharDriver *s = chr->opaque;\n    struct cmsghdr *cmsg;\n    for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {\n        int fd;\n        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||\n            cmsg->cmsg_level != SOL_SOCKET ||\n            cmsg->cmsg_type != SCM_RIGHTS)\n            continue;\n        fd = *((int *)CMSG_DATA(cmsg));\n        if (fd < 0)\n            continue;\n#ifndef MSG_CMSG_CLOEXEC\n        qemu_set_cloexec(fd);\n#endif\n        if (s->msgfd != -1)\n            close(s->msgfd);\n        s->msgfd = fd;\n    }\n}"},{"project":"qemu","commit_id":"ddca7f86ac022289840e0200fd4050b2b58e9176","target":0,"func":"static void v9fs_flush(void *opaque)\n\n{\n\n    int16_t tag;\n\n    size_t offset = 7;\n\n    V9fsPDU *cancel_pdu;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"w\", &tag);\n\n    trace_v9fs_flush(pdu->tag, pdu->id, tag);\n\n\n\n    QLIST_FOREACH(cancel_pdu, &s->active_list, next) {\n\n        if (cancel_pdu->tag == tag) {\n\n            break;\n\n        }\n\n    }\n\n    if (cancel_pdu) {\n\n        cancel_pdu->cancelled = 1;\n\n        \/*\n\n         * Wait for pdu to complete.\n\n         *\/\n\n        qemu_co_queue_wait(&cancel_pdu->complete);\n\n        cancel_pdu->cancelled = 0;\n\n        free_pdu(pdu->s, cancel_pdu);\n\n    }\n\n    complete_pdu(s, pdu, 7);\n\n    return;\n\n}\n"},{"project":"qemu","commit_id":"c489780203f9b22aca5539ec7589b7140bdc951f","target":1,"func":"static void qmp_input_type_null(Visitor *v, const char *name, Error **errp)\n{\n    QmpInputVisitor *qiv = to_qiv(v);\n    QObject *qobj = qmp_input_get_object(qiv, name, true);\n    if (qobject_type(qobj) != QTYPE_QNULL) {\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n                   \"null\");"},{"project":"qemu","commit_id":"dc38852aaa4ac187d8b44201f75fc2835241912d","target":0,"func":"static void print_report(const char *op, struct timeval *t, int64_t offset,\n\n                         int64_t count, int64_t total, int cnt, int Cflag)\n\n{\n\n    char s1[64], s2[64], ts[64];\n\n\n\n    timestr(t, ts, sizeof(ts), Cflag ? VERBOSE_FIXED_TIME : 0);\n\n    if (!Cflag) {\n\n        cvtstr((double)total, s1, sizeof(s1));\n\n        cvtstr(tdiv((double)total, *t), s2, sizeof(s2));\n\n        printf(\"%s %\"PRId64\"\/%\"PRId64\" bytes at offset %\" PRId64 \"\\n\",\n\n               op, total, count, offset);\n\n        printf(\"%s, %d ops; %s (%s\/sec and %.4f ops\/sec)\\n\",\n\n               s1, cnt, ts, s2, tdiv((double)cnt, *t));\n\n    } else {\/* bytes,ops,time,bytes\/sec,ops\/sec *\/\n\n        printf(\"%\"PRId64\",%d,%s,%.3f,%.3f\\n\",\n\n            total, cnt, ts,\n\n            tdiv((double)total, *t),\n\n            tdiv((double)cnt, *t));\n\n    }\n\n}\n"},{"project":"qemu","commit_id":"cd01b4a312248dd4e12c3d389d1a349cea4015d8","target":1,"func":"void bdrv_init(void)\n\n{\n\n    bdrv_register(&bdrv_raw);\n\n    bdrv_register(&bdrv_host_device);\n\n\n    bdrv_register(&bdrv_cow);\n\n\n    bdrv_register(&bdrv_qcow);\n\n    bdrv_register(&bdrv_vmdk);\n\n    bdrv_register(&bdrv_cloop);\n\n    bdrv_register(&bdrv_dmg);\n\n    bdrv_register(&bdrv_bochs);\n\n    bdrv_register(&bdrv_vpc);\n\n    bdrv_register(&bdrv_vvfat);\n\n    bdrv_register(&bdrv_qcow2);\n\n    bdrv_register(&bdrv_parallels);\n\n\n    bdrv_register(&bdrv_nbd);\n\n\n}"},{"project":"qemu","commit_id":"08fba7ac9b618516a5f1d096f78a7e2837fe0594","target":0,"func":"static bool main_loop_should_exit(void)\n\n{\n\n    RunState r;\n\n    ShutdownCause request;\n\n\n\n    if (qemu_debug_requested()) {\n\n        vm_stop(RUN_STATE_DEBUG);\n\n    }\n\n    if (qemu_suspend_requested()) {\n\n        qemu_system_suspend();\n\n    }\n\n    request = qemu_shutdown_requested();\n\n    if (request) {\n\n        qemu_kill_report();\n\n        \/* TODO update event based on request *\/\n\n        qapi_event_send_shutdown(&error_abort);\n\n        if (no_shutdown) {\n\n            vm_stop(RUN_STATE_SHUTDOWN);\n\n        } else {\n\n            return true;\n\n        }\n\n    }\n\n    request = qemu_reset_requested();\n\n    if (request) {\n\n        pause_all_vcpus();\n\n        qemu_system_reset(request);\n\n        resume_all_vcpus();\n\n        if (!runstate_check(RUN_STATE_RUNNING) &&\n\n                !runstate_check(RUN_STATE_INMIGRATE)) {\n\n            runstate_set(RUN_STATE_PRELAUNCH);\n\n        }\n\n    }\n\n    if (qemu_wakeup_requested()) {\n\n        pause_all_vcpus();\n\n        qemu_system_reset(SHUTDOWN_CAUSE_NONE);\n\n        notifier_list_notify(&wakeup_notifiers, &wakeup_reason);\n\n        wakeup_reason = QEMU_WAKEUP_REASON_NONE;\n\n        resume_all_vcpus();\n\n        qapi_event_send_wakeup(&error_abort);\n\n    }\n\n    if (qemu_powerdown_requested()) {\n\n        qemu_system_powerdown();\n\n    }\n\n    if (qemu_vmstop_requested(&r)) {\n\n        vm_stop(r);\n\n    }\n\n    return false;\n\n}\n"},{"project":"qemu","commit_id":"ea53854a54bc54dddeec0c56572adf53384e960c","target":1,"func":"void qpci_device_foreach(QPCIBus *bus, int vendor_id, int device_id,\n\n                         void (*func)(QPCIDevice *dev, int devfn, void *data),\n\n                         void *data)\n\n{\n\n    int slot;\n\n\n\n    for (slot = 0; slot < 32; slot++) {\n\n        int fn;\n\n\n\n        for (fn = 0; fn < 8; fn++) {\n\n            QPCIDevice *dev;\n\n\n\n            dev = qpci_device_find(bus, QPCI_DEVFN(slot, fn));\n\n            if (!dev) {\n\n                continue;\n\n            }\n\n\n\n            if (vendor_id != -1 &&\n\n                qpci_config_readw(dev, PCI_VENDOR_ID) != vendor_id) {\n\n\n                continue;\n\n            }\n\n\n\n            if (device_id != -1 &&\n\n                qpci_config_readw(dev, PCI_DEVICE_ID) != device_id) {\n\n\n                continue;\n\n            }\n\n\n\n            func(dev, QPCI_DEVFN(slot, fn), data);\n\n        }\n\n    }\n\n}"},{"project":"qemu","commit_id":"4f4321c11ff6e98583846bfd6f0e81954924b003","target":1,"func":"static int usb_net_handle_datain(USBNetState *s, USBPacket *p)\n\n{\n\n    int ret = USB_RET_NAK;\n\n\n\n    if (s->in_ptr > s->in_len) {\n\n        s->in_ptr = s->in_len = 0;\n\n        ret = USB_RET_NAK;\n\n        return ret;\n\n    }\n\n    if (!s->in_len) {\n\n        ret = USB_RET_NAK;\n\n        return ret;\n\n    }\n\n    ret = s->in_len - s->in_ptr;\n\n    if (ret > p->len)\n\n        ret = p->len;\n\n    memcpy(p->data, &s->in_buf[s->in_ptr], ret);\n\n    s->in_ptr += ret;\n\n    if (s->in_ptr >= s->in_len &&\n\n                    (is_rndis(s) || (s->in_len & (64 - 1)) || !ret)) {\n\n        \/* no short packet necessary *\/\n\n        s->in_ptr = s->in_len = 0;\n\n    }\n\n\n\n#ifdef TRAFFIC_DEBUG\n\n    fprintf(stderr, \"usbnet: data in len %u return %d\", p->len, ret);\n\n    {\n\n        int i;\n\n        fprintf(stderr, \":\");\n\n        for (i = 0; i < ret; i++) {\n\n            if (!(i & 15))\n\n                fprintf(stderr, \"\\n%04x:\", i);\n\n            fprintf(stderr, \" %02x\", p->data[i]);\n\n        }\n\n        fprintf(stderr, \"\\n\\n\");\n\n    }\n\n#endif\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"b2d1fe67d09d2b6c7da647fbcea6ca0148c206d3","target":1,"func":"static void bufp_alloc(USBRedirDevice *dev,\n\n    uint8_t *data, int len, int status, uint8_t ep)\n\n{\n\n    struct buf_packet *bufp;\n\n\n\n    if (!dev->endpoint[EP2I(ep)].bufpq_dropping_packets &&\n\n        dev->endpoint[EP2I(ep)].bufpq_size >\n\n            2 * dev->endpoint[EP2I(ep)].bufpq_target_size) {\n\n        DPRINTF(\"bufpq overflow, dropping packets ep %02X\\n\", ep);\n\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 1;\n\n    }\n\n    \/* Since we're interupting the stream anyways, drop enough packets to get\n\n       back to our target buffer size *\/\n\n    if (dev->endpoint[EP2I(ep)].bufpq_dropping_packets) {\n\n        if (dev->endpoint[EP2I(ep)].bufpq_size >\n\n                dev->endpoint[EP2I(ep)].bufpq_target_size) {\n\n            free(data);\n\n            return;\n\n        }\n\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0;\n\n    }\n\n\n\n    bufp = g_malloc(sizeof(struct buf_packet));\n\n    bufp->data   = data;\n\n    bufp->len    = len;\n\n    bufp->status = status;\n\n    QTAILQ_INSERT_TAIL(&dev->endpoint[EP2I(ep)].bufpq, bufp, next);\n\n    dev->endpoint[EP2I(ep)].bufpq_size++;\n\n}\n"},{"project":"qemu","commit_id":"fef6070eff233400015cede968b0afe46c80bb0f","target":0,"func":"static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)\n\n{\n\n    int ret = -EIO;\n\n\n\n    \/* Add footer to total size *\/\n\n    total_size += 512;\n\n    if (ftruncate(fd, total_size) != 0) {\n\n        ret = -errno;\n\n        goto fail;\n\n    }\n\n    if (lseek(fd, -512, SEEK_END) < 0) {\n\n        goto fail;\n\n    }\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\n\n\n fail:\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"25db9ebe15125deb32958c6df74996f745edf1f9","target":0,"func":"static void virtio_pci_reset(DeviceState *d)\n\n{\n\n    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);\n\n    virtio_reset(proxy->vdev);\n\n    msix_reset(&proxy->pci_dev);\n\n    proxy->flags = 0;\n\n}\n"},{"project":"qemu","commit_id":"8a6b28c7b5104263344508df0f4bce97f22cfcaf","target":0,"func":"static void gen_exception_insn(DisasContext *s, int offset, int excp,\n\n                               int syn, uint32_t target_el)\n\n{\n\n    gen_set_condexec(s);\n\n    gen_set_pc_im(s, s->pc - offset);\n\n    gen_exception(excp, syn, target_el);\n\n    s->is_jmp = DISAS_JUMP;\n\n}\n"},{"project":"qemu","commit_id":"60fe637bf0e4d7989e21e50f52526444765c63b4","target":1,"func":"void qemu_put_be64(QEMUFile *f, uint64_t v)\n\n{\n\n    qemu_put_be32(f, v >> 32);\n\n    qemu_put_be32(f, v);\n\n}\n"},{"project":"qemu","commit_id":"d1eb8f2acba579830cf3798c3c15ce51be852c56","target":0,"func":"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)\n\n{\n\n\n\n    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )\n\n         || (    ( extractFloatx80Exp( b ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )\n\n       ) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 0;\n\n    }\n\n    return\n\n           ( a.low == b.low )\n\n        && (    ( a.high == b.high )\n\n             || (    ( a.low == 0 )\n\n                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )\n\n           );\n\n\n\n}\n"},{"project":"qemu","commit_id":"4715d42efe8632b0f9d2594a80e917de45e4ef88","target":1,"func":"int object_property_get_enum(Object *obj, const char *name,\n\n                             const char *typename, Error **errp)\n\n{\n\n    StringOutputVisitor *sov;\n\n    StringInputVisitor *siv;\n\n    char *str;\n\n    int ret;\n\n    ObjectProperty *prop = object_property_find(obj, name, errp);\n\n    EnumProperty *enumprop;\n\n\n\n    if (prop == NULL) {\n\n        return 0;\n\n    }\n\n\n\n    if (!g_str_equal(prop->type, typename)) {\n\n        error_setg(errp, \"Property %s on %s is not '%s' enum type\",\n\n                   name, object_class_get_name(\n\n                       object_get_class(obj)), typename);\n\n        return 0;\n\n    }\n\n\n\n    enumprop = prop->opaque;\n\n\n\n    sov = string_output_visitor_new(false);\n\n    object_property_get(obj, string_output_get_visitor(sov), name, errp);\n\n    str = string_output_get_string(sov);\n\n    siv = string_input_visitor_new(str);\n\n    string_output_visitor_cleanup(sov);\n\n    visit_type_enum(string_input_get_visitor(siv),\n\n                    &ret, enumprop->strings, NULL, name, errp);\n\n\n\n    g_free(str);\n\n    string_input_visitor_cleanup(siv);\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"fd859081453f94c3cbd6527289e41b7fddbf645f","target":0,"func":"static int tpm_passthrough_unix_tx_bufs(TPMPassthruState *tpm_pt,\n\n                                        const uint8_t *in, uint32_t in_len,\n\n                                        uint8_t *out, uint32_t out_len)\n\n{\n\n    int ret;\n\n\n\n    tpm_pt->tpm_op_canceled = false;\n\n    tpm_pt->tpm_executing = true;\n\n\n\n    ret = tpm_passthrough_unix_write(tpm_pt->tpm_fd, in, in_len);\n\n    if (ret != in_len) {\n\n        if (!tpm_pt->tpm_op_canceled ||\n\n            (tpm_pt->tpm_op_canceled && errno != ECANCELED)) {\n\n            error_report(\"tpm_passthrough: error while transmitting data \"\n\n                         \"to TPM: %s (%i)\\n\",\n\n                         strerror(errno), errno);\n\n        }\n\n        goto err_exit;\n\n    }\n\n\n\n    tpm_pt->tpm_executing = false;\n\n\n\n    ret = tpm_passthrough_unix_read(tpm_pt->tpm_fd, out, out_len);\n\n    if (ret < 0) {\n\n        if (!tpm_pt->tpm_op_canceled ||\n\n            (tpm_pt->tpm_op_canceled && errno != ECANCELED)) {\n\n            error_report(\"tpm_passthrough: error while reading data from \"\n\n                         \"TPM: %s (%i)\\n\",\n\n                         strerror(errno), errno);\n\n        }\n\n    } else if (ret < sizeof(struct tpm_resp_hdr) ||\n\n               tpm_passthrough_get_size_from_buffer(out) != ret) {\n\n        ret = -1;\n\n        error_report(\"tpm_passthrough: received invalid response \"\n\n                     \"packet from TPM\\n\");\n\n    }\n\n\n\nerr_exit:\n\n    if (ret < 0) {\n\n        tpm_write_fatal_error_response(out, out_len);\n\n    }\n\n\n\n    tpm_pt->tpm_executing = false;\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"2ee73ac3a855fb0cfba3db91fdd1ecebdbc6f971","target":1,"func":"void OPPROTO op_fdiv_STN_ST0(void)\n\n{\n\n    ST(PARAM1) \/= ST0;\n\n}\n"},{"project":"qemu","commit_id":"2d0d2837dcf786da415cf4165d37f4ddd684ff57","target":0,"func":"static int drive_init_func(QemuOpts *opts, void *opaque)\n\n{\n\n    int *use_scsi = opaque;\n\n\n\n    return drive_init(opts, *use_scsi) == NULL;\n\n}\n"},{"project":"qemu","commit_id":"bd4b65ee5e5f750da709ac10c70266876e515c23","target":1,"func":"int pci_device_load(PCIDevice *s, QEMUFile *f)\n\n{\n\n    uint32_t version_id;\n\n    int i;\n\n\n\n    version_id = qemu_get_be32(f);\n\n    if (version_id > 2)\n\n        return -EINVAL;\n\n    qemu_get_buffer(f, s->config, 256);\n\n    pci_update_mappings(s);\n\n\n\n    if (version_id >= 2)\n\n        for (i = 0; i < 4; i ++)\n\n            s->irq_state[i] = qemu_get_be32(f);\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"6c5b5645ae0b73c052df962e18e48d87bb7385e0","target":0,"func":"static inline abi_long target_to_host_sockaddr(int fd, struct sockaddr *addr,\n\n                                               abi_ulong target_addr,\n\n                                               socklen_t len)\n\n{\n\n    const socklen_t unix_maxlen = sizeof (struct sockaddr_un);\n\n    sa_family_t sa_family;\n\n    struct target_sockaddr *target_saddr;\n\n\n\n    if (fd_trans_target_to_host_addr(fd)) {\n\n        return fd_trans_target_to_host_addr(fd)(addr, target_addr, len);\n\n    }\n\n\n\n    target_saddr = lock_user(VERIFY_READ, target_addr, len, 1);\n\n    if (!target_saddr)\n\n        return -TARGET_EFAULT;\n\n\n\n    sa_family = tswap16(target_saddr->sa_family);\n\n\n\n    \/* Oops. The caller might send a incomplete sun_path; sun_path\n\n     * must be terminated by \\0 (see the manual page), but\n\n     * unfortunately it is quite common to specify sockaddr_un\n\n     * length as \"strlen(x->sun_path)\" while it should be\n\n     * \"strlen(...) + 1\". We'll fix that here if needed.\n\n     * Linux kernel has a similar feature.\n\n     *\/\n\n\n\n    if (sa_family == AF_UNIX) {\n\n        if (len < unix_maxlen && len > 0) {\n\n            char *cp = (char*)target_saddr;\n\n\n\n            if ( cp[len-1] && !cp[len] )\n\n                len++;\n\n        }\n\n        if (len > unix_maxlen)\n\n            len = unix_maxlen;\n\n    }\n\n\n\n    memcpy(addr, target_saddr, len);\n\n    addr->sa_family = sa_family;\n\n    if (sa_family == AF_PACKET) {\n\n\tstruct target_sockaddr_ll *lladdr;\n\n\n\n\tlladdr = (struct target_sockaddr_ll *)addr;\n\n\tlladdr->sll_ifindex = tswap32(lladdr->sll_ifindex);\n\n\tlladdr->sll_hatype = tswap16(lladdr->sll_hatype);\n\n    }\n\n    unlock_user(target_saddr, target_addr, 0);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"4482e05cbbb7e50e476f6a9500cf0b38913bd939","target":1,"func":"static void ppc_prep_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    const char *boot_device = machine->boot_order;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    PowerPCCPU *cpu = NULL;\n\n    CPUPPCState *env = NULL;\n\n    Nvram *m48t59;\n\n#if 0\n\n    MemoryRegion *xcsr = g_new(MemoryRegion, 1);\n\n#endif\n\n    int linux_boot, i, nb_nics1;\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    uint32_t kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    DeviceState *dev;\n\n    PCIHostState *pcihost;\n\n    PCIBus *pci_bus;\n\n    PCIDevice *pci;\n\n    ISABus *isa_bus;\n\n    ISADevice *isa;\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n\n\n    sysctrl = g_malloc0(sizeof(sysctrl_t));\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    \/* init CPUs *\/\n\n    if (machine->cpu_model == NULL)\n\n        machine->cpu_model = \"602\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU,\n\n                                           machine->cpu_model));\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        if (env->flags & POWERPC_FLAG_RTC_CLK) {\n\n            \/* POWER \/ PowerPC 601 RTC clock frequency is 7.8125 MHz *\/\n\n            cpu_ppc_tb_init(env, 7812500UL);\n\n        } else {\n\n            \/* Set time-base frequency to 100 Mhz *\/\n\n            cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n        }\n\n        qemu_register_reset(ppc_prep_reset, cpu);\n\n    }\n\n\n\n    \/* allocate RAM *\/\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_prep.ram\", ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    if (linux_boot) {\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        \/* now we can load the kernel *\/\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            error_report(\"could not load kernel '%s'\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        \/* load initrd *\/\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                error_report(\"could not load initial ram disk '%s'\",\n\n                             initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        \/* For now, OHW cannot boot from the network. *\/\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        error_report(\"Only 6xx bus is supported on PREP machine\");\n\n        exit(1);\n\n    }\n\n\n\n    dev = qdev_create(NULL, \"raven-pcihost\");\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    qdev_prop_set_string(dev, \"bios-name\", bios_name);\n\n    qdev_prop_set_uint32(dev, \"elf-machine\", PPC_ELF_MACHINE);\n\n    pcihost = PCI_HOST_BRIDGE(dev);\n\n    object_property_add_child(qdev_get_machine(), \"raven\", OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (pci_bus == NULL) {\n\n        fprintf(stderr, \"Couldn't create PCI host controller.\\n\");\n\n        exit(1);\n\n    }\n\n    sysctrl->contiguous_map_irq = qdev_get_gpio_in(dev, 0);\n\n\n\n    \/* PCI -> ISA bridge *\/\n\n    pci = pci_create_simple(pci_bus, PCI_DEVFN(1, 0), \"i82378\");\n\n    cpu = POWERPC_CPU(first_cpu);\n\n    qdev_connect_gpio_out(&pci->qdev, 0,\n\n                          cpu->env.irq_inputs[PPC6xx_INPUT_INT]);\n\n    sysbus_connect_irq(&pcihost->busdev, 0, qdev_get_gpio_in(&pci->qdev, 9));\n\n    sysbus_connect_irq(&pcihost->busdev, 1, qdev_get_gpio_in(&pci->qdev, 11));\n\n    sysbus_connect_irq(&pcihost->busdev, 2, qdev_get_gpio_in(&pci->qdev, 9));\n\n    sysbus_connect_irq(&pcihost->busdev, 3, qdev_get_gpio_in(&pci->qdev, 11));\n\n    isa_bus = ISA_BUS(qdev_get_child_bus(DEVICE(pci), \"isa.0\"));\n\n\n\n    \/* Super I\/O (parallel + serial ports) *\/\n\n    isa = isa_create(isa_bus, TYPE_PC87312);\n\n    dev = DEVICE(isa);\n\n    qdev_prop_set_uint8(dev, \"config\", 13); \/* fdc, ser0, ser1, par0 *\/\n\n    qdev_init_nofail(dev);\n\n\n\n    \/* init basic PC hardware *\/\n\n    pci_vga_init(pci_bus);\n\n\n\n    nb_nics1 = nb_nics;\n\n    if (nb_nics1 > NE2000_NB_MAX)\n\n        nb_nics1 = NE2000_NB_MAX;\n\n    for(i = 0; i < nb_nics1; i++) {\n\n        if (nd_table[i].model == NULL) {\n\n\t    nd_table[i].model = g_strdup(\"ne2k_isa\");\n\n        }\n\n        if (strcmp(nd_table[i].model, \"ne2k_isa\") == 0) {\n\n            isa_ne2000_init(isa_bus, ne2000_io[i], ne2000_irq[i],\n\n                            &nd_table[i]);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], pci_bus, \"ne2k_pci\", NULL);\n\n        }\n\n    }\n\n\n\n    ide_drive_get(hd, ARRAY_SIZE(hd));\n\n    for(i = 0; i < MAX_IDE_BUS; i++) {\n\n        isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                     hd[2 * i],\n\n\t\t     hd[2 * i + 1]);\n\n    }\n\n    isa_create_simple(isa_bus, \"i8042\");\n\n\n\n    cpu = POWERPC_CPU(first_cpu);\n\n    sysctrl->reset_irq = cpu->env.irq_inputs[PPC6xx_INPUT_HRESET];\n\n\n\n    portio_list_init(&prep_port_list, NULL, prep_portio_list, sysctrl, \"prep\");\n\n    portio_list_add(&prep_port_list, isa_address_space_io(isa), 0x0);\n\n\n\n    \/* PowerPC control and status register group *\/\n\n#if 0\n\n    memory_region_init_io(xcsr, NULL, &PPC_XCSR_ops, NULL, \"ppc-xcsr\", 0x1000);\n\n    memory_region_add_subregion(sysmem, 0xFEFF0000, xcsr);\n\n#endif\n\n\n\n    if (machine_usb(machine)) {\n\n        pci_create_simple(pci_bus, -1, \"pci-ohci\");\n\n    }\n\n\n\n    m48t59 = m48t59_init_isa(isa_bus, 0x0074, NVRAM_SIZE, 2000, 59);\n\n    if (m48t59 == NULL)\n\n        return;\n\n    sysctrl->nvram = m48t59;\n\n\n\n    \/* Initialise NVRAM *\/\n\n    PPC_NVRAM_set_params(m48t59, NVRAM_SIZE, \"PREP\", ram_size,\n\n                         ppc_boot_device,\n\n                         kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         \/* XXX: need an option to load a NVRAM image *\/\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n}\n"},{"project":"qemu","commit_id":"83e6813a93e38976391b8c382c3375e3e188df3e","target":0,"func":"static void aarch64_cpu_register(const ARMCPUInfo *info)\n\n{\n\n    TypeInfo type_info = {\n\n        .parent = TYPE_AARCH64_CPU,\n\n        .instance_size = sizeof(ARMCPU),\n\n        .instance_init = info->initfn,\n\n        .class_size = sizeof(ARMCPUClass),\n\n        .class_init = info->class_init,\n\n    };\n\n\n\n    \/* TODO: drop when we support more CPUs - all entries will have name set *\/\n\n    if (!info->name) {\n\n        return;\n\n    }\n\n\n\n    type_info.name = g_strdup_printf(\"%s-\" TYPE_ARM_CPU, info->name);\n\n    type_register(&type_info);\n\n    g_free((void *)type_info.name);\n\n}\n"},{"project":"qemu","commit_id":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0,"func":"static void mainstone_common_init(MemoryRegion *address_space_mem,\n\n                ram_addr_t ram_size,\n\n                const char *kernel_filename,\n\n                const char *kernel_cmdline, const char *initrd_filename,\n\n                const char *cpu_model, enum mainstone_model_e model, int arm_id)\n\n{\n\n    uint32_t sector_len = 256 * 1024;\n\n    target_phys_addr_t mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };\n\n    PXA2xxState *mpu;\n\n    DeviceState *mst_irq;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    int be;\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa270-c5\";\n\n\n\n    \/* Setup CPU & memory *\/\n\n    mpu = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model);\n\n    memory_region_init_ram(rom, \"mainstone.rom\", MAINSTONE_ROM);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    \/* There are two 32MiB flash devices on the board *\/\n\n    for (i = 0; i < 2; i ++) {\n\n        dinfo = drive_get(IF_PFLASH, 0, i);\n\n        if (!dinfo) {\n\n            fprintf(stderr, \"Two flash images must be given with the \"\n\n                    \"'pflash' parameter\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (!pflash_cfi01_register(mainstone_flash_base[i], NULL,\n\n                                   i ? \"mainstone.flash1\" : \"mainstone.flash0\",\n\n                                   MAINSTONE_FLASH,\n\n                                   dinfo->bdrv, sector_len,\n\n                                   MAINSTONE_FLASH \/ sector_len, 4, 0, 0, 0, 0,\n\n                                   be)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    mst_irq = sysbus_create_simple(\"mainstone-fpga\", MST_FPGA_PHYS,\n\n                    qdev_get_gpio_in(mpu->gpio, 0));\n\n\n\n    \/* setup keypad *\/\n\n    printf(\"map addr %p\\n\", &map);\n\n    pxa27x_register_keypad(mpu->kp, map, 0xe0);\n\n\n\n    \/* MMC\/SD host *\/\n\n    pxa2xx_mmci_handlers(mpu->mmc, NULL, qdev_get_gpio_in(mst_irq, MMC_IRQ));\n\n\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[0],\n\n            qdev_get_gpio_in(mst_irq, S0_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S0_CD_IRQ));\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[1],\n\n            qdev_get_gpio_in(mst_irq, S1_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S1_CD_IRQ));\n\n\n\n    smc91c111_init(&nd_table[0], MST_ETH_PHYS,\n\n                    qdev_get_gpio_in(mst_irq, ETHERNET_IRQ));\n\n\n\n    mainstone_binfo.kernel_filename = kernel_filename;\n\n    mainstone_binfo.kernel_cmdline = kernel_cmdline;\n\n    mainstone_binfo.initrd_filename = initrd_filename;\n\n    mainstone_binfo.board_id = arm_id;\n\n    arm_load_kernel(mpu->cpu, &mainstone_binfo);\n\n}\n"},{"project":"qemu","commit_id":"b181e04777da67acbc7448f87e4ae9f1518e08b2","target":1,"func":"static CharDriverState *qemu_chr_open_pp(QemuOpts *opts)\n\n{\n\n    const char *filename = qemu_opt_get(opts, \"path\");\n\n    CharDriverState *chr;\n\n    int fd;\n\n\n\n    fd = open(filename, O_RDWR);\n\n    if (fd < 0)\n\n        return NULL;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    chr->opaque = (void *)(intptr_t)fd;\n\n    chr->chr_write = null_chr_write;\n\n    chr->chr_ioctl = pp_ioctl;\n\n    return chr;\n\n}\n"},{"project":"qemu","commit_id":"d21e8776f6578be155714ae95c7d6c1bb03e8e34","target":0,"func":"static void iothread_complete(UserCreatable *obj, Error **errp)\n\n{\n\n    Error *local_error = NULL;\n\n    IOThread *iothread = IOTHREAD(obj);\n\n\n\n    iothread->stopping = false;\n\n    iothread->thread_id = -1;\n\n    iothread->ctx = aio_context_new(&local_error);\n\n    if (!iothread->ctx) {\n\n        error_propagate(errp, local_error);\n\n        return;\n\n    }\n\n\n\n    qemu_mutex_init(&iothread->init_done_lock);\n\n    qemu_cond_init(&iothread->init_done_cond);\n\n\n\n    \/* This assumes we are called from a thread with useful CPU affinity for us\n\n     * to inherit.\n\n     *\/\n\n    qemu_thread_create(&iothread->thread, \"iothread\", iothread_run,\n\n                       iothread, QEMU_THREAD_JOINABLE);\n\n\n\n    \/* Wait for initialization to complete *\/\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    while (iothread->thread_id == -1) {\n\n        qemu_cond_wait(&iothread->init_done_cond,\n\n                       &iothread->init_done_lock);\n\n    }\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n}\n"},{"project":"qemu","commit_id":"6f2d8978728c48ca46f5c01835438508aace5c64","target":1,"func":"int mmu40x_get_physical_address (CPUState *env, mmu_ctx_t *ctx,\n\n                                 target_ulong address, int rw, int access_type)\n\n{\n\n    ppcemb_tlb_t *tlb;\n\n    target_phys_addr_t raddr;\n\n    int i, ret, zsel, zpr, pr;\n\n\n\n    ret = -1;\n\n    raddr = -1;\n\n    pr = msr_pr;\n\n    for (i = 0; i < env->nb_tlb; i++) {\n\n        tlb = &env->tlb[i].tlbe;\n\n        if (ppcemb_tlb_check(env, tlb, &raddr, address,\n\n                             env->spr[SPR_40x_PID], 0, i) < 0)\n\n            continue;\n\n        zsel = (tlb->attr >> 4) & 0xF;\n\n        zpr = (env->spr[SPR_40x_ZPR] >> (28 - (2 * zsel))) & 0x3;\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"%s: TLB %d zsel %d zpr %d rw %d attr %08x\\n\",\n\n                    __func__, i, zsel, zpr, rw, tlb->attr);\n\n        }\n\n#endif\n\n        \/* Check execute enable bit *\/\n\n        switch (zpr) {\n\n        case 0x2:\n\n            if (pr != 0)\n\n                goto check_perms;\n\n            \/* No break here *\/\n\n        case 0x3:\n\n            \/* All accesses granted *\/\n\n            ctx->prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n            ret = 0;\n\n            break;\n\n        case 0x0:\n\n            if (pr != 0) {\n\n                ctx->prot = 0;\n\n                ret = -2;\n\n                break;\n\n            }\n\n            \/* No break here *\/\n\n        case 0x1:\n\n        check_perms:\n\n            \/* Check from TLB entry *\/\n\n            \/* XXX: there is a problem here or in the TLB fill code... *\/\n\n            ctx->prot = tlb->prot;\n\n            ctx->prot |= PAGE_EXEC;\n\n            ret = check_prot(ctx->prot, rw, access_type);\n\n            break;\n\n        }\n\n        if (ret >= 0) {\n\n            ctx->raddr = raddr;\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n            if (loglevel != 0) {\n\n                fprintf(logfile, \"%s: access granted \" ADDRX \" => \" REGX\n\n                        \" %d %d\\n\", __func__, address, ctx->raddr, ctx->prot,\n\n                        ret);\n\n            }\n\n#endif\n\n            return 0;\n\n        }\n\n    }\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s: access refused \" ADDRX \" => \" REGX\n\n                \" %d %d\\n\", __func__, address, raddr, ctx->prot,\n\n                ret);\n\n    }\n\n#endif\n\n\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"5b15f27516ce3249c80bd2e0458d8d61f20da415","target":1,"func":"static void ppc_core99_init (ram_addr_t ram_size,\n\n                             const char *boot_device,\n\n                             const char *kernel_filename,\n\n                             const char *kernel_cmdline,\n\n                             const char *initrd_filename,\n\n                             const char *cpu_model)\n\n{\n\n    CPUState *env = NULL;\n\n    char *filename;\n\n    qemu_irq *pic, **openpic_irqs;\n\n    int unin_memory;\n\n    int linux_boot, i;\n\n    ram_addr_t ram_offset, bios_offset;\n\n    target_phys_addr_t kernel_base, initrd_base, cmdline_base = 0;\n\n    long kernel_size, initrd_size;\n\n    PCIBus *pci_bus;\n\n    MacIONVRAMState *nvr;\n\n    int bios_size;\n\n    MemoryRegion *pic_mem, *dbdma_mem, *cuda_mem, *escc_mem;\n\n    MemoryRegion *ide_mem[3];\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    void *fw_cfg;\n\n    void *dbdma;\n\n    int machine_arch;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    \/* init CPUs *\/\n\n    if (cpu_model == NULL)\n\n#ifdef TARGET_PPC64\n\n        cpu_model = \"970fx\";\n\n#else\n\n        cpu_model = \"G4\";\n\n#endif\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        \/* Set time-base frequency to 100 Mhz *\/\n\n        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);\n\n    }\n\n\n\n    \/* allocate RAM *\/\n\n    ram_offset = qemu_ram_alloc(NULL, \"ppc_core99.ram\", ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    \/* allocate and load BIOS *\/\n\n    bios_offset = qemu_ram_alloc(NULL, \"ppc_core99.bios\", BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n\n\n    \/* Load OpenBIOS (ELF) *\/\n\n    if (filename) {\n\n        bios_size = load_elf(filename, NULL, NULL, NULL,\n\n                             NULL, NULL, 1, ELF_MACHINE, 0);\n\n\n\n        g_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PowerPC bios '%s'\\n\", bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    if (linux_boot) {\n\n        uint64_t lowaddr = 0;\n\n        int bswap_needed;\n\n\n\n#ifdef BSWAP_NEEDED\n\n        bswap_needed = 1;\n\n#else\n\n        bswap_needed = 0;\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, kernel_base,\n\n                                    ram_size - kernel_base, bswap_needed,\n\n                                    TARGET_PAGE_SIZE);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              kernel_base,\n\n                                              ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        \/* load initrd *\/\n\n        if (initrd_filename) {\n\n            initrd_base = round_page(kernel_base + kernel_size + KERNEL_GAP);\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                         initrd_filename);\n\n                exit(1);\n\n            }\n\n            cmdline_base = round_page(initrd_base + initrd_size);\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n            cmdline_base = round_page(kernel_base + kernel_size + KERNEL_GAP);\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        \/* We consider that NewWorld PowerMac never have any floppy drive\n\n         * For now, OHW cannot boot from the network.\n\n         *\/\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'c' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0x80000000;\n\n\n\n    \/* Register 8 MB of ISA IO space *\/\n\n    isa_mmio_init(0xf2000000, 0x00800000);\n\n\n\n    \/* UniN init *\/\n\n    unin_memory = cpu_register_io_memory(unin_read, unin_write, NULL,\n\n                                         DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory);\n\n\n\n    openpic_irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *));\n\n    openpic_irqs[0] =\n\n        g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        \/* Mac99 IRQ connection between OpenPIC outputs pins\n\n         * and PowerPC input pins\n\n         *\/\n\n        switch (PPC_INPUT(env)) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];\n\n            \/* Not connected ? *\/\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            \/* Check this *\/\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];\n\n            break;\n\n#if defined(TARGET_PPC64)\n\n        case PPC_FLAGS_INPUT_970:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];\n\n            \/* Not connected ? *\/\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            \/* Check this *\/\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];\n\n            break;\n\n#endif \/* defined(TARGET_PPC64) *\/\n\n        default:\n\n            hw_error(\"Bus model not supported on mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n    pic = openpic_init(NULL, &pic_mem, smp_cpus, openpic_irqs, NULL);\n\n    if (PPC_INPUT(env) == PPC_FLAGS_INPUT_970) {\n\n        \/* 970 gets a U3 bus *\/\n\n        pci_bus = pci_pmac_u3_init(pic, get_system_memory(), get_system_io());\n\n        machine_arch = ARCH_MAC99_U3;\n\n    } else {\n\n        pci_bus = pci_pmac_init(pic, get_system_memory(), get_system_io());\n\n        machine_arch = ARCH_MAC99;\n\n    }\n\n    \/* init basic PC hardware *\/\n\n    pci_vga_init(pci_bus);\n\n\n\n    escc_mem = escc_init(0x80013000, pic[0x25], pic[0x24],\n\n                         serial_hds[0], serial_hds[1], ESCC_CLOCK, 4);\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init_nofail(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n    dbdma = DBDMA_init(&dbdma_mem);\n\n\n\n    \/* We only emulate 2 out of 3 IDE controllers for now *\/\n\n    ide_mem[0] = NULL;\n\n    ide_mem[1] = pmac_ide_init(hd, pic[0x0d], dbdma, 0x16, pic[0x02]);\n\n    ide_mem[2] = pmac_ide_init(&hd[MAX_IDE_DEVS], pic[0x0e], dbdma, 0x1a, pic[0x02]);\n\n\n\n    \/* cuda also initialize ADB *\/\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usb_enabled = 1;\n\n    }\n\n    cuda_init(&cuda_mem, pic[0x19]);\n\n\n\n    adb_kbd_init(&adb_bus);\n\n    adb_mouse_init(&adb_bus);\n\n\n\n    macio_init(pci_bus, PCI_DEVICE_ID_APPLE_UNI_N_KEYL, 0, pic_mem,\n\n               dbdma_mem, cuda_mem, NULL, 3, ide_mem, escc_mem);\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    \/* U3 needs to use USB for input because Linux doesn't support via-cuda\n\n       on PPC64 *\/\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usbdevice_create(\"keyboard\");\n\n        usbdevice_create(\"mouse\");\n\n    }\n\n\n\n    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)\n\n        graphic_depth = 15;\n\n\n\n    \/* The NewWorld NVRAM is not located in the MacIO device *\/\n\n    nvr = macio_nvram_init(0x2000, 1);\n\n    pmac_format_nvram_partition(nvr, 0x2000);\n\n    macio_nvram_setup_bar(nvr, get_system_memory(), 0xFFF04000);\n\n    \/* No PCI init: the BIOS will do it *\/\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine_arch);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, cmdline_base);\n\n        pstrcpy_targphys(\"cmdline\", cmdline_base, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());\n\n    if (kvm_enabled()) {\n\n#ifdef CONFIG_KVM\n\n        uint8_t *hypercall;\n\n\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq());\n\n        hypercall = g_malloc(16);\n\n        kvmppc_get_hypercall(env, hypercall, 16);\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());\n\n#endif\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec());\n\n    }\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n"},{"project":"qemu","commit_id":"80dcfb8532ae76343109a48f12ba8ca1c505c179","target":0,"func":"static int virtio_serial_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIOSerial *s = opaque;\n\n    VirtIOSerialPort *port;\n\n    uint32_t max_nr_ports, nr_active_ports, ports_map;\n\n    unsigned int i;\n\n    int ret;\n\n\n\n    if (version_id > 3) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    \/* The virtio device *\/\n\n    ret = virtio_load(&s->vdev, f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (version_id < 2) {\n\n        return 0;\n\n    }\n\n\n\n    \/* The config space *\/\n\n    qemu_get_be16s(f, &s->config.cols);\n\n    qemu_get_be16s(f, &s->config.rows);\n\n\n\n    qemu_get_be32s(f, &max_nr_ports);\n\n    tswap32s(&max_nr_ports);\n\n    if (max_nr_ports > tswap32(s->config.max_nr_ports)) {\n\n        \/* Source could have had more ports than us. Fail migration. *\/\n\n        return -EINVAL;\n\n    }\n\n\n\n    for (i = 0; i < (max_nr_ports + 31) \/ 32; i++) {\n\n        qemu_get_be32s(f, &ports_map);\n\n\n\n        if (ports_map != s->ports_map[i]) {\n\n            \/*\n\n             * Ports active on source and destination don't\n\n             * match. Fail migration.\n\n             *\/\n\n            return -EINVAL;\n\n        }\n\n    }\n\n\n\n    qemu_get_be32s(f, &nr_active_ports);\n\n\n\n    \/* Items in struct VirtIOSerialPort *\/\n\n    for (i = 0; i < nr_active_ports; i++) {\n\n        uint32_t id;\n\n        bool host_connected;\n\n\n\n        id = qemu_get_be32(f);\n\n        port = find_port_by_id(s, id);\n\n        if (!port) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        port->guest_connected = qemu_get_byte(f);\n\n        host_connected = qemu_get_byte(f);\n\n        if (host_connected != port->host_connected) {\n\n            \/*\n\n             * We have to let the guest know of the host connection\n\n             * status change\n\n             *\/\n\n            send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN,\n\n                               port->host_connected);\n\n        }\n\n\n\n        if (version_id > 2) {\n\n            uint32_t elem_popped;\n\n\n\n            qemu_get_be32s(f, &elem_popped);\n\n            if (elem_popped) {\n\n                qemu_get_be32s(f, &port->iov_idx);\n\n                qemu_get_be64s(f, &port->iov_offset);\n\n\n\n                qemu_get_buffer(f, (unsigned char *)&port->elem,\n\n                                sizeof(port->elem));\n\n                virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr,\n\n                                 port->elem.in_num, 1);\n\n                virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr,\n\n                                 port->elem.out_num, 1);\n\n\n\n                \/*\n\n                 *  Port was throttled on source machine.  Let's\n\n                 *  unthrottle it here so data starts flowing again.\n\n                 *\/\n\n                virtio_serial_throttle_port(port, false);\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"61007b316cd71ee7333ff7a0a749a8949527575f","target":0,"func":"static void tracked_request_end(BdrvTrackedRequest *req)\n\n{\n\n    if (req->serialising) {\n\n        req->bs->serialising_in_flight--;\n\n    }\n\n\n\n    QLIST_REMOVE(req, list);\n\n    qemu_co_queue_restart_all(&req->wait_queue);\n\n}\n"},{"project":"qemu","commit_id":"4f4321c11ff6e98583846bfd6f0e81954924b003","target":1,"func":"static int usb_wacom_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBWacomState *s = (USBWacomState *) dev;\n\n    int ret = 0;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_IN:\n\n        if (p->devep == 1) {\n\n            if (!(s->changed || s->idle))\n\n                return USB_RET_NAK;\n\n            s->changed = 0;\n\n            if (s->mode == WACOM_MODE_HID)\n\n                ret = usb_mouse_poll(s, p->data, p->len);\n\n            else if (s->mode == WACOM_MODE_WACOM)\n\n                ret = usb_wacom_poll(s, p->data, p->len);\n\n            break;\n\n        }\n\n        \/* Fall through.  *\/\n\n    case USB_TOKEN_OUT:\n\n    default:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n"},{"project":"qemu","commit_id":"a91246c95f913dc6fd391eee32f6c9796de70183","target":0,"func":"static int ram_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    rcu_read_lock();\n\n\n\n    if (!migration_in_postcopy(migrate_get_current())) {\n\n        migration_bitmap_sync();\n\n    }\n\n\n\n    ram_control_before_iterate(f, RAM_CONTROL_FINISH);\n\n\n\n    \/* try transferring iterative blocks of memory *\/\n\n\n\n    \/* flush all remaining blocks regardless of rate limiting *\/\n\n    while (true) {\n\n        int pages;\n\n\n\n        pages = ram_find_and_save_block(f, true, &bytes_transferred);\n\n        \/* no more blocks to sent *\/\n\n        if (pages == 0) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    flush_compressed_data(f);\n\n    ram_control_after_iterate(f, RAM_CONTROL_FINISH);\n\n\n\n    rcu_read_unlock();\n\n\n\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"46181129eac9a56d9a948667282dd03d5015f096","target":0,"func":"int bdrv_child_try_set_perm(BdrvChild *c, uint64_t perm, uint64_t shared,\n\n                            Error **errp)\n\n{\n\n    int ret;\n\n\n\n    ret = bdrv_child_check_perm(c, perm, shared, errp);\n\n    if (ret < 0) {\n\n        bdrv_child_abort_perm_update(c);\n\n        return ret;\n\n    }\n\n\n\n    bdrv_child_set_perm(c, perm, shared);\n\n\n\n    return 0;\n\n}\n"},{"project":"qemu","commit_id":"60fe637bf0e4d7989e21e50f52526444765c63b4","target":1,"func":"unsigned int qemu_get_be16(QEMUFile *f)\n\n{\n\n    unsigned int v;\n\n    v = qemu_get_byte(f) << 8;\n\n    v |= qemu_get_byte(f);\n\n    return v;\n\n}\n"},{"project":"qemu","commit_id":"60fe637bf0e4d7989e21e50f52526444765c63b4","target":1,"func":"static void register_to_network(RDMARegister *reg)\n\n{\n\n    reg->key.current_addr = htonll(reg->key.current_addr);\n\n    reg->current_index = htonl(reg->current_index);\n\n    reg->chunks = htonll(reg->chunks);\n\n}\n"}]